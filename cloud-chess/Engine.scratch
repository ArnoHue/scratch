when i receive [startgame v]
set [StartTime v] to ((days since 2000) * (86400))
set [IsJoinBlocked v] to [1]
set [JoinWaitingCounter v] to [0]
repeat until <(IsJoinBlocked) = (0)> 
wait (1) seconds
if <(((days since 2000) * (86400)) - (StartTime)) < (60)> then 
if <if <((JoinWaitingCounter) mod (6)) < (4)> then 
set [SP_Status v] to [Waiting...]
 else 
set [SP_Status v] to [Waiting..]
end> then 
((JoinWaitingCounter) mod (6)) < (2)
 else 
set [SP_Status v] to [Waiting.]
end
change [JoinWaitingCounter v] by (1)
UpdateStatePanelData
UpdateButtonStates
 else 
set [IsJoinBlocked v] to [0]
end
end
set [SP_Status v] to []
JoinOnline

define InitBoard
set [ExecutionDepth v] to [0]
set [IsExecutionRunning v] to [0]
InitMobilityBonusLookup
InitCoordLookup
InitHashLookup
InitMoveLookup
FillBoard
delete (all) of [OnlineBoardPieceMap v]
add [Empty] to [OnlineBoardPieceMap v]
add [BlackBishop] to [OnlineBoardPieceMap v]
add [BlackKing] to [OnlineBoardPieceMap v]
add [BlackKnight] to [OnlineBoardPieceMap v]
add [BlackPawn] to [OnlineBoardPieceMap v]
add [BlackQueen] to [OnlineBoardPieceMap v]
add [BlackRook] to [OnlineBoardPieceMap v]
add [WhiteBishop] to [OnlineBoardPieceMap v]
add [WhiteKing] to [OnlineBoardPieceMap v]
add [WhiteKnight] to [OnlineBoardPieceMap v]
add [WhitePawn] to [OnlineBoardPieceMap v]
add [WhiteQueen] to [OnlineBoardPieceMap v]
add [WhiteRook] to [OnlineBoardPieceMap v]
hide list [BoardHistory v]
hide list [GameMovesAN v]
hide list [ExportData v]
hide list [ExportMoves v]
set [CharsUpperCase v] to [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
delete (all) of [CharsUpperCaseList v]
set [Idx v] to [1]
repeat (length of [CharsUpperCaseList v]) 
add (letter (Idx) of [CharsUpperCase]) to [CharsUpperCaseList v]
change [Idx v] by (1)
end
set [Level3Depth v] to [2]
set [Moves1CaptureCount v] to [0]
set [Moves2CaptureCount v] to [0]
set [MonTimer1 v] to [0]
set [MonTimer2 v] to [0]
set [MonTimer3 v] to [0]
set [IsDebugMode v] to [0]
set [IsEndgame v] to [0]
set [IsEndgame2 v] to [0]
set [IsImportedBoard v] to [0]
set [Empty v] to [0]
set [WhiteKing v] to [-20000]
set [WhiteQueen v] to [-900]
set [WhiteRook v] to [-500]
set [WhiteBishop v] to [-330]
set [WhiteKnight v] to [-310]
set [WhitePawn v] to [-100]
set [BlackKing v] to [20000]
set [BlackQueen v] to [900]
set [BlackRook v] to [500]
set [BlackBishop v] to [330]
set [BlackKnight v] to [310]
set [BlackPawn v] to [100]
set [BlackKingsideCastling v] to [0090]
set [WhiteKingsideCastling v] to [0092]
set [BlackQueensideCastling v] to [0091]
set [WhiteQueensideCastling v] to [0093]
set [HasBlackCastled v] to [0]
set [HasWhiteKingMoved v] to [0]
set [HasWhiteCastled v] to [0]
set [HasBlackKingMoved v] to [0]
set [HasWhiteRookKSMoved v] to [0]
set [HasWhiteRookQSMoved v] to [0]
set [HasBlackRookKSMoved v] to [0]
set [HasBlackRookQSMoved v] to [0]
set [GameMoves v] to []
set [AddMoveModeDefault v] to [1]
set [AddMoveModeAttackRevert v] to [2]
set [LineMoveTypeStraight v] to [1]
set [LineMoveTypeCross v] to [2]
set [LookupMoveTypeKnight v] to [1]
set [LookupMoveTypeKing v] to [2]
set [IsGameSuspended v] to [0]
delete (all) of [BoardAttackedByWhite v]
delete (all) of [BoardAttackedByBlack v]
delete (all) of [KnightMoveOffsets v]
delete (all) of [KingMoveOffsets v]
delete (all) of [OpeningMoves v]
delete (all) of [BoardHistory v]
delete (all) of [GameMovesAN v]
delete (all) of [PieceMobility v]
delete (all) of [BoardAttackedByWhitePiece v]
delete (all) of [BoardAttackedByBlackPiece v]
repeat (64) 
add [0] to [BoardAttackedByWhite v]
add [0] to [BoardAttackedByBlack v]
add [0] to [PieceMobility v]
add [0] to [BoardAttackedByWhitePiece v]
add [0] to [BoardAttackedByBlackPiece v]
end
add [-2] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [-2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [-2] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [-2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
InitOpeningBook
InitKnightSquare
InitPawnSquare
InitPawnSquareEndgame
InitBishopSquare
InitRookSquare
InitQueenSquare
InitKingSquare
InitKingSquareEndgame
delete (all) of [Alphas v]
delete (all) of [Betas v]
delete (all) of [MinMaxResults v]
delete (all) of [MovesCount v]
delete (all) of [MovesIdx v]
delete (all) of [TargetPieces v]
delete (all) of [PreviousMoveHash v]
delete (all) of [BaseHashMove v]
delete (all) of [BestHashMoveType v]
delete (all) of [PickMoveRes v]
delete (all) of [PickPhase v]
delete (all) of [PickHash v]
delete (all) of [PrevBestHashMove v]
delete (all) of [CheckedState v]
delete (all) of [PromotionPieces v]
delete (all) of [TargetPiecesIdx v]
delete (all) of [PosScoreDelta v]
repeat (12) 
add [] to [Alphas v]
add [] to [Betas v]
add [] to [MinMaxResults v]
add [] to [MovesCount v]
add [] to [MovesIdx v]
add [] to [TargetPieces v]
add [] to [PreviousMoveHash v]
add [] to [BaseHashMove v]
add [] to [BestHashMoveType v]
add [] to [PickMoveRes v]
add [] to [PickPhase v]
add [] to [PickHash v]
add [] to [PrevBestHashMove v]
add [] to [CheckedState v]
add [] to [PromotionPieces v]
add [] to [TargetPiecesIdx v]
add [] to [PosScoreDelta v]
end
delete (all) of [BlackPawnCount v]
delete (all) of [WhitePawnCount v]
repeat (8) 
add [0] to [BlackPawnCount v]
add [0] to [WhitePawnCount v]
end
delete (all) of [BoardHistory v]
AddBoardToHistory

define InitBishopSquare
delete (all) of [BishopPieceSquare v]
set [BishopSquareDef v] to [-20, -18, -16, -14, -14, -16, -18, -20,-10, 11, 1, 1, 1, 1, 11, -10, 1, 11, 21, 26, 26, 21, 11, 1, 1, 21, 21, 26, 26, 21, 21, 1, 1, 1, 16, 21, 21, 16, 1, 1, -25, 6, 16, 11, 11, 16, 6, -25, -28, 11, 6, 1, 1, 6, 11, -28, -30, -25, -20, -20, -20, -20, -25, -30]
LoadList %s %s

define InitKingSquare
delete (all) of [KingPieceSquare v]
set [KingSquareDef v] to [-55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55,-50, -50, -55, -60, -60, -55, -50, -50, -40, -40, -45, -50, -50, -45, -40, -40, -30, -30, -30, -35, -35, -30, -30, -30, -20, 0, 0, -10, -10, 0, 0, -20]
LoadList %s %s

define InitRookSquare
delete (all) of [RookPieceSquare v]
set [RookSquareDef v] to [-8, -6, 2, 7, 7, 2, -6, -8,2, 2, 7, 12, 12, 7, 2, 2, -8, -6, 6, 10, 10, 6, -6, -8, -8, -6, 6, 8, 8, 6, -6, -8, -8, -6, 6, 7, 7, 6, -6, -8, -8, -6, 6, 7, 7, 6, -6, -8, -8, -6, 2, 7, 7, 2, -6, -8, -8, -6, 2, 7, 7, 2, -6, -8]
LoadList %s %s

define InitPawnSquare
delete (all) of [PawnPieceSquare v]
set [PawnSquareDef v] to [0, 0, 0, 0, 0, 0, 0, 0, 7, 11, 23, 39, 39, 23, 11, 7, -5, 1, 14, 29, 29, 14, 1, -5, -14, -8, 6, 22, 22, 6, -8, -14, -21, -16, -1, 14, 14, -1, -16, -21, -21, -16, -6, 4, 4, -6, -16, -21, -21, -16, -6, -1, -1, -6, -16, -21, 0, 0, 0, 0, 0, 0, 0, 0]
LoadList %s %s

define AddBoardToHistory
GetBoardString
add [GetBoardStringRes] to [BoardHistory v]

define RevertMove %n
GetCurrentMove %n
set [SourceIdx v] to ([floor v] of ((CurrentMove) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((CurrentMove) mod (100)) ::operators)
if <<(SourceIdx) > (0)> and <(TargetIdx) > (0)>> then 
replace item (SourceIdx) of [Board v] with (item (TargetIdx) of [Board v])
replace item (TargetIdx) of [Board v] with [Empty]
replace item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [Board v] with (item (argument_reporter_string_number) of [TargetPieces v])
if <(item (argument_reporter_string_number) of [PromotionPieces v]) > (0)> then 
replace item (SourceIdx) of [Board v] with [BlackPawn]
end
if <(item (argument_reporter_string_number) of [PromotionPieces v]) < (0)> then 
replace item (SourceIdx) of [Board v] with [WhitePawn]
end
 else 
if <(CurrentMove) = (WhiteKingsideCastling)> then 
replace item (item (61) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (62) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (63) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (64) of [VirtualBoard v]) of [Board v] with [WhiteRook]
 else 
if <(CurrentMove) = (WhiteQueensideCastling)> then 
replace item (item (57) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (59) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (60) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (61) of [VirtualBoard v]) of [Board v] with [WhiteKing]
 else 
if <(CurrentMove) = (BlackKingsideCastling)> then 
replace item (item (5) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (6) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (7) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (8) of [VirtualBoard v]) of [Board v] with [BlackRook]
 else 
if <(CurrentMove) = (BlackQueensideCastling)> then 
replace item (item (1) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (4) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (3) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (5) of [VirtualBoard v]) of [Board v] with [BlackKing]
end
end
end
end
end
replace item (argument_reporter_string_number) of [PosScoreDelta v] with [0]
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with []
replace item (argument_reporter_string_number) of [TargetPieces v] with [Empty]
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
set [CurrentMoveHash v] to (item (argument_reporter_string_number) of [PreviousMoveHash v])

define GetSubstringRight %s %n
GetSubstring %s %n %n

define DrawBoardAndWait
UpdateStatePanelData
set [ProgressValue v] to [0]
broadcast (1 v) and wait
broadcast (1 v) and wait

define InitQueenSquare
delete (all) of [QueenPieceSquare v]
set [QueenSquareDef v] to [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,-6, -6, -1, 4, 4, -1, -6, -6, -16, -11, -1, 4, 4, -1, -11, -16, -26, -16, -6, 4, 4, -6, -16, -26]
LoadList %s %s

define InitOpeningBook
delete (all) of [OpeningMoves v]
add [533711276346122052362736463607225843021962531321] to [OpeningMoves v]
add [533711276346122062260312] to [OpeningMoves v]
add [5337112763460219523627364636072258431220] to [OpeningMoves v]
add [5337112751430722372922285236273643361220] to [OpeningMoves v]
add [5337112758430219554715236255061552441220] to [OpeningMoves v]
add [5337112758430219634612206226031200920722] to [OpeningMoves v]
add [533711276235132163460917] to [OpeningMoves v]
add [533711276235132158430917] to [OpeningMoves v]
add [533711275236273660360219] to [OpeningMoves v]
add [533711195236122837290330] to [OpeningMoves v]
add [53371119523612285843283743370330] to [OpeningMoves v]
add [533713296032021962351523] to [OpeningMoves v]
add [5337132960460722] to [OpeningMoves v]
add [5337132962350722] to [OpeningMoves v]
add [533713296346021962260917263307220092061362610090] to [OpeningMoves v]
add [533713296346021962260917263307226052102633420613] to [OpeningMoves v]
add [533713296346021962260917263307225236293600920613] to [OpeningMoves v]
add [533713296346021962260917263307225843061300921026] to [OpeningMoves v]
add [5337132963460219622609172619121946290436] to [OpeningMoves v]
add [533713296346021962260917261912190092033956481632] to [OpeningMoves v]
add [533713296346021962260917261912195843142252362936] to [OpeningMoves v]
add [533713296346021962260917261912195236293660360436] to [OpeningMoves v]
add [5337132963460219523629364636062759450422] to [OpeningMoves v]
add [533713296346021962350722] to [OpeningMoves v]
add [5337132963460219584307226226063400920090] to [OpeningMoves v]
add [5337132954382938634615316235313946290440] to [OpeningMoves v]
add [533713295438293863461531564031394629072252361220] to [OpeningMoves v]
add [5337132954382938623504406162062752362718] to [OpeningMoves v]
add [53371329543829386346061362350722] to [OpeningMoves v]
add [53371329543829386235072258431119] to [OpeningMoves v]
add [53371329543829385236044061531220634603395648394653464032] to [OpeningMoves v]
add [53371329543806276346122062350722] to [OpeningMoves v]
add [53371329543802196346122062350339] to [OpeningMoves v]
add [533702195236122837280428] to [OpeningMoves v]
add [533715235236061562351220] to [OpeningMoves v]
add [53371523523606156346122062350722] to [OpeningMoves v]
add [53371523523606155843072263460090] to [OpeningMoves v]
add [533713215236122837291127514302195438273643360418] to [OpeningMoves v]
add [5337132152361228372911275143021963460418] to [OpeningMoves v]
add [53371321523612285843063460442837] to [OpeningMoves v]
add [53371321523612285843063437291127] to [OpeningMoves v]
add [5337132152361228584306343728212859520722] to [OpeningMoves v]
add [5337132163461228372821285236072258431119] to [OpeningMoves v]
add [533712205236072258430212634613296253061300921119] to [OpeningMoves v]
add [533712205236072258430212634613296235162400921119] to [OpeningMoves v]
add [533712205236072258430212634613296235061300920090] to [OpeningMoves v]
add [5337122052360722584315235945061554460090] to [OpeningMoves v]
add [5337122052360722584315236235061552440219] to [OpeningMoves v]
add [523612286346072259312237] to [OpeningMoves v]
add [523612286346072253451127] to [OpeningMoves v]
add [523612286346021958431321533707223729221259310613] to [OpeningMoves v]
add [523612286346021959380339] to [OpeningMoves v]
add [523612286346072251351119] to [OpeningMoves v]
add [52361228634613215843072253450219] to [OpeningMoves v]
add [52361228634613215843072253372837] to [OpeningMoves v]
add [523612285135132158430722534509176244283544350634] to [OpeningMoves v]
add [5236122851351321584307225931021253450634] to [OpeningMoves v]
add [523612285345072262441321] to [OpeningMoves v]
add [523612285135111958430722] to [OpeningMoves v]
add [5236122851351119634607225843132159312835] to [OpeningMoves v]
add [523612285938072253451321] to [OpeningMoves v]
add [52360722513515235843061563460090] to [OpeningMoves v]
add [52360722513515236346061555470090] to [OpeningMoves v]
add [52360722513515236346061558430090] to [OpeningMoves v]
add [52360722513513215843063453450090] to [OpeningMoves v]
add [523607225135122063460339] to [OpeningMoves v]
add [523607225135152358430615533712206346009062531329] to [OpeningMoves v]
add [52360722634613215135101858430310] to [OpeningMoves v]
add [52361430513507225843132153450634] to [OpeningMoves v]
add [5236143055470722625515236346061500920090] to [OpeningMoves v]
add [523614306346072255471321] to [OpeningMoves v]
add [5236132151350722634610185547031062550613] to [OpeningMoves v]
add [52361321513507225843063460510090] to [OpeningMoves v]
add [523613215135122858430722] to [OpeningMoves v]
add [494113295345122851350722] to [OpeningMoves v]
add [4933132953370722] to [OpeningMoves v]
add [493313293325122856401127] to [OpeningMoves v]
add [504213295950021951350722] to [OpeningMoves v]
add [503413295950122051350722] to [OpeningMoves v]
add [514313295337072252440219] to [OpeningMoves v]
add [513513295843072255471228] to [OpeningMoves v]
add [513513296346021958430722] to [OpeningMoves v]
add [5446132955390440] to [OpeningMoves v]
add [5438132155390440] to [OpeningMoves v]
add [543812286346152355470615] to [OpeningMoves v]
add [5539132954380440] to [OpeningMoves v]
add [554712286255132951352836] to [OpeningMoves v]
add [5648132953370722] to [OpeningMoves v]
add [5648132949411228] to [OpeningMoves v]
add [564013295337072252440627] to [OpeningMoves v]
add [5640072251351127] to [OpeningMoves v]
add [5640072263460219] to [OpeningMoves v]
add [6346072251351523554706156255009000921220] to [OpeningMoves v]
add [634612285236072251351321] to [OpeningMoves v]
add [6346122858431321] to [OpeningMoves v]
set [Count v] to (length of [OpeningMoves v])
set [Idx v] to [1]
repeat (Count) 
add [] to [OpeningMoves v]
if <((length of (item (Idx) of [OpeningMoves v])) / (4)) > (4)> then 
set [IdxSub v] to [1]
repeat ((length of (item (Idx) of [OpeningMoves v])) / (4)) 
GetVirtualMove %n
replace item (last) of [OpeningMoves v] with (join (item (last) of [OpeningMoves v]) [VirtualMove])
change [IdxSub v] by (4)
end
end
change [Idx v] by (1)
end
add [494113295345122851350722 ] to [OpeningMoves v]

define AddSimpleMove %n %n %n %n %b %b %b %b %b
set [Y v] to ((item (argument_reporter_string_number) of [IdxToRow v]) + (argument_reporter_string_number))
if <<(Y) > (0)> and <(Y) < (9)>> then 
set [X v] to ((item (argument_reporter_string_number) of [IdxToCol v]) + (argument_reporter_string_number))
if <<(X) > (0)> and <(X) < (9)>> then 
AddMoveImpl %n %n %n %b %b %b %b %b
end
end

define OnScoreCalc %n %n %n %b %b %b
set [ScoreCalcRes v] to [0]
if <(argument_reporter_string_number) = (0)> then 
set [EvalResult v] to [0]
set [EvalExtendedResult v] to [0]
set [WhiteKingMoveCount v] to [0]
set [BlackKingMoveCount v] to [0]
end
if <(IsEndgame) = (1)> then 
if <(argument_reporter_string_number) = (2)> then 
set [WhiteKingMoveCount v] to [0]
set [Idx v] to [1]
repeat (length of [Moves2 v]) 
if <(item ([floor v] of ((item (Idx) of [Moves2 v]) / (100)) ::operators) of [Board v]) = (WhiteKing)> then 
change [WhiteKingMoveCount v] by (1)
end
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (3)> then 
set [BlackKingMoveCount v] to [0]
set [Idx v] to [1]
repeat (length of [Moves3 v]) 
if <(item ([floor v] of ((item (Idx) of [Moves3 v]) / (100)) ::operators) of [Board v]) = (BlackKing)> then 
change [BlackKingMoveCount v] by (1)
end
change [Idx v] by (1)
end
end
end
if <<<(argument_reporter_string_number) = (argument_reporter_string_number)> and <(argument_reporter_string_number) < (4)>> or <<(argument_reporter_string_number) < (argument_reporter_string_number)> and <(argument_reporter_string_number) = (3)>>> then 
EvaluateBoard
end
if <<<(argument_reporter_string_number) = (argument_reporter_string_number)> and <(argument_reporter_string_number) < (3)>> or <<(argument_reporter_string_number) < (argument_reporter_string_number)> and <(argument_reporter_string_number) = (2)>>> then 
EvaluateBoardExtended %n
end
if <(argument_reporter_string_number) = (argument_reporter_string_number)> then 
set [ScoreCalcRes v] to ((EvalResult) + (EvalExtendedResult))
if <(argument_reporter_string_number) > (2)> then 
if <(1) = (0)> then 
change [ScoreCalcRes v] by ((0) - (item (3) of [TargetPieces v]))
change [ScoreCalcRes v] by (item (3) of [PosScoreDelta v])
if <not <(item (3) of [PromotionPieces v]) = (Empty)>> then 
change [ScoreCalcRes v] by ((item (3) of [PromotionPieces v]) - (BlackPawn))
end
end
if <(argument_reporter_string_number) > (3)> then 
change [ScoreCalcRes v] by ((0) - (item (4) of [TargetPieces v]))
change [ScoreCalcRes v] by (item (4) of [PosScoreDelta v])
if <not <(item (4) of [PromotionPieces v]) = (Empty)>> then 
change [ScoreCalcRes v] by ((item (4) of [PromotionPieces v]) - (WhitePawn))
end
if <(argument_reporter_string_number) > (4)> then 
change [ScoreCalcRes v] by ((0) - (item (5) of [TargetPieces v]))
change [ScoreCalcRes v] by (item (5) of [PosScoreDelta v])
if <not <(item (5) of [PromotionPieces v]) = (Empty)>> then 
change [ScoreCalcRes v] by ((item (5) of [PromotionPieces v]) - (BlackPawn))
end
if <(argument_reporter_string_number) > (5)> then 
change [ScoreCalcRes v] by ((0) - (item (6) of [TargetPieces v]))
change [ScoreCalcRes v] by (item (6) of [PosScoreDelta v])
if <not <(item (6) of [PromotionPieces v]) = (Empty)>> then 
change [ScoreCalcRes v] by ((item (6) of [PromotionPieces v]) - (WhitePawn))
end
if <(argument_reporter_string_number) > (6)> then 
change [ScoreCalcRes v] by ((0) - (item (7) of [TargetPieces v]))
change [ScoreCalcRes v] by (item (7) of [PosScoreDelta v])
if <not <(item (7) of [PromotionPieces v]) = (Empty)>> then 
change [ScoreCalcRes v] by ((item (7) of [PromotionPieces v]) - (BlackPawn))
end
if <(argument_reporter_string_number) > (7)> then 
change [ScoreCalcRes v] by ((0) - (item (8) of [TargetPieces v]))
change [ScoreCalcRes v] by (item (8) of [PosScoreDelta v])
if <not <(item (8) of [PromotionPieces v]) = (Empty)>> then 
change [ScoreCalcRes v] by ((item (8) of [PromotionPieces v]) - (WhitePawn))
end
if <(argument_reporter_string_number) > (8)> then 
change [ScoreCalcRes v] by ((0) - (item (9) of [TargetPieces v]))
change [ScoreCalcRes v] by (item (9) of [PosScoreDelta v])
if <not <(item (9) of [PromotionPieces v]) = (Empty)>> then 
change [ScoreCalcRes v] by ((item (9) of [PromotionPieces v]) - (BlackPawn))
end
if <(argument_reporter_string_number) > (9)> then 
change [ScoreCalcRes v] by ((0) - (item (10) of [TargetPieces v]))
change [ScoreCalcRes v] by (item (10) of [PosScoreDelta v])
if <not <(item (10) of [PromotionPieces v]) = (Empty)>> then 
change [ScoreCalcRes v] by ((item (10) of [PromotionPieces v]) - (WhitePawn))
end
end
end
end
end
end
end
end
end
if <argument_reporter_boolean> then 
if <not <(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)>> then 
GetCurrentMove %n
set [TargetIdx v] to ([floor v] of ((CurrentMove) mod (100)) ::operators)
if <<<((argument_reporter_string_number) mod (2)) = (0)> and <(item (TargetIdx) of [BoardAttackedByBlack v]) > (0)>> or <<((argument_reporter_string_number) mod (2)) = (1)> and <(item (TargetIdx) of [BoardAttackedByWhite v]) > (0)>>> then 
change [ScoreCalcRes v] by ((0) - (item (TargetIdx) of [Board v]))
end
end
end
if <(IsEndgame) = (1)> then 
if <(ScoreCalcRes) > (BlackKnight)> then 
change [ScoreCalcRes v] by ((-5) * (WhiteKingMoveCount))
end
if <(ScoreCalcRes) < (WhiteKnight)> then 
change [ScoreCalcRes v] by ((5) * (BlackKingMoveCount))
end
end
end

define InitKnightSquare
delete (all) of [KnightPieceSquare v]
set [KnightSquareDef v] to [-30, -20, -15, -15, -15, -15, -20, -30,-20, 15, 20, 20, 20, 20, 15, -20,-20, 22, 30, 35, 35, 30, 22, -20,-20, 20, 25, 25, 25, 25, 20, -20,-20,  5, 20, 18, 18, 20,  5, -20,-20,  0, 15, 10, 10, 15,  0, -20, -15, -15, -5, 5,  5, -5, -15, -15, -35, -10,-12,-7, -7,-12, -10, -35]
LoadList %s %s

define EvaluateBoardExtended %n
set [BlackKingIdx v] to [0]
set [WhiteKingIdx v] to [0]
set [EvalExtendedResult v] to [0]
set [Idx v] to [1]
repeat (8) 
replace item (Idx) of [BlackPawnCount v] with [0]
replace item (Idx) of [WhitePawnCount v] with [0]
change [Idx v] by (1)
end
set [Idx v] to [1]
set [InvIdx v] to [64]
repeat (64) 
set [CurrentPiece v] to (item (Idx) of [Board v])
if <(IsEndgame) = (0)> then 
if <(CurrentPiece) = (BlackPawn)> then 
set [IdxSub v] to (item (Idx) of [IdxToCol v])
replace item (IdxSub) of [BlackPawnCount v] with ((item (IdxSub) of [BlackPawnCount v]) + (1))
if <(Idx) > (16)> then 
if <<<(IdxSub) > (1)> and <(item ((Idx) - (9)) of [Board v]) = (BlackPawn)>> or <<(IdxSub) < (8)> and <(item ((Idx) - (7)) of [Board v]) = (BlackPawn)>>> then 
change [EvalExtendedResult v] by (10)
end
end
 else 
if <(CurrentPiece) = (WhitePawn)> then 
set [IdxSub v] to (item (Idx) of [IdxToCol v])
replace item (IdxSub) of [WhitePawnCount v] with ((item (IdxSub) of [WhitePawnCount v]) + (1))
if <(Idx) < (49)> then 
if <<<(IdxSub) > (1)> and <(item ((Idx) + (7)) of [Board v]) = (WhitePawn)>> or <<(IdxSub) < (8)> and <(item ((Idx) + (9)) of [Board v]) = (WhitePawn)>>> then 
change [EvalExtendedResult v] by (-10)
end
end
end
end
 else 
if <(CurrentPiece) = (WhiteKing)> then 
set [WhiteKingIdx v] to [Idx]
 else 
if <(CurrentPiece) = (BlackKing)> then 
set [BlackKingIdx v] to [Idx]
end
end
end
change [Idx v] by (1)
change [InvIdx v] by (-1)
end
if <(IsEndgame) = (0)> then 
set [Idx v] to [1]
repeat (8) 
if <(item (Idx) of [BlackPawnCount v]) = (1)> then 
if <<<(Idx) > (1)> and <(item ((Idx) - (1)) of [BlackPawnCount v]) > (0)>> or <<(Idx) < (8)> and <(item ((Idx) + (1)) of [BlackPawnCount v]) > (0)>>> then 
change [EvalExtendedResult v] by (10)
end
 else 
if <(item (Idx) of [BlackPawnCount v]) > (1)> then 
change [EvalExtendedResult v] by ((-15) * (item (Idx) of [BlackPawnCount v]))
end
end
if <(item (Idx) of [WhitePawnCount v]) = (1)> then 
if <<<(Idx) > (1)> and <(item ((Idx) - (1)) of [WhitePawnCount v]) > (0)>> or <<(Idx) < (8)> and <(item ((Idx) + (1)) of [WhitePawnCount v]) > (0)>>> then 
change [EvalExtendedResult v] by (-10)
end
 else 
if <(item (Idx) of [WhitePawnCount v]) > (1)> then 
change [EvalExtendedResult v] by ((15) * (item (Idx) of [WhitePawnCount v]))
end
end
change [Idx v] by (1)
end
 else 
if <<((WhiteQueenCount) + (WhiteMinorCount)) = (0)> or <((BlackQueenCount) + (BlackMinorCount)) = (0)>> then 
set [Delta v] to (([abs v] of ((item (WhiteKingIdx) of [IdxToRow v]) - (item (BlackKingIdx) of [IdxToRow v])) ::operators) + ([abs v] of ((item (WhiteKingIdx) of [IdxToCol v]) - (item (BlackKingIdx) of [IdxToCol v])) ::operators))
if <((WhiteQueenCount) + (WhiteMinorCount)) < ((BlackQueenCount) + (BlackMinorCount))> then 
change [EvalExtendedResult v] by ((-10) * (Delta))
 else 
if <((WhiteQueenCount) + (WhiteMinorCount)) > ((BlackQueenCount) + (BlackMinorCount))> then 
change [EvalExtendedResult v] by ((10) * (Delta))
end
end
end
end

define GetTargetIdx %n %n %n
set [GetTargetIdxRes v] to [-1]
set [X v] to ((item (argument_reporter_string_number) of [IdxToCol v]) + (argument_reporter_string_number))
if <<(X) > (0)> and <(X) < (9)>> then 
set [Y v] to ((item (argument_reporter_string_number) of [IdxToRow v]) + (argument_reporter_string_number))
if <<(Y) > (0)> and <(Y) < (9)>> then 
set [GetTargetIdxRes v] to ((X) + (((Y) - (1)) * (8)))
end
end

define AlphaBetaMinMax %n %n %n %n %b %b %n %b
OnScoreCalc %n %n %n %b %b %b
replace item (argument_reporter_string_number) of [Alphas v] with (argument_reporter_string_number)
replace item (argument_reporter_string_number) of [Betas v] with (argument_reporter_string_number)
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b

define IsStringEqual %s %n %s %n
set [IsStringEqualRes v] to [1]
set [Offset v] to [0]
repeat until <<(Offset) = (length of (argument_reporter_string_number))> or <(Offset) = (length of (argument_reporter_string_number))>> 
if <not <(letter ((argument_reporter_string_number) + (Offset)) of (argument_reporter_string_number)) = (letter ((argument_reporter_string_number) + (Offset)) of (argument_reporter_string_number))>> then 
set [IsStringEqualRes v] to [0]
stop [this script v]
end
change [Offset v] by (1)
end

define StoreMove %n %b
if <(1) = (0)> then 
if <argument_reporter_boolean> then 
GetCurrentMove %n
replace item (CurrentMove) of [HistoryTable v] with ((item (CurrentMove) of [HistoryTable v]) + (((10) - (argument_reporter_string_number)) * ((10) - (argument_reporter_string_number))))
end
end
if <(argument_reporter_string_number) = (10)> then 
replace item (10) of [PrevBestHashMove v] with (item (item (10) of [MovesIdx v]) of [Moves10 v])
 else 
if <(argument_reporter_string_number) = (9)> then 
replace item (9) of [PrevBestHashMove v] with (item (item (9) of [MovesIdx v]) of [Moves9 v])
 else 
if <(argument_reporter_string_number) = (8)> then 
replace item (8) of [PrevBestHashMove v] with (item (item (8) of [MovesIdx v]) of [Moves8 v])
 else 
if <(argument_reporter_string_number) = (7)> then 
replace item (7) of [PrevBestHashMove v] with (item (item (7) of [MovesIdx v]) of [Moves7 v])
 else 
if <(argument_reporter_string_number) = (6)> then 
replace item (6) of [PrevBestHashMove v] with (item (item (6) of [MovesIdx v]) of [Moves6 v])
if <argument_reporter_boolean> then 
if <not <[KillerMoves6 v] contains (item (item (6) of [MovesIdx v]) of [Moves6 v]) ? ::lists>> then 
add (item (item (6) of [MovesIdx v]) of [Moves6 v]) to [KillerMoves6 v]
if <(length of [KillerMoves6 v]) > (4)> then 
delete (1) of [KillerMoves6 v]
end
end
end
 else 
if <(argument_reporter_string_number) = (5)> then 
replace item (5) of [PrevBestHashMove v] with (item (item (5) of [MovesIdx v]) of [Moves5 v])
if <argument_reporter_boolean> then 
if <not <[KillerMoves5 v] contains (item (item (5) of [MovesIdx v]) of [Moves5 v]) ? ::lists>> then 
add (item (item (5) of [MovesIdx v]) of [Moves5 v]) to [KillerMoves5 v]
if <(length of [KillerMoves5 v]) > (4)> then 
delete (1) of [KillerMoves5 v]
end
end
end
 else 
if <(argument_reporter_string_number) = (4)> then 
replace item (4) of [PrevBestHashMove v] with (item (item (4) of [MovesIdx v]) of [Moves4 v])
if <argument_reporter_boolean> then 
if <not <[KillerMoves4 v] contains (item (item (4) of [MovesIdx v]) of [Moves4 v]) ? ::lists>> then 
add (item (item (4) of [MovesIdx v]) of [Moves4 v]) to [KillerMoves4 v]
if <(length of [KillerMoves4 v]) > (4)> then 
delete (1) of [KillerMoves4 v]
end
end
end
 else 
if <(argument_reporter_string_number) = (3)> then 
replace item (3) of [PrevBestHashMove v] with (item (item (3) of [MovesIdx v]) of [Moves3 v])
if <argument_reporter_boolean> then 
if <not <[KillerMoves3 v] contains (item (item (3) of [MovesIdx v]) of [Moves3 v]) ? ::lists>> then 
add (item (item (3) of [MovesIdx v]) of [Moves3 v]) to [KillerMoves3 v]
if <(length of [KillerMoves3 v]) > (4)> then 
delete (1) of [KillerMoves3 v]
end
end
end
 else 
if <(argument_reporter_string_number) = (2)> then 
replace item (2) of [PrevBestHashMove v] with (item (item (2) of [MovesIdx v]) of [Moves2 v])
if <argument_reporter_boolean> then 
if <not <[KillerMoves2 v] contains (item (item (2) of [MovesIdx v]) of [Moves2 v]) ? ::lists>> then 
add (item (item (2) of [MovesIdx v]) of [Moves2 v]) to [KillerMoves2 v]
if <(length of [KillerMoves2 v]) > (4)> then 
delete (1) of [KillerMoves2 v]
end
end
end
 else 
if <(argument_reporter_string_number) = (1)> then 
replace item (1) of [PrevBestHashMove v] with (item (item (1) of [MovesIdx v]) of [Moves1 v])
if <argument_reporter_boolean> then 
if <not <[KillerMoves1 v] contains (item (item (1) of [MovesIdx v]) of [Moves1 v]) ? ::lists>> then 
add (item (item (1) of [MovesIdx v]) of [Moves1 v]) to [KillerMoves1 v]
if <(length of [KillerMoves1 v]) > (4)> then 
delete (1) of [KillerMoves1 v]
end
end
end
end
end
end
end
end
end
end
end
end
end

define PickMove %n %n %b %b %b %b
if <(item (argument_reporter_string_number) of [PickPhase v]) = (1)> then 
ClearMoveList %n
replace item (argument_reporter_string_number) of [PickHash v] with []
if <<argument_reporter_boolean> and <(argument_reporter_string_number) < (7)>> then 
GetBestHashMove %n
if <<not <(BestHashMoveResult) = (-1)>> and <(length of [BestHashMoveResult]) > (0)>> then 
if <((argument_reporter_string_number) mod (2)) = ((BestHashMoveDepthResult) mod (2))> then 
set [IsLegalMove v] to [0]
set [SourceIdx v] to ([floor v] of ((BestHashMoveResult) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((BestHashMoveResult) mod (100)) ::operators)
if <<(SourceIdx) > (0)> and <(TargetIdx) > (0)>> then 
CalculateMovesForSource %n %n %b %b
if <<(argument_reporter_string_number) = (1)> and <[Moves1 v] contains [BestHashMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (2)> and <[Moves2 v] contains [BestHashMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (3)> and <[Moves3 v] contains [BestHashMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (4)> and <[Moves4 v] contains [BestHashMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (5)> and <[Moves5 v] contains [BestHashMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (6)> and <[Moves6 v] contains [BestHashMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (7)> and <[Moves7 v] contains [BestHashMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (8)> and <[Moves8 v] contains [BestHashMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (9)> and <[Moves9 v] contains [BestHashMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (10)> and <[Moves10 v] contains [BestHashMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
end
end
end
end
end
end
end
end
end
end
 else 
set [IsLegalMove v] to [1]
end
ClearMoveList %n
if <(IsLegalMove) = (1)> then 
replace item (argument_reporter_string_number) of [CheckedState v] with [BestHashMoveCheckedResult]
replace item (argument_reporter_string_number) of [PickHash v] with [BestHashMoveResult]
AddToMoveList %n %n
replace item (argument_reporter_string_number) of [MovesIdx v] with [1]
ApplyMove %n
replace item (argument_reporter_string_number) of [PickPhase v] with [2]
replace item (argument_reporter_string_number) of [PickMoveRes v] with [1]
stop [this script v]
end
end
end
end
replace item (argument_reporter_string_number) of [PickPhase v] with [2]
end
if <(item (argument_reporter_string_number) of [PickPhase v]) = (2)> then 
CalcBoardAttackedByMove %n
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (1)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (1)>>> then 
replace item (argument_reporter_string_number) of [CheckedState v] with [1]
 else 
replace item (argument_reporter_string_number) of [CheckedState v] with [0]
end
CalculateMovesImpl %n %b %b
if <argument_reporter_boolean> then 
CutoffPreProcess %n
end
if <not <argument_reporter_boolean>> then 
CutoffReorder %n %b
end
replace item (argument_reporter_string_number) of [MovesIdx v] with [0]
replace item (argument_reporter_string_number) of [PickPhase v] with [3]
end
if <(item (argument_reporter_string_number) of [PickPhase v]) = (3)> then 
replace item (argument_reporter_string_number) of [MovesIdx v] with ((item (argument_reporter_string_number) of [MovesIdx v]) + (1))
if <not <(item (argument_reporter_string_number) of [MovesIdx v]) > (item (argument_reporter_string_number) of [MovesCount v])>> then 
GetCurrentMove %n
if <(CurrentMove) = (item (argument_reporter_string_number) of [PickHash v])> then 
replace item (argument_reporter_string_number) of [MovesIdx v] with ((item (argument_reporter_string_number) of [MovesIdx v]) + (1))
end
if <not <(item (argument_reporter_string_number) of [MovesIdx v]) > (item (argument_reporter_string_number) of [MovesCount v])>> then 
ApplyMove %n
replace item (argument_reporter_string_number) of [PickMoveRes v] with [1]
stop [this script v]
end
end
replace item (argument_reporter_string_number) of [PickPhase v] with [4]
replace item (argument_reporter_string_number) of [PickMoveRes v] with [0]
end
replace item (argument_reporter_string_number) of [PickMoveRes v] with [0]

define CutoffReorder %n %b
if <(argument_reporter_string_number) = (1)> then 
if <argument_reporter_boolean> then 
if <<not <(length of [Moves1 v]) = (length of [SortedList v])>> or <not <(length of [Moves1 v]) = (length of [SortedList2 v])>>> then 
if <(IsDebugMode) = (1)> then 
say [Reorder lists inconsistent at depth 1]
end
 else 
delete (all) of [SortedListTemp v]
set [Idx v] to [1]
repeat (length of [SortedList2 v]) 
add (item (item (Idx) of [SortedList v]) of [SortedList2 v]) to [SortedListTemp v]
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList2 v]) 
replace item (Idx) of [SortedList2 v] with (item (Idx) of [SortedListTemp v])
change [Idx v] by (1)
end
delete (all) of [MovesTemp v]
set [Idx v] to [1]
repeat (length of [Moves1 v]) 
add (item (item (Idx) of [SortedList v]) of [Moves1 v]) to [MovesTemp v]
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [Moves1 v]) 
replace item (Idx) of [Moves1 v] with (item (Idx) of [MovesTemp v])
change [Idx v] by (1)
end
end
 else 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves1Score v]) 
if <(item (Idx) of [Moves1Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves1Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves1Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves1 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves1 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
end
if <(argument_reporter_string_number) = (2)> then 
if <argument_reporter_boolean> then 
if <not <(length of [Moves2 v]) = ((length of (item (item (1) of [MovesIdx v]) of [SortedList2 v])) / (4))>> then 
if <(IsDebugMode) = (1)> then 
say [Reorder lists inconsistent at depth 2]
end
 else 
delete (all) of [MovesTemp v]
set [Idx v] to [1]
repeat (length of [Moves2 v]) 
add (item (Idx) of [Moves2 v]) to [MovesTemp v]
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [Moves2 v]) 
GetSubstring %s %n %n
replace item (Idx) of [Moves2 v] with (item (SubstringRes) of [MovesTemp v])
change [Idx v] by (1)
end
end
 else 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves2Score v]) 
if <(item (Idx) of [Moves2Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves2Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves2Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves2 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves2 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
end
if <(argument_reporter_string_number) = (3)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves3Score v]) 
if <(item (Idx) of [Moves3Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves3Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves3Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves3 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves3 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (4)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves4Score v]) 
if <(item (Idx) of [Moves4Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves4Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves4Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves4 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves4 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (5)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves5Score v]) 
if <(item (Idx) of [Moves5Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves5Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves5Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves5 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves5 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (6)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves6Score v]) 
if <(item (Idx) of [Moves6Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves6Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves6Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves6 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves6 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (7)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves7Score v]) 
if <(item (Idx) of [Moves7Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves7Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves7Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves7 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves7 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (8)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves8Score v]) 
if <(item (Idx) of [Moves8Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves8Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves8Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves8 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves8 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (9)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves9Score v]) 
if <(item (Idx) of [Moves9Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves9Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves9Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves9 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves9 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (10)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves10Score v]) 
if <(item (Idx) of [Moves10Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves10Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves10Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves10 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves10 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end

define CutoffPreProcess %n
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [SortedList v]
repeat until <(length of [SortedList v]) = (length of [Moves1 v])> 
add [] to [SortedList v]
end
delete (all) of [SortedList2 v]
repeat until <(length of [SortedList2 v]) = (length of [Moves1 v])> 
add [] to [SortedList2 v]
end
end
if <(argument_reporter_string_number) = (2)> then 
delete (all) of [SortedListTemp v]
repeat until <(length of [SortedListTemp v]) = (length of [Moves2 v])> 
add [] to [SortedListTemp v]
end
end

define QuickSortTemp %s %s
set [QSLower v] to (argument_reporter_string_number)
set [QSUpper v] to (argument_reporter_string_number)
set [QSPivot v] to (item ([floor v] of (((argument_reporter_string_number) + (argument_reporter_string_number)) / (2)) ::operators) of [SortedListTemp v])
repeat until <(QSLower) > (QSUpper)> 
repeat until <not <(item (QSLower) of [SortedListTemp v]) < (QSPivot)>> 
change [QSLower v] by (1)
end
repeat until <not <(item (QSUpper) of [SortedListTemp v]) > (QSPivot)>> 
change [QSUpper v] by (-1)
end
if <not <(QSLower) > (QSUpper)>> then 
set [QSSwap v] to (item (QSLower) of [SortedListTemp v])
replace item (QSLower) of [SortedListTemp v] with (item (QSUpper) of [SortedListTemp v])
replace item (QSUpper) of [SortedListTemp v] with [QSSwap]
change [QSLower v] by (1)
change [QSUpper v] by (-1)
end
end
if <(argument_reporter_string_number) < (QSUpper)> then 
QuickSortTemp %s %s
end
if <(QSLower) < (argument_reporter_string_number)> then 
QuickSortTemp %s %s
end

define AddMoveImpl %n %n %n %b %b %b %b %b
set [TargetPiece v] to (item ([floor v] of (argument_reporter_string_number) ::operators) of [Board v])
if <<<argument_reporter_boolean> and <(TargetPiece) = (Empty)>> or <<<argument_reporter_boolean> and <(TargetPiece) > (0)>> or <<argument_reporter_boolean> and <(TargetPiece) < (0)>>>> then 
set [SourcePiece v] to (item (argument_reporter_string_number) of [Board v])
if <argument_reporter_boolean> then 
if <(SourcePiece) > (0)> then 
replace item (argument_reporter_string_number) of [BoardAttackedByBlack v] with ((item (argument_reporter_string_number) of [BoardAttackedByBlack v]) + (1))
if <(TargetPiece) = (WhiteKing)> then 
set [IsWhiteChecked v] to [1]
end
if <(1) = (0)> then 
GetSEEMapVal %n
replace item (argument_reporter_string_number) of [BoardAttackedByBlackPiece v] with ((item (argument_reporter_string_number) of [BoardAttackedByBlackPiece v]) + (SEEMapValRes))
end
 else 
replace item (argument_reporter_string_number) of [BoardAttackedByWhite v] with ((item (argument_reporter_string_number) of [BoardAttackedByWhite v]) + (1))
if <(TargetPiece) = (BlackKing)> then 
set [IsBlackChecked v] to [1]
end
if <(1) = (0)> then 
GetSEEMapVal %n
replace item (argument_reporter_string_number) of [BoardAttackedByWhitePiece v] with ((item (argument_reporter_string_number) of [BoardAttackedByWhitePiece v]) + (SEEMapValRes))
end
end
 else 
if <<argument_reporter_boolean> and <<(TargetPiece) = (Empty)> and <not <<<(SourcePiece) = (WhitePawn)> and <(item (argument_reporter_string_number) of [IdxToRow v]) = (2)>> or <<(SourcePiece) = (BlackPawn)> and <(item (argument_reporter_string_number) of [IdxToRow v]) = (7)>>>>>> then 
stop [this script v]
end
if <not <argument_reporter_boolean>> then 
if <<<(SourcePiece) > (0)> and <(item ([floor v] of (argument_reporter_string_number) ::operators) of [BoardAttackedByWhite v]) = (0)>> or <<(SourcePiece) < (0)> and <(item ([floor v] of (argument_reporter_string_number) ::operators) of [BoardAttackedByBlack v]) = (0)>>> then 
replace item (argument_reporter_string_number) of [PieceMobility v] with ((item (argument_reporter_string_number) of [PieceMobility v]) + (1))
end
end
set [CurrentMove v] to (((argument_reporter_string_number) * (100)) + (argument_reporter_string_number))
if <(argument_reporter_string_number) < (10)> then 
set [CurrentMove v] to (join [0] [CurrentMove])
end
if <<<(SourcePiece) = (WhitePawn)> and <(item (argument_reporter_string_number) of [IdxToRow v]) = (2)>> or <<(SourcePiece) = (BlackPawn)> and <(item (argument_reporter_string_number) of [IdxToRow v]) = (7)>>> then 
if <(CurrentMove) = ([floor v] of (CurrentMove) ::operators)> then 
AddMoveImpl %n %n %n %b %b %b %b %b
AddMoveImpl %n %n %n %b %b %b %b %b
AddMoveImpl %n %n %n %b %b %b %b %b
AddMoveImpl %n %n %n %b %b %b %b %b
stop [this script v]
end
end
if <(argument_reporter_string_number) = (10)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves10 v]
add [MoveScoreRes] to [Moves10Score v]
 else 
if <(argument_reporter_string_number) = (9)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves9 v]
add [MoveScoreRes] to [Moves9Score v]
 else 
if <(argument_reporter_string_number) = (8)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves8 v]
add [MoveScoreRes] to [Moves8Score v]
 else 
if <(argument_reporter_string_number) = (7)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves7 v]
add [MoveScoreRes] to [Moves7Score v]
 else 
if <(argument_reporter_string_number) = (6)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves6 v]
add [MoveScoreRes] to [Moves6Score v]
 else 
if <(argument_reporter_string_number) = (5)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves5 v]
add [MoveScoreRes] to [Moves5Score v]
 else 
if <(argument_reporter_string_number) = (4)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves4 v]
add [MoveScoreRes] to [Moves4Score v]
 else 
if <(argument_reporter_string_number) = (3)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves3 v]
add [MoveScoreRes] to [Moves3Score v]
 else 
if <(argument_reporter_string_number) = (2)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves2 v]
add [MoveScoreRes] to [Moves2Score v]
 else 
if <(argument_reporter_string_number) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves1 v]
add [MoveScoreRes] to [Moves1Score v]
end
end
end
end
end
end
end
end
end
end
end
end

define CalcBoardAttackedByMove %n
ClearBoardAttackedByMove %n
CalculateMovesImpl %n %b %b

define AddPossibleEnPassant %n %n %b
AddPossibleEnPassantImpl %n %n %n %b
AddPossibleEnPassantImpl %n %n %n %b

define AddLineMove %n %n %n %b %b %b %b %b
set [Count v] to [1]
set [IdxOuter v] to (item (argument_reporter_string_number) of [MoveLookupLineIndexOffset v])
set [InvIdxOuter v] to [8]
repeat until <(Count) > (32)> 
set [TargetIdxOuter v] to [-1]
if <(argument_reporter_string_number) = (LineMoveTypeStraight)> then 
set [TargetIdxOuter v] to (item ((IdxOuter) + (Count)) of [MoveLookupStraight v])
end
if <(argument_reporter_string_number) = (LineMoveTypeCross)> then 
set [TargetIdxOuter v] to (item ((IdxOuter) + (Count)) of [MoveLookupCross v])
end
set [TargetPieceOuter v] to [Empty]
if <not <(TargetIdxOuter) = (-1)>> then 
AddMoveImpl %n %n %n %b %b %b %b %b
set [TargetPieceOuter v] to (item (TargetIdxOuter) of [Board v])
end
if <<(TargetIdxOuter) = (-1)> or <not <(TargetPieceOuter) = (Empty)>>> then 
change [Count v] by (InvIdxOuter)
set [InvIdxOuter v] to [8]
 else 
change [Count v] by (1)
change [InvIdxOuter v] by (-1)
end
end

define GetBoardString
set [GetBoardStringRes v] to []
set [Idx v] to [1]
repeat (64) 
if <(item (Idx) of [Board v]) = (0)> then 
set [GetBoardStringRes v] to (join [GetBoardStringRes] [,])
 else 
set [GetBoardStringRes v] to (join [GetBoardStringRes] (join (item (Idx) of [Board v]) [,]))
end
change [Idx v] by (1)
end

when i receive [progressvaluechangedinternal v]
broadcast (1 v) and wait

when i receive [stageclicked v]
hide list [ExportData v]
hide list [ExportMoves v]
if <(IsExecutionRunning) = (0)> then 
say []
end

define GetSubstringLeft %n %n
GetSubstring %s %n %n

define QuickSort %s %s
set [QSLower v] to (argument_reporter_string_number)
set [QSUpper v] to (argument_reporter_string_number)
set [QSPivot v] to (item ([floor v] of (((argument_reporter_string_number) + (argument_reporter_string_number)) / (2)) ::operators) of [SortedList v])
repeat until <(QSLower) > (QSUpper)> 
repeat until <not <(item (QSLower) of [SortedList v]) < (QSPivot)>> 
change [QSLower v] by (1)
end
repeat until <not <(item (QSUpper) of [SortedList v]) > (QSPivot)>> 
change [QSUpper v] by (-1)
end
if <not <(QSLower) > (QSUpper)>> then 
set [QSSwap v] to (item (QSLower) of [SortedList v])
replace item (QSLower) of [SortedList v] with (item (QSUpper) of [SortedList v])
replace item (QSUpper) of [SortedList v] with [QSSwap]
change [QSLower v] by (1)
change [QSUpper v] by (-1)
end
end
if <(argument_reporter_string_number) < (QSUpper)> then 
QuickSort %s %s
end
if <(QSLower) < (argument_reporter_string_number)> then 
QuickSort %s %s
end

define DrawBoard
UpdateStatePanelData
set [ProgressValue v] to [0]
broadcast (1 v)
broadcast (1 v)

define GetSubstring %s %n %n
set [SubstringRes v] to []
set [IdxString v] to (argument_reporter_string_number)
repeat (((argument_reporter_string_number) - (argument_reporter_string_number)) + (1)) 
set [SubstringRes v] to (join [SubstringRes] (letter (IdxString) of (argument_reporter_string_number)))
change [IdxString v] by (1)
end

define CutoffOnMoveScore %n %n
if <(argument_reporter_string_number) = (1)> then 
if <(argument_reporter_string_number) < (0)> then 
replace item (item (1) of [MovesIdx v]) of [SortedList v] with ((0) - (([abs v] of ((argument_reporter_string_number) * (10000)) ::operators) + (item (1) of [MovesIdx v])))
 else 
replace item (item (1) of [MovesIdx v]) of [SortedList v] with (((argument_reporter_string_number) * (10000)) + (item (1) of [MovesIdx v]))
end
end
if <(argument_reporter_string_number) = (2)> then 
if <(argument_reporter_string_number) < (0)> then 
replace item (item (2) of [MovesIdx v]) of [SortedListTemp v] with ((0) - (([abs v] of ((argument_reporter_string_number) * (10000)) ::operators) + (item (2) of [MovesIdx v])))
 else 
replace item (item (2) of [MovesIdx v]) of [SortedListTemp v] with (((argument_reporter_string_number) * (10000)) + (item (2) of [MovesIdx v]))
end
end

define InitMoveLookup
delete (all) of [MoveLookupStraight v]
delete (all) of [MoveLookupCross v]
delete (all) of [MoveLookupOffsetsStraight v]
delete (all) of [MoveLookupOffsetsCross v]
delete (all) of [MoveLookupKnight v]
delete (all) of [MoveLookupKing v]
delete (all) of [MoveLookupIndexOffset v]
delete (all) of [MoveLookupLineIndexOffset v]
add [1] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [1] to [MoveLookupOffsetsStraight v]
add [-1] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [-1] to [MoveLookupOffsetsStraight v]
add [1] to [MoveLookupOffsetsCross v]
add [1] to [MoveLookupOffsetsCross v]
add [1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
add [1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
set [Idx v] to [1]
repeat (64) 
set [IdxSub v] to [1]
repeat (4) 
set [X v] to (item (Idx) of [IdxToCol v])
set [Y v] to (item (Idx) of [IdxToRow v])
repeat (8) 
change [X v] by (item (IdxSub) of [MoveLookupOffsetsStraight v])
change [Y v] by (item ((IdxSub) + (1)) of [MoveLookupOffsetsStraight v])
add [-1] to [MoveLookupStraight v]
if <<(Y) > (0)> and <(Y) < (9)>> then 
if <<(X) > (0)> and <(X) < (9)>> then 
set [TargetIdx v] to ((X) + (((Y) - (1)) * (8)))
replace item (last) of [MoveLookupStraight v] with [TargetIdx]
end
end
end
change [IdxSub v] by (2)
end
set [IdxSub v] to [1]
repeat (4) 
set [X v] to (item (Idx) of [IdxToCol v])
set [Y v] to (item (Idx) of [IdxToRow v])
repeat (8) 
change [X v] by (item (IdxSub) of [MoveLookupOffsetsCross v])
change [Y v] by (item ((IdxSub) + (1)) of [MoveLookupOffsetsCross v])
add [-1] to [MoveLookupCross v]
if <<(Y) > (0)> and <(Y) < (9)>> then 
if <<(X) > (0)> and <(X) < (9)>> then 
set [TargetIdx v] to ((X) + (((Y) - (1)) * (8)))
replace item (last) of [MoveLookupCross v] with [TargetIdx]
end
end
end
change [IdxSub v] by (2)
end
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (64) 
insert (((Idx) - (1)) * (8)) at (Idx) of [MoveLookupIndexOffset v]
insert (((Idx) - (1)) * (32)) at (Idx) of [MoveLookupLineIndexOffset v]
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (64) 
set [IdxSub v] to [1]
repeat (8) 
GetTargetIdx %n %n %n
if <(GetTargetIdxRes) = (-1)> then 
add [GetTargetIdxRes] to [MoveLookupKing v]
 else 
end
change [IdxSub v] by (2)
end
repeat until <(length of [MoveLookupKing v]) = ((Idx) * (8))> 
add [-1] to [MoveLookupKing v]
end
set [IdxSub v] to [1]
repeat (8) 
GetTargetIdx %n %n %n
if <(GetTargetIdxRes) = (-1)> then 
add [GetTargetIdxRes] to [MoveLookupKnight v]
 else 
end
change [IdxSub v] by (2)
end
repeat until <(length of [MoveLookupKnight v]) = ((Idx) * (8))> 
add [-1] to [MoveLookupKnight v]
end
change [Idx v] by (1)
end

define GetRepetitionCount
set [Idx v] to ((length of [BoardHistory v]) - (1))
set [RepetitionCountRes v] to [1]
repeat ((length of [BoardHistory v]) - (1)) 
if <(item (Idx) of [BoardHistory v]) = (item (last) of [BoardHistory v])> then 
change [RepetitionCountRes v] by (1)
end
change [Idx v] by (-1)
end

define CutoffPostProcess %n
if <(argument_reporter_string_number) = (1)> then 
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000))
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat ([floor v] of ((length of [SortedList v]) / (2)) ::operators) 
set [Swap v] to (item (Idx) of [SortedList v])
replace item (Idx) of [SortedList v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
replace item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v] with [Swap]
change [Idx v] by (1)
end
replace item (item (1) of [SortedList v]) of [HistoryTable v] with ((item (item (1) of [SortedList v]) of [HistoryTable v]) + (((10) - (argument_reporter_string_number)) * ((10) - (argument_reporter_string_number))))
end
if <(argument_reporter_string_number) = (2)> then 
QuickSortTemp %s %s
set [Idx v] to [1]
repeat (length of [SortedListTemp v]) 
set [CurrentIdx v] to (([abs v] of (item (Idx) of [SortedListTemp v]) ::operators) mod (10000))
repeat until <(length of [CurrentIdx]) > (3)> 
set [CurrentIdx v] to (join [0] [CurrentIdx])
end
replace item (item (1) of [MovesIdx v]) of [SortedList2 v] with (join (item (item (1) of [MovesIdx v]) of [SortedList2 v]) [CurrentIdx])
change [Idx v] by (1)
end
GetSubstring %s %n %n
replace item (SubstringRes) of [HistoryTable v] with ((item (SubstringRes) of [HistoryTable v]) + (((10) - (argument_reporter_string_number)) * ((10) - (argument_reporter_string_number))))
end

define CalculateOpeningMoves
delete (all) of [BestMoves v]
if <(IsImportedBoard) = (0)> then 
if <(IsPlayerBlack) = (0)> then 
set [Idx v] to [1]
 else 
set [Idx v] to (((length of [OpeningMoves v]) / (2)) + (1))
end
repeat ((length of [OpeningMoves v]) / (2)) 
if <(length of [GameMoves]) < (length of (item (Idx) of [OpeningMoves v]))> then 
set [IdxString v] to [1]
set [IsEqual v] to [1]
repeat (length of [GameMoves]) 
if <not <(letter (IdxString) of [GameMoves]) = (letter (IdxString) of (item (Idx) of [OpeningMoves v]))>> then 
set [IsEqual v] to [0]
end
change [IdxString v] by (1)
end
if <(IsEqual) = (1)> then 
set [BestMove v] to (letter ((length of [GameMoves]) + (1)) of (item (Idx) of [OpeningMoves v]))
set [BestMove v] to (join [BestMove] (letter ((length of [GameMoves]) + (2)) of (item (Idx) of [OpeningMoves v])))
set [BestMove v] to (join [BestMove] (letter ((length of [GameMoves]) + (3)) of (item (Idx) of [OpeningMoves v])))
set [BestMove v] to (join [BestMove] (letter ((length of [GameMoves]) + (4)) of (item (Idx) of [OpeningMoves v])))
add [BestMove] to [BestMoves v]
end
end
change [Idx v] by (1)
end
end

define GetXOR %n %n
set [XORA v] to (argument_reporter_string_number)
set [XORB v] to (argument_reporter_string_number)
set [XORVal v] to [1]
set [XORResult v] to [0]
repeat until <<(XORA) = (0)> and <(XORB) = (0)>> 
if <not <((XORA) mod (2)) = ((XORB) mod (2))>> then 
change [XORResult v] by (XORVal)
end
set [XORA v] to ([floor v] of ((XORA) / (2)) ::operators)
set [XORB v] to ([floor v] of ((XORB) / (2)) ::operators)
set [XORVal v] to ((XORVal) * (2))
end

define InitCoordLookup
delete (all) of [IdxToCol v]
delete (all) of [IdxToRow v]
set [Idx v] to [1]
repeat (64) 
add ((((Idx) - (1)) mod (8)) + (1)) to [IdxToCol v]
add ([ceiling v] of ((Idx) / (8)) ::operators) to [IdxToRow v]
change [Idx v] by (1)
end

define ImportBoard %s
set [Level3Depth v] to [2]
set [IsImportedBoard v] to [1]
set [HasWhiteKingMoved v] to [0]
set [HasBlackKingMoved v] to [0]
set [HasWhiteCastled v] to [0]
set [HasBlackCastled v] to [0]
set [HasWhiteRookKSMoved v] to [0]
set [HasWhiteRookQSMoved v] to [0]
set [HasBlackRookKSMoved v] to [0]
set [HasBlackRookQSMoved v] to [0]
set [GameMoves v] to []
delete (all) of [BoardHistory v]
delete (all) of [GameMovesAN v]
set [IsFEN v] to [1]
set [IdxString v] to [1]
repeat (length of (argument_reporter_string_number)) 
if <(letter (IdxString) of (argument_reporter_string_number)) = (,)> then 
set [IsFEN v] to [0]
end
change [IdxString v] by (1)
end
if <(IsFEN) = (1)> then 
ImportBoardFEN %s
 else 
ImportBoardInternal %s
end

define CalculateMovesForSource %n %n %b %b
set [CurrentPiece v] to (item (argument_reporter_string_number) of [Board v])
if <<(CurrentPiece) > (0)> or <argument_reporter_boolean>> then 
set [DoMoveOnWhite v] to [1]
 else 
set [DoMoveOnWhite v] to [0]
end
if <<(CurrentPiece) < (0)> or <argument_reporter_boolean>> then 
set [DoMoveOnBlack v] to [1]
 else 
set [DoMoveOnBlack v] to [0]
end
set [SourceIdx v] to (argument_reporter_string_number)
if <(CurrentPiece) = (BlackPawn)> then 
set [Row v] to (item (SourceIdx) of [IdxToRow v])
set [Column v] to (item (SourceIdx) of [IdxToCol v])
if <(Row) < (8)> then 
if <(Column) > (1)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <(Column) < (8)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
if <(Row) = (2)> then 
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <(item ((SourceIdx) + (8)) of [Board v]) = (Empty)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
 else 
if <(Row) = (5)> then 
AddPossibleEnPassant %n %n %b
end
end
 else 
if <(CurrentPiece) = (WhitePawn)> then 
set [Row v] to (item (SourceIdx) of [IdxToRow v])
set [Column v] to (item (SourceIdx) of [IdxToCol v])
if <(Row) > (1)> then 
if <(Column) > (1)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <(Column) < (8)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
if <(Row) = (7)> then 
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <(item ((SourceIdx) - (8)) of [Board v]) = (Empty)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
 else 
if <(Row) = (4)> then 
AddPossibleEnPassant %n %n %b
end
end
 else 
if <<(CurrentPiece) = (BlackKnight)> or <(CurrentPiece) = (WhiteKnight)>> then 
AddLookupMove %n %n %n %b %b %b %b %b
 else 
if <<(CurrentPiece) = (BlackKing)> or <(CurrentPiece) = (WhiteKing)>> then 
AddLookupMove %n %n %n %b %b %b %b %b
 else 
if <<<(CurrentPiece) = (BlackBishop)> or <(CurrentPiece) = (WhiteBishop)>> or <<(CurrentPiece) = (BlackQueen)> or <(CurrentPiece) = (WhiteQueen)>>> then 
AddLineMove %n %n %n %b %b %b %b %b
end
if <<<(CurrentPiece) = (WhiteRook)> or <(CurrentPiece) = (BlackRook)>> or <<(CurrentPiece) = (BlackQueen)> or <(CurrentPiece) = (WhiteQueen)>>> then 
AddLineMove %n %n %n %b %b %b %b %b
end
end
end
end
end

define ApplyMove %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with [0]
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with []
replace item (argument_reporter_string_number) of [TargetPieces v] with [Empty]
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
replace item (argument_reporter_string_number) of [PreviousMoveHash v] with [CurrentMoveHash]
GetCurrentMove %n
set [SourceIdx v] to ([floor v] of ((CurrentMove) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((CurrentMove) mod (100)) ::operators)
if <<(SourceIdx) > (0)> and <(TargetIdx) > (0)>> then 
if <(argument_reporter_string_number) < (6)> then 
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
if <not <(item (TargetIdx) of [Board v]) = (Empty)>> then 
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
end
 else 
set [CurrentMoveHash v] to (pick random (-1073741823) to (1073741824))
end
GetPosScore %n %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with [PosScoreRes]
GetPosScore %n %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((item (argument_reporter_string_number) of [PosScoreDelta v]) - (PosScoreRes))
GetPosScore %n %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((item (argument_reporter_string_number) of [PosScoreDelta v]) - (PosScoreRes))
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with [TargetIdx]
replace item (argument_reporter_string_number) of [TargetPieces v] with (item (TargetIdx) of [Board v])
replace item (TargetIdx) of [Board v] with (item (SourceIdx) of [Board v])
replace item (SourceIdx) of [Board v] with [Empty]
if <<(item (TargetIdx) of [Board v]) = (BlackPawn)> and <<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <not <(item (SourceIdx) of [IdxToCol v]) = (item (TargetIdx) of [IdxToCol v])>>>> then 
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with ((TargetIdx) - (8))
replace item (argument_reporter_string_number) of [TargetPieces v] with (item ((TargetIdx) - (8)) of [Board v])
replace item ((TargetIdx) - (8)) of [Board v] with [Empty]
set [CurrentMoveHash v] to (pick random (-1073741823) to (1073741824))
end
if <<(item (TargetIdx) of [Board v]) = (WhitePawn)> and <<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <not <(item (SourceIdx) of [IdxToCol v]) = (item (TargetIdx) of [IdxToCol v])>>>> then 
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with ((TargetIdx) + (8))
replace item (argument_reporter_string_number) of [TargetPieces v] with (item ((TargetIdx) + (8)) of [Board v])
replace item ((TargetIdx) + (8)) of [Board v] with [Empty]
set [CurrentMoveHash v] to (pick random (-1073741823) to (1073741824))
end
if <<(item (TargetIdx) of [Board v]) = (BlackPawn)> and <(TargetIdx) > (56)>> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
set [PromotionVal v] to (letter (6) of [CurrentMove])
if <(PromotionVal) = (1)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackQueen]
end
if <(PromotionVal) = (2)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackRook]
end
if <(PromotionVal) = (3)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackBishop]
end
if <(PromotionVal) = (4)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackKnight]
end
if <not <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>> then 
replace item (TargetIdx) of [Board v] with (item (argument_reporter_string_number) of [PromotionPieces v])
end
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
end
if <<(item (TargetIdx) of [Board v]) = (WhitePawn)> and <(TargetIdx) < (9)>> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
set [PromotionVal v] to (letter (6) of [CurrentMove])
if <(PromotionVal) = (1)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteQueen]
end
if <(PromotionVal) = (2)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteRook]
end
if <(PromotionVal) = (3)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteBishop]
end
if <(PromotionVal) = (4)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteKnight]
end
if <not <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>> then 
replace item (TargetIdx) of [Board v] with (item (argument_reporter_string_number) of [PromotionPieces v])
end
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
end
 else 
set [CurrentMoveHash v] to (pick random (-1073741823) to (1073741824))
if <(CurrentMove) = (WhiteKingsideCastling)> then 
replace item (item (61) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (62) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (63) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (64) of [VirtualBoard v]) of [Board v] with [Empty]
 else 
if <(CurrentMove) = (WhiteQueensideCastling)> then 
replace item (item (57) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (59) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (60) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (61) of [VirtualBoard v]) of [Board v] with [Empty]
 else 
if <(CurrentMove) = (BlackKingsideCastling)> then 
replace item (item (5) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (6) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (7) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (8) of [VirtualBoard v]) of [Board v] with [Empty]
 else 
if <(CurrentMove) = (BlackQueensideCastling)> then 
replace item (item (1) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (3) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (4) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (5) of [VirtualBoard v]) of [Board v] with [Empty]
end
end
end
end
end

define AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
AddMoveImpl %n %n %n %b %b %b %b %b

define EvaluateBoard
set [BlackBishopCount v] to [0]
set [WhiteBishopCount v] to [0]
set [EvalResult v] to [0]
set [Idx v] to [1]
set [InvIdx v] to [64]
set [BlackKingIdx v] to [0]
repeat (64) 
set [CurrentPiece v] to (item (Idx) of [Board v])
change [EvalResult v] by (CurrentPiece)
if <not <(CurrentPiece) = (Empty)>> then 
if <<(CurrentPiece) = (BlackPawn)> or <(CurrentPiece) = (WhitePawn)>> then 
if <(IsEndgame) = (1)> then 
if <(CurrentPiece) = (BlackPawn)> then 
change [EvalResult v] by (item (InvIdx) of [PawnPieceSquareEndgame v])
 else 
change [EvalResult v] by ((0) - (item (Idx) of [PawnPieceSquareEndgame v]))
end
 else 
if <(CurrentPiece) = (BlackPawn)> then 
change [EvalResult v] by (item (InvIdx) of [PawnPieceSquare v])
 else 
change [EvalResult v] by ((0) - (item (Idx) of [PawnPieceSquare v]))
end
end
 else 
if <(IsEndgame) = (1)> then 
if <(CurrentPiece) = (BlackKing)> then 
set [BlackKingIdx v] to [Idx]
change [EvalResult v] by (item (InvIdx) of [KingPieceSquareEndgame v])
 else 
if <(CurrentPiece) = (WhiteKing)> then 
change [EvalResult v] by ((0) - (item (Idx) of [KingPieceSquareEndgame v]))
end
end
end
if <(IsEndgame) = (0)> then 
if <(CurrentPiece) = (BlackKnight)> then 
change [EvalResult v] by (item (InvIdx) of [KnightPieceSquare v])
 else 
if <(CurrentPiece) = (WhiteKnight)> then 
change [EvalResult v] by ((0) - (item (Idx) of [KnightPieceSquare v]))
 else 
if <(CurrentPiece) = (BlackBishop)> then 
change [EvalResult v] by (item (InvIdx) of [BishopPieceSquare v])
change [BlackBishopCount v] by (1)
 else 
if <(CurrentPiece) = (WhiteBishop)> then 
change [EvalResult v] by ((0) - (item (Idx) of [BishopPieceSquare v]))
change [WhiteBishopCount v] by (1)
 else 
if <(CurrentPiece) = (BlackRook)> then 
change [EvalResult v] by (item (InvIdx) of [RookPieceSquare v])
 else 
if <(CurrentPiece) = (WhiteRook)> then 
change [EvalResult v] by ((0) - (item (Idx) of [RookPieceSquare v]))
 else 
if <(CurrentPiece) = (BlackKing)> then 
set [BlackKingIdx v] to [Idx]
change [EvalResult v] by (item (InvIdx) of [KingPieceSquare v])
 else 
if <(CurrentPiece) = (WhiteKing)> then 
change [EvalResult v] by ((0) - (item (Idx) of [KingPieceSquare v]))
 else 
if <(CurrentPiece) = (BlackQueen)> then 
change [EvalResult v] by (item (InvIdx) of [QueenPieceSquare v])
 else 
if <(CurrentPiece) = (WhiteQueen)> then 
change [EvalResult v] by ((0) - (item (Idx) of [QueenPieceSquare v]))
end
end
end
end
end
end
end
end
end
end
end
end
end
change [Idx v] by (1)
change [InvIdx v] by (-1)
end
if <(1) = (0)> then 
if <(BlackBishopCount) = (2)> then 
change [EvalResult v] by (50)
end
if <(WhiteBishopCount) = (2)> then 
change [EvalResult v] by (-50)
end
end
if <<(IsImportedBoard) = (0)> and <(length of [GameMovesAN v]) < (13)>> then 
if <not <(item (item (4) of [VirtualBoard v]) of [Board v]) = (BlackQueen)>> then 
change [EvalResult v] by (-20)
end
if <not <(item (item (60) of [VirtualBoard v]) of [Board v]) = (WhiteQueen)>> then 
change [EvalResult v] by (20)
end
end
if <(IsEndgame) = (0)> then 
change [EvalResult v] by ((BlackMobilityBonus) - (WhiteMobilityBonus))
if <<(HasBlackCastled) = (1)> or <<<(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackQueensideCastling)> or <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackQueensideCastling)>> or <<(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackKingsideCastling)> or <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackKingsideCastling)>>>> then 
set [IsQueenside v] to [0]
set [IsKingside v] to [0]
set [KingProtection v] to [0]
if <(HasBlackCastled) = (0)> then 
if <<(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackQueensideCastling)> or <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackQueensideCastling)>> then 
set [IsQueenside v] to [1]
end
if <<(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackKingsideCastling)> or <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackKingsideCastling)>> then 
set [IsKingside v] to [1]
end
 else 
if <<(item (item (1) of [VirtualBoard v]) of [Board v]) = (BlackKing)> or <<(item (item (2) of [VirtualBoard v]) of [Board v]) = (BlackKing)> or <(item (item (3) of [VirtualBoard v]) of [Board v]) = (BlackKing)>>> then 
set [IsQueenside v] to [1]
end
if <<(item (item (9) of [VirtualBoard v]) of [Board v]) = (BlackKing)> or <<(item (item (10) of [VirtualBoard v]) of [Board v]) = (BlackKing)> or <(item (item (11) of [VirtualBoard v]) of [Board v]) = (BlackKing)>>> then 
set [IsQueenside v] to [1]
end
if <<(item (item (6) of [VirtualBoard v]) of [Board v]) = (BlackKing)> or <<(item (item (7) of [VirtualBoard v]) of [Board v]) = (BlackKing)> or <(item (item (8) of [VirtualBoard v]) of [Board v]) = (BlackKing)>>> then 
set [IsKingside v] to [1]
end
if <<(item (item (14) of [VirtualBoard v]) of [Board v]) = (BlackKing)> or <<(item (item (15) of [VirtualBoard v]) of [Board v]) = (BlackKing)> or <(item (item (16) of [VirtualBoard v]) of [Board v]) = (BlackKing)>>> then 
set [IsKingside v] to [1]
end
end
if <(IsQueenside) = (1)> then 
if <<(item (item (9) of [VirtualBoard v]) of [Board v]) = (BlackPawn)> or <(item (item (17) of [VirtualBoard v]) of [Board v]) = (BlackPawn)>> then 
change [KingProtection v] by (1)
end
if <<(item (item (10) of [VirtualBoard v]) of [Board v]) = (BlackPawn)> or <(item (item (18) of [VirtualBoard v]) of [Board v]) = (BlackPawn)>> then 
change [KingProtection v] by (1)
end
if <<(item (item (11) of [VirtualBoard v]) of [Board v]) = (BlackPawn)> or <(item (item (19) of [VirtualBoard v]) of [Board v]) = (BlackPawn)>> then 
change [KingProtection v] by (1)
end
end
if <(IsKingside) = (1)> then 
if <<(item (item (14) of [VirtualBoard v]) of [Board v]) = (BlackPawn)> or <(item (item (22) of [VirtualBoard v]) of [Board v]) = (BlackPawn)>> then 
change [KingProtection v] by (1)
end
if <<(item (item (15) of [VirtualBoard v]) of [Board v]) = (BlackPawn)> or <(item (item (23) of [VirtualBoard v]) of [Board v]) = (BlackPawn)>> then 
change [KingProtection v] by (1)
end
if <<(item (item (16) of [VirtualBoard v]) of [Board v]) = (BlackPawn)> or <(item (item (24) of [VirtualBoard v]) of [Board v]) = (BlackPawn)>> then 
change [KingProtection v] by (1)
end
end
if <(KingProtection) = (0)> then 
change [EvalResult v] by (-100)
 else 
if <(KingProtection) = (1)> then 
change [EvalResult v] by (-50)
 else 
if <(KingProtection) = (2)> then 
change [EvalResult v] by (0)
 else 
change [EvalResult v] by (100)
end
end
end
end
if <<(HasBlackCastled) = (0)> and <<(HasBlackKingMoved) = (0)> and <<(HasBlackRookQSMoved) = (0)> or <(HasBlackRookKSMoved) = (0)>>>> then 
if <<not <(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackQueensideCastling)>> and <not <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackQueensideCastling)>>> then 
if <<not <(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackKingsideCastling)>> and <not <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackKingsideCastling)>>> then 
if <<not <(item (item (5) of [VirtualBoard v]) of [Board v]) = (BlackKing)>> or <(item ([floor v] of ((item (item (3) of [MovesIdx v]) of [Moves3 v]) mod (100)) ::operators) of [Board v]) = (BlackKing)>> then 
change [EvalResult v] by (-60)
 else 
if <<not <(item (item (1) of [VirtualBoard v]) of [Board v]) = (BlackRook)>> or <(item ([floor v] of ((item (item (3) of [MovesIdx v]) of [Moves3 v]) mod (100)) ::operators) of [Board v]) = (BlackRook)>> then 
change [EvalResult v] by (-30)
end
if <<not <(item (item (8) of [VirtualBoard v]) of [Board v]) = (BlackRook)>> or <(item ([floor v] of ((item (item (3) of [MovesIdx v]) of [Moves3 v]) mod (100)) ::operators) of [Board v]) = (BlackRook)>> then 
change [EvalResult v] by (-30)
end
end
end
end
end
if <<(HasWhiteCastled) = (0)> and <<(HasWhiteKingMoved) = (0)> and <<(HasWhiteRookQSMoved) = (0)> or <(HasWhiteRookKSMoved) = (0)>>>> then 
if <<not <(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (WhiteQueensideCastling)>> and <not <(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (WhiteQueensideCastling)>>> then 
if <<not <(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (WhiteKingsideCastling)>> and <not <(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (WhiteKingsideCastling)>>> then 
if <<not <(item (item (61) of [VirtualBoard v]) of [Board v]) = (WhiteKing)>> or <(item ([floor v] of ((item (item (4) of [MovesIdx v]) of [Moves4 v]) mod (100)) ::operators) of [Board v]) = (WhiteKing)>> then 
change [EvalResult v] by (60)
 else 
if <<not <(item (item (57) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> or <(item ([floor v] of ((item (item (4) of [MovesIdx v]) of [Moves4 v]) mod (100)) ::operators) of [Board v]) = (WhiteRook)>> then 
change [EvalResult v] by (30)
end
if <<not <(item (item (64) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> or <(item ([floor v] of ((item (item (4) of [MovesIdx v]) of [Moves4 v]) mod (100)) ::operators) of [Board v]) = (WhiteRook)>> then 
change [EvalResult v] by (30)
end
end
end
end
end
end

define ClearMoveList %n
if <(argument_reporter_string_number) = (10)> then 
delete (all) of [Moves10 v]
delete (all) of [Moves10Score v]
replace item (10) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (9)> then 
delete (all) of [Moves9 v]
delete (all) of [Moves9Score v]
replace item (9) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (8)> then 
delete (all) of [Moves8 v]
delete (all) of [Moves8Score v]
replace item (8) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (7)> then 
delete (all) of [Moves7 v]
delete (all) of [Moves7Score v]
replace item (7) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (6)> then 
delete (all) of [Moves6 v]
delete (all) of [Moves6Score v]
replace item (6) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (5)> then 
delete (all) of [Moves5 v]
delete (all) of [Moves5Score v]
replace item (5) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (4)> then 
delete (all) of [Moves4 v]
delete (all) of [Moves4Score v]
replace item (4) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (3)> then 
delete (all) of [Moves3 v]
delete (all) of [Moves3Score v]
replace item (3) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (2)> then 
delete (all) of [Moves2 v]
delete (all) of [Moves2Score v]
replace item (2) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [Moves1 v]
replace item (1) of [MovesCount v] with [0]
end
end
end
end
end
end
end
end
end
end

define RUN_BEFORE_SAVING
delete (all) of [HashMovesChecked v]
delete (all) of [HashMovesHash v]
delete (all) of [HashMovesBestMove v]
delete (all) of [HashMovesScore v]
delete (all) of [HashMovesDepth v]
delete (all) of [HashMovesAge v]
delete (all) of [HashMovesType v]
delete (all) of [KillerMoves1 v]
delete (all) of [KillerMoves2 v]
delete (all) of [KillerMoves3 v]
delete (all) of [KillerMoves4 v]
delete (all) of [KillerMoves5 v]
delete (all) of [KillerMoves6 v]
delete (all) of [HistoryTable v]
if <(1) = (0)> then 
delete (all) of [MoveLookupStraight v]
delete (all) of [MoveLookupCross v]
delete (all) of [MoveLookupOffsetsStraight v]
delete (all) of [MoveLookupOffsetsCross v]
delete (all) of [OpeningMoves v]
delete (all) of [KnightPieceSquare v]
delete (all) of [PawnPieceSquare v]
delete (all) of [BishopPieceSquare v]
delete (all) of [RookPieceSquare v]
delete (all) of [QueenPieceSquare v]
delete (all) of [KingPieceSquare v]
delete (all) of [KingPieceSquareEndgame v]
delete (all) of [OpeningMoves v]
delete (all) of [PawnPieceSquareEndgame v]
delete (all) of [PosPieceHashLookup v]
delete (all) of [BoardHistory v]
end

define GetMoveNotation %n
GetVirtualMove %n
set [MoveNotationRes v] to []
if <<(VirtualMove) = (BlackKingsideCastling)> or <(VirtualMove) = (WhiteKingsideCastling)>> then 
set [MoveNotationRes v] to [O-O]
stop [this script v]
end
if <<(VirtualMove) = (BlackQueensideCastling)> or <(VirtualMove) = (WhiteQueensideCastling)>> then 
set [MoveNotationRes v] to [O-O-O]
stop [this script v]
end
set [SourceIdx v] to ([floor v] of ((VirtualMove) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((VirtualMove) mod (100)) ::operators)
set [CurrentPiece v] to (item ([floor v] of ((argument_reporter_string_number) / (100)) ::operators) of [Board v])
Log %s %s %s %s %s %s %s %s
if <<(CurrentPiece) = (BlackBishop)> or <(CurrentPiece) = (WhiteBishop)>> then 
set [MoveNotationRes v] to [B]
end
if <<(CurrentPiece) = (BlackKing)> or <(CurrentPiece) = (WhiteKing)>> then 
set [MoveNotationRes v] to [K]
end
if <<(CurrentPiece) = (BlackRook)> or <(CurrentPiece) = (WhiteRook)>> then 
set [MoveNotationRes v] to [R]
end
if <<(CurrentPiece) = (BlackKnight)> or <(CurrentPiece) = (WhiteKnight)>> then 
set [MoveNotationRes v] to [N]
end
if <<(CurrentPiece) = (WhiteQueen)> or <(CurrentPiece) = (BlackQueen)>> then 
set [MoveNotationRes v] to [Q]
end
set [X v] to (item (SourceIdx) of [IdxToCol v])
set [Y v] to ((9) - (item (SourceIdx) of [IdxToRow v]))
set [MoveNotationRes v] to (join [MoveNotationRes] (join (letter (X) of [abcdefgh]) [Y]))
if <not <(item ([floor v] of ((argument_reporter_string_number) mod (100)) ::operators) of [Board v]) = (Empty)>> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [x])
end
set [X v] to (item (TargetIdx) of [IdxToCol v])
set [Y v] to ((9) - (item (TargetIdx) of [IdxToRow v]))
if <((letter (5) of [VirtualMove]) = (.)) = (.1)> then 
if <(letter (6) of [VirtualMove]) = (1)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [Q])
end
if <(letter (6) of [VirtualMove]) = (2)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [R])
end
if <(letter (6) of [VirtualMove]) = (3)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [B])
end
if <(letter (6) of [VirtualMove]) = (4)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [N])
end
 else 
set [MoveNotationRes v] to (join [MoveNotationRes] (join (letter (X) of [abcdefgh]) [Y]))
end

define LoadList %s %s
set [IdxString v] to [1]
set [CurrentValue v] to []
repeat until <(IdxString) > (length of (argument_reporter_string_number))> 
if <<not <(letter (IdxString) of (argument_reporter_string_number)) = ( )>> and <not <(letter (IdxString) of (argument_reporter_string_number)) = (,)>>> then 
set [CurrentValue v] to (join [CurrentValue] (letter (IdxString) of (argument_reporter_string_number)))
end
if <<(letter (IdxString) of (argument_reporter_string_number)) = (,)> or <(IdxString) = (length of (argument_reporter_string_number))>> then 
if <(argument_reporter_string_number) = (PawnPieceSquare)> then 
add [CurrentValue] to [PawnPieceSquare v]
end
if <(argument_reporter_string_number) = (PawnPieceSquareEndgame)> then 
add [CurrentValue] to [PawnPieceSquareEndgame v]
end
if <(argument_reporter_string_number) = (PawnPieceSquareKingside)> then 
add [CurrentValue] to [PawnPieceSquareKingside v]
end
if <(argument_reporter_string_number) = (PawnPieceSquareQueenside)> then 
add [CurrentValue] to [PawnPieceSquareQueenside v]
end
if <(argument_reporter_string_number) = (KingPieceSquare)> then 
add [CurrentValue] to [KingPieceSquare v]
end
if <(argument_reporter_string_number) = (KingPieceSquareEndgame)> then 
add [CurrentValue] to [KingPieceSquareEndgame v]
end
if <(argument_reporter_string_number) = (QueenPieceSquare)> then 
add [CurrentValue] to [QueenPieceSquare v]
end
if <(argument_reporter_string_number) = (RookPieceSquare)> then 
add [CurrentValue] to [RookPieceSquare v]
end
if <(argument_reporter_string_number) = (BishopPieceSquare)> then 
add [CurrentValue] to [BishopPieceSquare v]
end
if <(argument_reporter_string_number) = (KnightPieceSquare)> then 
add [CurrentValue] to [KnightPieceSquare v]
end
if <(argument_reporter_string_number) = (KnightMobilityBonus)> then 
add [CurrentValue] to [KnightMobilityBonus v]
end
if <(argument_reporter_string_number) = (BishopMobilityBonus)> then 
add [CurrentValue] to [BishopMobilityBonus v]
end
if <(argument_reporter_string_number) = (RookMobilityBonus)> then 
add [CurrentValue] to [RookMobilityBonus v]
end
if <(argument_reporter_string_number) = (QueenMobilityBonus)> then 
add [CurrentValue] to [QueenMobilityBonus v]
end
set [CurrentValue v] to []
end
change [IdxString v] by (1)
end

define OnProgressChanged %n
set [ProgressValue v] to (argument_reporter_string_number)
broadcast (1 v)

define AddPossibleEnPassantImpl %n %n %n %b
GetTargetIdx %n %n %n
if <not <(GetTargetIdxRes) = (-1)>> then 
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(item (GetTargetIdxRes) of [Board v]) = (WhitePawn)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(item (GetTargetIdxRes) of [Board v]) = (BlackPawn)>>> then 
set [IsEnPassantAllowed v] to [0]
if <((argument_reporter_string_number) mod (2)) = (1)> then 
set [EnPassantPrevMove v] to (join ((GetTargetIdxRes) + (16)) [GetTargetIdxRes])
 else 
set [EnPassantPrevMove v] to (join ((GetTargetIdxRes) - (16)) [GetTargetIdxRes])
end
GetSubstringRight %s %n
if <<(argument_reporter_string_number) = (1)> and <(SubstringRes) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (2)> and <<(SubstringRes) = (EnPassantPrevMove)> or <(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (EnPassantPrevMove)>>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (3)> and <(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (4)> and <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (5)> and <(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (6)> and <(item (item (5) of [MovesIdx v]) of [Moves5 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (7)> and <(item (item (6) of [MovesIdx v]) of [Moves6 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (8)> and <(item (item (7) of [MovesIdx v]) of [Moves7 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (9)> and <(item (item (8) of [MovesIdx v]) of [Moves8 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (10)> and <(item (item (9) of [MovesIdx v]) of [Moves9 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <(IsEnPassantAllowed) = (1)> then 
if <argument_reporter_boolean> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
replace item (GetTargetIdxRes) of [BoardAttackedByBlack v] with ((item (GetTargetIdxRes) of [BoardAttackedByBlack v]) + (1))
 else 
replace item (GetTargetIdxRes) of [BoardAttackedByWhite v] with ((item (GetTargetIdxRes) of [BoardAttackedByWhite v]) + (1))
end
 else 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
AddSpecialMove %s %n
 else 
AddSpecialMove %s %n
end
end
end
end
end

define GetCurrentMove %n
if <(argument_reporter_string_number) = (10)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves10 v])
 else 
if <(argument_reporter_string_number) = (9)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves9 v])
 else 
if <(argument_reporter_string_number) = (8)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves8 v])
 else 
if <(argument_reporter_string_number) = (7)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves7 v])
 else 
if <(argument_reporter_string_number) = (6)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves6 v])
 else 
if <(argument_reporter_string_number) = (5)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves5 v])
 else 
if <(argument_reporter_string_number) = (4)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves4 v])
 else 
if <(argument_reporter_string_number) = (3)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves3 v])
 else 
if <(argument_reporter_string_number) = (2)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves2 v])
 else 
if <(argument_reporter_string_number) = (1)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves1 v])
end
end
end
end
end
end
end
end
end
end

define AddLookupMove %n %n %n %b %b %b %b %b
set [IdxOuter v] to (item (argument_reporter_string_number) of [MoveLookupIndexOffset v])
set [Count v] to [1]
repeat until <(Count) > (8)> 
if <(argument_reporter_string_number) = (LookupMoveTypeKnight)> then 
set [TargetIdx v] to (item ((IdxOuter) + (Count)) of [MoveLookupKnight v])
 else 
if <(argument_reporter_string_number) = (LookupMoveTypeKing)> then 
set [TargetIdx v] to (item ((IdxOuter) + (Count)) of [MoveLookupKing v])
 else 
set [TargetIdx v] to [-1]
end
end
if <not <(TargetIdx) = (-1)>> then 
if <<<argument_reporter_boolean> or <not <(argument_reporter_string_number) = (LookupMoveTypeKing)>>> or <<<(item (argument_reporter_string_number) of [Board v]) = (BlackKing)> and <(item (TargetIdx) of [BoardAttackedByWhite v]) = (0)>> or <<(item (argument_reporter_string_number) of [Board v]) = (WhiteKing)> and <(item (TargetIdx) of [BoardAttackedByBlack v]) = (0)>>>> then 
AddMoveImpl %n %n %n %b %b %b %b %b
end
change [Count v] by (1)
 else 
set [Count v] to [9]
end
end

define IsTwoKingDraw
set [TwoKingDrawRes v] to [1]
set [Idx v] to [1]
repeat (64) 
if <<not <(item (Idx) of [Board v]) = (Empty)>> and <<not <(item (Idx) of [Board v]) = (BlackKing)>> and <not <(item (Idx) of [Board v]) = (WhiteKing)>>>> then 
set [TwoKingDrawRes v] to [0]
end
change [Idx v] by (1)
end

define CalculateMoves %n
CalcBoardAttackedByMove %n
CalculateMovesImpl %n %b %b

define AddToMoveList %n %n
if <(argument_reporter_string_number) = (10)> then 
add (argument_reporter_string_number) to [Moves10 v]
add [0] to [Moves10Score v]
replace item (10) of [MovesCount v] with (length of [Moves10 v])
 else 
if <(argument_reporter_string_number) = (9)> then 
add (argument_reporter_string_number) to [Moves9 v]
add [0] to [Moves9Score v]
replace item (9) of [MovesCount v] with (length of [Moves9 v])
 else 
if <(argument_reporter_string_number) = (8)> then 
add (argument_reporter_string_number) to [Moves8 v]
add [0] to [Moves8Score v]
replace item (8) of [MovesCount v] with (length of [Moves8 v])
 else 
if <(argument_reporter_string_number) = (7)> then 
add (argument_reporter_string_number) to [Moves7 v]
add [0] to [Moves7Score v]
replace item (7) of [MovesCount v] with (length of [Moves7 v])
 else 
if <(argument_reporter_string_number) = (6)> then 
add (argument_reporter_string_number) to [Moves6 v]
add [0] to [Moves6Score v]
replace item (6) of [MovesCount v] with (length of [Moves6 v])
 else 
if <(argument_reporter_string_number) = (5)> then 
add (argument_reporter_string_number) to [Moves5 v]
add [0] to [Moves5Score v]
replace item (5) of [MovesCount v] with (length of [Moves5 v])
 else 
if <(argument_reporter_string_number) = (4)> then 
add (argument_reporter_string_number) to [Moves4 v]
add [0] to [Moves4Score v]
replace item (4) of [MovesCount v] with (length of [Moves4 v])
 else 
if <(argument_reporter_string_number) = (3)> then 
add (argument_reporter_string_number) to [Moves3 v]
add [0] to [Moves3Score v]
replace item (3) of [MovesCount v] with (length of [Moves3 v])
 else 
if <(argument_reporter_string_number) = (2)> then 
add (argument_reporter_string_number) to [Moves2 v]
add [0] to [Moves2Score v]
replace item (2) of [MovesCount v] with (length of [Moves2 v])
 else 
if <(argument_reporter_string_number) = (1)> then 
add (argument_reporter_string_number) to [Moves1 v]
add [0] to [Moves1Score v]
replace item (1) of [MovesCount v] with (length of [Moves1 v])
end
end
end
end
end
end
end
end
end
end

define GetPosScore %n %n
set [PosScoreRes v] to [0]
if <<(argument_reporter_string_number) = (BlackPawn)> or <(argument_reporter_string_number) = (WhitePawn)>> then 
if <(IsEndgame) = (1)> then 
if <(argument_reporter_string_number) = (BlackPawn)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [PawnPieceSquareEndgame v])
 else 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [PawnPieceSquareEndgame v]))
end
 else 
if <(argument_reporter_string_number) = (BlackPawn)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [PawnPieceSquare v])
 else 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [PawnPieceSquare v]))
end
end
 else 
if <(IsEndgame) = (1)> then 
if <(argument_reporter_string_number) = (BlackKing)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [KingPieceSquareEndgame v])
 else 
if <(argument_reporter_string_number) = (WhiteKing)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [KingPieceSquareEndgame v]))
end
end
end
if <(IsEndgame) = (0)> then 
if <(argument_reporter_string_number) = (BlackKnight)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [KnightPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteKnight)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [KnightPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackBishop)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [BishopPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteBishop)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [BishopPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackRook)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [RookPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteRook)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [RookPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackKing)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [KingPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteKing)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [KingPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackQueen)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [QueenPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteQueen)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [QueenPieceSquare v]))
end
end
end
end
end
end
end
end
end
end
end
end

define ClearBoardAttackedByMove %n
set [IsBlackMove v] to ((argument_reporter_string_number) mod (2))
set [Idx v] to [1]
repeat (64) 
if <(IsBlackMove) = (1)> then 
replace item (Idx) of [BoardAttackedByBlack v] with [0]
replace item (Idx) of [BoardAttackedByBlackPiece v] with [0]
 else 
replace item (Idx) of [BoardAttackedByWhite v] with [0]
replace item (Idx) of [BoardAttackedByWhitePiece v] with [0]
end
change [Idx v] by (1)
end
if <(IsBlackMove) = (1)> then 
set [IsWhiteChecked v] to [0]
 else 
set [IsBlackChecked v] to [0]
end

define GetPosPieceHash %n %n
if <(argument_reporter_string_number) = (BlackBishop)> then 
set [PosPieceHash v] to (item (argument_reporter_string_number) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (BlackPawn)> then 
set [PosPieceHash v] to (item ((64) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (BlackQueen)> then 
set [PosPieceHash v] to (item ((128) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (BlackKing)> then 
set [PosPieceHash v] to (item ((192) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (BlackKnight)> then 
set [PosPieceHash v] to (item ((256) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (BlackRook)> then 
set [PosPieceHash v] to (item ((320) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhiteBishop)> then 
set [PosPieceHash v] to (item ((384) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhiteQueen)> then 
set [PosPieceHash v] to (item ((448) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhiteKing)> then 
set [PosPieceHash v] to (item ((512) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhitePawn)> then 
set [PosPieceHash v] to (item ((576) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhiteKnight)> then 
set [PosPieceHash v] to (item ((640) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhiteRook)> then 
set [PosPieceHash v] to (item ((704) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end

define AddSpecialMove %s %n
GetMoveScore %n %n %n %n %n %n
if <(argument_reporter_string_number) = (1)> then 
add (argument_reporter_string_number) to [Moves1 v]
add [MoveScoreRes] to [Moves1Score v]
end
if <(argument_reporter_string_number) = (2)> then 
add (argument_reporter_string_number) to [Moves2 v]
add [MoveScoreRes] to [Moves2Score v]
end
if <(argument_reporter_string_number) = (3)> then 
add (argument_reporter_string_number) to [Moves3 v]
add [MoveScoreRes] to [Moves3Score v]
end
if <(argument_reporter_string_number) = (4)> then 
add (argument_reporter_string_number) to [Moves4 v]
add [MoveScoreRes] to [Moves4Score v]
end
if <(argument_reporter_string_number) = (5)> then 
add (argument_reporter_string_number) to [Moves5 v]
add [MoveScoreRes] to [Moves5Score v]
end
if <(argument_reporter_string_number) = (6)> then 
add (argument_reporter_string_number) to [Moves6 v]
add [MoveScoreRes] to [Moves6Score v]
end
if <(argument_reporter_string_number) = (7)> then 
add (argument_reporter_string_number) to [Moves7 v]
add [MoveScoreRes] to [Moves7Score v]
end
if <(argument_reporter_string_number) = (8)> then 
add (argument_reporter_string_number) to [Moves8 v]
add [MoveScoreRes] to [Moves8Score v]
end
if <(argument_reporter_string_number) = (9)> then 
add (argument_reporter_string_number) to [Moves8 v]
add [MoveScoreRes] to [Moves8Score v]
end
if <(argument_reporter_string_number) = (10)> then 
add (argument_reporter_string_number) to [Moves10 v]
add [MoveScoreRes] to [Moves10Score v]
end

define GetBestHashMove %n
set [BestHashMoveResult v] to [-1]
set [BestHashMoveScoreResult v] to [-1]
set [BestHashMoveDepthResult v] to [-1]
set [BestHashMoveTypeResult v] to []
set [CurrentIdx v] to [1]
set [HashBucket v] to (((argument_reporter_string_number) mod (length of [HashMovesHash v])) + (1))
repeat until <(item (HashBucket) of [HashMovesHash v]) = (argument_reporter_string_number)> 
change [HashBucket v] by (1)
if <(HashBucket) > (length of [HashMovesHash v])> then 
set [HashBucket v] to [1]
end
change [CurrentIdx v] by (1)
if <(CurrentIdx) > (10)> then 
stop [this script v]
end
end
set [BestHashMoveResult v] to (item (HashBucket) of [HashMovesBestMove v])
set [BestHashMoveScoreResult v] to (item (HashBucket) of [HashMovesScore v])
set [BestHashMoveDepthResult v] to (item (HashBucket) of [HashMovesDepth v])
set [BestHashMoveTypeResult v] to (item (HashBucket) of [HashMovesType v])
set [BestHashMoveCheckedResult v] to (item (HashBucket) of [HashMovesChecked v])

define InitMobilityBonusLookup
delete (all) of [QueenMobilityBonus v]
delete (all) of [BishopMobilityBonus v]
delete (all) of [RookMobilityBonus v]
delete (all) of [KnightMobilityBonus v]
LoadList %s %s
LoadList %s %s
LoadList %s %s
LoadList %s %s

define ClearLog
delete (all) of [Logfile v]

define Log %s %s %s %s %s %s %s %s
add (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (argument_reporter_string_number)))))))) to [Logfile v]

define InitAlphaBeta %n %b
if <(argument_reporter_string_number) = (1)> then 
set [BlackMinorCount v] to [0]
set [BlackQueenCount v] to [0]
set [WhiteQueenCount v] to [0]
set [WhiteMinorCount v] to [0]
set [Idx v] to [1]
repeat (64) 
if <(item (Idx) of [Board v]) = (WhiteQueen)> then 
change [WhiteQueenCount v] by (1)
end
if <(item (Idx) of [Board v]) = (BlackQueen)> then 
change [BlackQueenCount v] by (1)
end
if <<(item (Idx) of [Board v]) = (WhiteKnight)> or <<(item (Idx) of [Board v]) = (WhiteBishop)> or <(item (Idx) of [Board v]) = (WhiteRook)>>> then 
change [WhiteMinorCount v] by (1)
end
if <<(item (Idx) of [Board v]) = (BlackKnight)> or <<(item (Idx) of [Board v]) = (BlackBishop)> or <(item (Idx) of [Board v]) = (BlackRook)>>> then 
change [BlackMinorCount v] by (1)
end
change [Idx v] by (1)
end
set [IsEndgame v] to [0]
if <<(((WhiteQueenCount) * (9)) + ((WhiteMinorCount) * (4))) < (13)> and <(((BlackQueenCount) * (9)) + ((BlackMinorCount) * (4))) < (13)>> then 
set [IsEndgame v] to [1]
end
if <<(((WhiteQueenCount) * (9)) + ((WhiteMinorCount) * (4))) < (8)> or <(((BlackQueenCount) * (9)) + ((BlackMinorCount) * (4))) < (8)>> then 
set [IsEndgame v] to [1]
end
if <argument_reporter_boolean> then 
change [HashMoveAge v] by (1)
set [CurrentMoveHash v] to [0]
set [Idx v] to [1]
repeat (64) 
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
change [Idx v] by (1)
end
end
set [ProfileCount1 v] to [0]
set [ProfileCount2 v] to [0]
set [MonTimer1 v] to [0]
set [MonTimer2 v] to [0]
set [MonTimer3 v] to [0]
set [MonTimer4 v] to [0]
if <(1) = (0)> then 
ClearLog
end
end

define IsLowerCase %s
set [Chars v] to []
set [CharsIdx v] to [1]
repeat (length of [CharsUpperCase]) 
if <(letter (CharsIdx) of [CharsUpperCase]) = (argument_reporter_string_number)> then 
set [Chars v] to (join [Chars] (argument_reporter_string_number))
 else 
set [Chars v] to (join [Chars] (letter (CharsIdx) of [CharsUpperCase]))
end
change [CharsIdx v] by (1)
end
switch costume to (1 v)
switch costume to (3 v)
if <(costume [number v] ::looks) = (1)> then 
set [IsLowerCaseRes v] to [0]
 else 
set [IsLowerCaseRes v] to [1]
end

define ImportBoardInternal %s
set [Idx v] to [1]
set [IdxString v] to [1]
set [CurrentPiece v] to [0]
repeat until <(IdxString) > (length of (argument_reporter_string_number))> 
if <(letter (IdxString) of (argument_reporter_string_number)) = (,)> then 
replace item (Idx) of [Board v] with [CurrentPiece]
change [Idx v] by (1)
set [CurrentPiece v] to [0]
 else 
set [CurrentPiece v] to (join [CurrentPiece] (letter (IdxString) of (argument_reporter_string_number)))
end
change [IdxString v] by (1)
end
AddBoardToHistory
DrawBoardAndWait
set [IsGameSuspended v] to [0]

define ImportBoardFEN %s
if <(IsPlayerBlack) = (0)> then 
set [Idx v] to [1]
set [IdxInc v] to [1]
 else 
set [Idx v] to [64]
set [IdxInc v] to [-1]
end
set [IdxString v] to [1]
repeat until <<(Idx) > (64)> or <(Idx) < (1)>> 
set [CurrentValue v] to (letter (IdxString) of (argument_reporter_string_number))
if <<not <(CurrentValue) < (A)>> and <not <(CurrentValue) > (Z)>>> then 
set [CurrentPiece v] to [Empty]
if <(CurrentValue) = (P)> then 
set [CurrentPiece v] to [BlackPawn]
end
if <(CurrentValue) = (N)> then 
set [CurrentPiece v] to [BlackKnight]
end
if <(CurrentValue) = (B)> then 
set [CurrentPiece v] to [BlackBishop]
end
if <(CurrentValue) = (R)> then 
set [CurrentPiece v] to [BlackRook]
end
if <(CurrentValue) = (Q)> then 
set [CurrentPiece v] to [BlackQueen]
end
if <(CurrentValue) = (K)> then 
set [CurrentPiece v] to [BlackKing]
end
IsLowerCase %s
if <(IsLowerCaseRes) = (0)> then 
set [CurrentPiece v] to ((CurrentPiece) * (-1))
end
if <(IsPlayerBlack) = (1)> then 
set [CurrentPiece v] to ((CurrentPiece) * (-1))
end
replace item (Idx) of [Board v] with [CurrentPiece]
change [Idx v] by (IdxInc)
 else 
if <<not <(CurrentValue) < (0)>> and <not <(CurrentValue) > (9)>>> then 
repeat (CurrentValue) 
replace item (Idx) of [Board v] with [Empty]
change [Idx v] by (IdxInc)
end
 else 
if <(CurrentValue) = (/)> then 
repeat until <<<((Idx) mod (8)) = (1)> and <(IsPlayerBlack) = (0)>> or <<((Idx) mod (8)) = (0)> and <(IsPlayerBlack) = (1)>>> 
replace item (Idx) of [Board v] with [Empty]
change [Idx v] by (IdxInc)
end
end
end
end
change [IdxString v] by (1)
end
AddBoardToHistory
DrawBoardAndWait
change [IdxString v] by (1)
set [CurrentValue v] to (letter (IdxString) of (argument_reporter_string_number))
if <<<(CurrentValue) = (B)> and <(IsPlayerBlack) = (0)>> or <<(CurrentValue) = (W)> and <(IsPlayerBlack) = (1)>>> then 
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
say [Checkmate!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
CalculateMoves %n
if <(length of [Moves1 v]) = (0)> then 
say [Draw!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
set [IsGameSuspended v] to [0]
ExecuteEngineMove
end
end
end
if <<<(CurrentValue) = (W)> and <(IsPlayerBlack) = (0)>> or <<(CurrentValue) = (B)> and <(IsPlayerBlack) = (1)>>> then 
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (1)> then 
say [Checkmate!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
CalculateMoves %n
if <(length of [Moves2 v]) = (0)> then 
say [Draw!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
set [IsGameSuspended v] to [0]
end
end
end

when i receive [import v]
ask [Please paste FEN data or GoK data into the text field for import from your clipboard via Ctrl-V] and wait
if <(length of (answer)) > (0)> then 
ImportBoard %s
end

when i receive [export v]
ExportBoardFEN
delete (all) of [ExportData v]
add [ExportDataFEN] to [ExportData v]
add [ExportDataFENLichess] to [ExportData v]
add (item (last) of [BoardHistory v]) to [ExportData v]
show list [ExportData v]
SayAsync %s %n

define InitPawnSquareEndgame
delete (all) of [PawnPieceSquareEndgame v]
set [PawnSquareDefEndgame v] to [ 100, 90, 80, 75, 75, 80, 90, 100,  65, 55, 45, 40, 40, 45, 55, 65,  35, 25, 15, 10, 10, 15, 25, 35,  20, 10, 0, -5, -5, 0, 10, 20,  10, 0, -10, -15, -15, -10, 0, 10,  5, -10, -20, -25, -25, -20, -10, 5,  5, -10, -20, -25, -25, -20, -10, 5,  0, 0, 0, 0, 0, 0, 0, 0]
LoadList %s %s

define ExportMovesPGN
set [ExportMovesPGN v] to []
set [Idx v] to [1]
repeat (length of [GameMovesAN v]) 
if <((Idx) mod (2)) = (1)> then 
set [ExportMovesPGN v] to (join [ExportMovesPGN] (join ((((Idx) - (1)) / (2)) + (1)) [. ]))
end
set [ExportMovesPGN v] to (join [ExportMovesPGN] (join (item (Idx) of [GameMovesAN v]) [ ]))
change [Idx v] by (1)
end

define UndoMove
if <(length of [BoardHistory v]) > (2)> then 
set [CurrentValue v] to (item ((length of [BoardHistory v]) - (2)) of [BoardHistory v])
delete (last) of [BoardHistory v]
delete (last) of [BoardHistory v]
delete (last) of [BoardHistory v]
ImportBoardInternal %s
if <<(item (last) of [GameMovesAN v]) = (O-O)> or <(item (last) of [GameMovesAN v]) = (O-O-O)>> then 
set [HasBlackCastled v] to [0]
set [HasBlackKingMoved v] to [0]
end
if <(letter (1) of (item (last) of [GameMovesAN v])) = (K)> then 
set [HasBlackKingMoved v] to [0]
set [Idx v] to ((length of [GameMovesAN v]) - (2))
repeat until <(Idx) < (1)> 
if <(letter (1) of (item (Idx) of [GameMovesAN v])) = (K)> then 
set [HasBlackKingMoved v] to [1]
end
change [Idx v] by (-1)
end
end
delete (last) of [GameMovesAN v]
if <<(item (last) of [GameMovesAN v]) = (O-O)> or <(item (last) of [GameMovesAN v]) = (O-O-O)>> then 
set [HasWhiteCastled v] to [0]
set [HasWhiteKingMoved v] to [0]
end
if <(letter (1) of (item (last) of [GameMovesAN v])) = (K)> then 
set [HasWhiteKingMoved v] to [0]
set [Idx v] to ((length of [GameMovesAN v]) - (2))
repeat until <(Idx) < (1)> 
if <(letter (1) of (item (Idx) of [GameMovesAN v])) = (K)> then 
set [HasBlackKingMoved v] to [1]
end
change [Idx v] by (-1)
end
end
delete (last) of [GameMovesAN v]
GetSubstringLeft %n %n
set [GameMoves v] to [SubstringRes]
set [IsGameSuspended v] to [0]
end

when i receive [showmoves v]
ExportMovesPGN
delete (all) of [ExportMoves v]
add [ExportMovesPGN] to [ExportMoves v]
show list [ExportMoves v]
SayAsync %s %n

define FillBoard
InitVirtualBoard
delete (all) of [Board v]
delete (all) of [BoardCpy v]
repeat (64) 
add [Empty] to [Board v]
add [Empty] to [BoardCpy v]
end
replace item (item (1) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (2) of [VirtualBoard v]) of [Board v] with [BlackKnight]
replace item (item (3) of [VirtualBoard v]) of [Board v] with [BlackBishop]
replace item (item (4) of [VirtualBoard v]) of [Board v] with [BlackQueen]
replace item (item (5) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (6) of [VirtualBoard v]) of [Board v] with [BlackBishop]
replace item (item (7) of [VirtualBoard v]) of [Board v] with [BlackKnight]
replace item (item (8) of [VirtualBoard v]) of [Board v] with [BlackRook]
set [Idx v] to [9]
repeat (8) 
replace item (item (Idx) of [VirtualBoard v]) of [Board v] with [BlackPawn]
change [Idx v] by (1)
end
set [Idx v] to [49]
repeat (8) 
replace item (item (Idx) of [VirtualBoard v]) of [Board v] with [WhitePawn]
change [Idx v] by (1)
end
replace item (item (57) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (58) of [VirtualBoard v]) of [Board v] with [WhiteKnight]
replace item (item (59) of [VirtualBoard v]) of [Board v] with [WhiteBishop]
replace item (item (60) of [VirtualBoard v]) of [Board v] with [WhiteQueen]
replace item (item (61) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (62) of [VirtualBoard v]) of [Board v] with [WhiteBishop]
replace item (item (63) of [VirtualBoard v]) of [Board v] with [WhiteKnight]
replace item (item (64) of [VirtualBoard v]) of [Board v] with [WhiteRook]

when i receive [undo v]
UndoMove
say []

define HashOnMoveScore %n %n %n %n %s %n
set [HashBucket v] to (((argument_reporter_string_number) mod (length of [HashMovesHash v])) + (1))
set [CurrentIdx v] to [1]
repeat until <<<(length of (item (HashBucket) of [HashMovesHash v])) = (0)> or <<(item (HashBucket) of [HashMovesHash v]) = (argument_reporter_string_number)> and <(argument_reporter_string_number) < (item (HashBucket) of [HashMovesDepth v])>>> or <(item (CurrentIdx) of [HashMovesAge v]) < (HashMoveAge)>> 
change [HashBucket v] by (1)
if <(HashBucket) > (length of [HashMovesHash v])> then 
set [HashBucket v] to [1]
end
change [CurrentIdx v] by (1)
if <(CurrentIdx) > (10)> then 
stop [this script v]
end
end
replace item (HashBucket) of [HashMovesHash v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesDepth v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesScore v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesBestMove v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesAge v] with [HashMoveAge]
replace item (HashBucket) of [HashMovesType v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesChecked v] with (argument_reporter_string_number)

define ExecuteInit
set [ExecutionDepth v] to [0]
set [IsExecutionRunning v] to [0]
EnterExecution %n
if <(IsPlayerBlack) = (1)> then 
CalculateOpeningMoves
set [BestMove v] to (item (pick random (1) to (length of [BestMoves v])) of [BestMoves v])
GetMoveNotation %n
set [BestMoveAN v] to [MoveNotationRes]
set [GameMoves v] to (join [GameMoves] [BestMove])
set [MovePieceFromIdx v] to ([floor v] of ((BestMove) / (100)) ::operators)
set [MovePieceToIdx v] to ([floor v] of ((BestMove) mod (100)) ::operators)
if <<<(BestMove) = (BlackQueensideCastling)> or <(BestMove) = (BlackKingsideCastling)>> or <<(BestMove) = (WhiteQueensideCastling)> or <(BestMove) = (WhiteKingsideCastling)>>> then 
set [MovePieceSpecial v] to [BestMove]
 else 
set [MovePieceSpecial v] to []
end
broadcast (1 v) and wait
delete (all) of [Moves1 v]
add [BestMove] to [Moves1 v]
replace item (1) of [MovesIdx v] with [1]
replace item (1) of [MovesCount v] with [1]
ApplyMove %n
DrawBoardAndWait
AddBoardToHistory
add [BestMoveAN] to [GameMovesAN v]
end
ExecuteMovePostProcess
ExitExecution

define ExecuteMovePostProcess
set [MoveFromIdx v] to [-1]
set [MoveToIdx v] to [-1]
set [FromSquareIdx v] to [-1]
set [ToSquareIdx v] to [-1]
broadcast (1 v) and wait
broadcast (1 v) and wait
broadcast (1 v) and wait

when i receive [sayasyncmsg v]
say [SayAsyncText] for (SayAsyncDuration) seconds

define SayAsync %s %n
set [SayAsyncText v] to (argument_reporter_string_number)
set [SayAsyncDuration v] to (argument_reporter_string_number)
broadcast (1 v)

define ExitExecution
set [IsExecutionRunning v] to [0]

when i receive [levelchanged v]
if <(Level) = (3)> then 
SayAsync %s %n
 else 
say []
end

define GetSEEMapVal %n
set [SEEMapValRes v] to [0]
set [CurrentPieceSub v] to ([abs v] of (argument_reporter_string_number) ::operators)
if <(CurrentPieceSub) = (BlackPawn)> then 
set [SEEMapValRes v] to [100000]
 else 
if <(CurrentPieceSub) = (BlackKnight)> then 
set [SEEMapValRes v] to [10000]
 else 
if <(CurrentPieceSub) = (BlackBishop)> then 
set [SEEMapValRes v] to [1000]
 else 
if <(CurrentPieceSub) = (BlackRook)> then 
set [SEEMapValRes v] to [100]
 else 
if <(CurrentPieceSub) = (BlackQueen)> then 
set [SEEMapValRes v] to [10]
 else 
if <(CurrentPieceSub) = (BlackKing)> then 
set [SEEMapValRes v] to [1]
end
end
end
end
end
end

define GetSEEPiece %n %n
set [SEEPieceRes v] to [Empty]
if <not <(argument_reporter_string_number) < (100000)>> then 
set [SEEPieceRes v] to [BlackPawn]
 else 
if <not <(argument_reporter_string_number) < (10000)>> then 
set [SEEPieceRes v] to [BlackKnight]
 else 
if <not <(argument_reporter_string_number) < (1000)>> then 
set [SEEPieceRes v] to [BlackBishop]
 else 
if <not <(argument_reporter_string_number) < (100)>> then 
set [SEEPieceRes v] to [BlackRook]
 else 
if <not <(argument_reporter_string_number) < (10)>> then 
set [SEEPieceRes v] to [BlackQueen]
 else 
if <not <(argument_reporter_string_number) < (1)>> then 
set [SEEPieceRes v] to [BlackKing]
end
end
end
end
end
end
if <((argument_reporter_string_number) mod (2)) = (0)> then 
set [SEEPieceRes v] to ((0) - (SEEPieceRes))
end

define ExportBoardFEN
set [ExportDataFEN v] to []
set [ExportDataFENLichess v] to [https://lichess.org/analysis/]
set [Idx v] to [1]
repeat until <(Idx) > (64)> 
if <(IsPlayerBlack) = (0)> then 
set [CurrentPiece v] to (item (Idx) of [Board v])
 else 
set [CurrentPiece v] to ((0) - (item ((65) - (Idx)) of [Board v]))
end
if <(CurrentPiece) = (BlackPawn)> then 
set [CurrentValue v] to [p]
end
if <(CurrentPiece) = (BlackKnight)> then 
set [CurrentValue v] to [n]
end
if <(CurrentPiece) = (BlackBishop)> then 
set [CurrentValue v] to [b]
end
if <(CurrentPiece) = (BlackRook)> then 
set [CurrentValue v] to [r]
end
if <(CurrentPiece) = (BlackQueen)> then 
set [CurrentValue v] to [q]
end
if <(CurrentPiece) = (BlackKing)> then 
set [CurrentValue v] to [k]
end
if <(CurrentPiece) = (WhitePawn)> then 
set [CurrentValue v] to [P]
end
if <(CurrentPiece) = (WhiteKnight)> then 
set [CurrentValue v] to [N]
end
if <(CurrentPiece) = (WhiteBishop)> then 
set [CurrentValue v] to [B]
end
if <(CurrentPiece) = (WhiteRook)> then 
set [CurrentValue v] to [R]
end
if <(CurrentPiece) = (WhiteQueen)> then 
set [CurrentValue v] to [Q]
end
if <(CurrentPiece) = (WhiteKing)> then 
set [CurrentValue v] to [K]
end
if <(CurrentPiece) = (Empty)> then 
set [IdxSub v] to [Idx]
repeat until <<((IdxSub) mod (8)) = (0)> or <<<(IsPlayerBlack) = (0)> and <not <(item ((IdxSub) + (1)) of [Board v]) = (Empty)>>> or <<(IsPlayerBlack) = (1)> and <not <(item ((65) - ((IdxSub) + (1))) of [Board v]) = (Empty)>>>>> 
change [IdxSub v] by (1)
end
set [CurrentValue v] to (((IdxSub) - (Idx)) + (1))
change [Idx v] by ((IdxSub) - (Idx))
end
set [ExportDataFEN v] to (join [ExportDataFEN] [CurrentValue])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [CurrentValue])
if <<((Idx) mod (8)) = (0)> and <(Idx) < (64)>> then 
set [ExportDataFEN v] to (join [ExportDataFEN] [/])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [/])
end
change [Idx v] by (1)
end
if <(IsPlayerBlack) = (0)> then 
set [ExportDataFEN v] to (join [ExportDataFEN] [ w])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [_w])
 else 
set [ExportDataFEN v] to (join [ExportDataFEN] [ b])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [_b])
end

define HasSEEMapVal %n %n
set [HasSEEMapValRes v] to [0]
set [CurrentPieceSub v] to ([abs v] of (argument_reporter_string_number) ::operators)
if <(CurrentPieceSub) = (BlackPawn)> then 
if <<(letter (6) of (argument_reporter_string_number)) > (0)> and <not <(letter (6) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
 else 
if <(CurrentPieceSub) = (BlackKnight)> then 
if <<(letter (5) of (argument_reporter_string_number)) > (0)> and <not <(letter (5) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
 else 
if <(CurrentPieceSub) = (BlackBishop)> then 
if <<(letter (4) of (argument_reporter_string_number)) > (0)> and <not <(letter (4) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
 else 
if <(CurrentPieceSub) = (BlackRook)> then 
if <<(letter (3) of (argument_reporter_string_number)) > (0)> and <not <(letter (3) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
 else 
if <(CurrentPieceSub) = (BlackQueen)> then 
if <<(letter (2) of (argument_reporter_string_number)) > (0)> and <not <(letter (2) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
 else 
if <(CurrentPieceSub) = (BlackKing)> then 
if <<(letter (1) of (argument_reporter_string_number)) > (0)> and <not <(letter (1) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
end
end
end
end
end
end

define SEEImpl (Currently not used)
set [SEEMapValWhite v] to (item (argument_reporter_string_number) of [BoardAttackedByWhitePiece v])
set [SEEMapValBlack v] to (item (argument_reporter_string_number) of [BoardAttackedByBlackPiece v])
if <((argument_reporter_string_number) mod (2)) = (0)> then 
set [SEEPieceWhite v] to (argument_reporter_string_number)
set [SEEPieceBlack v] to [Empty]
if <<not <(argument_reporter_string_number) = (WhitePawn)>> or <not <(item (argument_reporter_string_number) of [IdxToCol v]) = (item (argument_reporter_string_number) of [IdxToCol v])>>> then 
GetSEEMapVal %n
change [SEEMapValWhite v] by ((0) - (SEEMapValRes))
end
 else 
set [SEEPieceBlack v] to (argument_reporter_string_number)
set [SEEPieceWhite v] to [Empty]
if <<not <(argument_reporter_string_number) = (BlackPawn)>> or <not <(item (argument_reporter_string_number) of [IdxToCol v]) = (item (argument_reporter_string_number) of [IdxToCol v])>>> then 
GetSEEMapVal %n
change [SEEMapValBlack v] by ((0) - (SEEMapValRes))
end
end
set [SEEMoveDepth v] to ((argument_reporter_string_number) + (1))
if <<<((SEEMoveDepth) mod (2)) = (0)> and <(SEEMapValWhite) > (0)>> or <<((SEEMoveDepth) mod (2)) = (1)> and <(SEEMapValBlack) > (0)>>> then 
if <((SEEMoveDepth) mod (2)) = (0)> then 
GetSEEPiece %n %n
set [SEEPieceWhite v] to [SEEPieceRes]
GetSEEMapVal %n
change [SEEMapValWhite v] by ((0) - (SEEMapValRes))
change [MoveScoreRes v] by ((0) - (SEEPieceBlack))
 else 
GetSEEPiece %n %n
set [SEEPieceBlack v] to [SEEPieceRes]
GetSEEMapVal %n
change [SEEMapValBlack v] by ((0) - (SEEMapValRes))
change [MoveScoreRes v] by ((0) - (SEEPieceWhite))
end
change [SEEMoveDepth v] by (1)
end

define IsValidMove %n
set [ValidMoveRes v] to [1]
if <<<(argument_reporter_string_number) < (0)> or <(argument_reporter_string_number) > (9999)>> or <<<([floor v] of ((argument_reporter_string_number) / (100)) ::operators) = (0)> or <([floor v] of ((argument_reporter_string_number) mod (100)) ::operators) = (0)>> and <not <<<(argument_reporter_string_number) = (BlackQueensideCastling)> or <(argument_reporter_string_number) = (BlackKingsideCastling)>> or <<(argument_reporter_string_number) = (WhiteQueensideCastling)> or <(argument_reporter_string_number) = (WhiteKingsideCastling)>>>>>> then 
set [ValidMoveRes v] to [0]
end

define IsBlackKingCheckMate
set [IsBlackKingCheckMateRes v] to [0]
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (1)> then 
set [IsBlackKingCheckMateRes v] to [1]
CalculateMoves %n
replace item (1) of [MovesIdx v] with [1]
repeat (item (1) of [MovesCount v]) 
if <(IsBlackKingCheckMateRes) = (1)> then 
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (0)> then 
set [IsBlackKingCheckMateRes v] to [0]
end
RevertMove %n
end
replace item (1) of [MovesIdx v] with ((item (1) of [MovesIdx v]) + (1))
end
end

define IsWhiteKingCheckMate
set [IsWhiteKingCheckMateRes v] to [0]
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
set [IsWhiteKingCheckMateRes v] to [1]
CalculateMoves %n
replace item (2) of [MovesIdx v] with [1]
repeat (item (2) of [MovesCount v]) 
if <(IsWhiteKingCheckMateRes) = (1)> then 
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (0)> then 
set [IsWhiteKingCheckMateRes v] to [0]
end
RevertMove %n
end
replace item (2) of [MovesIdx v] with ((item (2) of [MovesIdx v]) + (1))
end
end

define CalculateMovesImpl %n %b %b
if <not <argument_reporter_boolean>> then 
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [Moves1 v]
delete (all) of [Moves1Score v]
end
if <(argument_reporter_string_number) = (2)> then 
delete (all) of [Moves2 v]
delete (all) of [Moves2Score v]
end
if <(argument_reporter_string_number) = (3)> then 
delete (all) of [Moves3 v]
delete (all) of [Moves3Score v]
end
if <(argument_reporter_string_number) = (4)> then 
delete (all) of [Moves4 v]
delete (all) of [Moves4Score v]
end
if <(argument_reporter_string_number) = (5)> then 
delete (all) of [Moves5 v]
delete (all) of [Moves5Score v]
end
if <(argument_reporter_string_number) = (6)> then 
delete (all) of [Moves6 v]
delete (all) of [Moves6Score v]
end
if <(argument_reporter_string_number) = (7)> then 
delete (all) of [Moves7 v]
delete (all) of [Moves7Score v]
end
if <(argument_reporter_string_number) = (8)> then 
delete (all) of [Moves8 v]
delete (all) of [Moves8Score v]
end
if <(argument_reporter_string_number) = (9)> then 
delete (all) of [Moves9 v]
delete (all) of [Moves9Score v]
end
if <(argument_reporter_string_number) = (10)> then 
delete (all) of [Moves10 v]
delete (all) of [Moves10Score v]
end
replace item (argument_reporter_string_number) of [MovesCount v] with [0]
end
set [SourceIdxOuter v] to [1]
set [IsBlackMove v] to ((argument_reporter_string_number) mod (2))
if <not <argument_reporter_boolean>> then 
if <(IsBlackMove) = (1)> then 
set [BlackMobilityBonus v] to [0]
 else 
set [WhiteMobilityBonus v] to [0]
end
end
repeat (64) 
if <not <argument_reporter_boolean>> then 
replace item (SourceIdxOuter) of [PieceMobility v] with [0]
end
if <<<(IsBlackMove) = (1)> and <(item (SourceIdxOuter) of [Board v]) > (0)>> or <<(IsBlackMove) = (0)> and <(item (SourceIdxOuter) of [Board v]) < (0)>>> then 
CalculateMovesForSource %n %n %b %b
end
if <not <argument_reporter_boolean>> then 
set [CurrentPiece v] to (item (SourceIdxOuter) of [Board v])
if <(IsBlackMove) = (1)> then 
if <(CurrentPiece) = (BlackRook)> then 
change [BlackMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [RookMobilityBonus v])
 else 
if <(CurrentPiece) = (BlackQueen)> then 
change [BlackMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [QueenMobilityBonus v])
 else 
if <(CurrentPiece) = (BlackBishop)> then 
change [BlackMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [BishopMobilityBonus v])
 else 
if <(CurrentPiece) = (BlackKnight)> then 
change [BlackMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [KnightMobilityBonus v])
end
end
end
end
end
if <(IsBlackMove) = (0)> then 
if <(CurrentPiece) = (WhiteRook)> then 
change [WhiteMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [RookMobilityBonus v])
 else 
if <(CurrentPiece) = (WhiteQueen)> then 
change [WhiteMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [QueenMobilityBonus v])
 else 
if <(CurrentPiece) = (WhiteBishop)> then 
change [WhiteMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [BishopMobilityBonus v])
 else 
if <(CurrentPiece) = (WhiteKnight)> then 
change [WhiteMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [KnightMobilityBonus v])
end
end
end
end
end
end
change [SourceIdxOuter v] by (1)
end
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <(IsBlackMove) = (1)> then 
if <<(HasBlackKingMoved) = (0)> and <(HasBlackCastled) = (0)>> then 
if <<<<(item (item (1) of [VirtualBoard v]) of [Board v]) = (BlackRook)> and <(item (item (2) of [VirtualBoard v]) of [Board v]) = (Empty)>> and <<(item (item (3) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (4) of [VirtualBoard v]) of [Board v]) = (Empty)>>> and <(item (item (5) of [VirtualBoard v]) of [Board v]) = (BlackKing)>> then 
if <<(item (item (3) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <<(item (item (4) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <(item (item (5) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)>>> then 
if <(HasBlackRookQSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
if <<<(item (item (5) of [VirtualBoard v]) of [Board v]) = (BlackKing)> and <(item (item (6) of [VirtualBoard v]) of [Board v]) = (Empty)>> and <<(item (item (7) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (8) of [VirtualBoard v]) of [Board v]) = (BlackRook)>>> then 
if <<(item (item (5) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <<(item (item (6) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <(item (item (7) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)>>> then 
if <(HasBlackRookKSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
end
 else 
if <<(HasWhiteKingMoved) = (0)> and <(HasWhiteCastled) = (0)>> then 
if <<<(item (item (57) of [VirtualBoard v]) of [Board v]) = (WhiteRook)> and <(item (item (58) of [VirtualBoard v]) of [Board v]) = (Empty)>> and <<(item (item (59) of [VirtualBoard v]) of [Board v]) = (Empty)> and <<(item (item (60) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (61) of [VirtualBoard v]) of [Board v]) = (WhiteKing)>>>> then 
if <<(item (item (59) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <<(item (item (60) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <(item (item (61) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)>>> then 
if <(HasWhiteRookQSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
if <<<(item (item (62) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (61) of [VirtualBoard v]) of [Board v]) = (WhiteKing)>> and <<(item (item (63) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (64) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>>> then 
if <<(item (item (61) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <<(item (item (62) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <(item (item (63) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)>>> then 
if <(HasWhiteRookKSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
end
end
end
if <not <argument_reporter_boolean>> then 
if <(argument_reporter_string_number) = (1)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves1 v])
end
if <(argument_reporter_string_number) = (2)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves2 v])
end
if <(argument_reporter_string_number) = (3)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves3 v])
end
if <(argument_reporter_string_number) = (4)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves4 v])
end
if <(argument_reporter_string_number) = (5)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves5 v])
end
if <(argument_reporter_string_number) = (6)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves6 v])
end
if <(argument_reporter_string_number) = (7)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves7 v])
end
if <(argument_reporter_string_number) = (8)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves8 v])
end
if <(argument_reporter_string_number) = (9)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves9 v])
end
if <(argument_reporter_string_number) = (10)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves10 v])
end
end

define AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
InitAlphaBeta %n %b
if <argument_reporter_boolean> then 
OnScoreCalc %n %n %n %b %b %b
 else 
OnScoreCalc %n %n %n %b %b %b
end
if <(argument_reporter_string_number) = (argument_reporter_string_number)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [ScoreCalcRes]
stop [this script v]
end
if <<(argument_reporter_string_number) = (1)> and <<<(argument_reporter_string_number) = (2)> or <(argument_reporter_string_number) = (3)>> or <<(argument_reporter_string_number) > (3)> and <<(item ((argument_reporter_string_number) - (1)) of [CheckedState v]) = (1)> and <not <argument_reporter_boolean>>>>>> then 
CalcBoardAttackedByMove %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(IsWhiteChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((100000) - ((argument_reporter_string_number) * (1000)))
stop [this script v]
end
 else 
if <(IsBlackChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((-100000) + ((argument_reporter_string_number) * (1000)))
stop [this script v]
end
end
end
if <argument_reporter_boolean> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <not <(ScoreCalcRes) < (item (argument_reporter_string_number) of [Betas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
stop [this script v]
end
if <(ScoreCalcRes) > (item (argument_reporter_string_number) of [Alphas v])> then 
replace item (argument_reporter_string_number) of [Alphas v] with [ScoreCalcRes]
end
 else 
if <not <(ScoreCalcRes) > (item (argument_reporter_string_number) of [Alphas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
stop [this script v]
end
if <(ScoreCalcRes) < (item (argument_reporter_string_number) of [Betas v])> then 
replace item (argument_reporter_string_number) of [Betas v] with [ScoreCalcRes]
end
end
 else 
if <<(argument_reporter_string_number) = (1)> and <<(argument_reporter_string_number) = (2)> or <(argument_reporter_string_number) = (3)>>> then 
GetBoardString
if <[BoardHistory v] contains [GetBoardStringRes] ? ::lists> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
stop [this script v]
end
if <(argument_reporter_string_number) = (2)> then 
IsDraw %n
if <(IsDrawRes) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
stop [this script v]
end
end
end
if <<<argument_reporter_boolean> and <(argument_reporter_string_number) > (1)>> and <(argument_reporter_string_number) < (7)>> then 
GetBestHashMove %n
if <<not <(BestHashMoveResult) = (-1)>> and <<((argument_reporter_string_number) mod (2)) = ((BestHashMoveDepthResult) mod (2))> and <not <(argument_reporter_string_number) < (BestHashMoveDepthResult)>>>> then 
if <(BestHashMoveTypeResult) = (E)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [BestHashMoveScoreResult]
stop [this script v]
 else 
if <<(BestHashMoveTypeResult) = (A)> and <not <(BestHashMoveScoreResult) > (item (argument_reporter_string_number) of [Alphas v])>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [BestHashMoveScoreResult]
stop [this script v]
 else 
if <<(BestHashMoveTypeResult) = (B)> and <not <(BestHashMoveScoreResult) < (item (argument_reporter_string_number) of [Betas v])>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [BestHashMoveScoreResult]
stop [this script v]
end
end
end
end
end
end
replace item (argument_reporter_string_number) of [PickPhase v] with [1]
replace item (argument_reporter_string_number) of [PickMoveRes v] with [1]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with []
replace item (argument_reporter_string_number) of [CheckedState v] with [0]
replace item (argument_reporter_string_number) of [PrevBestHashMove v] with []
repeat until <(item (argument_reporter_string_number) of [PickMoveRes v]) = (0)> 
PickMove %n %n %b %b %b %b
if <(item (argument_reporter_string_number) of [PickMoveRes v]) = (1)> then 
if <argument_reporter_boolean> then 
if <<(argument_reporter_string_number) = (1)> and <(item (argument_reporter_string_number) of [PickPhase v]) = (3)>> then 
if <(1) = (0)> then 
OnProgressChanged %n
end
end
end
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with (item (argument_reporter_string_number) of [Alphas v])
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with (item (argument_reporter_string_number) of [Betas v])
if <<(argument_reporter_string_number) > (0)> and <(argument_reporter_string_number) = ((argument_reporter_string_number) - (1))>> then 
if <not <argument_reporter_boolean>> then 
CalcBoardAttackedByMove %n
end
if <<not <argument_reporter_boolean>> and <<<((argument_reporter_string_number) mod (2)) = (0)> and <(IsBlackChecked) = (1)>> or <<((argument_reporter_string_number) mod (2)) = (1)> and <(IsWhiteChecked) = (1)>>>> then 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
 else 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
end
 else 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
end
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
if <<(argument_reporter_string_number) < (3)> and <argument_reporter_boolean>> then 
CutoffOnMoveScore %n %n
end
if <argument_reporter_boolean> then 
if <(argument_reporter_string_number) < (6)> then 
HashOnMoveScore %n %n %n %n %s %n
end
end
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> then 
set [IsPotentialKillerMove v] to [1]
 else 
set [IsPotentialKillerMove v] to [0]
end
RevertMove %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(argument_reporter_string_number) > (1)> then 
if <not <(Score) < (item (argument_reporter_string_number) of [Betas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
StoreMove %n %b
stop [this script v]
end
end
if <(Score) > (item (argument_reporter_string_number) of [Alphas v])> then 
replace item (argument_reporter_string_number) of [Alphas v] with [Score]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [BestMoves v]
add (item (item (1) of [MovesIdx v]) of [Moves1 v]) to [BestMoves v]
end
StoreMove %n %b
end
 else 
if <not <(Score) > (item (argument_reporter_string_number) of [Alphas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
if <<not <argument_reporter_boolean>> or <(argument_reporter_string_number) > (2)>> then 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
StoreMove %n %b
stop [this script v]
end
end
if <(Score) < (item (argument_reporter_string_number) of [Betas v])> then 
replace item (argument_reporter_string_number) of [Betas v] with [Score]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
StoreMove %n %b
end
end
end
end
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <<(argument_reporter_string_number) = (1)> and <argument_reporter_boolean>> then 
CutoffPostProcess %n
end
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
if <not <(item (argument_reporter_string_number) of [BestHashMoveType v]) = (E)>> then 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
end
 else 
if <<(argument_reporter_string_number) = (2)> and <argument_reporter_boolean>> then 
CutoffPostProcess %n
end
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
if <not <(item (argument_reporter_string_number) of [BestHashMoveType v]) = (E)>> then 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
end
end
if <(item (argument_reporter_string_number) of [MovesCount v]) = (0)> then 
if <argument_reporter_boolean> then 
OnScoreCalc %n %n %n %b %b %b
replace item (argument_reporter_string_number) of [MinMaxResults v] with [ScoreCalcRes]
stop [this script v]
 else 
CalcBoardAttackedByMove %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(IsBlackChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((-100000) + ((argument_reporter_string_number) * (1000)))
stop [this script v]
 else 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
stop [this script v]
end
 else 
if <(IsWhiteChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((100000) - ((argument_reporter_string_number) * (1000)))
stop [this script v]
 else 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
stop [this script v]
end
end
end
end

define GetMoveScore %n %n %n %n %n %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
set [RankFac v] to [1]
 else 
set [RankFac v] to [-1]
end
if <(letter (5) of (argument_reporter_string_number)) = (.)> then 
if <(letter (6) of (argument_reporter_string_number)) = (1)> then 
set [MoveScoreRes v] to ((800) * (RankFac))
end
if <(letter (6) of (argument_reporter_string_number)) = (2)> then 
set [MoveScoreRes v] to ((400) * (RankFac))
end
if <(letter (6) of (argument_reporter_string_number)) = (3)> then 
set [MoveScoreRes v] to ((230) * (RankFac))
end
if <(letter (6) of (argument_reporter_string_number)) = (4)> then 
set [MoveScoreRes v] to ((210) * (RankFac))
end
stop [this script v]
end
if <<<((argument_reporter_string_number) mod (2)) = (0)> and <(item (argument_reporter_string_number) of [BoardAttackedByBlack v]) = (0)>> or <<((argument_reporter_string_number) mod (2)) = (1)> and <(item (argument_reporter_string_number) of [BoardAttackedByWhite v]) = (0)>>> then 
set [IsAttacked v] to [0]
 else 
set [IsAttacked v] to [1]
end
if <<(argument_reporter_string_number) = (Empty)> and <(IsAttacked) = (0)>> then 
if <(argument_reporter_string_number) = (2)> then 
if <[KillerMoves2 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to ((80) * (RankFac))
stop [this script v]
end
end
if <(argument_reporter_string_number) = (3)> then 
if <[KillerMoves3 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to ((80) * (RankFac))
stop [this script v]
end
if <(1) = (0)> then 
if <(argument_reporter_string_number) = (item (1) of [Moves1 v])> then 
set [MoveScoreRes v] to ((70) * (RankFac))
stop [this script v]
end
if <(argument_reporter_string_number) = (item (2) of [Moves1 v])> then 
set [MoveScoreRes v] to ((65) * (RankFac))
stop [this script v]
end
if <(argument_reporter_string_number) = (item (3) of [Moves1 v])> then 
set [MoveScoreRes v] to ((60) * (RankFac))
stop [this script v]
end
end
end
if <(argument_reporter_string_number) = (4)> then 
if <[KillerMoves4 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to ((80) * (RankFac))
stop [this script v]
end
if <(1) = (0)> then 
if <(argument_reporter_string_number) = (item (1) of [Moves2 v])> then 
set [MoveScoreRes v] to ((70) * (RankFac))
stop [this script v]
end
if <(argument_reporter_string_number) = (item (2) of [Moves2 v])> then 
set [MoveScoreRes v] to ((65) * (RankFac))
stop [this script v]
end
if <(argument_reporter_string_number) = (item (3) of [Moves2 v])> then 
set [MoveScoreRes v] to ((60) * (RankFac))
stop [this script v]
end
end
end
if <<(argument_reporter_string_number) = (5)> or <(argument_reporter_string_number) = (6)>> then 
if <<<(argument_reporter_string_number) = (5)> and <[KillerMoves5 v] contains (argument_reporter_string_number) ? ::lists>> or <<(argument_reporter_string_number) = (6)> and <[KillerMoves6 v] contains (argument_reporter_string_number) ? ::lists>>> then 
set [MoveScoreRes v] to ((80) * (RankFac))
stop [this script v]
end
end
if <<<(argument_reporter_string_number) = (BlackQueensideCastling)> or <(argument_reporter_string_number) = (BlackKingsideCastling)>> or <<(argument_reporter_string_number) = (WhiteQueensideCastling)> or <(argument_reporter_string_number) = (WhiteKingsideCastling)>>> then 
set [MoveScoreRes v] to ((50) * (RankFac))
stop [this script v]
end
end
set [MoveScoreRes v] to [0]
GetPosScore %n %n
change [MoveScoreRes v] by ((0) - (PosScoreRes))
if <(IsAttacked) = (0)> then 
GetPosScore %n %n
change [MoveScoreRes v] by (PosScoreRes)
 else 
change [MoveScoreRes v] by ((0) - (argument_reporter_string_number))
end
if <not <(argument_reporter_string_number) = (Empty)>> then 
change [MoveScoreRes v] by ((0) - (argument_reporter_string_number))
GetPosScore %n %n
change [MoveScoreRes v] by ((0) - (PosScoreRes))
end

define ImportBoardFENOnline %n
if <(IsPlayerBlack) = (0)> then 
set [Idx v] to [1]
set [IdxInc v] to [1]
 else 
set [Idx v] to [64]
set [IdxInc v] to [-1]
end
set [IdxString v] to [1]
repeat until <<(Idx) > (64)> or <(Idx) < (1)>> 
set [CurrentValue v] to (letter (IdxString) of (argument_reporter_string_number))
if <<not <(CurrentValue) < (A)>> and <not <(CurrentValue) > (Z)>>> then 
set [CurrentPiece v] to [Empty]
if <(CurrentValue) = (P)> then 
set [CurrentPiece v] to [BlackPawn]
end
if <(CurrentValue) = (N)> then 
set [CurrentPiece v] to [BlackKnight]
end
if <(CurrentValue) = (B)> then 
set [CurrentPiece v] to [BlackBishop]
end
if <(CurrentValue) = (R)> then 
set [CurrentPiece v] to [BlackRook]
end
if <(CurrentValue) = (Q)> then 
set [CurrentPiece v] to [BlackQueen]
end
if <(CurrentValue) = (K)> then 
set [CurrentPiece v] to [BlackKing]
end
IsLowerCase %s
if <(IsLowerCaseRes) = (0)> then 
set [CurrentPiece v] to ((CurrentPiece) * (-1))
end
if <(IsPlayerBlack) = (1)> then 
set [CurrentPiece v] to ((CurrentPiece) * (-1))
end
replace item (Idx) of [Board v] with [CurrentPiece]
change [Idx v] by (IdxInc)
 else 
if <<not <(CurrentValue) < (0)>> and <not <(CurrentValue) > (9)>>> then 
repeat (CurrentValue) 
replace item (Idx) of [Board v] with [Empty]
change [Idx v] by (IdxInc)
end
 else 
if <(CurrentValue) = (/)> then 
repeat until <<<((Idx) mod (8)) = (1)> and <(IsPlayerBlack) = (0)>> or <<((Idx) mod (8)) = (0)> and <(IsPlayerBlack) = (1)>>> 
replace item (Idx) of [Board v] with [Empty]
change [Idx v] by (IdxInc)
end
end
end
end
change [IdxString v] by (1)
end
DrawBoardAndWait
change [IdxString v] by (1)
set [CurrentValue v] to (letter (IdxString) of (argument_reporter_string_number))
if <(CurrentValue) = (W)> then 
set [Local_IsWhitesTurn v] to [1]
end
if <(CurrentValue) = (B)> then 
set [Local_IsWhitesTurn v] to [0]
end

define ExportBoardInternal
set [ExportDataInt v] to []
set [Idx v] to [1]
repeat (64) 
if <(IsPlayerBlack) = (0)> then 
set [CurrentPiece v] to (item (Idx) of [Board v])
 else 
set [CurrentPiece v] to ((0) - (item ((65) - (Idx)) of [Board v]))
end
if <(CurrentPiece) = (Empty)> then 
set [ExportDataInt v] to (join [ExportDataInt] [9])
 else 
set [IdxSub v] to [1]
repeat (length of [OnlineBoardPieceMap v]) 
if <(CurrentPiece) = (item (IdxSub) of [OnlineBoardPieceMap v])> then 
if <(length of [IdxSub]) = (1)> then 
set [ExportDataInt v] to (join [ExportDataInt] (join [0] [IdxSub]))
 else 
set [ExportDataInt v] to (join [ExportDataInt] [IdxSub])
end
end
change [IdxSub v] by (1)
end
end
change [Idx v] by (1)
end

define ExecuteUserMoveOnline
if <<(IsGameSuspended) = (1)> or <(IsExecutionRunning) = (1)>> then 
stop [this script v]
end
EnterExecution %n
if <<(item (MoveFromIdx) of [Board v]) < (0)> and <not <(MoveFromIdx) = (MoveToIdx)>>> then 
set [UserMove v] to []
if <<(item (MoveFromIdx) of [Board v]) = (WhiteKing)> and <(MoveFromIdx) = (item (61) of [VirtualBoard v])>> then 
if <<(MoveToIdx) = (item (59) of [VirtualBoard v])> and <(item (item (57) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> then 
CalculateMoves %n
if <[Moves2 v] contains [WhiteQueensideCastling] ? ::lists> then 
set [UserMove v] to [WhiteQueensideCastling]
 else 
set [UserMove v] to [6159]
end
end
if <<(MoveToIdx) = (item (63) of [VirtualBoard v])> and <(item (item (64) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> then 
CalculateMoves %n
if <[Moves2 v] contains [WhiteKingsideCastling] ? ::lists> then 
set [UserMove v] to [WhiteKingsideCastling]
 else 
set [UserMove v] to [6163]
end
end
end
if <(UserMove) = ()> then 
set [UserMove v] to (((MoveFromIdx) * (100)) + (MoveToIdx))
if <(length of [UserMove]) = (3)> then 
set [UserMove v] to (join [0] [UserMove])
end
if <<(item (MoveFromIdx) of [Board v]) = (WhitePawn)> and <(MoveFromIdx) < (17)>> then 
set [UserMove v] to (join [UserMove] [.1])
end
end
set [MovePieceFromIdx v] to [MoveFromIdx]
set [MovePieceToIdx v] to [MoveToIdx]
if <<<(UserMove) = (BlackQueensideCastling)> or <(UserMove) = (BlackKingsideCastling)>> or <<(UserMove) = (WhiteQueensideCastling)> or <(UserMove) = (WhiteKingsideCastling)>>> then 
set [MovePieceSpecial v] to [UserMove]
 else 
set [MovePieceSpecial v] to []
end
broadcast (1 v) and wait
set [FromSquareIdx v] to [-1]
set [ToSquareIdx v] to [-1]
broadcast (1 v) and wait
broadcast (1 v) and wait
CalculateMoves %n
if <not <[Moves2 v] contains [UserMove] ? ::lists>> then 
delete (all) of [Moves2 v]
add [UserMove] to [Moves2 v]
replace item (2) of [MovesIdx v] with [1]
replace item (2) of [MovesCount v] with [1]
ApplyMove %n
CalcBoardAttackedByMove %n
RevertMove %n
if <(IsWhiteChecked) = (1)> then 
broadcast (1 v)
SayAsync %s %n
 else 
broadcast (1 v)
SayAsync %s %n
end
DrawBoardForcedAndWait
 else 
if <not <(UserMove) = ([floor v] of (UserMove) ::operators)>> then 
say [Please select promotion piece]
broadcast (1 v) and wait
say []
if <(SelectedPromotionPiece) = (WhiteQueen)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.1])
 else 
if <(SelectedPromotionPiece) = (WhiteRook)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.2])
 else 
if <(SelectedPromotionPiece) = (WhiteBishop)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.3])
 else 
if <(SelectedPromotionPiece) = (WhiteKnight)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.4])
end
end
end
end
repeat until <(length of [UserMove]) > (5)> 
set [UserMove v] to (join [0] [UserMove])
end
end
delete (all) of [Moves2 v]
add [UserMove] to [Moves2 v]
replace item (2) of [MovesIdx v] with [1]
replace item (2) of [MovesCount v] with [1]
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
RevertMove %n
DrawBoardAndWait
broadcast (1 v)
SayAsync %s %n
 else 
if <(item ((UserMove) mod (100)) of [Board v]) = (WhiteKing)> then 
set [HasWhiteKingMoved v] to [1]
end
if <(item ((UserMove) mod (100)) of [Board v]) = (WhiteRook)> then 
if <([floor v] of ((UserMove) / (100)) ::operators) = (item (57) of [VirtualBoard v])> then 
set [HasWhiteRookQSMoved v] to [1]
end
if <([floor v] of ((UserMove) / (100)) ::operators) = (item (64) of [VirtualBoard v])> then 
set [HasWhiteRookKSMoved v] to [1]
end
end
if <<(UserMove) = (WhiteQueensideCastling)> or <(UserMove) = (WhiteKingsideCastling)>> then 
set [HasWhiteCastled v] to [1]
set [HasWhiteKingMoved v] to [1]
end
GetPlayerState
if <<<(IsPlayerBlack) = (0)> and <(IsPlayer1) = (1)>> or <<(IsPlayerBlack) = (1)> and <(IsPlayer2) = (1)>>> then 
if <(IsPlayer1) = (1)> then 
wait (CloudUpdateDelay) seconds
Encode %s
set [ Cloud_Player1Name v] to [EncodedText]
end
if <(IsPlayer2) = (1)> then 
wait (CloudUpdateDelay) seconds
Encode %s
set [ Cloud_Player2Name v] to [EncodedText]
end
wait (CloudUpdateDelay) seconds
set [ Cloud_Player1Heartbeat v] to [ Cloud_HeartbeatValue]
wait (CloudUpdateDelay) seconds
set [ Cloud_Player2Heartbeat v] to [ Cloud_HeartbeatValue]
ExportBoardInternal
if <(IsPlayerBlack) = (0)> then 
wait (CloudUpdateDelay) seconds
set [Local_IsWhitesTurn v] to [0]
set [Local_LastMove v] to ([floor v] of (UserMove) ::operators)
UpdateCloudState %s %s %s %s %s %s %s %s %s %s %s
 else 
wait (CloudUpdateDelay) seconds
set [Local_IsWhitesTurn v] to [1]
if <(UserMove) = (WhiteKingsideCastling)> then 
set [Local_LastMove v] to [BlackKingsideCastling]
 else 
if <(UserMove) = (WhiteQueensideCastling)> then 
set [Local_LastMove v] to [BlackQueensideCastling]
 else 
set [Local_LastMove v] to ([floor v] of ((((65) - ([floor v] of ((UserMove) / (100)) ::operators)) * (100)) + ((65) - ([floor v] of ((UserMove) mod (100)) ::operators))) ::operators)
if <(length of [Local_LastMove]) = (3)> then 
set [Local_LastMove v] to (join [0] [Local_LastMove])
end
end
end
UpdateCloudState %s %s %s %s %s %s %s %s %s %s %s
end
set [GameMoves v] to (join [GameMoves] [UserMove])
AddBoardToHistory
HandlePostOnlineMove
DrawBoardAndWait
end
end
end
end
ExecuteMovePostProcess
ExitExecution

when i receive [squareclicked v]
HandleSquareClicked

define Decode %s
set [DecodedText v] to []
set [TextIdx v] to [1]
set [CharIdx v] to [-1]
repeat until <<(CharIdx) = (0)> or <(TextIdx) > (length of (argument_reporter_string_number))>> 
set [CharIdx v] to (((letter (TextIdx) of (argument_reporter_string_number)) * (10)) + (letter ((TextIdx) + (1)) of (argument_reporter_string_number)))
if <(CharIdx) > (0)> then 
if <not <(CharIdx) > (length of [CharMap])>> then 
set [DecodedText v] to (join [DecodedText] (letter (CharIdx) of [CharMap]))
 else 
set [DecodedText v] to (join [DecodedText] [?])
end
change [TextIdx v] by (2)
end
end

when i receive [startgame v]
RunOnlineLoop

define ShowOnlineState
UpdateStatePanelData
broadcast (1 v) and wait

define ImportBoardIntOnWrite %n
set [ImportBoardIntOnWriteRes v] to [0]
set [Idx v] to [1]
set [IdxSub v] to [1]
repeat (64) 
if <(IsPlayerBlack) = (0)> then 
replace item (Idx) of [BoardCpy v] with (item (join (letter (IdxSub) of (argument_reporter_string_number)) (letter ((IdxSub) + (1)) of (argument_reporter_string_number))) of [OnlineBoardPieceMap v])
 else 
replace item ((65) - (Idx)) of [BoardCpy v] with ((0) - (item (join (letter (IdxSub) of (argument_reporter_string_number)) (letter ((IdxSub) + (1)) of (argument_reporter_string_number))) of [OnlineBoardPieceMap v]))
end
if <not <(item (Idx) of [Board v]) = (item (Idx) of [BoardCpy v])>> then 
replace item (Idx) of [Board v] with (item (Idx) of [BoardCpy v])
set [ImportBoardIntOnWriteRes v] to [1]
end
change [Idx v] by (1)
change [IdxSub v] by (2)
end

define UpdateCloudState %s %s %s %s %s %s %s %s %s %s %s
set [Local_CloudState v] to []
set [Local_CloudStateCpy v] to [ Cloud_State]
if <(length of (argument_reporter_string_number)) = (1)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
set [Local_CloudState v] to (join [Local_CloudState] (letter (1) of [Local_CloudStateCpy]))
end
if <(length of (argument_reporter_string_number)) = (1)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
set [Local_CloudState v] to (join [Local_CloudState] (letter (2) of [Local_CloudStateCpy]))
end
if <(length of (argument_reporter_string_number)) = (1)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
set [Local_CloudState v] to (join [Local_CloudState] (letter (3) of [Local_CloudStateCpy]))
end
if <(length of (argument_reporter_string_number)) = (1)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
set [Local_CloudState v] to (join [Local_CloudState] (letter (4) of [Local_CloudStateCpy]))
end
if <(length of (argument_reporter_string_number)) = (1)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
set [Local_CloudState v] to (join [Local_CloudState] (letter (5) of [Local_CloudStateCpy]))
end
if <(length of (argument_reporter_string_number)) = (1)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
set [Local_CloudState v] to (join [Local_CloudState] (letter (6) of [Local_CloudStateCpy]))
end
if <(length of (argument_reporter_string_number)) = (1)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
set [Local_CloudState v] to (join [Local_CloudState] (letter (7) of [Local_CloudStateCpy]))
end
if <(length of (argument_reporter_string_number)) = (1)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
set [Local_CloudState v] to (join [Local_CloudState] (letter (8) of [Local_CloudStateCpy]))
end
if <(length of (argument_reporter_string_number)) = (1)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
set [Local_CloudState v] to (join [Local_CloudState] (letter (9) of [Local_CloudStateCpy]))
end
if <(length of (argument_reporter_string_number)) = (2)> then 
set [Local_CloudState v] to (join [Local_CloudState] (join [00] (argument_reporter_string_number)))
 else 
if <(length of (argument_reporter_string_number)) = (3)> then 
set [Local_CloudState v] to (join [Local_CloudState] (join [0] (argument_reporter_string_number)))
 else 
if <(length of (argument_reporter_string_number)) = (4)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
set [Local_CloudState v] to (join [Local_CloudState] (join (join (letter (10) of [Local_CloudStateCpy]) (letter (11) of [Local_CloudStateCpy])) (join (letter (12) of [Local_CloudStateCpy]) (letter (13) of [Local_CloudStateCpy]))))
end
end
end
if <(length of (argument_reporter_string_number)) > (0)> then 
set [Local_CloudState v] to (join [Local_CloudState] (argument_reporter_string_number))
 else 
GetSubstring %s %n %n
set [Local_CloudState v] to (join [Local_CloudState] [SubstringRes])
end
set [ Cloud_State v] to [Local_CloudState]

define InitVirtualBoard
delete (all) of [VirtualBoard v]
delete (all) of [SwitchedBoard v]
set [Idx v] to [1]
repeat (64) 
if <(IsPlayerBlack) = (0)> then 
add [Idx] to [VirtualBoard v]
add [Idx] to [SwitchedBoard v]
 else 
add ((((item (Idx) of [IdxToRow v]) - (1)) * (8)) + ((9) - (item (Idx) of [IdxToCol v]))) to [VirtualBoard v]
add ((((item (Idx) of [IdxToRow v]) - (1)) * (8)) + ((9) - (item (Idx) of [IdxToCol v]))) to [SwitchedBoard v]
end
change [Idx v] by (1)
end

define ShowMove %n %n
set [ShowMoveRes v] to [0]
if <((argument_reporter_string_number) mod (2)) = (1)> then 
CalculateMoves %n
if <<not <[Moves1 v] contains (argument_reporter_string_number) ? ::lists>> and <<<<not <[Moves1 v] contains (join (argument_reporter_string_number) [.1]) ? ::lists>> and <not <[Moves1 v] contains (join (argument_reporter_string_number) [.2]) ? ::lists>>> and <<not <[Moves1 v] contains (join (argument_reporter_string_number) [.3]) ? ::lists>> and <not <[Moves1 v] contains (join (argument_reporter_string_number) [.4]) ? ::lists>>>> and <<not <(argument_reporter_string_number) = (BlackQueensideCastling)>> and <not <(argument_reporter_string_number) = (BlackKingsideCastling)>>>>> then 
stop [this script v]
end
 else 
CalculateMoves %n
if <<not <[Moves2 v] contains (argument_reporter_string_number) ? ::lists>> and <<<<not <[Moves2 v] contains (join (argument_reporter_string_number) [.1]) ? ::lists>> and <not <[Moves2 v] contains (join (argument_reporter_string_number) [.2]) ? ::lists>>> and <<not <[Moves2 v] contains (join (argument_reporter_string_number) [.3]) ? ::lists>> and <not <[Moves2 v] contains (join (argument_reporter_string_number) [.4]) ? ::lists>>>> and <<not <(argument_reporter_string_number) = (WhiteQueensideCastling)>> and <not <(argument_reporter_string_number) = (WhiteKingsideCastling)>>>>> then 
stop [this script v]
end
end
set [MovePieceFromIdx v] to ([floor v] of ((argument_reporter_string_number) / (100)) ::operators)
set [MovePieceToIdx v] to ([floor v] of ((argument_reporter_string_number) mod (100)) ::operators)
if <<<(argument_reporter_string_number) = (BlackQueensideCastling)> or <(argument_reporter_string_number) = (BlackKingsideCastling)>> or <<(argument_reporter_string_number) = (WhiteQueensideCastling)> or <(argument_reporter_string_number) = (WhiteKingsideCastling)>>> then 
set [MovePieceSpecial v] to (argument_reporter_string_number)
 else 
set [MovePieceSpecial v] to []
end
wait (0.01) seconds
broadcast (1 v) and wait
set [ShowMoveRes v] to [1]

define UpdateButtonStates
if <(IsExecutionRunning) = (1)> then 
set [BtnJoinEnabled v] to [0]
set [BtnLeaveEnabled v] to [0]
set [BtnResetEnabled v] to [0]
 else 
GetPlayerState
Encode %s
if <<(IsPlayer1) = (1)> or <(IsPlayer2) = (1)>> then 
set [BtnLeaveEnabled v] to [1]
 else 
set [BtnLeaveEnabled v] to [0]
end
if <<(IsJoinBlocked) = (0)> and <<<(IsPlayer1GoK) = (1)> or <(IsPlayer2GoK) = (1)>> and <not <<( Cloud_Player1Name) = (EncodedText)> or <( Cloud_Player2Name) = (EncodedText)>>>>> then 
set [BtnJoinEnabled v] to [1]
 else 
set [BtnJoinEnabled v] to [0]
end
if <<<(IsPlayer1) = (1)> or <(IsPlayer2) = (1)>> or <<(username) = (ArnoHu)> or <(username) = (FunnyAnimatorJimTV)>>> then 
set [BtnResetEnabled v] to [1]
 else 
set [BtnResetEnabled v] to [0]
end
end
broadcast (1 v) and wait

when i receive [leaveonline v]
LeaveOnline

when i receive [resetonline v]
ResetOnline

define GetVirtualMove %n
if <(IsPlayerBlack) = (0)> then 
set [VirtualMove v] to (argument_reporter_string_number)
 else 
if <<not <(argument_reporter_string_number) < (0100)>> and <not <(argument_reporter_string_number) > (6499)>>> then 
set [VirtualMove v] to ((65) - ([floor v] of ((argument_reporter_string_number) mod (100)) ::operators))
repeat until <(length of [VirtualMove]) > (1)> 
set [VirtualMove v] to (join [0] [VirtualMove])
end
set [VirtualMove v] to (join ((65) - ([floor v] of ((argument_reporter_string_number) / (100)) ::operators)) [VirtualMove])
repeat until <(length of [VirtualMove]) > (3)> 
set [VirtualMove v] to (join [0] [VirtualMove])
end
if <(letter (5) of (argument_reporter_string_number)) = (.)> then 
set [VirtualMove v] to (join [VirtualMove] (join (letter (5) of (argument_reporter_string_number)) (letter (6) of (argument_reporter_string_number))))
end
 else 
if <(argument_reporter_string_number) = (BlackKingsideCastling)> then 
set [VirtualMove v] to [WhiteKingsideCastling]
 else 
if <(argument_reporter_string_number) = (BlackQueensideCastling)> then 
set [VirtualMove v] to [WhiteQueensideCastling]
 else 
if <(argument_reporter_string_number) = (WhiteKingsideCastling)> then 
set [VirtualMove v] to [BlackKingsideCastling]
 else 
if <(argument_reporter_string_number) = (WhiteQueensideCastling)> then 
set [VirtualMove v] to [BlackQueensideCastling]
end
end
end
end
end
end

when i receive [joinonline v]
JoinOnline

define Encode %s
set [EncodedText v] to []
set [TextIdx v] to [1]
repeat until <(TextIdx) > (length of (argument_reporter_string_number))> 
set [CharIdx v] to [1]
repeat until <<(letter (CharIdx) of [CharMap]) = (letter (TextIdx) of (argument_reporter_string_number))> or <(CharIdx) > (length of [CharMap])>> 
change [CharIdx v] by (1)
end
if <(letter (CharIdx) of [CharMap]) = (letter (TextIdx) of (argument_reporter_string_number))> then 
set [EncodedText v] to (join [EncodedText] ([floor v] of ((CharIdx) / (10)) ::operators))
set [EncodedText v] to (join [EncodedText] ((CharIdx) mod (10)))
end
change [TextIdx v] by (1)
end

define ClearHashCache
delete (all) of [HashMovesHash v]
delete (all) of [HashMovesBestMove v]
delete (all) of [HashMovesScore v]
delete (all) of [HashMovesDepth v]
delete (all) of [HashMovesAge v]
delete (all) of [HashMovesType v]
delete (all) of [HashMovesChecked v]
if <(1) = (0)> then 
repeat (262144) 
add [] to [HashMovesChecked v]
end
repeat (262144) 
add [] to [HashMovesHash v]
end
repeat (262144) 
add [] to [HashMovesBestMove v]
end
repeat (262144) 
add [] to [HashMovesScore v]
end
repeat (262144) 
add [] to [HashMovesDepth v]
end
repeat (262144) 
add [] to [HashMovesAge v]
end
repeat (262144) 
add [] to [HashMovesType v]
end
end

define HandlePostOnlineMove
IsBlackKingCheckMate
if <(IsBlackKingCheckMateRes) = (1)> then 
if <(IsGameSuspended) = (0)> then 
broadcast (1 v)
end
set [SP_Status v] to [Checkmate!]
set [IsGameSuspended v] to [1]
 else 
IsWhiteKingCheckMate
if <(IsWhiteKingCheckMateRes) = (1)> then 
if <(IsGameSuspended) = (0)> then 
broadcast (1 v)
end
set [SP_Status v] to [Checkmate!]
set [IsGameSuspended v] to [1]
 else 
IsDraw %n
if <<(IsDrawRes) = (1)> and <<<(Local_IsWhitesTurn) = (0)> and <(IsPlayerBlack) = (0)>> or <<(Local_IsWhitesTurn) = (1)> and <(IsPlayerBlack) = (1)>>>> then 
if <(IsGameSuspended) = (0)> then 
broadcast (1 v)
end
set [SP_Status v] to [Draw!]
set [IsGameSuspended v] to [1]
 else 
IsDraw %n
if <<(IsDrawRes) = (1)> and <<<(Local_IsWhitesTurn) = (1)> and <(IsPlayerBlack) = (0)>> or <<(Local_IsWhitesTurn) = (0)> and <(IsPlayerBlack) = (1)>>>> then 
if <(IsGameSuspended) = (0)> then 
broadcast (1 v)
end
set [SP_Status v] to [Draw!]
set [IsGameSuspended v] to [1]
 else 
GetRepetitionCount
if <(RepetitionCountRes) > (2)> then 
if <(IsGameSuspended) = (0)> then 
broadcast (1 v)
end
set [SP_Status v] to [Draw!]
set [IsGameSuspended v] to [1]
 else 
IsTwoKingDraw
if <(TwoKingDrawRes) = (1)> then 
if <(IsGameSuspended) = (0)> then 
broadcast (1 v)
end
set [SP_Status v] to [Draw!]
set [IsGameSuspended v] to [1]
 else 
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
if <(PrevCheck) = (0)> then 
broadcast (1 v)
end
set [SP_Status v] to [Check!]
set [PrevCheck v] to [1]
 else 
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (1)> then 
if <(PrevCheck) = (0)> then 
broadcast (1 v)
end
set [SP_Status v] to [Check!]
set [PrevCheck v] to [1]
 else 
set [SP_Status v] to []
set [PrevCheck v] to [0]
end
end
set [IsGameSuspended v] to [0]
end
end
end
end
end
end
if <(IsGameSuspended) = (1)> then 
if <(HasPendingReset) = (0)> then 
GetCloudState
if <<(IsHeartbeatPlayer) = (1)> or <<(IsPlayer1) = (1)> or <(IsPlayer2) = (1)>>> then 
broadcast (1 v)
end
end
end

define RunOnlineLoop
set [ReceiveCounter v] to [0]
set [CloudUpdateDelay v] to [0.2]
set [CharMap v] to [ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 ,.-;:_]
set [SessionToken v] to ([floor v] of (pick random (1) to (4294967295)) ::operators)
set [IsHeartbeat v] to [0]
set [IsGoK v] to [0]
set [MoveFromIdx v] to [-1]
set [MoveToIdx v] to [-1]
go to x: (240) y: (-140)
set [IsPlayerBlack v] to [0]
switch backdrop to (1 v) ::looks
InitBoard
GetPlayerState
GetCloudState
ImportBoardInt %n
if <not <(Local_LastMove) = (0000)>> then 
set [GameMoves v] to [0000]
end
HandlePostOnlineMove
DrawBoardAndWait
broadcast (1 v)
broadcast (1 v)
forever 
wait (1) seconds
if <(IsExecutionRunning) = (0)> then 
GetCloudState
ExportBoardInternal
if <(join [X] [Local_Board]) = (join [X] [ExportDataInt])> then 
UpdateStatePanelData
DrawBoardAndWait
UpdateButtonStates
 else 
if <(IsExecutionRunning) = (0)> then 
EnterExecution %n
UpdateButtonStates
set [ShowMoveRes v] to [0]
if <(IsGameSuspended) = (0)> then 
if <(Local_LastMove) = (0000)> then 
set [GameMoves v] to []
delete (all) of [BoardHistory v]
 else 
if <(Local_IsWhitesTurn) = (IsPlayerBlack)> then 
ShowMove %n %n
 else 
ShowMove %n %n
end
end
end
ImportBoardInt %n
HandlePostOnlineMove
DrawBoardForcedAndWait
if <(ShowMoveRes) = (1)> then 
set [GameMoves v] to (join [GameMoves] [Local_LastMove])
AddBoardToHistory
end
ExitExecution
change [ReceiveCounter v] by (1)
if <(ReceiveCounter) > (1)> then 
set [IsJoinBlocked v] to [0]
end
UpdateButtonStates
end
end
if <<(IsExecutionRunning) = (0)> and <(IsGameSuspended) = (0)>> then 
GetCloudState
GetPlayerState
if <(IsHeartbeatPlayer) = (1)> then 
if <<<<(IsPlayer1GoK) = (1)> and <(Local_IsWhitesTurn) = (1)>> and <( Cloud_Player1Heartbeat) < (( Cloud_HeartbeatValue) - (0))>> or <<<(IsPlayer2GoK) = (1)> and <(Local_IsWhitesTurn) = (0)>> and <( Cloud_Player2Heartbeat) < (( Cloud_HeartbeatValue) - (0))>>> then 
EnterExecution %n
UpdateButtonStates
set [Local_BoardCpy v] to [Local_Board]
set [IsPlayerBlackPrev v] to [IsPlayerBlack]
set [IsWhitesTurnPrev v] to [Local_IsWhitesTurn]
if <<(IsPlayerBlack) = (0)> and <(Local_IsWhitesTurn) = (1)>> then 
set [IsPlayerBlack v] to [1]
end
if <<(IsPlayerBlack) = (1)> and <(Local_IsWhitesTurn) = (0)>> then 
set [IsPlayerBlack v] to [0]
end
if <(IsPlayerBlack) = (0)> then 
set [HasBlackCastled v] to (letter (6) of [Local_CloudState])
set [HasBlackKingMoved v] to (letter (7) of [Local_CloudState])
set [HasBlackRookQSMoved v] to (letter (8) of [Local_CloudState])
set [HasBlackRookKSMoved v] to (letter (9) of [Local_CloudState])
 else 
set [HasBlackCastled v] to (letter (2) of [Local_CloudState])
set [HasBlackKingMoved v] to (letter (3) of [Local_CloudState])
set [HasBlackRookQSMoved v] to (letter (4) of [Local_CloudState])
set [HasBlackRookKSMoved v] to (letter (5) of [Local_CloudState])
end
InitVirtualBoard
InitOpeningBook
ImportBoardInt %n
ExitExecution
ExecuteEngineMoveOnline
EnterExecution %n
set [IsPlayerBlack v] to [IsPlayerBlackPrev]
if <(IsPlayerBlack) = (0)> then 
set [HasBlackCastled v] to (letter (6) of [Local_CloudState])
set [HasBlackKingMoved v] to (letter (7) of [Local_CloudState])
set [HasBlackRookQSMoved v] to (letter (8) of [Local_CloudState])
set [HasBlackRookKSMoved v] to (letter (9) of [Local_CloudState])
 else 
set [HasBlackCastled v] to (letter (2) of [Local_CloudState])
set [HasBlackKingMoved v] to (letter (3) of [Local_CloudState])
set [HasBlackRookQSMoved v] to (letter (4) of [Local_CloudState])
set [HasBlackRookKSMoved v] to (letter (5) of [Local_CloudState])
end
InitVirtualBoard
InitOpeningBook
ImportBoardInt %n
GetCloudState
if <<<(IsPlayerBlack) = (0)> and <(IsWhitesTurnPrev) = (0)>> or <<(IsPlayerBlack) = (1)> and <(IsWhitesTurnPrev) = (1)>>> then 
ShowMove %n %n
 else 
ShowMove %n %n
end
ImportBoardInt %n
set [GameMoves v] to (join [GameMoves] [Local_LastMove])
AddBoardToHistory
HandlePostOnlineMove
DrawBoardAndWait
ExitExecution
change [ReceiveCounter v] by (1)
if <(ReceiveCounter) > (1)> then 
set [IsJoinBlocked v] to [0]
end
UpdateButtonStates
end
end
end
end
end

define JoinOnline
if <(IsJoinBlocked) = (1)> then 
stop [this script v]
end
GetPlayerState
Encode %s
if <<<(IsPlayer1GoK) = (1)> and <not <( Cloud_Player2Name) = (EncodedText)>>> or <<<(IsPlayer1) = (0)> or <(1) = (1)>> and <( Cloud_Player1Name) = (EncodedText)>>> then 
Encode %s
set [ Cloud_Player1Name v] to [EncodedText]
if <(1) = (0)> then 
wait (CloudUpdateDelay) seconds
set [ Cloud_Player1Token v] to [SessionToken]
end
wait (CloudUpdateDelay) seconds
set [ Cloud_Player1Heartbeat v] to [ Cloud_HeartbeatValue]
set [IsPlayerBlack v] to [0]
InitVirtualBoard
GetCloudState
ImportBoardInt %n
switch backdrop to (1 v) ::looks
DrawBoardAndWait
UpdateButtonStates
 else 
if <<<(IsPlayer2GoK) = (1)> and <not <( Cloud_Player1Name) = (EncodedText)>>> or <<<(IsPlayer2) = (0)> or <(1) = (1)>> and <( Cloud_Player2Name) = (EncodedText)>>> then 
Encode %s
set [ Cloud_Player2Name v] to [EncodedText]
if <(1) = (0)> then 
wait (CloudUpdateDelay) seconds
set [ Cloud_Player2Token v] to [SessionToken]
end
wait (CloudUpdateDelay) seconds
set [ Cloud_Player2Heartbeat v] to [ Cloud_HeartbeatValue]
set [IsPlayerBlack v] to [1]
InitVirtualBoard
GetCloudState
ImportBoardInt %n
switch backdrop to (1 v) ::looks
DrawBoardAndWait
UpdateButtonStates
end
end

define RunHeartbeatLoop
set [IsHeartbeat v] to [0]
set [IsGoK v] to [0]
forever 
set [Local_HeartbeatValue v] to [ Cloud_HeartbeatValue]
set [Local_Heartbeatname v] to [ Cloud_HeartbeatName]
GetPlayerState
if <(IsHeartbeatPlayer) = (1)> then 
set [IsHeartbeat v] to [1]
if <<(IsPlayer1GoK) = (1)> or <(IsPlayer2GoK) = (1)>> then 
set [IsGoK v] to [1]
 else 
set [IsGoK v] to [0]
end
wait (10) seconds
GetPlayerState
if <(IsHeartbeatPlayer) = (1)> then 
if <( Cloud_Player1Heartbeat) < (( Cloud_HeartbeatValue) - (3))> then 
wait (CloudUpdateDelay) seconds
Encode %s
set [ Cloud_Player1Name v] to [EncodedText]
if <(1) = (0)> then 
wait (CloudUpdateDelay) seconds
set [ Cloud_Player1Token v] to [0]
end
end
if <( Cloud_Player2Heartbeat) < (( Cloud_HeartbeatValue) - (3))> then 
wait (CloudUpdateDelay) seconds
Encode %s
set [ Cloud_Player2Name v] to [EncodedText]
if <(1) = (0)> then 
wait (CloudUpdateDelay) seconds
set [ Cloud_Player2Token v] to [0]
end
end
wait (CloudUpdateDelay) seconds
Encode %s
set [ Cloud_HeartbeatName v] to [EncodedText]
wait (CloudUpdateDelay) seconds
set [ Cloud_HeartbeatToken v] to [SessionToken]
wait (CloudUpdateDelay) seconds
set [ Cloud_HeartbeatValue v] to (( Cloud_HeartbeatValue) + (1))
GetCloudState
if <(Local_IsWhitesTurn) = (0)> then 
wait (CloudUpdateDelay) seconds
set [ Cloud_Player1Heartbeat v] to [ Cloud_HeartbeatValue]
 else 
wait (CloudUpdateDelay) seconds
set [ Cloud_Player2Heartbeat v] to [ Cloud_HeartbeatValue]
end
end
 else 
set [IsHeartbeat v] to [0]
set [IsGoK v] to [0]
wait (20) seconds
if <not <( Cloud_HeartbeatValue) > (Local_HeartbeatValue)>> then 
wait (CloudUpdateDelay) seconds
Encode %s
set [ Cloud_HeartbeatName v] to [EncodedText]
wait (CloudUpdateDelay) seconds
set [ Cloud_HeartbeatToken v] to [SessionToken]
wait (CloudUpdateDelay) seconds
set [ Cloud_HeartbeatValue v] to (( Cloud_HeartbeatValue) + (2))
if <(IsGameSuspended) = (1)> then 
if <(HasPendingReset) = (0)> then 
broadcast (1 v)
end
end
end
end
end

when i receive [usermove v]
if <(1) = (0)> then 
ExecuteUserMove
end
ExecuteUserMoveOnline

define GetPlayerState
set [IsPlayer1 v] to [0]
set [IsPlayer2 v] to [0]
set [IsHeartbeatPlayer v] to [0]
set [IsPlayer1GoK v] to [0]
set [IsPlayer2GoK v] to [0]
Encode %s
if <<( Cloud_Player1Name) = (EncodedText)> and <<( Cloud_Player1Token) = (SessionToken)> or <(1) = (1)>>> then 
set [IsPlayer1 v] to [1]
end
if <<( Cloud_Player2Name) = (EncodedText)> and <<( Cloud_Player2Token) = (SessionToken)> or <(1) = (1)>>> then 
set [IsPlayer2 v] to [1]
end
if <<( Cloud_HeartbeatName) = (EncodedText)> and <( Cloud_HeartbeatToken) = (SessionToken)>> then 
set [IsHeartbeatPlayer v] to [1]
end
Encode %s
if <<( Cloud_Player1Name) = (EncodedText)> and <<( Cloud_Player1Token) = (0)> or <(1) = (1)>>> then 
set [IsPlayer1GoK v] to [1]
end
if <<( Cloud_Player2Name) = (EncodedText)> and <<( Cloud_Player2Token) = (0)> or <(1) = (1)>>> then 
set [IsPlayer2GoK v] to [1]
end

when i receive [schedulereset v]
set [HasPendingReset v] to [1]
wait (5) seconds
ResetOnline
set [HasPendingReset v] to [0]

define UpdateStatePanelData
GetCloudState
set [SP_IsWhitesTurn v] to [Local_IsWhitesTurn]
Decode %s
set [SP_Player1 v] to [DecodedText]
Decode %s
set [SP_Player2 v] to [DecodedText]
if <(length of (username)) = (0)> then 
set [SP_Status v] to [No Scratcher Login]
end

define GetCloudState
set [Local_CloudState v] to [ Cloud_State]
set [Local_IsWhitesTurn v] to (letter (1) of [Local_CloudState])
if <(IsPlayerBlack) = (0)> then 
set [HasWhiteCastled v] to (letter (2) of [Local_CloudState])
set [HasWhiteKingMoved v] to (letter (3) of [Local_CloudState])
set [HasWhiteRookQSMoved v] to (letter (4) of [Local_CloudState])
set [HasWhiteRookKSMoved v] to (letter (5) of [Local_CloudState])
set [HasBlackCastled v] to (letter (6) of [Local_CloudState])
set [HasBlackKingMoved v] to (letter (7) of [Local_CloudState])
set [HasBlackRookQSMoved v] to (letter (8) of [Local_CloudState])
set [HasBlackRookKSMoved v] to (letter (9) of [Local_CloudState])
set [Local_LastMove v] to (join (join (letter (10) of [Local_CloudState]) (letter (11) of [Local_CloudState])) (join (letter (12) of [Local_CloudState]) (letter (13) of [Local_CloudState])))
 else 
set [HasWhiteCastled v] to (letter (6) of [Local_CloudState])
set [HasWhiteKingMoved v] to (letter (7) of [Local_CloudState])
set [HasWhiteRookQSMoved v] to (letter (8) of [Local_CloudState])
set [HasWhiteRookKSMoved v] to (letter (9) of [Local_CloudState])
set [HasBlackCastled v] to (letter (2) of [Local_CloudState])
set [HasBlackKingMoved v] to (letter (3) of [Local_CloudState])
set [HasBlackRookQSMoved v] to (letter (4) of [Local_CloudState])
set [HasBlackRookKSMoved v] to (letter (5) of [Local_CloudState])
set [Local_LastMove v] to (join (join (letter (10) of [Local_CloudState]) (letter (11) of [Local_CloudState])) (join (letter (12) of [Local_CloudState]) (letter (13) of [Local_CloudState])))
if <not <(Local_LastMove) = (0000)>> then 
if <(Local_LastMove) = (WhiteKingsideCastling)> then 
set [Local_LastMove v] to [BlackKingsideCastling]
 else 
if <(Local_LastMove) = (WhiteQueensideCastling)> then 
set [Local_LastMove v] to [BlackQueensideCastling]
 else 
if <(Local_LastMove) = (BlackKingsideCastling)> then 
set [Local_LastMove v] to [WhiteKingsideCastling]
 else 
if <(Local_LastMove) = (BlackQueensideCastling)> then 
set [Local_LastMove v] to [WhiteQueensideCastling]
 else 
set [Local_LastMove v] to ((((65) - ([floor v] of ((Local_LastMove) / (100)) ::operators)) * (100)) + ((65) - ([floor v] of ((Local_LastMove) mod (100)) ::operators)))
set [Local_LastMove v] to ([floor v] of (Local_LastMove) ::operators)
if <(length of [Local_LastMove]) = (3)> then 
set [Local_LastMove v] to (join [0] [Local_LastMove])
end
end
end
end
end
end
end
GetSubstring %s %n %n
set [Local_Board v] to [SubstringRes]

define ExecuteUserMove

define ExecuteEngineMove

define EnterExecution %n
set [IsExecutionRunning v] to [1]

define HandleSquareClicked
if <(MoveFromIdx) = (-1)> then 
if <(item (SquareClickedIdx) of [Board v]) < (0)> then 
if <<(IsExecutionRunning) = (0)> and <(IsGameSuspended) = (0)>> then 
if <(1) = (0)> then 
GetCloudState
end
GetPlayerState
if <<<(IsPlayer1) = (1)> and <(Local_IsWhitesTurn) = (1)>> or <<(IsPlayer2) = (1)> and <(Local_IsWhitesTurn) = (0)>>> then 
set [MoveFromIdx v] to [SquareClickedIdx]
set [FromSquareIdx v] to [SquareClickedIdx]
broadcast (1 v) and wait
end
end
end
 else 
if <(MoveToIdx) = (-1)> then 
if <<(IsExecutionRunning) = (0)> and <(IsGameSuspended) = (0)>> then 
if <(1) = (0)> then 
GetCloudState
end
GetPlayerState
if <<<(IsPlayer1) = (1)> and <(Local_IsWhitesTurn) = (1)>> or <<(IsPlayer2) = (1)> and <(Local_IsWhitesTurn) = (0)>>> then 
set [MoveToIdx v] to [SquareClickedIdx]
set [ToSquareIdx v] to [SquareClickedIdx]
broadcast (1 v) and wait
broadcast (1 v)
end
end
 else 
set [MoveFromIdx v] to [-1]
set [MoveToIdx v] to [-1]
end
end

define ImportBoardInt %n
set [Idx v] to [1]
set [IdxSub v] to [1]
repeat (64) 
if <(letter (IdxSub) of (argument_reporter_string_number)) = (9)> then 
if <(IsPlayerBlack) = (0)> then 
replace item (Idx) of [Board v] with [Empty]
 else 
replace item ((65) - (Idx)) of [Board v] with [Empty]
end
change [Idx v] by (1)
change [IdxSub v] by (1)
 else 
if <(IsPlayerBlack) = (0)> then 
replace item (Idx) of [Board v] with (item (join (letter (IdxSub) of (argument_reporter_string_number)) (letter ((IdxSub) + (1)) of (argument_reporter_string_number))) of [OnlineBoardPieceMap v])
 else 
replace item ((65) - (Idx)) of [Board v] with ((0) - (item (join (letter (IdxSub) of (argument_reporter_string_number)) (letter ((IdxSub) + (1)) of (argument_reporter_string_number))) of [OnlineBoardPieceMap v]))
end
change [Idx v] by (1)
change [IdxSub v] by (2)
end
end

define DrawBoardForcedAndWait
UpdateStatePanelData
set [ProgressValue v] to [0]
broadcast (1 v) and wait
broadcast (1 v) and wait

when i receive [initremix v]
InitBoard
FillBoard
ExportBoardInternal
UpdateCloudState %s %s %s %s %s %s %s %s %s %s %s
Encode %s
set [ Cloud_Player1Name v] to [EncodedText]
set [ Cloud_Player1Token v] to [0]
set [ Cloud_Player1Heartbeat v] to [0]
set [ Cloud_Player2Name v] to [EncodedText]
set [ Cloud_Player2Token v] to [0]
set [ Cloud_Player2Heartbeat v] to [0]
set [ Cloud_HeartbeatName v] to [EncodedText]
set [ Cloud_HeartbeatValue v] to [0]
set [ Cloud_HeartbeatToken v] to [0]

when i receive [runheartbeatloopmsg v]
RunHeartbeatLoop

define InitHashLookup
set [HashMoveAge v] to [0]
delete (all) of [PosPieceHashLookup v]
repeat (1024) 
add (pick random (-1073741823) to (1073741824)) to [PosPieceHashLookup v]
end
ClearHashCache

define ExecuteEngineMoveOnline
if <<(IsGameSuspended) = (1)> or <(IsExecutionRunning) = (1)>> then 
stop [this script v]
end
EnterExecution %n
CalculateMoves %n
delete (all) of [BestMoves v]
if <(1) = (1)> then 
CalculateOpeningMoves
end
if <<(length of [BestMoves v]) = (0)> or <not <[Moves1 v] contains (item (1) of [BestMoves v]) ? ::lists>>> then 
AlphaBetaMinMax %n %n %n %n %b %b %n %b
end
set [BestMove v] to (item (pick random (1) to (length of [BestMoves v])) of [BestMoves v])
if <(1) = (0)> then 
set [MovePieceFromIdx v] to ([floor v] of ((BestMove) / (100)) ::operators)
set [MovePieceToIdx v] to ([floor v] of ((BestMove) mod (100)) ::operators)
if <<<(BestMove) = (BlackQueensideCastling)> or <(BestMove) = (BlackKingsideCastling)>> or <<(BestMove) = (WhiteQueensideCastling)> or <(BestMove) = (WhiteKingsideCastling)>>> then 
set [MovePieceSpecial v] to [BestMove]
 else 
set [MovePieceSpecial v] to []
end
broadcast (1 v) and wait
end
delete (all) of [Moves1 v]
add [BestMove] to [Moves1 v]
replace item (1) of [MovesIdx v] with [1]
replace item (1) of [MovesCount v] with [1]
if <not <(item ([floor v] of ((BestMove) mod (100)) ::operators) of [Board v]) = (WhiteKing)>> then 
ApplyMove %n
end
if <(item ((BestMove) mod (100)) of [Board v]) = (BlackKing)> then 
set [HasBlackKingMoved v] to [1]
end
if <(item ((BestMove) mod (100)) of [Board v]) = (BlackRook)> then 
if <([floor v] of ((BestMove) / (100)) ::operators) = (item (1) of [VirtualBoard v])> then 
set [HasBlackRookQSMoved v] to [1]
end
if <([floor v] of ((BestMove) / (100)) ::operators) = (item (8) of [VirtualBoard v])> then 
set [HasBlackRookKSMoved v] to [1]
end
end
if <<(BestMove) = (BlackQueensideCastling)> or <(BestMove) = (BlackKingsideCastling)>> then 
set [HasBlackKingMoved v] to [1]
set [HasBlackCastled v] to [1]
end
GetPlayerState
if <(IsHeartbeatPlayer) = (1)> then 
wait (CloudUpdateDelay) seconds
set [ Cloud_Player1Heartbeat v] to [ Cloud_HeartbeatValue]
wait (CloudUpdateDelay) seconds
set [ Cloud_Player2Heartbeat v] to [ Cloud_HeartbeatValue]
ExportBoardInternal
if <(IsPlayerBlack) = (0)> then 
wait (CloudUpdateDelay) seconds
set [Local_IsWhitesTurn v] to [1]
set [Local_LastMove v] to ([floor v] of (BestMove) ::operators)
UpdateCloudState %s %s %s %s %s %s %s %s %s %s %s
 else 
wait (CloudUpdateDelay) seconds
set [Local_IsWhitesTurn v] to [0]
if <(BestMove) = (BlackKingsideCastling)> then 
set [Local_LastMove v] to [WhiteKingsideCastling]
 else 
if <(BestMove) = (BlackQueensideCastling)> then 
set [Local_LastMove v] to [WhiteQueensideCastling]
 else 
set [Local_LastMove v] to ([floor v] of ((((65) - (join (letter (1) of [BestMove]) (letter (2) of [BestMove]))) * (100)) + ((65) - (join (letter (3) of [BestMove]) (letter (4) of [BestMove])))) ::operators)
if <(length of [Local_LastMove]) = (3)> then 
set [Local_LastMove v] to (join [0] [Local_LastMove])
end
end
end
UpdateCloudState %s %s %s %s %s %s %s %s %s %s %s
end
end
ExecuteMovePostProcess
ExitExecution

define InitKingSquareEndgame
delete (all) of [KingPieceSquareEndgame v]
set [KingSquareDefEndgame v] to [-10, 10, 15, 20, 20, 15, 10, -10,0, 20, 35, 45, 45, 35, 20, 0, 10, 25, 40, 50, 50, 40, 25, 10, 10, 25, 40, 50, 50, 40, 25, 10, 10, 25, 40, 50, 50, 40, 25, 10, 0, 15, 30, 40, 40, 30, 15, 0, -15, -10, 0, 10, 10, 0, -10, -15, -30, -25, -15, -10, -10, -15, -25, -30]
LoadList %s %s

define ResetOnline
GetPlayerState
if <<<(IsHeartbeatPlayer) = (1)> or <<(username) = (ArnoHu)> or <(username) = (FunnyAnimatorJimTV)>>> or <<(IsPlayer1) = (1)> or <(IsPlayer2) = (1)>>> then 
FillBoard
ExportBoardInternal
UpdateCloudState %s %s %s %s %s %s %s %s %s %s %s
wait (CloudUpdateDelay) seconds
Encode %s
set [ Cloud_Player1Name v] to [EncodedText]
if <(1) = (0)> then 
wait (CloudUpdateDelay) seconds
set [ Cloud_Player1Token v] to [0]
end
wait (CloudUpdateDelay) seconds
set [ Cloud_Player1Heartbeat v] to (( Cloud_HeartbeatValue) + (1))
wait (CloudUpdateDelay) seconds
Encode %s
set [ Cloud_Player2Name v] to [EncodedText]
if <(1) = (0)> then 
wait (CloudUpdateDelay) seconds
set [ Cloud_Player2Token v] to [0]
end
wait (CloudUpdateDelay) seconds
set [ Cloud_Player2Heartbeat v] to (( Cloud_HeartbeatValue) + (1))
wait (CloudUpdateDelay) seconds
Encode %s
set [ Cloud_HeartbeatName v] to [EncodedText]
wait (CloudUpdateDelay) seconds
set [ Cloud_HeartbeatToken v] to [SessionToken]
wait (CloudUpdateDelay) seconds
set [ Cloud_HeartbeatValue v] to (( Cloud_HeartbeatValue) + (1))
set [GameMoves v] to []
delete (all) of [BoardHistory v]
HandlePostOnlineMove
DrawBoardAndWait
UpdateButtonStates
end

define IsDraw %n
CalcBoardAttackedByMove %n
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (1)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (1)>>> then 
set [IsDrawRes v] to [0]
stop [this script v]
end
set [IsDrawRes v] to [1]
CalculateMoves %n
replace item (argument_reporter_string_number) of [MovesIdx v] with [1]
repeat (item (argument_reporter_string_number) of [MovesCount v]) 
if <(IsDrawRes) = (1)> then 
ApplyMove %n
CalcBoardAttackedByMove %n
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (0)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (0)>>> then 
set [IsDrawRes v] to [0]
end
RevertMove %n
end
replace item (argument_reporter_string_number) of [MovesIdx v] with ((item (argument_reporter_string_number) of [MovesIdx v]) + (1))
end

define LeaveOnline
GetPlayerState
Encode %s
if <(IsPlayer1) = (1)> then 
Encode %s
set [ Cloud_Player1Name v] to [EncodedText]
if <(1) = (0)> then 
wait (0.2) seconds
set [ Cloud_Player1Token v] to [0]
end
DrawBoardAndWait
UpdateButtonStates
 else 
if <(IsPlayer2) = (1)> then 
Encode %s
set [ Cloud_Player2Name v] to [EncodedText]
if <(1) = (0)> then 
wait (CloudUpdateDelay) seconds
set [ Cloud_Player2Token v] to [0]
end
DrawBoardAndWait
UpdateButtonStates
end
end
