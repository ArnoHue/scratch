define HashOnBoardScore %s %s
set [HashBucket v] to (((argument_reporter_string_number) mod (length of [HashMoves2Hash v])) + (1))
set [CurrentIdx v] to [1]
repeat until <<<(length of (item (HashBucket) of [HashMoves2Hash v])) = (0)> or <(item (HashBucket) of [HashMoves2Hash v]) = (argument_reporter_string_number)>> or <(item (CurrentIdx) of [HashMoves2Age v]) < ((HashMoveAge) - (5))>> 
change [HashBucket v] by (1)
if <(HashBucket) > (length of [HashMoves2Hash v])> then 
set [HashBucket v] to [1]
end
change [CurrentIdx v] by (1)
if <(CurrentIdx) > (10)> then 
stop [this script v]
end
end
replace item (HashBucket) of [HashMoves2Hash v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMoves2Age v] with [HashMoveAge]
replace item (HashBucket) of [HashMoves2BoardScore v] with (argument_reporter_string_number)

define GetBestHashMoveBoardScore %s
set [BestHashMoveResult v] to [0]
set [BestHashMoveBoardScoreResult v] to []
set [CurrentIdx v] to [1]
set [HashBucket v] to (((argument_reporter_string_number) mod (length of [HashMoves2Hash v])) + (1))
repeat until <(item (HashBucket) of [HashMoves2Hash v]) = (argument_reporter_string_number)> 
change [HashBucket v] by (1)
if <(HashBucket) > (length of [HashMoves2Hash v])> then 
set [HashBucket v] to [1]
end
change [CurrentIdx v] by (1)
if <(CurrentIdx) > (10)> then 
stop [this script v]
end
end
set [BestHashMoveResult v] to [1]
set [BestHashMoveBoardScoreResult v] to (item (HashBucket) of [HashMoves2BoardScore v])
replace item (HashBucket) of [HashMoves2Age v] with [HashMoveAge]

define InitBoard
DetectFlash30Bug
InitKingSafety
InitMobilityBonusLookup
InitCoordLookup
InitHashLookup
InitMoveLookup
FillBoard
hide list [BoardHistory v]
hide list [GameMovesAN v]
hide list [ExportData v]
hide list [ExportMoves v]
set [CharsUpperCase v] to [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
delete (all) of [CharsUpperCaseList v]
set [Idx v] to [1]
repeat (length of [CharsUpperCaseList v]) 
add (letter (Idx) of [CharsUpperCase]) to [CharsUpperCaseList v]
change [Idx v] by (1)
end
set [ExecutionDepth v] to [0]
set [IsExecutionRunning v] to [0]
set [IsProfilerEnabled v] to [0]
set [Level3Depth v] to [2]
set [Moves1CaptureCount v] to [0]
set [Moves2CaptureCount v] to [0]
set [MonTimer1 v] to [0]
set [MonTimer2 v] to [0]
set [MonTimer3 v] to [0]
set [IsDebugMode v] to [0]
set [IsEndgame v] to [0]
set [IsEndgame2 v] to [0]
set [IsImportedBoard v] to [0]
set [Empty v] to [0]
set [WhiteKing v] to [-20000]
set [WhiteQueen v] to [-900]
set [WhiteRook v] to [-500]
set [WhiteBishop v] to [-330]
set [WhiteKnight v] to [-310]
set [WhitePawn v] to [-100]
set [BlackKing v] to [20000]
set [BlackQueen v] to [900]
set [BlackRook v] to [500]
set [BlackBishop v] to [330]
set [BlackKnight v] to [310]
set [BlackPawn v] to [100]
set [BlackKingsideCastling v] to [0090]
set [WhiteKingsideCastling v] to [0092]
set [BlackQueensideCastling v] to [0091]
set [WhiteQueensideCastling v] to [0093]
set [HasBlackCastled v] to [0]
set [HasWhiteKingMoved v] to [0]
set [HasWhiteCastled v] to [0]
set [HasBlackKingMoved v] to [0]
set [HasWhiteRookKSMoved v] to [0]
set [HasWhiteRookQSMoved v] to [0]
set [HasBlackRookKSMoved v] to [0]
set [HasBlackRookQSMoved v] to [0]
set [GameMoves v] to []
set [AddMoveModeDefault v] to [1]
set [AddMoveModeAttackRevert v] to [2]
set [LineMoveTypeStraight v] to [1]
set [LineMoveTypeCross v] to [2]
set [LookupMoveTypeKnight v] to [1]
set [LookupMoveTypeKing v] to [2]
set [IsGameSuspended v] to [0]
delete (all) of [BoardAttackedByWhite v]
delete (all) of [BoardAttackedByBlack v]
delete (all) of [KnightMoveOffsets v]
delete (all) of [KingMoveOffsets v]
delete (all) of [OpeningMoves v]
delete (all) of [BoardHistory v]
delete (all) of [BoardHistoryHash v]
delete (all) of [GameMovesAN v]
delete (all) of [PieceMobility v]
delete (all) of [BoardAttackedByWhitePiece v]
delete (all) of [BoardAttackedByBlackPiece v]
repeat (64) 
add [0] to [BoardAttackedByWhite v]
add [0] to [BoardAttackedByBlack v]
add [0] to [PieceMobility v]
add [0] to [BoardAttackedByWhitePiece v]
add [0] to [BoardAttackedByBlackPiece v]
end
add [-2] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [-2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [-2] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [-2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
InitOpeningBook
InitKnightSquare
InitPawnSquare
InitPawnSquareEndgame
InitBishopSquare
InitRookSquare
InitQueenSquare
InitKingSquare
InitKingSquareEndgame
InitPawnSquarePreCastling
delete (all) of [Alphas v]
delete (all) of [Betas v]
delete (all) of [MinMaxResults v]
delete (all) of [MovesCount v]
delete (all) of [MovesIdx v]
delete (all) of [TargetPieces v]
delete (all) of [PreviousMoveHash v]
delete (all) of [BestHashMoveMaxDepth v]
delete (all) of [BaseHashMove v]
delete (all) of [BestHashMoveType v]
delete (all) of [PickMoveRes v]
delete (all) of [PickPhase v]
delete (all) of [PickHash v]
delete (all) of [PrevBestHashMove v]
delete (all) of [CheckedState v]
delete (all) of [PromotionPieces v]
delete (all) of [TargetPiecesIdx v]
delete (all) of [PosScoreDelta v]
delete (all) of [BoardAttackedCalculated v]
delete (all) of [ScoreCalc v]
delete (all) of [PlyExtension v]
delete (all) of [PawnPromotionCol v]
repeat (25) 
add [] to [Alphas v]
add [] to [Betas v]
add [] to [MinMaxResults v]
add [] to [MovesCount v]
add [] to [MovesIdx v]
add [] to [TargetPieces v]
add [] to [PreviousMoveHash v]
add [] to [BaseHashMove v]
add [] to [BestHashMoveType v]
add [] to [PickMoveRes v]
add [] to [PickPhase v]
add [] to [PickHash v]
add [] to [PrevBestHashMove v]
add [] to [BestHashMoveMaxDepth v]
add [] to [CheckedState v]
add [] to [PromotionPieces v]
add [] to [TargetPiecesIdx v]
add [] to [PosScoreDelta v]
add [] to [BoardAttackedCalculated v]
add [] to [CaptureFollowup v]
add [] to [ScoreCalc v]
add [] to [PlyExtension v]
add [] to [PawnPromotionCol v]
end
delete (all) of [BlackPawnCount v]
delete (all) of [WhitePawnCount v]
repeat (8) 
add [0] to [BlackPawnCount v]
add [0] to [WhitePawnCount v]
end
delete (all) of [BoardHistory v]
AddBoardToHistory

define InitBishopSquare
delete (all) of [BishopPieceSquare v]
set [BishopSquareDef v] to [-20, -18, -16, -14, -14, -16, -18, -20,-10, 11, 1, 1, 1, 1, 11, -10, 1, 11, 21, 26, 26, 21, 11, 1, 1, 21, 21, 26, 26, 21, 21, 1, 1, 1, 16, 21, 21, 16, 1, 1, -25, 6, 16, 11, 11, 16, 6, -25, -28, 11, 6, 1, 1, 6, 11, -28, -30, -25, -20, -20, -20, -20, -25, -30]
LoadList %s %s

define InitKingSquare
delete (all) of [KingPieceSquare v]
set [KingSquareDef v] to [-55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55,-50, -50, -55, -60, -60, -55, -50, -50, -40, -40, -45, -50, -50, -45, -40, -40, -30, -30, -30, -35, -35, -30, -30, -30, -20, 0, 0, -10, -10, 0, 0, -20]
LoadList %s %s

define InitRookSquare
delete (all) of [RookPieceSquare v]
set [RookSquareDef v] to [-8, -6, 2, 7, 7, 2, -6, -8,2, 2, 7, 12, 12, 7, 2, 2, -8, -6, 6, 10, 10, 6, -6, -8, -8, -6, 6, 8, 8, 6, -6, -8, -8, -6, 6, 7, 7, 6, -6, -8, -8, -6, 6, 7, 7, 6, -6, -8, -8, -6, 2, 7, 7, 2, -6, -8, -8, -6, 2, 7, 7, 2, -6, -8]
LoadList %s %s

when i receive [squareclicked v]
if <<(IsExecutionRunning) = (0)> and <(IsGameSuspended) = (0)>> then 
if <(MoveFromIdx) = (-1)> then 
if <(item (SquareClickedIdx) of [Board v]) < (0)> then 
set [MoveFromIdx v] to [SquareClickedIdx]
set [FromSquareIdx v] to [SquareClickedIdx]
broadcast (1 v) and wait
end
 else 
if <(MoveToIdx) = (-1)> then 
set [MoveToIdx v] to [SquareClickedIdx]
set [ToSquareIdx v] to [SquareClickedIdx]
broadcast (1 v) and wait
broadcast (1 v)
 else 
set [MoveFromIdx v] to [-1]
set [MoveToIdx v] to [-1]
end
end
end

define InitPawnSquare
delete (all) of [PawnPieceSquare v]
set [PawnSquareDef v] to [0, 0, 0, 0, 0, 0, 0, 0, 7, 11, 23, 39, 39, 23, 11, 7,  -5, 1, 14, 29, 29, 14, 1, -5,  -14, -8, 6, 22, 22, 6, -8, -14,  -21, -16, -1, 14, 14, -1, -16, -21,  -26, -21, -6, 4, 4, -6, -21, -26,  -31, -26, -11, -1, -1, -11, -26, -31,  0, 0, 0, 0, 0, 0, 0, 0]
LoadList %s %s

define AddBoardToHistory
GetBoardString
add [GetBoardStringRes] to [BoardHistory v]
GetCurrentMoveHash
add [CurrentMoveHash] to [BoardHistoryHash v]

define RevertMove %n
GetCurrentMove %n
set [SourceIdx v] to ([floor v] of ((CurrentMove) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((CurrentMove) mod (100)) ::operators)
if <<(SourceIdx) > (0)> and <(TargetIdx) > (0)>> then 
replace item (SourceIdx) of [Board v] with (item (TargetIdx) of [Board v])
replace item (TargetIdx) of [Board v] with [Empty]
replace item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [Board v] with (item (argument_reporter_string_number) of [TargetPieces v])
if <(item (argument_reporter_string_number) of [PromotionPieces v]) > (0)> then 
replace item (SourceIdx) of [Board v] with [BlackPawn]
end
if <(item (argument_reporter_string_number) of [PromotionPieces v]) < (0)> then 
replace item (SourceIdx) of [Board v] with [WhitePawn]
end
 else 
if <(CurrentMove) = (WhiteKingsideCastling)> then 
replace item (item (61) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (62) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (63) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (64) of [VirtualBoard v]) of [Board v] with [WhiteRook]
 else 
if <(CurrentMove) = (WhiteQueensideCastling)> then 
replace item (item (57) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (59) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (60) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (61) of [VirtualBoard v]) of [Board v] with [WhiteKing]
 else 
if <(CurrentMove) = (BlackKingsideCastling)> then 
replace item (item (5) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (6) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (7) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (8) of [VirtualBoard v]) of [Board v] with [BlackRook]
 else 
if <(CurrentMove) = (BlackQueensideCastling)> then 
replace item (item (1) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (4) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (3) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (5) of [VirtualBoard v]) of [Board v] with [BlackKing]
end
end
end
end
end
replace item (argument_reporter_string_number) of [PosScoreDelta v] with [0]
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with []
replace item (argument_reporter_string_number) of [TargetPieces v] with [Empty]
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
set [CurrentMoveHash v] to (item (argument_reporter_string_number) of [PreviousMoveHash v])

define GetSubstringRight %s %n
GetSubstring %s %n %n

define InitQueenSquare
delete (all) of [QueenPieceSquare v]
set [QueenSquareDef v] to [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,-6, -6, -1, 4, 4, -1, -6, -6, -16, -11, -1, 4, 4, -1, -11, -16, -26, -16, -6, 4, 4, -6, -16, -26]
LoadList %s %s

define InitOpeningBook
delete (all) of [OpeningMoves v]
add [533711276346122052362736463607225843021962531321] to [OpeningMoves v]
add [533711276346122062260312] to [OpeningMoves v]
add [5337112763460219523627364636072258431220] to [OpeningMoves v]
add [5337112751430722372922285236273643361220] to [OpeningMoves v]
add [5337112758430219554715236255061552441220] to [OpeningMoves v]
add [5337112758430219634612206226031200920722] to [OpeningMoves v]
add [533711276235132163460917] to [OpeningMoves v]
add [533711276235132158430917] to [OpeningMoves v]
add [533711275236273660360219] to [OpeningMoves v]
add [533711195236122837290330] to [OpeningMoves v]
add [53371119523612285843283743370330] to [OpeningMoves v]
add [533713296032021962351523] to [OpeningMoves v]
add [5337132960460722] to [OpeningMoves v]
add [5337132962350722] to [OpeningMoves v]
add [533713296346021962260917263307220092061362610090] to [OpeningMoves v]
add [533713296346021962260917263307226053102633420613] to [OpeningMoves v]
add [533713296346021962260917263307225236293600920613] to [OpeningMoves v]
add [533713296346021962260917263307225843061300921026] to [OpeningMoves v]
add [5337132963460219622609172619121946290436] to [OpeningMoves v]
add [533713296346021962260917261912190092033956481632] to [OpeningMoves v]
add [533713296346021962260917261912195843142252362936] to [OpeningMoves v]
add [533713296346021962260917261912195236293660360436] to [OpeningMoves v]
add [5337132963460219523629364636062759450422] to [OpeningMoves v]
add [533713296346021962350722] to [OpeningMoves v]
add [5337132963460219584307226226063400920090] to [OpeningMoves v]
add [5337132954382938634615316235313946290440] to [OpeningMoves v]
add [533713295438293863461531564031394629072252361220] to [OpeningMoves v]
add [5337132954382938623504406162062752362718] to [OpeningMoves v]
add [53371329543829386346061362350722] to [OpeningMoves v]
add [53371329543829386235072258431119] to [OpeningMoves v]
add [53371329543829385236044061531220634603395648394653464032] to [OpeningMoves v]
add [53371329543806276346122062350722] to [OpeningMoves v]
add [53371329543802196346122062350339] to [OpeningMoves v]
add [533702195236122837280428] to [OpeningMoves v]
add [533715235236061562351220] to [OpeningMoves v]
add [53371523523606156346122062350722] to [OpeningMoves v]
add [53371523523606155843072263460090] to [OpeningMoves v]
add [533713215236122837291127514302195438273643360418] to [OpeningMoves v]
add [5337132152361228372911275143021963460418] to [OpeningMoves v]
add [53371321523612285843063460442837] to [OpeningMoves v]
add [53371321523612285843063437291127] to [OpeningMoves v]
add [5337132152361228584306343728212859520722] to [OpeningMoves v]
add [5337132163461228372821285236072258431119] to [OpeningMoves v]
add [533712205236072258430212634613296253061300921119] to [OpeningMoves v]
add [533712205236072258430212634613296235162400921119] to [OpeningMoves v]
add [533712205236072258430212634613296235061300920090] to [OpeningMoves v]
add [5337122052360722584315235945061554460090] to [OpeningMoves v]
add [5337122052360722584315236235061563460219] to [OpeningMoves v]
add [523612286346072259312237] to [OpeningMoves v]
add [523612286346072253451127] to [OpeningMoves v]
add [523612286346021958431321533707223729221259310613] to [OpeningMoves v]
add [523612286346021959380339] to [OpeningMoves v]
add [523612286346072251351119] to [OpeningMoves v]
add [52361228634613215843072253450219] to [OpeningMoves v]
add [52361228634613215843072253372837] to [OpeningMoves v]
add [523612285135132158430722534509176244283544350634] to [OpeningMoves v]
add [5236122851351321584307225931021253450634] to [OpeningMoves v]
add [523612285345072262441321] to [OpeningMoves v]
add [523612285135111958430722] to [OpeningMoves v]
add [5236122851351119634607225843132159312835] to [OpeningMoves v]
add [523612285938072253451321] to [OpeningMoves v]
add [52360722513515235843061563460090] to [OpeningMoves v]
add [52360722513515236346061555470090] to [OpeningMoves v]
add [52360722513515236346061558430090] to [OpeningMoves v]
add [52360722513513215843063453450090] to [OpeningMoves v]
add [523607225135122063460339] to [OpeningMoves v]
add [523607225135152358430615533712206346009062531329] to [OpeningMoves v]
add [52360722634613215135101858430310] to [OpeningMoves v]
add [52361430513507225843132153450634] to [OpeningMoves v]
add [5236143055470722625515236346061500920090] to [OpeningMoves v]
add [523614306346072255471321] to [OpeningMoves v]
add [5236132151350722634610185547031062550613] to [OpeningMoves v]
add [52361321513507225843063460510090] to [OpeningMoves v]
add [523613215135122858430722] to [OpeningMoves v]
add [494113295345122851350722] to [OpeningMoves v]
add [4933132953370722] to [OpeningMoves v]
add [493313293325122856401127] to [OpeningMoves v]
add [504213295950021951350722] to [OpeningMoves v]
add [503413295950122051350722] to [OpeningMoves v]
add [514313295337072252440219] to [OpeningMoves v]
add [513513295843072255471228] to [OpeningMoves v]
add [513513296346021958430722] to [OpeningMoves v]
add [5446132955390440] to [OpeningMoves v]
add [5438132155390440] to [OpeningMoves v]
add [543812286346152355470615] to [OpeningMoves v]
add [5539132954380440] to [OpeningMoves v]
add [554712286255132951352836] to [OpeningMoves v]
add [5648132953370722] to [OpeningMoves v]
add [5648132949411228] to [OpeningMoves v]
add [564013295337072252440627] to [OpeningMoves v]
add [5640072251351127] to [OpeningMoves v]
add [5640072263460219] to [OpeningMoves v]
add [6346072251351523554706156255009000921220] to [OpeningMoves v]
add [634612285236072251351321] to [OpeningMoves v]
add [6346122858431321] to [OpeningMoves v]
set [Count v] to (length of [OpeningMoves v])
set [Idx v] to [1]
repeat (Count) 
add [] to [OpeningMoves v]
if <((length of (item (Idx) of [OpeningMoves v])) / (4)) > (4)> then 
set [IdxSub v] to [1]
repeat ((length of (item (Idx) of [OpeningMoves v])) / (4)) 
GetVirtualMove %n
replace item (last) of [OpeningMoves v] with (join (item (last) of [OpeningMoves v]) [VirtualMove])
change [IdxSub v] by (4)
end
end
change [Idx v] by (1)
end

define AddSimpleMove %n %n %n %n %b %b %b %b %b
set [Y v] to ((item (argument_reporter_string_number) of [IdxToRow v]) + (argument_reporter_string_number))
if <<(Y) > (0)> and <(Y) < (9)>> then 
set [X v] to ((item (argument_reporter_string_number) of [IdxToCol v]) + (argument_reporter_string_number))
if <<(X) > (0)> and <(X) < (9)>> then 
set [TargetIdx v] to ((X) + (((Y) - (1)) * (8)))
if <<not <argument_reporter_boolean>> or <<<(item (argument_reporter_string_number) of [Board v]) > (0)> and <(item (TargetIdx) of [Board v]) < (0)>> or <<(item (argument_reporter_string_number) of [Board v]) < (0)> and <(item (TargetIdx) of [Board v]) > (0)>>>> then 
AddMoveImpl %n %n %n %b %b %b %b %b
end
end
end

define InitKnightSquare
delete (all) of [KnightPieceSquare v]
set [KnightSquareDef v] to [-30, -20, -15, -15, -15, -15, -20, -30,-20, 15, 20, 20, 20, 20, 15, -20,-20, 22, 30, 35, 35, 30, 22, -20,-20, 20, 25, 25, 25, 25, 20, -20,-20,  5, 20, 18, 18, 20,  5, -20,-20,  0, 15, 10, 10, 15,  0, -20, -15, -15, -5, 5,  5, -5, -15, -15, -35, -10,-12,-7, -7,-12, -10, -35]
LoadList %s %s

define EvaluateBoardExtended %n
GetBestHashMoveBoardScore %s
if <(BestHashMoveResult) = (1)> then 
set [EvalExtendedResult v] to [BestHashMoveBoardScoreResult]
stop [this script v]
end
set [BlackKingEndgameTargetIdx v] to [0]
set [WhiteKingEndgameTargetIdx v] to [0]
set [BlackKingIdx v] to [0]
set [WhiteKingIdx v] to [0]
set [WhitePotentialPromotionPawnIdx v] to [0]
set [EvalExtendedResult v] to [0]
set [Idx v] to [1]
repeat (8) 
replace item (Idx) of [BlackPawnCount v] with [0]
replace item (Idx) of [WhitePawnCount v] with [0]
change [Idx v] by (1)
end
delete (all) of [PawnAdvancePerCol v]
repeat (32) 
add [0] to [PawnAdvancePerCol v]
end
set [Idx v] to [1]
set [InvIdx v] to [64]
repeat (64) 
set [CurrentPiece v] to (item (Idx) of [Board v])
if <(CurrentPiece) = (WhiteKing)> then 
set [WhiteKingIdx v] to [Idx]
 else 
if <(CurrentPiece) = (BlackKing)> then 
set [BlackKingIdx v] to [Idx]
end
end
if <(CurrentPiece) = (BlackPawn)> then 
set [Column v] to (item (Idx) of [IdxToCol v])
replace item (Column) of [BlackPawnCount v] with ((item (Column) of [BlackPawnCount v]) + (1))
if <(Idx) > (24)> then 
if <<<(Column) > (1)> and <(item ((Idx) - (9)) of [Board v]) = (BlackPawn)>> or <<(Column) < (8)> and <(item ((Idx) - (7)) of [Board v]) = (BlackPawn)>>> then 
change [EvalExtendedResult v] by (5)
end
end
if <<(item ((Column) + (16)) of [PawnAdvancePerCol v]) = (0)> or <(item (Idx) of [IdxToRow v]) < (item ((Column) + (16)) of [PawnAdvancePerCol v])>> then 
replace item ((Column) + (16)) of [PawnAdvancePerCol v] with (item (Idx) of [IdxToRow v])
end
if <<(item ((Column) + (24)) of [PawnAdvancePerCol v]) = (0)> or <(item (Idx) of [IdxToRow v]) > (item ((Column) + (24)) of [PawnAdvancePerCol v])>> then 
replace item ((Column) + (24)) of [PawnAdvancePerCol v] with (item (Idx) of [IdxToRow v])
end
 else 
if <(CurrentPiece) = (WhitePawn)> then 
set [Column v] to (item (Idx) of [IdxToCol v])
replace item (Column) of [WhitePawnCount v] with ((item (Column) of [WhitePawnCount v]) + (1))
if <(Idx) < (41)> then 
if <<<(Column) > (1)> and <(item ((Idx) + (7)) of [Board v]) = (WhitePawn)>> or <<(Column) < (8)> and <(item ((Idx) + (9)) of [Board v]) = (WhitePawn)>>> then 
change [EvalExtendedResult v] by (-5)
end
end
if <<(item (Column) of [PawnAdvancePerCol v]) = (0)> or <(item (Idx) of [IdxToRow v]) > (item (Column) of [PawnAdvancePerCol v])>> then 
replace item (Column) of [PawnAdvancePerCol v] with (item (Idx) of [IdxToRow v])
end
if <<(item ((Column) + (8)) of [PawnAdvancePerCol v]) = (0)> or <(item (Idx) of [IdxToRow v]) < (item ((Column) + (8)) of [PawnAdvancePerCol v])>> then 
replace item ((Column) + (8)) of [PawnAdvancePerCol v] with (item (Idx) of [IdxToRow v])
end
end
end
change [Idx v] by (1)
change [InvIdx v] by (-1)
end
if <<(IsImportedBoard) = (0)> and <(length of [GameMovesAN v]) < (13)>> then 
if <not <(item (item (4) of [VirtualBoard v]) of [Board v]) = (BlackQueen)>> then 
change [EvalExtendedResult v] by (-10)
end
if <not <(item (item (60) of [VirtualBoard v]) of [Board v]) = (WhiteQueen)>> then 
change [EvalExtendedResult v] by (10)
end
end
if <(IsEndgame) = (0)> then 
if <(1) = (1)> then 
if <<(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackKingsideCastling)> or <(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackQueensideCastling)>> then 
change [EvalExtendedResult v] by (50)
end
if <<(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackKingsideCastling)> or <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackQueensideCastling)>> then 
change [EvalExtendedResult v] by (25)
end
if <<(item (item (5) of [MovesIdx v]) of [Moves5 v]) = (BlackKingsideCastling)> or <(item (item (5) of [MovesIdx v]) of [Moves5 v]) = (BlackQueensideCastling)>> then 
change [EvalExtendedResult v] by (10)
end
if <<(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (WhiteKingsideCastling)> or <(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (WhiteQueensideCastling)>> then 
change [EvalExtendedResult v] by (-50)
end
if <<(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (WhiteKingsideCastling)> or <(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (WhiteQueensideCastling)>> then 
change [EvalExtendedResult v] by (-25)
end
if <<(item (item (6) of [MovesIdx v]) of [Moves6 v]) = (WhiteKingsideCastling)> or <(item (item (6) of [MovesIdx v]) of [Moves6 v]) = (WhiteQueensideCastling)>> then 
change [EvalExtendedResult v] by (-10)
end
end
if <<(HasBlackCastled) = (0)> and <<(HasBlackKingMoved) = (0)> and <<(HasBlackRookQSMoved) = (0)> or <(HasBlackRookKSMoved) = (0)>>>> then 
if <<not <(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackQueensideCastling)>> and <<not <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackQueensideCastling)>> and <not <(item (item (5) of [MovesIdx v]) of [Moves5 v]) = (BlackQueensideCastling)>>>> then 
if <<not <(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackKingsideCastling)>> and <<not <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackKingsideCastling)>> and <not <(item (item (5) of [MovesIdx v]) of [Moves5 v]) = (BlackKingsideCastling)>>>> then 
if <<not <(item (item (5) of [VirtualBoard v]) of [Board v]) = (BlackKing)>> or <(item ([floor v] of ((item (item (3) of [MovesIdx v]) of [Moves3 v]) mod (100)) ::operators) of [Board v]) = (BlackKing)>> then 
change [EvalExtendedResult v] by (-50)
 else 
if <<not <(item (item (1) of [VirtualBoard v]) of [Board v]) = (BlackRook)>> or <(item ([floor v] of ((item (item (3) of [MovesIdx v]) of [Moves3 v]) mod (100)) ::operators) of [Board v]) = (BlackRook)>> then 
change [EvalExtendedResult v] by (-15)
end
if <<not <(item (item (8) of [VirtualBoard v]) of [Board v]) = (BlackRook)>> or <(item ([floor v] of ((item (item (3) of [MovesIdx v]) of [Moves3 v]) mod (100)) ::operators) of [Board v]) = (BlackRook)>> then 
change [EvalExtendedResult v] by (-15)
end
end
end
end
end
if <<(HasWhiteCastled) = (0)> and <<(HasWhiteKingMoved) = (0)> and <<(HasWhiteRookQSMoved) = (0)> or <(HasWhiteRookKSMoved) = (0)>>>> then 
if <<not <(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (WhiteQueensideCastling)>> and <<not <(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (WhiteQueensideCastling)>> and <not <(item (item (6) of [MovesIdx v]) of [Moves6 v]) = (WhiteQueensideCastling)>>>> then 
if <<not <(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (WhiteKingsideCastling)>> and <<not <(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (WhiteKingsideCastling)>> and <not <(item (item (6) of [MovesIdx v]) of [Moves6 v]) = (WhiteKingsideCastling)>>>> then 
if <<not <(item (item (61) of [VirtualBoard v]) of [Board v]) = (WhiteKing)>> or <(item ([floor v] of ((item (item (4) of [MovesIdx v]) of [Moves4 v]) mod (100)) ::operators) of [Board v]) = (WhiteKing)>> then 
change [EvalExtendedResult v] by (50)
 else 
if <<not <(item (item (57) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> or <(item ([floor v] of ((item (item (4) of [MovesIdx v]) of [Moves4 v]) mod (100)) ::operators) of [Board v]) = (WhiteRook)>> then 
change [EvalExtendedResult v] by (15)
end
if <<not <(item (item (64) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> or <(item ([floor v] of ((item (item (4) of [MovesIdx v]) of [Moves4 v]) mod (100)) ::operators) of [Board v]) = (WhiteRook)>> then 
change [EvalExtendedResult v] by (15)
end
end
end
end
end
end
set [Idx v] to [1]
repeat (8) 
if <<(IsEndgame) = (1)> or <(1) = (0)>> then 
if <<not <(item ((Idx) + (8)) of [PawnAdvancePerCol v]) = (0)>> and <<(item ((Idx) + (8)) of [PawnAdvancePerCol v]) < (item ((Idx) + (16)) of [PawnAdvancePerCol v])> or <(item ((Idx) + (16)) of [PawnAdvancePerCol v]) = (0)>>> then 
if <<(item ((Idx) + (8)) of [PawnAdvancePerCol v]) < (5)> and <<<<(Idx) = (1)> or <(item (((Idx) - (1)) + (16)) of [PawnAdvancePerCol v]) = (0)>> or <(item ((Idx) + (8)) of [PawnAdvancePerCol v]) < (item (((Idx) - (1)) + (16)) of [PawnAdvancePerCol v])>> and <<<(Idx) = (8)> or <(item (((Idx) + (1)) + (16)) of [PawnAdvancePerCol v]) = (0)>> or <(item ((Idx) + (8)) of [PawnAdvancePerCol v]) < (item (((Idx) + (1)) + (16)) of [PawnAdvancePerCol v])>>>> then 
if <not <(item (2) of [PawnPromotionCol v]) = (Idx)>> then 
change [EvalExtendedResult v] by ((-35) * ((5) - (item ((Idx) + (8)) of [PawnAdvancePerCol v])))
if <<(BlackKingEndgameTargetIdx) = (0)> or <(BlackKingEndgameTargetIdx) < ((0) + (Idx))>> then 
set [BlackKingEndgameTargetIdx v] to ((0) + (Idx))
end
end
 else 
change [EvalExtendedResult v] by ((-10) * ((5) - (item ((Idx) + (8)) of [PawnAdvancePerCol v])))
end
end
if <<not <(item ((Idx) + (24)) of [PawnAdvancePerCol v]) = (0)>> and <<(item ((Idx) + (24)) of [PawnAdvancePerCol v]) > (item ((Idx) + (0)) of [PawnAdvancePerCol v])> or <(item ((Idx) + (0)) of [PawnAdvancePerCol v]) = (0)>>> then 
if <<(item ((Idx) + (24)) of [PawnAdvancePerCol v]) > (4)> and <<<<(Idx) = (1)> or <(item (((Idx) - (1)) + (0)) of [PawnAdvancePerCol v]) = (0)>> or <(item ((Idx) + (24)) of [PawnAdvancePerCol v]) > (item (((Idx) - (1)) + (0)) of [PawnAdvancePerCol v])>> and <<<(Idx) = (8)> or <(item (((Idx) + (1)) + (0)) of [PawnAdvancePerCol v]) = (0)>> or <(item ((Idx) + (24)) of [PawnAdvancePerCol v]) > (item (((Idx) + (1)) + (0)) of [PawnAdvancePerCol v])>>>> then 
if <not <(item (1) of [PawnPromotionCol v]) = (Idx)>> then 
change [EvalExtendedResult v] by ((35) * ((item ((Idx) + (24)) of [PawnAdvancePerCol v]) - (4)))
if <<(WhiteKingEndgameTargetIdx) = (0)> or <(WhiteKingEndgameTargetIdx) > ((50) + (Idx))>> then 
set [WhiteKingEndgameTargetIdx v] to ((50) + (Idx))
end
end
 else 
change [EvalExtendedResult v] by ((10) * ((item ((Idx) + (24)) of [PawnAdvancePerCol v]) - (4)))
end
end
end
if <(item (Idx) of [BlackPawnCount v]) > (0)> then 
if <not <<<(Idx) > (1)> and <(item ((Idx) - (1)) of [BlackPawnCount v]) > (0)>> or <<(Idx) < (8)> and <(item ((Idx) + (1)) of [BlackPawnCount v]) > (0)>>>> then 
change [EvalExtendedResult v] by (-30)
end
if <(item (Idx) of [BlackPawnCount v]) > (1)> then 
change [EvalExtendedResult v] by ((-30) * ((item (Idx) of [BlackPawnCount v]) - (1)))
end
end
if <(item (Idx) of [WhitePawnCount v]) > (0)> then 
if <not <<<(Idx) > (1)> and <(item ((Idx) - (1)) of [WhitePawnCount v]) > (0)>> or <<(Idx) < (8)> and <(item ((Idx) + (1)) of [WhitePawnCount v]) > (0)>>>> then 
change [EvalExtendedResult v] by (30)
end
if <(item (Idx) of [WhitePawnCount v]) > (1)> then 
change [EvalExtendedResult v] by ((30) * ((item (Idx) of [WhitePawnCount v]) - (1)))
end
end
change [Idx v] by (1)
end
if <<<<(WhiteQueenCount) > (0)> or <(WhiteMinorCount) > (2)>> or <(IsEndgame) = (0)>> and <<not <(BlackKingIdx) = (item (5) of [VirtualBoard v])>> or <<(HasBlackCastled) = (1)> or <(HasBlackKingMoved) = (1)>>>> then 
set [KingProtection v] to [0]
set [Column v] to ((item (BlackKingIdx) of [IdxToCol v]) - (1))
repeat (3) 
if <<(Column) > (0)> and <(Column) < (9)>> then 
if <(item ((Column) + (16)) of [PawnAdvancePerCol v]) > (0)> then 
if <(Column) = (item (BlackKingIdx) of [IdxToCol v])> then 
change [KingProtection v] by (item ((((item ((Column) + (16)) of [PawnAdvancePerCol v]) - (item (BlackKingIdx) of [IdxToRow v])) * (8)) + (Column)) of [PawnShelterKingCol v])
 else 
change [KingProtection v] by (item ((((item ((Column) + (16)) of [PawnAdvancePerCol v]) - (item (BlackKingIdx) of [IdxToRow v])) * (8)) + (Column)) of [PawnShelterNeighborCol v])
end
 else 
if <(Column) = (item (BlackKingIdx) of [IdxToCol v])> then 
change [KingProtection v] by (item (Column) of [PawnShelterKingCol v])
if <(item ((Column) + (0)) of [PawnAdvancePerCol v]) = (0)> then 
change [KingProtection v] by (-30)
end
 else 
change [KingProtection v] by (item (Column) of [PawnShelterNeighborCol v])
if <(item ((Column) + (0)) of [PawnAdvancePerCol v]) = (0)> then 
change [KingProtection v] by (-15)
end
end
end
if <(item (Column) of [PawnAdvancePerCol v]) > (0)> then 
if <(item ((Column) + (16)) of [PawnAdvancePerCol v]) < (item ((Column) + (8)) of [PawnAdvancePerCol v])> then 
change [KingProtection v] by ((0) - (item ((((item ((Column) + (8)) of [PawnAdvancePerCol v]) - (item (BlackKingIdx) of [IdxToRow v])) * (8)) + (Column)) of [PawnStormBlockedByPawn v]))
 else 
if <((BlackKingIdx) + (8)) = ((((item ((Column) + (8)) of [PawnAdvancePerCol v]) - (1)) * (8)) + (Column))> then 
change [KingProtection v] by ((0) - (item ((((item ((Column) + (8)) of [PawnAdvancePerCol v]) - (item (BlackKingIdx) of [IdxToRow v])) * (8)) + (Column)) of [PawnStormBlockedByKing v]))
 else 
change [KingProtection v] by ((0) - (item ((((item ((Column) + (8)) of [PawnAdvancePerCol v]) - (item (BlackKingIdx) of [IdxToRow v])) * (8)) + (Column)) of [PawnStormBlockedByNone v]))
end
if <(item ((Column) + (16)) of [PawnAdvancePerCol v]) = (0)> then 
if <(Column) = (item (BlackKingIdx) of [IdxToCol v])> then 
change [KingProtection v] by (-20)
 else 
change [KingProtection v] by (-10)
end
end
end
end
end
change [Column v] by (1)
end
change [EvalExtendedResult v] by (KingProtection)
end
if <<<<(BlackMinorCount) > (2)> or <(BlackQueenCount) > (0)>> or <(IsEndgame) = (0)>> and <<not <(WhiteKingIdx) = (item (61) of [VirtualBoard v])>> or <<(HasWhiteCastled) = (1)> or <(HasWhiteKingMoved) = (1)>>>> then 
set [KingProtection v] to [0]
set [Column v] to ((item (WhiteKingIdx) of [IdxToCol v]) - (1))
repeat (3) 
if <<(Column) > (0)> and <(Column) < (9)>> then 
if <(item ((Column) + (0)) of [PawnAdvancePerCol v]) > (0)> then 
if <(Column) = (item (WhiteKingIdx) of [IdxToCol v])> then 
change [KingProtection v] by (item ((((item (WhiteKingIdx) of [IdxToRow v]) - (item ((Column) + (0)) of [PawnAdvancePerCol v])) * (8)) + (Column)) of [PawnShelterKingCol v])
 else 
change [KingProtection v] by (item ((((item (WhiteKingIdx) of [IdxToRow v]) - (item ((Column) + (0)) of [PawnAdvancePerCol v])) * (8)) + (Column)) of [PawnShelterNeighborCol v])
end
 else 
if <(Column) = (item (WhiteKingIdx) of [IdxToCol v])> then 
change [KingProtection v] by (item (Column) of [PawnShelterKingCol v])
if <(item ((Column) + (16)) of [PawnAdvancePerCol v]) = (0)> then 
change [KingProtection v] by (-30)
end
 else 
change [KingProtection v] by (item (Column) of [PawnShelterNeighborCol v])
if <(item ((Column) + (16)) of [PawnAdvancePerCol v]) = (0)> then 
change [KingProtection v] by (-15)
end
end
end
if <(item (Column) of [PawnAdvancePerCol v]) > (0)> then 
if <(item ((Column) + (0)) of [PawnAdvancePerCol v]) > (item ((Column) + (24)) of [PawnAdvancePerCol v])> then 
change [KingProtection v] by ((0) - (item ((((item (WhiteKingIdx) of [IdxToRow v]) - (item ((Column) + (24)) of [PawnAdvancePerCol v])) * (8)) + (Column)) of [PawnStormBlockedByPawn v]))
 else 
if <((WhiteKingIdx) - (8)) = ((((item ((Column) + (24)) of [PawnAdvancePerCol v]) - (1)) * (8)) + (Column))> then 
change [KingProtection v] by ((0) - (item ((((item (WhiteKingIdx) of [IdxToRow v]) - (item ((Column) + (24)) of [PawnAdvancePerCol v])) * (8)) + (Column)) of [PawnStormBlockedByKing v]))
 else 
change [KingProtection v] by ((0) - (item ((((item (WhiteKingIdx) of [IdxToRow v]) - (item ((Column) + (24)) of [PawnAdvancePerCol v])) * (8)) + (Column)) of [PawnStormBlockedByNone v]))
end
if <(item ((Column) + (0)) of [PawnAdvancePerCol v]) = (0)> then 
if <(Column) = (item (WhiteKingIdx) of [IdxToCol v])> then 
change [KingProtection v] by (-20)
 else 
change [KingProtection v] by (-10)
end
end
end
end
end
change [Column v] by (1)
end
change [EvalExtendedResult v] by ((0) - (KingProtection))
end
if <(IsEndgame) = (1)> then 
if <(BlackKingEndgameTargetIdx) = (0)> then 
set [BlackKingEndgameTargetIdx v] to [WhiteKingEndgameTargetIdx]
end
if <(WhiteKingEndgameTargetIdx) = (0)> then 
set [WhiteKingEndgameTargetIdx v] to [BlackKingEndgameTargetIdx]
end
if <not <(BlackKingEndgameTargetIdx) = (0)>> then 
set [Delta v] to (([abs v] of ((item (BlackKingEndgameTargetIdx) of [IdxToRow v]) - (item (BlackKingIdx) of [IdxToRow v])) ::operators) + ([abs v] of ((item (BlackKingEndgameTargetIdx) of [IdxToCol v]) - (item (BlackKingIdx) of [IdxToCol v])) ::operators))
change [EvalExtendedResult v] by ((-25) * (Delta))
end
if <not <(WhiteKingEndgameTargetIdx) = (0)>> then 
set [Delta v] to (([abs v] of ((item (WhiteKingEndgameTargetIdx) of [IdxToRow v]) - (item (WhiteKingIdx) of [IdxToRow v])) ::operators) + ([abs v] of ((item (WhiteKingEndgameTargetIdx) of [IdxToCol v]) - (item (WhiteKingIdx) of [IdxToCol v])) ::operators))
change [EvalExtendedResult v] by ((25) * (Delta))
end
if <<((WhiteQueenCount) + (WhiteMinorCount)) = (0)> or <((BlackQueenCount) + (BlackMinorCount)) = (0)>> then 
set [Delta v] to (([abs v] of ((item (WhiteKingIdx) of [IdxToRow v]) - (item (BlackKingIdx) of [IdxToRow v])) ::operators) + ([abs v] of ((item (WhiteKingIdx) of [IdxToCol v]) - (item (BlackKingIdx) of [IdxToCol v])) ::operators))
if <<(EvalResult) > (BlackBishop)> and <(BlackKingEndgameTargetIdx) = (0)>> then 
change [EvalExtendedResult v] by ((-15) * (Delta))
 else 
if <<(EvalResult) < (WhiteBishop)> and <(WhiteKingEndgameTargetIdx) = (0)>> then 
change [EvalExtendedResult v] by ((15) * (Delta))
end
end
end
end
HashOnBoardScore %s %s

define GetTargetIdx %n %n %n
set [GetTargetIdxRes v] to [-1]
set [X v] to ((item (argument_reporter_string_number) of [IdxToCol v]) + (argument_reporter_string_number))
if <<(X) > (0)> and <(X) < (9)>> then 
set [Y v] to ((item (argument_reporter_string_number) of [IdxToRow v]) + (argument_reporter_string_number))
if <<(Y) > (0)> and <(Y) < (9)>> then 
set [GetTargetIdxRes v] to ((X) + (((Y) - (1)) * (8)))
end
end

define AlphaBetaMinMax %n %n %n %n %b %b %n %b
OnScoreCalc %n %n %n %b %b %b
replace item (argument_reporter_string_number) of [Alphas v] with (argument_reporter_string_number)
replace item (argument_reporter_string_number) of [Betas v] with (argument_reporter_string_number)
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b

define IsStringEqual %s %n %s %n
set [IsStringEqualRes v] to [1]
set [Offset v] to [0]
repeat until <<(Offset) = (length of (argument_reporter_string_number))> or <(Offset) = (length of (argument_reporter_string_number))>> 
if <not <(letter ((argument_reporter_string_number) + (Offset)) of (argument_reporter_string_number)) = (letter ((argument_reporter_string_number) + (Offset)) of (argument_reporter_string_number))>> then 
set [IsStringEqualRes v] to [0]
stop [this script v]
end
change [Offset v] by (1)
end

define PickMove %n %n %b %b %b %b
if <(item (argument_reporter_string_number) of [PickPhase v]) = (1)> then 
ClearMoveList %n
replace item (argument_reporter_string_number) of [PickHash v] with []
replace item (argument_reporter_string_number) of [PawnPromotionCol v] with []
if <argument_reporter_boolean> then 
GetBestHashMove %s %s
if <(argument_reporter_string_number) = (1)> then 
Log %s %s %s %s %s %s %s %s
end
if <<(BestHashMoveResult) = (1)> and <<not <(BestHashMoveMoveResult) = ()>> and <((argument_reporter_string_number) mod (2)) = ((BestHashMoveDepthResult) mod (2))>>> then 
set [SourceIdx v] to ([floor v] of ((BestHashMoveMoveResult) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((BestHashMoveMoveResult) mod (100)) ::operators)
GetMoveScore %n %n %n %n %n %n
if <<<not <argument_reporter_boolean>> and <<not <(BestHashMoveHorizonResult) = (-1)>> or <<<((argument_reporter_string_number) mod (2)) = (1)> and <(MoveScoreRes) > (0)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(MoveScoreRes) < (0)>>>>> or <<argument_reporter_boolean> and <not <(item (TargetIdx) of [Board v]) = (Empty)>>>> then 
set [IsLegalMove v] to [1]
if <(1) = (0)> then 
ClearBoardAttackedByMove %n
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [1]
CalculateMovesForSource %n %n %b %b
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [0]
if <<(argument_reporter_string_number) = (1)> and <[Moves1 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (2)> and <[Moves2 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (3)> and <[Moves3 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (4)> and <[Moves4 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (5)> and <[Moves5 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (6)> and <[Moves6 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (7)> and <[Moves7 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (8)> and <[Moves8 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (9)> and <[Moves9 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (10)> and <[Moves10 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (11)> and <[Moves11 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (12)> and <[Moves12 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (13)> and <[Moves13 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (14)> and <[Moves14 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
 else 
if <<(argument_reporter_string_number) = (15)> and <[Moves15 v] contains [BestHashMoveMoveResult] ? ::lists>> then 
set [IsLegalMove v] to [1]
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
if <(IsLegalMove) = (1)> then 
replace item (argument_reporter_string_number) of [PrevBestHashMove v] with [BestHashMoveMoveResult]
if <not <(BestHashMoveMoveResult) = ([floor v] of (BestHashMoveMoveResult) ::operators)>> then 
replace item (argument_reporter_string_number) of [PawnPromotionCol v] with (item (([floor v] of (BestHashMoveMoveResult) ::operators) mod (100)) of [IdxToCol v])
end
replace item (argument_reporter_string_number) of [CheckedState v] with [BestHashMoveCheckedResult]
replace item (argument_reporter_string_number) of [PickHash v] with [BestHashMoveMoveResult]
AddToMoveList %n %n
replace item (argument_reporter_string_number) of [MovesIdx v] with [1]
ApplyMove %n
replace item (argument_reporter_string_number) of [PickPhase v] with [2]
replace item (argument_reporter_string_number) of [PickMoveRes v] with [1]
Profile_IncCounter %n
stop [this script v]
end
end
end
end
replace item (argument_reporter_string_number) of [PickPhase v] with [2]
end
if <(item (argument_reporter_string_number) of [PickPhase v]) = (2)> then 
ClearBoardAttackedByMove %n
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [0]
replace item (argument_reporter_string_number) of [CheckedState v] with [-1]
if <not <argument_reporter_boolean>> then 
CalcBoardAttackedByMove %n
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [1]
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (1)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (1)>>> then 
replace item (argument_reporter_string_number) of [CheckedState v] with [1]
 else 
replace item (argument_reporter_string_number) of [CheckedState v] with [0]
end
end
set [CalculateMovesRequiresAttackRecalc v] to [0]
CalculateMovesImpl %n %b %b
if <<argument_reporter_boolean> and <(CalculateMovesRequiresAttackRecalc) = (1)>> then 
CalcBoardAttackedByMove %n
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [1]
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (1)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (1)>>> then 
replace item (argument_reporter_string_number) of [CheckedState v] with [1]
 else 
replace item (argument_reporter_string_number) of [CheckedState v] with [0]
end
CalculateMovesImpl %n %b %b
end
if <argument_reporter_boolean> then 
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [DeepeningScore v]
repeat (length of [Moves1Score v]) 
add [] to [DeepeningScore v]
end
delete (all) of [DeepeningScoreOrderMap v]
repeat (length of [Moves1Score v]) 
add [] to [DeepeningScoreOrderMap v]
end
end
end
if <argument_reporter_boolean> then 
if <(argument_reporter_string_number) = (1)> then 
EvaluateBoard
set [Idx v] to [1]
repeat (length of [Moves1Score v]) 
if <(item (Idx) of [DeepeningScore v]) = ()> then 
replace item (Idx) of [Moves1Score v] with ((EvalResult) + (item (Idx) of [Moves1Score v]))
 else 
replace item (Idx) of [Moves1Score v] with ((1000) + (item (Idx) of [DeepeningScore v]))
replace item (Idx) of [DeepeningScore v] with []
end
change [Idx v] by (1)
end
end
end
CutoffReorder %n %b
if <(item (argument_reporter_string_number) of [PrevBestHashMove v]) = ()> then 
replace item (argument_reporter_string_number) of [MovesIdx v] with [1]
GetCurrentMove %n
replace item (argument_reporter_string_number) of [PrevBestHashMove v] with [CurrentMove]
end
replace item (argument_reporter_string_number) of [MovesIdx v] with [0]
replace item (argument_reporter_string_number) of [PickPhase v] with [3]
end
if <(item (argument_reporter_string_number) of [PickPhase v]) = (3)> then 
replace item (argument_reporter_string_number) of [MovesIdx v] with ((item (argument_reporter_string_number) of [MovesIdx v]) + (1))
if <not <(item (argument_reporter_string_number) of [MovesIdx v]) > (item (argument_reporter_string_number) of [MovesCount v])>> then 
GetCurrentMove %n
if <(CurrentMove) = (item (argument_reporter_string_number) of [PickHash v])> then 
replace item (argument_reporter_string_number) of [MovesIdx v] with ((item (argument_reporter_string_number) of [MovesIdx v]) + (1))
end
if <not <(item (argument_reporter_string_number) of [MovesIdx v]) > (item (argument_reporter_string_number) of [MovesCount v])>> then 
ApplyMove %n
replace item (argument_reporter_string_number) of [PickMoveRes v] with [1]
stop [this script v]
end
end
replace item (argument_reporter_string_number) of [PickPhase v] with [4]
replace item (argument_reporter_string_number) of [PickMoveRes v] with [0]
end
replace item (argument_reporter_string_number) of [PickMoveRes v] with [0]

define CutoffReorder %n %b
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves1Score v]) 
if <(item (Idx) of [Moves1Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves1Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves1Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [DeepeningScoreOrderMap v] with (([abs v] of (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v]) ::operators) mod (10000))
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves1 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves1 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (2)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves2Score v]) 
if <(item (Idx) of [Moves2Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves2Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves2Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves2 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves2 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (3)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves3Score v]) 
if <(item (Idx) of [Moves3Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves3Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves3Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves3 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves3 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (4)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves4Score v]) 
if <(item (Idx) of [Moves4Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves4Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves4Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves4 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves4 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (5)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves5Score v]) 
if <(item (Idx) of [Moves5Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves5Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves5Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves5 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves5 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (6)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves6Score v]) 
if <(item (Idx) of [Moves6Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves6Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves6Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves6 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves6 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (7)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves7Score v]) 
if <(item (Idx) of [Moves7Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves7Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves7Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves7 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves7 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (8)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves8Score v]) 
if <(item (Idx) of [Moves8Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves8Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves8Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves8 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves8 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (9)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves9Score v]) 
if <(item (Idx) of [Moves9Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves9Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves9Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves9 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves9 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (10)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves10Score v]) 
if <(item (Idx) of [Moves10Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves10Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves10Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves10 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves10 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (11)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves9Score v]) 
if <(item (Idx) of [Moves11Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves11Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves11Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves11 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves11 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (12)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves12Score v]) 
if <(item (Idx) of [Moves12Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves12Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves12Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves12 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves12 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end

define CutoffPreProcess %n
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [SortedList v]
repeat until <(length of [SortedList v]) = (length of [Moves1 v])> 
add [] to [SortedList v]
end
delete (all) of [SortedList2 v]
repeat until <(length of [SortedList2 v]) = (length of [Moves1 v])> 
add [] to [SortedList2 v]
end
end
if <(argument_reporter_string_number) = (2)> then 
if <(1) = (0)> then 
delete (all) of [SortedListTemp v]
repeat until <(length of [SortedListTemp v]) = (length of [Moves2 v])> 
add [] to [SortedListTemp v]
end
end
end

define QuickSortTemp %s %s
set [QSLower v] to (argument_reporter_string_number)
set [QSUpper v] to (argument_reporter_string_number)
set [QSPivot v] to (item ([floor v] of (((argument_reporter_string_number) + (argument_reporter_string_number)) / (2)) ::operators) of [SortedListTemp v])
repeat until <(QSLower) > (QSUpper)> 
repeat until <not <(item (QSLower) of [SortedListTemp v]) < (QSPivot)>> 
change [QSLower v] by (1)
end
repeat until <not <(item (QSUpper) of [SortedListTemp v]) > (QSPivot)>> 
change [QSUpper v] by (-1)
end
if <not <(QSLower) > (QSUpper)>> then 
set [QSSwap v] to (item (QSLower) of [SortedListTemp v])
replace item (QSLower) of [SortedListTemp v] with (item (QSUpper) of [SortedListTemp v])
replace item (QSUpper) of [SortedListTemp v] with [QSSwap]
change [QSLower v] by (1)
change [QSUpper v] by (-1)
end
end
if <(argument_reporter_string_number) < (QSUpper)> then 
QuickSortTemp %s %s
end
if <(QSLower) < (argument_reporter_string_number)> then 
QuickSortTemp %s %s
end

define AddMoveImpl %n %n %n %b %b %b %b %b
if <(1) = (0)> then 
Profile_MethodEnter %n
end
set [TargetPiece v] to (item ([floor v] of (argument_reporter_string_number) ::operators) of [Board v])
if <<<argument_reporter_boolean> and <(TargetPiece) = (Empty)>> or <<<argument_reporter_boolean> and <(TargetPiece) > (0)>> or <<argument_reporter_boolean> and <(TargetPiece) < (0)>>>> then 
set [SourcePiece v] to (item (argument_reporter_string_number) of [Board v])
if <argument_reporter_boolean> then 
if <(SourcePiece) > (0)> then 
replace item (argument_reporter_string_number) of [BoardAttackedByBlack v] with ((item (argument_reporter_string_number) of [BoardAttackedByBlack v]) + (1))
if <(TargetPiece) = (WhiteKing)> then 
set [IsWhiteChecked v] to [1]
end
if <(1) = (0)> then 
GetSEEMapVal %n
replace item (argument_reporter_string_number) of [BoardAttackedByBlackPiece v] with ((item (argument_reporter_string_number) of [BoardAttackedByBlackPiece v]) + (SEEMapValRes))
end
 else 
replace item (argument_reporter_string_number) of [BoardAttackedByWhite v] with ((item (argument_reporter_string_number) of [BoardAttackedByWhite v]) + (1))
if <(TargetPiece) = (BlackKing)> then 
set [IsBlackChecked v] to [1]
end
if <(1) = (0)> then 
GetSEEMapVal %n
replace item (argument_reporter_string_number) of [BoardAttackedByWhitePiece v] with ((item (argument_reporter_string_number) of [BoardAttackedByWhitePiece v]) + (SEEMapValRes))
end
end
 else 
if <<argument_reporter_boolean> and <<(TargetPiece) = (Empty)> and <not <<<(SourcePiece) = (WhitePawn)> and <(item (argument_reporter_string_number) of [IdxToRow v]) = (1)>> or <<(SourcePiece) = (BlackPawn)> and <(item (argument_reporter_string_number) of [IdxToRow v]) = (8)>>>>>> then 
if <(1) = (0)> then 
Profile_MethodExit %n
end
stop [this script v]
end
if <<(SourcePiece) = (WhiteKing)> or <(SourcePiece) = (BlackKing)>> then 
if <not <(item (argument_reporter_string_number) of [BoardAttackedCalculated v]) = (1)>> then 
set [CalculateMovesRequiresAttackRecalc v] to [1]
if <(1) = (0)> then 
Profile_MethodExit %n
end
stop [this script v]
end
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(item (argument_reporter_string_number) of [BoardAttackedByWhite v]) > (0)> then 
if <(1) = (0)> then 
Profile_MethodExit %n
end
stop [this script v]
end
 else 
if <(item (argument_reporter_string_number) of [BoardAttackedByBlack v]) > (0)> then 
if <(1) = (0)> then 
Profile_MethodExit %n
end
stop [this script v]
end
end
end
if <not <argument_reporter_boolean>> then 
if <<<(SourcePiece) > (0)> and <(item ([floor v] of (argument_reporter_string_number) ::operators) of [BoardAttackedByWhite v]) = (0)>> or <<(SourcePiece) < (0)> and <(item ([floor v] of (argument_reporter_string_number) ::operators) of [BoardAttackedByBlack v]) = (0)>>> then 
replace item (argument_reporter_string_number) of [PieceMobility v] with ((item (argument_reporter_string_number) of [PieceMobility v]) + (1))
end
end
set [CurrentMove v] to (((argument_reporter_string_number) * (100)) + (argument_reporter_string_number))
if <(argument_reporter_string_number) < (10)> then 
set [CurrentMove v] to (join [0] [CurrentMove])
end
if <<<(SourcePiece) = (WhitePawn)> and <(item (argument_reporter_string_number) of [IdxToRow v]) = (2)>> or <<(SourcePiece) = (BlackPawn)> and <(item (argument_reporter_string_number) of [IdxToRow v]) = (7)>>> then 
if <(CurrentMove) = ([floor v] of (CurrentMove) ::operators)> then 
replace item (argument_reporter_string_number) of [PawnPromotionCol v] with (item (([floor v] of (CurrentMove) ::operators) mod (100)) of [IdxToCol v])
AddMoveImpl %n %n %n %b %b %b %b %b
AddMoveImpl %n %n %n %b %b %b %b %b
AddMoveImpl %n %n %n %b %b %b %b %b
AddMoveImpl %n %n %n %b %b %b %b %b
if <(1) = (0)> then 
Profile_MethodExit %n
end
stop [this script v]
end
end
if <(argument_reporter_string_number) = (20)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves20 v]
add [MoveScoreRes] to [Moves20Score v]
 else 
add [CurrentMove] to [Moves20 v]
add [0] to [Moves20Score v]
end
 else 
if <(argument_reporter_string_number) = (19)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves19 v]
add [MoveScoreRes] to [Moves19Score v]
 else 
add [CurrentMove] to [Moves19 v]
add [0] to [Moves19Score v]
end
 else 
if <(argument_reporter_string_number) = (18)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves18 v]
add [MoveScoreRes] to [Moves18Score v]
 else 
add [CurrentMove] to [Moves18 v]
add [0] to [Moves18Score v]
end
 else 
if <(argument_reporter_string_number) = (17)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves17 v]
add [MoveScoreRes] to [Moves17Score v]
 else 
add [CurrentMove] to [Moves17 v]
add [0] to [Moves17Score v]
end
 else 
if <(argument_reporter_string_number) = (16)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves16 v]
add [MoveScoreRes] to [Moves16Score v]
 else 
add [CurrentMove] to [Moves16 v]
add [0] to [Moves16Score v]
end
 else 
if <(argument_reporter_string_number) = (15)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves15 v]
add [MoveScoreRes] to [Moves15Score v]
 else 
add [CurrentMove] to [Moves15 v]
add [0] to [Moves15Score v]
end
 else 
if <(argument_reporter_string_number) = (14)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves14 v]
add [MoveScoreRes] to [Moves14Score v]
 else 
add [CurrentMove] to [Moves14 v]
add [0] to [Moves14Score v]
end
 else 
if <(argument_reporter_string_number) = (13)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves13 v]
add [MoveScoreRes] to [Moves13Score v]
 else 
add [CurrentMove] to [Moves13 v]
add [0] to [Moves13Score v]
end
 else 
if <(argument_reporter_string_number) = (12)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves12 v]
add [MoveScoreRes] to [Moves12Score v]
 else 
add [CurrentMove] to [Moves12 v]
add [0] to [Moves12Score v]
end
 else 
if <(argument_reporter_string_number) = (11)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves11 v]
add [MoveScoreRes] to [Moves11Score v]
 else 
add [CurrentMove] to [Moves11 v]
add [0] to [Moves11Score v]
end
 else 
if <(argument_reporter_string_number) = (10)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves10 v]
add [MoveScoreRes] to [Moves10Score v]
 else 
add [CurrentMove] to [Moves10 v]
add [0] to [Moves10Score v]
end
 else 
if <(argument_reporter_string_number) = (9)> then 
if <(1) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves9 v]
add [MoveScoreRes] to [Moves9Score v]
 else 
add [CurrentMove] to [Moves9 v]
add [0] to [Moves9Score v]
end
 else 
if <(argument_reporter_string_number) = (8)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves8 v]
add [MoveScoreRes] to [Moves8Score v]
 else 
if <(argument_reporter_string_number) = (7)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves7 v]
add [MoveScoreRes] to [Moves7Score v]
 else 
if <(argument_reporter_string_number) = (6)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves6 v]
add [MoveScoreRes] to [Moves6Score v]
 else 
if <(argument_reporter_string_number) = (5)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves5 v]
add [MoveScoreRes] to [Moves5Score v]
 else 
if <(argument_reporter_string_number) = (4)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves4 v]
add [MoveScoreRes] to [Moves4Score v]
 else 
if <(argument_reporter_string_number) = (3)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves3 v]
add [MoveScoreRes] to [Moves3Score v]
 else 
if <(argument_reporter_string_number) = (2)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves2 v]
add [MoveScoreRes] to [Moves2Score v]
 else 
if <(argument_reporter_string_number) = (1)> then 
GetMoveScore %n %n %n %n %n %n
add [CurrentMove] to [Moves1 v]
add [MoveScoreRes] to [Moves1Score v]
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
if <(1) = (0)> then 
Profile_MethodExit %n
end

define AddPossibleEnPassant %n %n %b
AddPossibleEnPassantImpl %n %n %n %b
AddPossibleEnPassantImpl %n %n %n %b

define AddLineMove %n %n %n %b %b %b %b %b
set [Count v] to [1]
set [IdxOuter v] to (item (argument_reporter_string_number) of [MoveLookupLineIndexOffset v])
set [InvIdxOuter v] to [8]
repeat until <(Count) > (32)> 
set [TargetIdxOuter v] to [-1]
if <(argument_reporter_string_number) = (LineMoveTypeStraight)> then 
set [TargetIdxOuter v] to (item ((IdxOuter) + (Count)) of [MoveLookupStraight v])
end
if <(argument_reporter_string_number) = (LineMoveTypeCross)> then 
set [TargetIdxOuter v] to (item ((IdxOuter) + (Count)) of [MoveLookupCross v])
end
set [TargetPieceOuter v] to [Empty]
if <not <(TargetIdxOuter) = (-1)>> then 
if <<not <argument_reporter_boolean>> or <<<(item (argument_reporter_string_number) of [Board v]) > (0)> and <(item (TargetIdxOuter) of [Board v]) < (0)>> or <<(item (argument_reporter_string_number) of [Board v]) < (0)> and <(item (TargetIdxOuter) of [Board v]) > (0)>>>> then 
AddMoveImpl %n %n %n %b %b %b %b %b
end
set [TargetPieceOuter v] to (item (TargetIdxOuter) of [Board v])
end
if <<(TargetIdxOuter) = (-1)> or <not <(TargetPieceOuter) = (Empty)>>> then 
change [Count v] by (InvIdxOuter)
set [InvIdxOuter v] to [8]
 else 
change [Count v] by (1)
change [InvIdxOuter v] by (-1)
end
end

define GetBoardString
set [GetBoardStringRes v] to []
set [Idx v] to [1]
repeat (64) 
set [GetBoardStringRes v] to (join [GetBoardStringRes] (join (item (Idx) of [Board v]) [,]))
change [Idx v] by (1)
end

when i receive [progressvaluechangedinternal v]
broadcast (1 v) and wait

when i receive [stageclicked v]
hide list [ExportData v]
hide list [ExportMoves v]
if <(IsExecutionRunning) = (0)> then 
say []
end

define GetSubstringLeft %s %n
GetSubstring %s %n %n

define QuickSort %s %s
set [QSLower v] to (argument_reporter_string_number)
set [QSUpper v] to (argument_reporter_string_number)
set [QSPivot v] to (item ([floor v] of (((argument_reporter_string_number) + (argument_reporter_string_number)) / (2)) ::operators) of [SortedList v])
repeat until <(QSLower) > (QSUpper)> 
repeat until <not <(item (QSLower) of [SortedList v]) < (QSPivot)>> 
change [QSLower v] by (1)
end
repeat until <not <(item (QSUpper) of [SortedList v]) > (QSPivot)>> 
change [QSUpper v] by (-1)
end
if <not <(QSLower) > (QSUpper)>> then 
set [QSSwap v] to (item (QSLower) of [SortedList v])
replace item (QSLower) of [SortedList v] with (item (QSUpper) of [SortedList v])
replace item (QSUpper) of [SortedList v] with [QSSwap]
change [QSLower v] by (1)
change [QSUpper v] by (-1)
end
end
if <(argument_reporter_string_number) < (QSUpper)> then 
QuickSort %s %s
end
if <(QSLower) < (argument_reporter_string_number)> then 
QuickSort %s %s
end

define DrawBoard
set [ProgressValue v] to [0]
broadcast (1 v)
broadcast (1 v)

define GetSubstring %s %n %n
set [SubstringRes v] to []
set [IdxString v] to (argument_reporter_string_number)
repeat (((argument_reporter_string_number) - (argument_reporter_string_number)) + (1)) 
set [SubstringRes v] to (join [SubstringRes] (letter (IdxString) of (argument_reporter_string_number)))
change [IdxString v] by (1)
end

define CutoffOnMoveScore %n %n
if <(argument_reporter_string_number) = (1)> then 
if <(argument_reporter_string_number) < (0)> then 
replace item (item (1) of [MovesIdx v]) of [SortedList v] with ((0) - (([abs v] of ((argument_reporter_string_number) * (10000)) ::operators) + (item (1) of [MovesIdx v])))
 else 
replace item (item (1) of [MovesIdx v]) of [SortedList v] with (((argument_reporter_string_number) * (10000)) + (item (1) of [MovesIdx v]))
end
end
if <(argument_reporter_string_number) = (2)> then 
if <(argument_reporter_string_number) < (0)> then 
replace item (item (2) of [MovesIdx v]) of [SortedListTemp v] with ((0) - (([abs v] of ((argument_reporter_string_number) * (10000)) ::operators) + (item (2) of [MovesIdx v])))
 else 
replace item (item (2) of [MovesIdx v]) of [SortedListTemp v] with (((argument_reporter_string_number) * (10000)) + (item (2) of [MovesIdx v]))
end
end

define InitMoveLookup
delete (all) of [MoveLookupStraight v]
delete (all) of [MoveLookupCross v]
delete (all) of [MoveLookupOffsetsStraight v]
delete (all) of [MoveLookupOffsetsCross v]
delete (all) of [MoveLookupKnight v]
delete (all) of [MoveLookupKing v]
delete (all) of [MoveLookupIndexOffset v]
delete (all) of [MoveLookupLineIndexOffset v]
add [1] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [1] to [MoveLookupOffsetsStraight v]
add [-1] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [-1] to [MoveLookupOffsetsStraight v]
add [1] to [MoveLookupOffsetsCross v]
add [1] to [MoveLookupOffsetsCross v]
add [1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
add [1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
set [Idx v] to [1]
repeat (64) 
set [IdxSub v] to [1]
repeat (4) 
set [X v] to (item (Idx) of [IdxToCol v])
set [Y v] to (item (Idx) of [IdxToRow v])
repeat (8) 
change [X v] by (item (IdxSub) of [MoveLookupOffsetsStraight v])
change [Y v] by (item ((IdxSub) + (1)) of [MoveLookupOffsetsStraight v])
add [-1] to [MoveLookupStraight v]
if <<(Y) > (0)> and <(Y) < (9)>> then 
if <<(X) > (0)> and <(X) < (9)>> then 
set [TargetIdx v] to ((X) + (((Y) - (1)) * (8)))
replace item (last) of [MoveLookupStraight v] with [TargetIdx]
end
end
end
change [IdxSub v] by (2)
end
set [IdxSub v] to [1]
repeat (4) 
set [X v] to (item (Idx) of [IdxToCol v])
set [Y v] to (item (Idx) of [IdxToRow v])
repeat (8) 
change [X v] by (item (IdxSub) of [MoveLookupOffsetsCross v])
change [Y v] by (item ((IdxSub) + (1)) of [MoveLookupOffsetsCross v])
add [-1] to [MoveLookupCross v]
if <<(Y) > (0)> and <(Y) < (9)>> then 
if <<(X) > (0)> and <(X) < (9)>> then 
set [TargetIdx v] to ((X) + (((Y) - (1)) * (8)))
replace item (last) of [MoveLookupCross v] with [TargetIdx]
end
end
end
change [IdxSub v] by (2)
end
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (64) 
insert (((Idx) - (1)) * (8)) at (Idx) of [MoveLookupIndexOffset v]
insert (((Idx) - (1)) * (32)) at (Idx) of [MoveLookupLineIndexOffset v]
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (64) 
set [IdxSub v] to [1]
repeat (8) 
GetTargetIdx %n %n %n
if <not <(GetTargetIdxRes) = (-1)>> then 
add [GetTargetIdxRes] to [MoveLookupKing v]
end
change [IdxSub v] by (2)
end
repeat until <(length of [MoveLookupKing v]) = ((Idx) * (8))> 
add [-1] to [MoveLookupKing v]
end
set [IdxSub v] to [1]
repeat (8) 
GetTargetIdx %n %n %n
if <not <(GetTargetIdxRes) = (-1)>> then 
add [GetTargetIdxRes] to [MoveLookupKnight v]
end
change [IdxSub v] by (2)
end
repeat until <(length of [MoveLookupKnight v]) = ((Idx) * (8))> 
add [-1] to [MoveLookupKnight v]
end
change [Idx v] by (1)
end

define GetRepetitionCount
set [Idx v] to ((length of [BoardHistory v]) - (1))
set [RepetitionCountRes v] to [1]
repeat ((length of [BoardHistory v]) - (1)) 
if <(item (Idx) of [BoardHistory v]) = (item (last) of [BoardHistory v])> then 
change [RepetitionCountRes v] by (1)
end
change [Idx v] by (-1)
end

define CutoffPostProcess %n
if <(argument_reporter_string_number) = (1)> then 
QuickSort %s %s
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000))
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat ([floor v] of ((length of [SortedList v]) / (2)) ::operators) 
set [Swap v] to (item (Idx) of [SortedList v])
replace item (Idx) of [SortedList v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
replace item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v] with [Swap]
change [Idx v] by (1)
end
replace item (item (1) of [SortedList v]) of [HistoryTable v] with ((item (item (1) of [SortedList v]) of [HistoryTable v]) + (((10) - (argument_reporter_string_number)) * ((10) - (argument_reporter_string_number))))
end
if <(argument_reporter_string_number) = (2)> then 
if <(1) = (0)> then 
QuickSortTemp %s %s
set [Idx v] to [1]
repeat (length of [SortedListTemp v]) 
set [CurrentIdx v] to (([abs v] of (item (Idx) of [SortedListTemp v]) ::operators) mod (10000))
repeat until <(length of [CurrentIdx]) > (3)> 
set [CurrentIdx v] to (join [0] [CurrentIdx])
end
replace item (item (1) of [MovesIdx v]) of [SortedList2 v] with (join (item (item (1) of [MovesIdx v]) of [SortedList2 v]) [CurrentIdx])
change [Idx v] by (1)
end
GetSubstring %s %n %n
replace item (SubstringRes) of [HistoryTable v] with ((item (SubstringRes) of [HistoryTable v]) + (((10) - (argument_reporter_string_number)) * ((10) - (argument_reporter_string_number))))
end
end

define CalculateOpeningMoves
delete (all) of [BestMoves v]
if <(IsImportedBoard) = (0)> then 
if <(IsPlayerBlack) = (0)> then 
set [Idx v] to [1]
 else 
set [Idx v] to (((length of [OpeningMoves v]) / (2)) + (1))
end
repeat ((length of [OpeningMoves v]) / (2)) 
if <(length of [GameMoves]) < (length of (item (Idx) of [OpeningMoves v]))> then 
set [IdxString v] to [1]
set [IsEqual v] to [1]
repeat (length of [GameMoves]) 
if <not <(letter (IdxString) of [GameMoves]) = (letter (IdxString) of (item (Idx) of [OpeningMoves v]))>> then 
set [IsEqual v] to [0]
end
change [IdxString v] by (1)
end
if <(IsEqual) = (1)> then 
set [BestMove v] to (letter ((length of [GameMoves]) + (1)) of (item (Idx) of [OpeningMoves v]))
set [BestMove v] to (join [BestMove] (letter ((length of [GameMoves]) + (2)) of (item (Idx) of [OpeningMoves v])))
set [BestMove v] to (join [BestMove] (letter ((length of [GameMoves]) + (3)) of (item (Idx) of [OpeningMoves v])))
set [BestMove v] to (join [BestMove] (letter ((length of [GameMoves]) + (4)) of (item (Idx) of [OpeningMoves v])))
add [BestMove] to [BestMoves v]
end
end
change [Idx v] by (1)
end
end

define GetXOR %n %n
set [XORA v] to (argument_reporter_string_number)
set [XORB v] to (argument_reporter_string_number)
set [XORVal v] to [1]
set [XORResult v] to [0]
repeat until <<(XORA) = (0)> and <(XORB) = (0)>> 
if <not <((XORA) mod (2)) = ((XORB) mod (2))>> then 
change [XORResult v] by (XORVal)
end
set [XORA v] to ([floor v] of ((XORA) / (2)) ::operators)
set [XORB v] to ([floor v] of ((XORB) / (2)) ::operators)
set [XORVal v] to ((XORVal) * (2))
end

define InitCoordLookup
delete (all) of [IdxToCol v]
delete (all) of [IdxToRow v]
set [Idx v] to [1]
repeat (64) 
add ((((Idx) - (1)) mod (8)) + (1)) to [IdxToCol v]
add ([ceiling v] of ((Idx) / (8)) ::operators) to [IdxToRow v]
change [Idx v] by (1)
end

define ImportBoard %s
set [Level3Depth v] to [2]
set [IsImportedBoard v] to [1]
set [HasWhiteKingMoved v] to [0]
set [HasBlackKingMoved v] to [0]
set [HasWhiteCastled v] to [0]
set [HasBlackCastled v] to [0]
set [HasWhiteRookKSMoved v] to [0]
set [HasWhiteRookQSMoved v] to [0]
set [HasBlackRookKSMoved v] to [0]
set [HasBlackRookQSMoved v] to [0]
set [GameMoves v] to []
delete (all) of [BoardHistory v]
delete (all) of [BoardHistoryHash v]
delete (all) of [GameMovesAN v]
set [IsFEN v] to [1]
set [IdxString v] to [1]
repeat (length of (argument_reporter_string_number)) 
if <(letter (IdxString) of (argument_reporter_string_number)) = (,)> then 
set [IsFEN v] to [0]
end
change [IdxString v] by (1)
end
if <(IsFEN) = (1)> then 
ImportBoardFEN %s
 else 
ImportBoardInternal %s
end
if <not <(item (item (1) of [VirtualBoard v]) of [Board v]) = (BlackRook)>> then 
set [HasBlackRookQSMoved v] to [1]
end
if <not <(item (item (5) of [VirtualBoard v]) of [Board v]) = (BlackKing)>> then 
set [HasBlackKingMoved v] to [1]
end
if <not <(item (item (8) of [VirtualBoard v]) of [Board v]) = (BlackRook)>> then 
set [HasBlackRookQSMoved v] to [1]
end
if <not <(item (item (57) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> then 
set [HasWhiteRookQSMoved v] to [1]
end
if <not <(item (item (61) of [VirtualBoard v]) of [Board v]) = (WhiteKing)>> then 
set [HasWhiteKingMoved v] to [1]
end
if <not <(item (item (64) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> then 
set [HasWhiteRookKSMoved v] to [1]
end

define CalculateMovesForSource %n %n %b %b
if <<(item (argument_reporter_string_number) of [Board v]) > (0)> or <argument_reporter_boolean>> then 
set [DoMoveOnWhite v] to [1]
 else 
set [DoMoveOnWhite v] to [0]
end
if <<(item (argument_reporter_string_number) of [Board v]) < (0)> or <argument_reporter_boolean>> then 
set [DoMoveOnBlack v] to [1]
 else 
set [DoMoveOnBlack v] to [0]
end
if <(item (argument_reporter_string_number) of [Board v]) = (BlackPawn)> then 
if <(item (argument_reporter_string_number) of [IdxToRow v]) < (8)> then 
if <(item (argument_reporter_string_number) of [IdxToCol v]) > (1)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <(item (argument_reporter_string_number) of [IdxToCol v]) < (8)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
if <(item (argument_reporter_string_number) of [IdxToRow v]) = (2)> then 
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <(item ((argument_reporter_string_number) + (8)) of [Board v]) = (Empty)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
 else 
if <(item (argument_reporter_string_number) of [IdxToRow v]) = (5)> then 
AddPossibleEnPassant %n %n %b
end
end
 else 
if <(item (argument_reporter_string_number) of [Board v]) = (WhitePawn)> then 
if <(item (argument_reporter_string_number) of [IdxToRow v]) > (1)> then 
if <(item (argument_reporter_string_number) of [IdxToCol v]) > (1)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <(item (argument_reporter_string_number) of [IdxToCol v]) < (8)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
if <(item (argument_reporter_string_number) of [IdxToRow v]) = (7)> then 
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <(item ((argument_reporter_string_number) - (8)) of [Board v]) = (Empty)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
 else 
if <(item (argument_reporter_string_number) of [IdxToRow v]) = (4)> then 
AddPossibleEnPassant %n %n %b
end
end
 else 
if <<(item (argument_reporter_string_number) of [Board v]) = (BlackKnight)> or <(item (argument_reporter_string_number) of [Board v]) = (WhiteKnight)>> then 
AddLookupMove %n %n %n %b %b %b %b %b
 else 
if <<(item (argument_reporter_string_number) of [Board v]) = (BlackKing)> or <(item (argument_reporter_string_number) of [Board v]) = (WhiteKing)>> then 
AddLookupMove %n %n %n %b %b %b %b %b
 else 
if <<<(item (argument_reporter_string_number) of [Board v]) = (BlackBishop)> or <(item (argument_reporter_string_number) of [Board v]) = (WhiteBishop)>> or <<(item (argument_reporter_string_number) of [Board v]) = (BlackQueen)> or <(item (argument_reporter_string_number) of [Board v]) = (WhiteQueen)>>> then 
AddLineMove %n %n %n %b %b %b %b %b
end
if <<<(item (argument_reporter_string_number) of [Board v]) = (BlackRook)> or <(item (argument_reporter_string_number) of [Board v]) = (WhiteRook)>> or <<(item (argument_reporter_string_number) of [Board v]) = (BlackQueen)> or <(item (argument_reporter_string_number) of [Board v]) = (WhiteQueen)>>> then 
AddLineMove %n %n %n %b %b %b %b %b
end
end
end
end
end

define ClearMoveList %n
if <(argument_reporter_string_number) = (20)> then 
delete (all) of [Moves20 v]
delete (all) of [Moves20Score v]
replace item (20) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (19)> then 
delete (all) of [Moves19 v]
delete (all) of [Moves19Score v]
replace item (19) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (18)> then 
delete (all) of [Moves18 v]
delete (all) of [Moves18Score v]
replace item (18) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (17)> then 
delete (all) of [Moves17 v]
delete (all) of [Moves17Score v]
replace item (17) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (16)> then 
delete (all) of [Moves16 v]
delete (all) of [Moves16Score v]
replace item (16) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (15)> then 
delete (all) of [Moves15 v]
delete (all) of [Moves15Score v]
replace item (15) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (14)> then 
delete (all) of [Moves14 v]
delete (all) of [Moves14Score v]
replace item (14) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (13)> then 
delete (all) of [Moves13 v]
delete (all) of [Moves13Score v]
replace item (13) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (12)> then 
delete (all) of [Moves12 v]
delete (all) of [Moves12Score v]
replace item (12) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (11)> then 
delete (all) of [Moves11 v]
delete (all) of [Moves11Score v]
replace item (11) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (10)> then 
delete (all) of [Moves10 v]
delete (all) of [Moves10Score v]
replace item (10) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (9)> then 
delete (all) of [Moves9 v]
delete (all) of [Moves9Score v]
replace item (9) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (8)> then 
delete (all) of [Moves8 v]
delete (all) of [Moves8Score v]
replace item (8) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (7)> then 
delete (all) of [Moves7 v]
delete (all) of [Moves7Score v]
replace item (7) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (6)> then 
delete (all) of [Moves6 v]
delete (all) of [Moves6Score v]
replace item (6) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (5)> then 
delete (all) of [Moves5 v]
delete (all) of [Moves5Score v]
replace item (5) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (4)> then 
delete (all) of [Moves4 v]
delete (all) of [Moves4Score v]
replace item (4) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (3)> then 
delete (all) of [Moves3 v]
delete (all) of [Moves3Score v]
replace item (3) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (2)> then 
delete (all) of [Moves2 v]
delete (all) of [Moves2Score v]
replace item (2) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [Moves1 v]
delete (all) of [Moves1Score v]
replace item (1) of [MovesCount v] with [0]
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end

define RUN_BEFORE_SAVING
delete (all) of [HashMoves2BoardScore v]
delete (all) of [HashMoves2Hash v]
delete (all) of [HashMoves2Age v]
delete (all) of [HashMovesChecked v]
delete (all) of [HashMovesHash v]
delete (all) of [HashMovesBestMove v]
delete (all) of [HashMovesScore v]
delete (all) of [HashMovesDepth v]
delete (all) of [HashMovesAge v]
delete (all) of [HashMovesType v]
delete (all) of [KillerMoves1 v]
delete (all) of [KillerMoves2 v]
delete (all) of [KillerMoves3 v]
delete (all) of [KillerMoves4 v]
delete (all) of [KillerMoves5 v]
delete (all) of [KillerMoves6 v]
delete (all) of [HistoryTable v]
delete (all) of [HashMovesHorizon v]
if <(1) = (0)> then 
delete (all) of [MoveLookupStraight v]
delete (all) of [MoveLookupCross v]
delete (all) of [MoveLookupOffsetsStraight v]
delete (all) of [MoveLookupOffsetsCross v]
delete (all) of [OpeningMoves v]
delete (all) of [KnightPieceSquare v]
delete (all) of [PawnPieceSquare v]
delete (all) of [BishopPieceSquare v]
delete (all) of [RookPieceSquare v]
delete (all) of [QueenPieceSquare v]
delete (all) of [KingPieceSquare v]
delete (all) of [KingPieceSquareEndgame v]
delete (all) of [OpeningMoves v]
delete (all) of [PawnPieceSquareEndgame v]
delete (all) of [PosPieceHashLookup v]
delete (all) of [BoardHistory v]
end

define GetMoveNotation %n
GetVirtualMove %n
set [MoveNotationRes v] to []
if <<(VirtualMove) = (BlackKingsideCastling)> or <(VirtualMove) = (WhiteKingsideCastling)>> then 
set [MoveNotationRes v] to [O-O]
stop [this script v]
end
if <<(VirtualMove) = (BlackQueensideCastling)> or <(VirtualMove) = (WhiteQueensideCastling)>> then 
set [MoveNotationRes v] to [O-O-O]
stop [this script v]
end
set [SourceIdx v] to ([floor v] of ((VirtualMove) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((VirtualMove) mod (100)) ::operators)
set [CurrentPiece v] to (item ([floor v] of ((argument_reporter_string_number) / (100)) ::operators) of [Board v])
if <<(CurrentPiece) = (BlackBishop)> or <(CurrentPiece) = (WhiteBishop)>> then 
set [MoveNotationRes v] to [B]
end
if <<(CurrentPiece) = (BlackKing)> or <(CurrentPiece) = (WhiteKing)>> then 
set [MoveNotationRes v] to [K]
end
if <<(CurrentPiece) = (BlackRook)> or <(CurrentPiece) = (WhiteRook)>> then 
set [MoveNotationRes v] to [R]
end
if <<(CurrentPiece) = (BlackKnight)> or <(CurrentPiece) = (WhiteKnight)>> then 
set [MoveNotationRes v] to [N]
end
if <<(CurrentPiece) = (WhiteQueen)> or <(CurrentPiece) = (BlackQueen)>> then 
set [MoveNotationRes v] to [Q]
end
set [X v] to (item (SourceIdx) of [IdxToCol v])
set [Y v] to ((9) - (item (SourceIdx) of [IdxToRow v]))
set [MoveNotationRes v] to (join [MoveNotationRes] (join (letter (X) of [abcdefgh]) [Y]))
if <not <(item ([floor v] of ((argument_reporter_string_number) mod (100)) ::operators) of [Board v]) = (Empty)>> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [x])
end
set [X v] to (item (TargetIdx) of [IdxToCol v])
set [Y v] to ((9) - (item (TargetIdx) of [IdxToRow v]))
if <((letter (5) of [VirtualMove]) = (.)) = (.1)> then 
if <(letter (6) of [VirtualMove]) = (1)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [Q])
end
if <(letter (6) of [VirtualMove]) = (2)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [R])
end
if <(letter (6) of [VirtualMove]) = (3)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [B])
end
if <(letter (6) of [VirtualMove]) = (4)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [N])
end
 else 
set [MoveNotationRes v] to (join [MoveNotationRes] (join (letter (X) of [abcdefgh]) [Y]))
end

define LoadList %s %s
set [IdxString v] to [1]
set [CurrentValue v] to []
repeat until <(IdxString) > (length of (argument_reporter_string_number))> 
if <<not <(letter (IdxString) of (argument_reporter_string_number)) = ( )>> and <not <(letter (IdxString) of (argument_reporter_string_number)) = (,)>>> then 
set [CurrentValue v] to (join [CurrentValue] (letter (IdxString) of (argument_reporter_string_number)))
end
if <<(letter (IdxString) of (argument_reporter_string_number)) = (,)> or <(IdxString) = (length of (argument_reporter_string_number))>> then 
if <(argument_reporter_string_number) = (PawnPieceSquare)> then 
add [CurrentValue] to [PawnPieceSquare v]
end
if <(argument_reporter_string_number) = (PawnPieceSquareEndgame)> then 
add [CurrentValue] to [PawnPieceSquareEndgame v]
end
if <(argument_reporter_string_number) = (PawnPieceSquareKingside)> then 
add [CurrentValue] to [PawnPieceSquareKingside v]
end
if <(argument_reporter_string_number) = (PawnPieceSquareQueenside)> then 
add [CurrentValue] to [PawnPieceSquareQueenside v]
end
if <(argument_reporter_string_number) = (KingPieceSquare)> then 
add [CurrentValue] to [KingPieceSquare v]
end
if <(argument_reporter_string_number) = (KingPieceSquareEndgame)> then 
add [CurrentValue] to [KingPieceSquareEndgame v]
end
if <(argument_reporter_string_number) = (QueenPieceSquare)> then 
add [CurrentValue] to [QueenPieceSquare v]
end
if <(argument_reporter_string_number) = (RookPieceSquare)> then 
add [CurrentValue] to [RookPieceSquare v]
end
if <(argument_reporter_string_number) = (BishopPieceSquare)> then 
add [CurrentValue] to [BishopPieceSquare v]
end
if <(argument_reporter_string_number) = (KnightPieceSquare)> then 
add [CurrentValue] to [KnightPieceSquare v]
end
if <(argument_reporter_string_number) = (KnightMobilityBonus)> then 
add ((CurrentValue) * (2)) to [KnightMobilityBonus v]
end
if <(argument_reporter_string_number) = (BishopMobilityBonus)> then 
add ((CurrentValue) * (2)) to [BishopMobilityBonus v]
end
if <(argument_reporter_string_number) = (RookMobilityBonus)> then 
add ((CurrentValue) * (2)) to [RookMobilityBonus v]
end
if <(argument_reporter_string_number) = (QueenMobilityBonus)> then 
add ((CurrentValue) * (2)) to [QueenMobilityBonus v]
end
if <(argument_reporter_string_number) = (PawnStormBlockedByKing)> then 
add [CurrentValue] to [PawnStormBlockedByKing v]
end
if <(argument_reporter_string_number) = (PawnStormBlockedByPawn)> then 
add [CurrentValue] to [PawnStormBlockedByPawn v]
end
if <(argument_reporter_string_number) = (PawnStormBlockedByNone)> then 
add [CurrentValue] to [PawnStormBlockedByNone v]
end
if <(argument_reporter_string_number) = (PawnShelterKingCol)> then 
add [CurrentValue] to [PawnShelterKingCol v]
end
if <(argument_reporter_string_number) = (PawnShelterNeighborCol)> then 
add [CurrentValue] to [PawnShelterNeighborCol v]
end
if <(argument_reporter_string_number) = (DeepeningScore2)> then 
add [CurrentValue] to [DeepeningScore2 v]
end
set [CurrentValue v] to []
end
change [IdxString v] by (1)
end

define AddPossibleEnPassantImpl %n %n %n %b
GetTargetIdx %n %n %n
if <not <(GetTargetIdxRes) = (-1)>> then 
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(item (GetTargetIdxRes) of [Board v]) = (WhitePawn)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(item (GetTargetIdxRes) of [Board v]) = (BlackPawn)>>> then 
set [IsEnPassantAllowed v] to [0]
if <((argument_reporter_string_number) mod (2)) = (1)> then 
set [EnPassantPrevMove v] to (join ((GetTargetIdxRes) + (16)) [GetTargetIdxRes])
 else 
set [EnPassantPrevMove v] to (join ((GetTargetIdxRes) - (16)) [GetTargetIdxRes])
end
GetSubstringRight %s %n
if <<(argument_reporter_string_number) = (1)> and <(SubstringRes) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (2)> and <<(SubstringRes) = (EnPassantPrevMove)> or <(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (EnPassantPrevMove)>>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (3)> and <(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (4)> and <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (5)> and <(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (6)> and <(item (item (5) of [MovesIdx v]) of [Moves5 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (7)> and <(item (item (6) of [MovesIdx v]) of [Moves6 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (8)> and <(item (item (7) of [MovesIdx v]) of [Moves7 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (9)> and <(item (item (8) of [MovesIdx v]) of [Moves8 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (10)> and <(item (item (9) of [MovesIdx v]) of [Moves9 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (11)> and <(item (item (10) of [MovesIdx v]) of [Moves10 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (12)> and <(item (item (11) of [MovesIdx v]) of [Moves11 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (13)> and <(item (item (12) of [MovesIdx v]) of [Moves12 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (14)> and <(item (item (13) of [MovesIdx v]) of [Moves13 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (15)> and <(item (item (14) of [MovesIdx v]) of [Moves14 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (16)> and <(item (item (15) of [MovesIdx v]) of [Moves15 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (17)> and <(item (item (16) of [MovesIdx v]) of [Moves16 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (18)> and <(item (item (17) of [MovesIdx v]) of [Moves17 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (19)> and <(item (item (18) of [MovesIdx v]) of [Moves18 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (20)> and <(item (item (19) of [MovesIdx v]) of [Moves19 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <(IsEnPassantAllowed) = (1)> then 
if <argument_reporter_boolean> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
replace item (GetTargetIdxRes) of [BoardAttackedByBlack v] with ((item (GetTargetIdxRes) of [BoardAttackedByBlack v]) + (1))
 else 
replace item (GetTargetIdxRes) of [BoardAttackedByWhite v] with ((item (GetTargetIdxRes) of [BoardAttackedByWhite v]) + (1))
end
 else 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
AddSpecialMove %s %n
 else 
AddSpecialMove %s %n
end
end
end
end
end

define GetCurrentMove %n
if <(argument_reporter_string_number) = (20)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves20 v])
 else 
if <(argument_reporter_string_number) = (19)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves19 v])
 else 
if <(argument_reporter_string_number) = (18)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves18 v])
 else 
if <(argument_reporter_string_number) = (17)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves17 v])
 else 
if <(argument_reporter_string_number) = (16)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves16 v])
 else 
if <(argument_reporter_string_number) = (15)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves15 v])
 else 
if <(argument_reporter_string_number) = (14)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves14 v])
 else 
if <(argument_reporter_string_number) = (13)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves13 v])
 else 
if <(argument_reporter_string_number) = (12)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves12 v])
 else 
if <(argument_reporter_string_number) = (11)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves11 v])
 else 
if <(argument_reporter_string_number) = (10)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves10 v])
 else 
if <(argument_reporter_string_number) = (9)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves9 v])
 else 
if <(argument_reporter_string_number) = (8)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves8 v])
 else 
if <(argument_reporter_string_number) = (7)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves7 v])
 else 
if <(argument_reporter_string_number) = (6)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves6 v])
 else 
if <(argument_reporter_string_number) = (5)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves5 v])
 else 
if <(argument_reporter_string_number) = (4)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves4 v])
 else 
if <(argument_reporter_string_number) = (3)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves3 v])
 else 
if <(argument_reporter_string_number) = (2)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves2 v])
 else 
if <(argument_reporter_string_number) = (1)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves1 v])
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end

define AddLookupMove %n %n %n %b %b %b %b %b
set [IdxOuter v] to (item (argument_reporter_string_number) of [MoveLookupIndexOffset v])
set [Count v] to [1]
repeat until <(Count) > (8)> 
if <(argument_reporter_string_number) = (LookupMoveTypeKnight)> then 
set [TargetIdxOuter v] to (item ((IdxOuter) + (Count)) of [MoveLookupKnight v])
 else 
if <(argument_reporter_string_number) = (LookupMoveTypeKing)> then 
set [TargetIdxOuter v] to (item ((IdxOuter) + (Count)) of [MoveLookupKing v])
 else 
set [TargetIdxOuter v] to [-1]
end
end
if <not <(TargetIdxOuter) = (-1)>> then 
if <<not <argument_reporter_boolean>> or <<<(item (argument_reporter_string_number) of [Board v]) > (0)> and <(item (TargetIdxOuter) of [Board v]) < (0)>> or <<(item (argument_reporter_string_number) of [Board v]) < (0)> and <(item (TargetIdxOuter) of [Board v]) > (0)>>>> then 
AddMoveImpl %n %n %n %b %b %b %b %b
end
change [Count v] by (1)
 else 
set [Count v] to [9]
end
end

define IsTwoKingDraw
set [TwoKingDrawRes v] to [1]
set [Idx v] to [1]
repeat (64) 
if <<not <(item (Idx) of [Board v]) = (Empty)>> and <<not <(item (Idx) of [Board v]) = (BlackKing)>> and <not <(item (Idx) of [Board v]) = (WhiteKing)>>>> then 
set [TwoKingDrawRes v] to [0]
end
change [Idx v] by (1)
end

define CalculateMoves %n
CalcBoardAttackedByMove %n
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [1]
CalculateMovesImpl %n %b %b
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [0]

define AddToMoveList %n %n
if <(argument_reporter_string_number) = (20)> then 
add (argument_reporter_string_number) to [Moves20 v]
add [0] to [Moves20Score v]
replace item (20) of [MovesCount v] with (length of [Moves20 v])
 else 
if <(argument_reporter_string_number) = (19)> then 
add (argument_reporter_string_number) to [Moves19 v]
add [0] to [Moves19Score v]
replace item (19) of [MovesCount v] with (length of [Moves19 v])
 else 
if <(argument_reporter_string_number) = (18)> then 
add (argument_reporter_string_number) to [Moves18 v]
add [0] to [Moves18Score v]
replace item (18) of [MovesCount v] with (length of [Moves18 v])
 else 
if <(argument_reporter_string_number) = (17)> then 
add (argument_reporter_string_number) to [Moves17 v]
add [] to [Moves17Score v]
replace item (17) of [MovesCount v] with (length of [Moves17 v])
 else 
if <(argument_reporter_string_number) = (16)> then 
add (argument_reporter_string_number) to [Moves16 v]
add [0] to [Moves16Score v]
replace item (16) of [MovesCount v] with (length of [Moves16 v])
 else 
if <(argument_reporter_string_number) = (15)> then 
add (argument_reporter_string_number) to [Moves15 v]
add [0] to [Moves15Score v]
replace item (15) of [MovesCount v] with (length of [Moves15 v])
 else 
if <(argument_reporter_string_number) = (14)> then 
add (argument_reporter_string_number) to [Moves14 v]
add [0] to [Moves14Score v]
replace item (14) of [MovesCount v] with (length of [Moves14 v])
 else 
if <(argument_reporter_string_number) = (13)> then 
add (argument_reporter_string_number) to [Moves13 v]
add [0] to [Moves13Score v]
replace item (13) of [MovesCount v] with (length of [Moves13 v])
 else 
if <(argument_reporter_string_number) = (12)> then 
add (argument_reporter_string_number) to [Moves12 v]
add [] to [Moves12Score v]
replace item (12) of [MovesCount v] with (length of [Moves12 v])
 else 
if <(argument_reporter_string_number) = (11)> then 
add (argument_reporter_string_number) to [Moves11 v]
add [0] to [Moves11Score v]
replace item (11) of [MovesCount v] with (length of [Moves11 v])
 else 
if <(argument_reporter_string_number) = (10)> then 
add (argument_reporter_string_number) to [Moves10 v]
add [0] to [Moves10Score v]
replace item (10) of [MovesCount v] with (length of [Moves10 v])
 else 
if <(argument_reporter_string_number) = (9)> then 
add (argument_reporter_string_number) to [Moves9 v]
add [0] to [Moves9Score v]
replace item (9) of [MovesCount v] with (length of [Moves9 v])
 else 
if <(argument_reporter_string_number) = (8)> then 
add (argument_reporter_string_number) to [Moves8 v]
add [0] to [Moves8Score v]
replace item (8) of [MovesCount v] with (length of [Moves8 v])
 else 
if <(argument_reporter_string_number) = (7)> then 
add (argument_reporter_string_number) to [Moves7 v]
add [0] to [Moves7Score v]
replace item (7) of [MovesCount v] with (length of [Moves7 v])
 else 
if <(argument_reporter_string_number) = (6)> then 
add (argument_reporter_string_number) to [Moves6 v]
add [0] to [Moves6Score v]
replace item (6) of [MovesCount v] with (length of [Moves6 v])
 else 
if <(argument_reporter_string_number) = (5)> then 
add (argument_reporter_string_number) to [Moves5 v]
add [0] to [Moves5Score v]
replace item (5) of [MovesCount v] with (length of [Moves5 v])
 else 
if <(argument_reporter_string_number) = (4)> then 
add (argument_reporter_string_number) to [Moves4 v]
add [0] to [Moves4Score v]
replace item (4) of [MovesCount v] with (length of [Moves4 v])
 else 
if <(argument_reporter_string_number) = (3)> then 
add (argument_reporter_string_number) to [Moves3 v]
add [0] to [Moves3Score v]
replace item (3) of [MovesCount v] with (length of [Moves3 v])
 else 
if <(argument_reporter_string_number) = (2)> then 
add (argument_reporter_string_number) to [Moves2 v]
add [0] to [Moves2Score v]
replace item (2) of [MovesCount v] with (length of [Moves2 v])
 else 
if <(argument_reporter_string_number) = (1)> then 
add (argument_reporter_string_number) to [Moves1 v]
add [0] to [Moves1Score v]
replace item (1) of [MovesCount v] with (length of [Moves1 v])
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end

define GetPosScore %n %n
set [PosScoreRes v] to [0]
if <<(argument_reporter_string_number) = (BlackPawn)> or <(argument_reporter_string_number) = (WhitePawn)>> then 
if <(IsEndgame) = (1)> then 
if <(argument_reporter_string_number) = (BlackPawn)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [PawnPieceSquareEndgame v])
 else 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [PawnPieceSquareEndgame v]))
end
 else 
if <(argument_reporter_string_number) = (BlackPawn)> then 
if <<(HasBlackCastled) = (0)> and <<(HasBlackKingMoved) = (0)> and <<(HasBlackRookKSMoved) = (0)> or <(HasBlackRookQSMoved) = (0)>>>> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [PawnPieceSquarePreCastling v])
 else 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [PawnPieceSquare v])
end
 else 
if <<(HasWhiteCastled) = (0)> and <<(HasWhiteKingMoved) = (0)> and <<(HasWhiteRookKSMoved) = (0)> or <(HasWhiteRookQSMoved) = (0)>>>> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [PawnPieceSquarePreCastling v]))
 else 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [PawnPieceSquare v]))
end
end
end
 else 
if <(IsEndgame) = (1)> then 
if <(argument_reporter_string_number) = (BlackKing)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [KingPieceSquareEndgame v])
 else 
if <(argument_reporter_string_number) = (WhiteKing)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [KingPieceSquareEndgame v]))
end
end
if <(IsEndgame2) = (1)> then 
set [PosScoreRes v] to ((PosScoreRes) * (2))
end
 else 
if <(argument_reporter_string_number) = (BlackKing)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [KingPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteKing)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [KingPieceSquare v]))
end
end
end
if <(argument_reporter_string_number) = (BlackKnight)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [KnightPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteKnight)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [KnightPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackBishop)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [BishopPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteBishop)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [BishopPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackRook)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [RookPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteRook)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [RookPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackQueen)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [QueenPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteQueen)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [QueenPieceSquare v]))
end
end
end
end
end
end
end
end
end

define ClearBoardAttackedByMove %n
set [IsBlackMove v] to ((argument_reporter_string_number) mod (2))
set [Idx v] to [1]
repeat (64) 
if <(IsBlackMove) = (1)> then 
replace item (Idx) of [BoardAttackedByBlack v] with [0]
replace item (Idx) of [BoardAttackedByBlackPiece v] with [0]
 else 
replace item (Idx) of [BoardAttackedByWhite v] with [0]
replace item (Idx) of [BoardAttackedByWhitePiece v] with [0]
end
change [Idx v] by (1)
end
if <(IsBlackMove) = (1)> then 
set [IsWhiteChecked v] to [0]
 else 
set [IsBlackChecked v] to [0]
end

define GetPosPieceHash %n %n
set [PosPieceHash v] to [0]
if <(argument_reporter_string_number) = (BlackBishop)> then 
set [PosPieceHash v] to (item (argument_reporter_string_number) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (BlackPawn)> then 
set [PosPieceHash v] to (item ((64) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (BlackQueen)> then 
set [PosPieceHash v] to (item ((128) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (BlackKing)> then 
set [PosPieceHash v] to (item ((192) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (BlackKnight)> then 
set [PosPieceHash v] to (item ((256) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (BlackRook)> then 
set [PosPieceHash v] to (item ((320) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhiteBishop)> then 
set [PosPieceHash v] to (item ((384) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhiteQueen)> then 
set [PosPieceHash v] to (item ((448) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhiteKing)> then 
set [PosPieceHash v] to (item ((512) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhitePawn)> then 
set [PosPieceHash v] to (item ((576) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhiteKnight)> then 
set [PosPieceHash v] to (item ((640) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
if <(argument_reporter_string_number) = (WhiteRook)> then 
set [PosPieceHash v] to (item ((704) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end

define DEPOT

define GetBestHashMove %s %s
set [BestHashMoveResult v] to [0]
set [BestHashMoveMoveResult v] to []
set [BestHashMoveScoreResult v] to []
set [BestHashMoveDepthResult v] to []
set [BestHashMoveTypeResult v] to []
set [BestHashMoveCheckedResult v] to []
set [BestHashMoveExistsCapture v] to []
set [BestHashMoveHorizonResult v] to []
set [CurrentIdx v] to [1]
set [HashBucket v] to (((argument_reporter_string_number) mod (length of [HashMovesHash v])) + (1))
repeat until <<(item (HashBucket) of [HashMovesHash v]) = (argument_reporter_string_number)> and <((item (HashBucket) of [HashMovesDepth v]) mod (2)) = ((argument_reporter_string_number) mod (2))>> 
change [HashBucket v] by (1)
if <(HashBucket) > (length of [HashMovesHash v])> then 
set [HashBucket v] to [1]
end
change [CurrentIdx v] by (1)
if <(CurrentIdx) > (10)> then 
stop [this script v]
end
end
set [BestHashMoveResult v] to [1]
set [BestHashMoveMoveResult v] to (item (HashBucket) of [HashMovesBestMove v])
set [BestHashMoveScoreResult v] to (item (HashBucket) of [HashMovesScore v])
set [BestHashMoveDepthResult v] to (item (HashBucket) of [HashMovesDepth v])
set [BestHashMoveTypeResult v] to (item (HashBucket) of [HashMovesType v])
set [BestHashMoveCheckedResult v] to (item (HashBucket) of [HashMovesChecked v])
set [BestHashMoveAgeResult v] to (item (HashBucket) of [HashMovesAge v])
set [BestHashMoveHorizonResult v] to (item (HashBucket) of [HashMovesHorizon v])
replace item (HashBucket) of [HashMovesAge v] with [HashMoveAge]

define InitMobilityBonusLookup
delete (all) of [QueenMobilityBonus v]
delete (all) of [BishopMobilityBonus v]
delete (all) of [RookMobilityBonus v]
delete (all) of [KnightMobilityBonus v]
LoadList %s %s
LoadList %s %s
LoadList %s %s
LoadList %s %s

define ClearLog
delete (all) of [Logfile v]

define Log %s %s %s %s %s %s %s %s
add (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (argument_reporter_string_number)))))))) to [Logfile v]

define InitAlphaBeta %n %n %b
if <(argument_reporter_string_number) = (1)> then 
set [IsInNullMove v] to [0]
set [IsInReduction v] to [0]
set [IsMinMaxTimeout v] to [0]
if <not <argument_reporter_boolean>> then 
Profile_Reset
end
change [HashMoveAge v] by (1)
set [CurrentMoveHash v] to [0]
set [Idx v] to [1]
repeat (64) 
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
change [Idx v] by (1)
end
delete (all) of [MinMaxPly1EvalMoves v]
set [BlackMinorCount v] to [0]
set [BlackQueenCount v] to [0]
set [WhiteQueenCount v] to [0]
set [WhiteMinorCount v] to [0]
set [Idx v] to [1]
repeat (64) 
if <(item (Idx) of [Board v]) = (WhiteQueen)> then 
change [WhiteQueenCount v] by (1)
end
if <(item (Idx) of [Board v]) = (BlackQueen)> then 
change [BlackQueenCount v] by (1)
end
if <<(item (Idx) of [Board v]) = (WhiteKnight)> or <<(item (Idx) of [Board v]) = (WhiteBishop)> or <(item (Idx) of [Board v]) = (WhiteRook)>>> then 
change [WhiteMinorCount v] by (1)
end
if <<(item (Idx) of [Board v]) = (BlackKnight)> or <<(item (Idx) of [Board v]) = (BlackBishop)> or <(item (Idx) of [Board v]) = (BlackRook)>>> then 
change [BlackMinorCount v] by (1)
end
change [Idx v] by (1)
end
set [IsEndgame v] to [0]
if <<(((WhiteQueenCount) * (9)) + ((WhiteMinorCount) * (4))) < (10)> or <(((BlackQueenCount) * (9)) + ((BlackMinorCount) * (4))) < (10)>> then 
set [IsEndgame v] to [1]
end
set [IsEndgame2 v] to [0]
if <<((WhiteQueenCount) + (WhiteMinorCount)) < (2)> or <((BlackQueenCount) + (BlackMinorCount)) < (2)>> then 
set [IsEndgame2 v] to [1]
end
if <(1) = (0)> then 
ClearLog
end
if <(IsScratch3) = (1)> then 
set [ExtendedEvaluationMaxDepth v] to [3]
if <(1) = (1)> then 
if <(argument_reporter_string_number) < ((3) + ((IsEndgame) * (1)))> then 
set [ExtendedEvaluationMaxDepth v] to (argument_reporter_string_number)
 else 
set [ExtendedEvaluationMaxDepth v] to ((3) + ((IsEndgame) * (1)))
end
end
 else 
set [ExtendedEvaluationMaxDepth v] to [4]
if <(1) = (1)> then 
if <(argument_reporter_string_number) < (((3) + (Level)) + ((IsEndgame) * (2)))> then 
set [ExtendedEvaluationMaxDepth v] to (argument_reporter_string_number)
 else 
set [ExtendedEvaluationMaxDepth v] to (((3) + (Level)) + ((IsEndgame) * (2)))
end
end
end
Log %s %s %s %s %s %s %s %s
end

define InitKingSquareEndgame
delete (all) of [KingPieceSquareEndgame v]
set [KingSquareDefEndgame v] to [  -30, -25, -20, -15, -15, -20, -25, -30 ,  -20, -15, -10, -5, -5, -10, -15, -20,   -15, -10, -5, 0, 0, -5, -10, -15,   -15, -10, -5, 0, 0, -5, -10, -15,   -15, -10, -5, 0, 0, -5, -10, -15,   -20, -15, -10, -5, -5, -10, -15, -20,   -25, -20, -15, -10, -10, -15, -20, -25,  -30, -25, -20, -15, -15, -20, -25, -30]
LoadList %s %s

define IsLowerCase %s
set [Chars v] to []
set [CharsIdx v] to [1]
repeat (length of [CharsUpperCase]) 
if <(letter (CharsIdx) of [CharsUpperCase]) = (argument_reporter_string_number)> then 
set [Chars v] to (join [Chars] (argument_reporter_string_number))
 else 
set [Chars v] to (join [Chars] (letter (CharsIdx) of [CharsUpperCase]))
end
change [CharsIdx v] by (1)
end
switch costume to (1 v)
switch costume to (3 v)
if <(costume [number v] ::looks) = (1)> then 
set [IsLowerCaseRes v] to [0]
 else 
set [IsLowerCaseRes v] to [1]
end

define ImportBoardInternal %s
set [Idx v] to [1]
set [IdxString v] to [1]
set [CurrentPiece v] to []
repeat until <(IdxString) > (length of (argument_reporter_string_number))> 
if <(letter (IdxString) of (argument_reporter_string_number)) = (,)> then 
replace item (Idx) of [Board v] with [CurrentPiece]
change [Idx v] by (1)
set [CurrentPiece v] to []
 else 
set [CurrentPiece v] to (join [CurrentPiece] (letter (IdxString) of (argument_reporter_string_number)))
end
change [IdxString v] by (1)
end
AddBoardToHistory
DrawBoardAndWait
set [IsGameSuspended v] to [0]

when i receive [import v]
ask [Please paste FEN data or GoK data into the text field for import from your clipboard via Ctrl-V] and wait
if <(length of (answer)) > (0)> then 
ImportBoard %s
end

when i receive [export v]
ExportBoardFEN
delete (all) of [ExportData v]
add [ExportDataFEN] to [ExportData v]
add [ExportDataFENLichess] to [ExportData v]
add (item (last) of [BoardHistory v]) to [ExportData v]
show list [ExportData v]
SayAsync %s %n

define InitPawnSquareEndgame
delete (all) of [PawnPieceSquareEndgame v]
set [PawnSquareDefEndgame v] to [ 100, 90, 80, 75, 75, 80, 90, 100,  65, 55, 45, 40, 40, 45, 55, 65,  35, 25, 15, 10, 10, 15, 25, 35,  20, 10, 0, -5, -5, 0, 10, 20,  10, 0, -10, -15, -15, -10, 0, 10,  5, -10, -20, -25, -25, -20, -10, 5,  5, -10, -20, -25, -25, -20, -10, 5,  0, 0, 0, 0, 0, 0, 0, 0]
LoadList %s %s

define ExportMovesPGN
set [ExportMovesPGN v] to []
set [Idx v] to [1]
repeat (length of [GameMovesAN v]) 
if <((Idx) mod (2)) = (1)> then 
set [ExportMovesPGN v] to (join [ExportMovesPGN] (join ((((Idx) - (1)) / (2)) + (1)) [. ]))
end
set [ExportMovesPGN v] to (join [ExportMovesPGN] (join (item (Idx) of [GameMovesAN v]) [ ]))
change [Idx v] by (1)
end

define UndoMove
if <(length of [GameMovesAN v]) > (0)> then 
GetSubstringRight %s %n
if <(item ([floor v] of ((SubstringRes) mod (100)) ::operators) of [Board v]) > (0)> then 
set [IsBlackMove v] to [1]
 else 
set [IsBlackMove v] to [0]
end
if <(IsBlackMove) = (0)> then 
UndoPrevMove
set [IsGameSuspended v] to [0]
 else 
if <(length of [GameMovesAN v]) > (1)> then 
UndoPrevMove
UndoPrevMove
set [IsGameSuspended v] to [0]
end
end
end

when i receive [showmoves v]
ExportMovesPGN
delete (all) of [ExportMoves v]
add [ExportMovesPGN] to [ExportMoves v]
show list [ExportMoves v]
SayAsync %s %n

define FillBoard
delete (all) of [VirtualBoard v]
delete (all) of [SwitchedBoard v]
set [Idx v] to [1]
repeat (64) 
if <(IsPlayerBlack) = (0)> then 
add [Idx] to [VirtualBoard v]
add [Idx] to [SwitchedBoard v]
 else 
add ((((item (Idx) of [IdxToRow v]) - (1)) * (8)) + ((9) - (item (Idx) of [IdxToCol v]))) to [VirtualBoard v]
add ((((item (Idx) of [IdxToRow v]) - (1)) * (8)) + ((9) - (item (Idx) of [IdxToCol v]))) to [SwitchedBoard v]
end
change [Idx v] by (1)
end
delete (all) of [Board v]
repeat (64) 
add [Empty] to [Board v]
end
replace item (item (1) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (2) of [VirtualBoard v]) of [Board v] with [BlackKnight]
replace item (item (3) of [VirtualBoard v]) of [Board v] with [BlackBishop]
replace item (item (4) of [VirtualBoard v]) of [Board v] with [BlackQueen]
replace item (item (5) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (6) of [VirtualBoard v]) of [Board v] with [BlackBishop]
replace item (item (7) of [VirtualBoard v]) of [Board v] with [BlackKnight]
replace item (item (8) of [VirtualBoard v]) of [Board v] with [BlackRook]
set [Idx v] to [9]
repeat (8) 
replace item (item (Idx) of [VirtualBoard v]) of [Board v] with [BlackPawn]
change [Idx v] by (1)
end
set [Idx v] to [49]
repeat (8) 
replace item (item (Idx) of [VirtualBoard v]) of [Board v] with [WhitePawn]
change [Idx v] by (1)
end
replace item (item (57) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (58) of [VirtualBoard v]) of [Board v] with [WhiteKnight]
replace item (item (59) of [VirtualBoard v]) of [Board v] with [WhiteBishop]
replace item (item (60) of [VirtualBoard v]) of [Board v] with [WhiteQueen]
replace item (item (61) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (62) of [VirtualBoard v]) of [Board v] with [WhiteBishop]
replace item (item (63) of [VirtualBoard v]) of [Board v] with [WhiteKnight]
replace item (item (64) of [VirtualBoard v]) of [Board v] with [WhiteRook]

when i receive [undo v]
UndoMove
say []

define GetVirtualMove %n
if <(IsPlayerBlack) = (0)> then 
set [VirtualMove v] to (argument_reporter_string_number)
 else 
if <<not <(argument_reporter_string_number) < (0100)>> and <not <(argument_reporter_string_number) > (6499)>>> then 
set [VirtualMove v] to ((65) - ([floor v] of ((argument_reporter_string_number) mod (100)) ::operators))
repeat until <(length of [VirtualMove]) > (1)> 
set [VirtualMove v] to (join [0] [VirtualMove])
end
set [VirtualMove v] to (join ((65) - ([floor v] of ((argument_reporter_string_number) / (100)) ::operators)) [VirtualMove])
repeat until <(length of [VirtualMove]) > (3)> 
set [VirtualMove v] to (join [0] [VirtualMove])
end
if <(letter (5) of (argument_reporter_string_number)) = (.)> then 
set [VirtualMove v] to (join [VirtualMove] (join (letter (5) of (argument_reporter_string_number)) (letter (6) of (argument_reporter_string_number))))
end
 else 
if <(argument_reporter_string_number) = (BlackKingsideCastling)> then 
set [VirtualMove v] to [WhiteKingsideCastling]
 else 
if <(argument_reporter_string_number) = (BlackQueensideCastling)> then 
set [VirtualMove v] to [WhiteQueensideCastling]
 else 
if <(argument_reporter_string_number) = (WhiteKingsideCastling)> then 
set [VirtualMove v] to [BlackKingsideCastling]
 else 
if <(argument_reporter_string_number) = (WhiteQueensideCastling)> then 
set [VirtualMove v] to [BlackQueensideCastling]
end
end
end
end
end
end

define HashOnMoveScore %s %s %s %s %s %s %s
set [HashBucket v] to (((argument_reporter_string_number) mod (length of [HashMovesHash v])) + (1))
set [CurrentIdx v] to [1]
repeat until <<<(length of (item (HashBucket) of [HashMovesHash v])) = (0)> or <<(item (HashBucket) of [HashMovesHash v]) = (argument_reporter_string_number)> and <((item (HashBucket) of [HashMovesDepth v]) mod (2)) = ((argument_reporter_string_number) mod (2))>>> or <(item (CurrentIdx) of [HashMovesAge v]) < ((HashMoveAge) - (2))>> 
change [HashBucket v] by (1)
if <(HashBucket) > (length of [HashMovesHash v])> then 
set [HashBucket v] to [1]
end
change [CurrentIdx v] by (1)
if <(CurrentIdx) > (10)> then 
stop [this script v]
end
end
replace item (HashBucket) of [HashMovesAge v] with [HashMoveAge]
if <<(argument_reporter_string_number) = (item (HashBucket) of [HashMovesHash v])> and <((argument_reporter_string_number) mod (2)) = ((item (HashBucket) of [HashMovesDepth v]) mod (2))>> then 
if <not <(argument_reporter_string_number) = (1)>> then 
if <(argument_reporter_string_number) < (item (HashBucket) of [HashMovesHorizon v])> then 
stop [this script v]
end
if <if <<not <(argument_reporter_string_number) = (E)>> and <(item (HashBucket) of [HashMovesType v]) = (E)>> then 
stop [this script v]
end> then 
(argument_reporter_string_number) = (item (HashBucket) of [HashMovesHorizon v])
end
if <<(argument_reporter_string_number) = ()> and <not <(item (HashBucket) of [HashMovesBestMove v]) = ()>>> then 
stop [this script v]
end
end
end
replace item (HashBucket) of [HashMovesHash v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesDepth v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesScore v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesType v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesChecked v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesHorizon v] with (argument_reporter_string_number)
replace item (HashBucket) of [HashMovesBestMove v] with (argument_reporter_string_number)

define ExecuteInit
set [ExecutionDepth v] to [0]
set [IsExecutionRunning v] to [0]
EnterExecution
if <(IsPlayerBlack) = (1)> then 
ExecuteEngineMove
end
ExecuteMovePostProcess
ExitExecution

define ExecuteEngineMove
EnterExecution
if <(IsGameSuspended) = (0)> then 
delete (all) of [BestMoves v]
CalculateOpeningMoves
set [BestMove v] to (item (pick random (1) to (length of [BestMoves v])) of [BestMoves v])
IsValidMove %n
if <(ValidMoveRes) = (0)> then 
think [Thinking...]
wait (0) seconds
if <(IsModeJunior) = (0)> then 
if <(Level) = (1)> then 
set [ThinkTimeLimit v] to [5]
 else 
if <(Level) = (2)> then 
set [ThinkTimeLimit v] to [15]
 else 
if <(IsModeCompetition) = (0)> then 
if <(IsEndgame) = (0)> then 
set [ThinkTimeLimit v] to [30]
 else 
set [ThinkTimeLimit v] to [15]
end
 else 
set [ThinkTimeLimit v] to [60]
end
end
end
set [ThinkTimeStart v] to (timer)
set [IsDeepeningDone v] to [0]
set [IdxDeepening v] to [2]
set [BestMove v] to []
set [BestMinMaxRes v] to []
set [ProgressPaintEnabled v] to [1]
repeat until <(IsDeepeningDone) = (1)> 
set [QuiescenceDepth v] to ((20) - (IdxDeepening))
if <(IdxDeepening) > (2)> then 
set [ThinkTimeLimitMinMax v] to [ThinkTimeLimit]
 else 
set [ThinkTimeLimitMinMax v] to [60]
end
if <<(IdxDeepening) > (2)> and <<(IsEndgame2) = (0)> or <(1) = (1)>>> then 
if <(IsScratch3) = (1)> then 
if <((IdxDeepening) mod (2)) = (0)> then 
set [PruningAlphaWindow v] to [70]
set [PruningBetaWindow v] to [30]
 else 
set [PruningAlphaWindow v] to [30]
set [PruningBetaWindow v] to [70]
end
 else 
if <((IdxDeepening) mod (2)) = (0)> then 
set [PruningAlphaWindow v] to [40]
set [PruningBetaWindow v] to [20]
 else 
set [PruningAlphaWindow v] to [20]
set [PruningBetaWindow v] to [40]
end
end
set [IsDone v] to [0]
repeat until <<(IsDone) = (1)> or <(IsMinMaxTimeout) = (1)>> 
set [PruningAlpha v] to ((BestMinMaxRes) - (PruningAlphaWindow))
set [PruningBeta v] to ((BestMinMaxRes) + (PruningBetaWindow))
delete (all) of [BestMoves v]
AlphaBetaMinMax %n %n %n %n %b %b %n %b
if <not <(item (1) of [MinMaxResults v]) > (PruningAlpha)>> then 
change [HashMoveAge v] by (-1)
delete (all) of [BestMoves v]
if <<(PruningAlphaWindow) > (0)> or <(IsEndgame) = (1)>> then 
set [PruningAlphaWindow v] to [100000]
 else 
set [PruningAlphaWindow v] to ((PruningAlphaWindow) * (3))
end
 else 
if <not <(item (1) of [MinMaxResults v]) < (PruningBeta)>> then 
change [HashMoveAge v] by (-1)
delete (all) of [BestMoves v]
if <<(PruningBetaWindow) > (0)> or <(IsEndgame) = (1)>> then 
set [PruningBetaWindow v] to [100000]
 else 
set [PruningBetaWindow v] to ((PruningBetaWindow) * (3))
end
 else 
set [IsDone v] to [1]
end
end
end
 else 
delete (all) of [BestMoves v]
AlphaBetaMinMax %n %n %n %n %b %b %n %b
end
if <<(length of [BestMoves v]) > (0)> and <(length of (item (1) of [BestMoves v])) > (0)>> then 
if <<<(BestMove) = ()> or <[MinMaxPly1EvalMoves v] contains [BestMove] ? ::lists>> or <(1) = (0)>> then 
set [BestMove v] to (item (1) of [BestMoves v])
set [BestMinMaxRes v] to (item (1) of [BestMinMaxResults v])
GetCurrentMoveHash
HashOnMoveScore %s %s %s %s %s %s %s
end
end
if <<(IsMinMaxTimeout) = (1)> or <<<(BestMinMaxRes) > ((BlackKing) / (2))> or <(BestMinMaxRes) < ((WhiteKing) / (2))>> or <(IdxDeepening) = (20)>>> then 
set [IsDeepeningDone v] to [1]
 else 
change [IdxDeepening v] by (1)
end
end
 else 
delete (all) of [BestMoves v]
if <(Level) = (1)> then 
set [JuniorDistQuota v] to [10]
set [JuniorSearchQuota v] to [0]
 else 
if <(Level) = (2)> then 
set [JuniorDistQuota v] to [5]
set [JuniorSearchQuota v] to [50]
 else 
set [JuniorDistQuota v] to [1]
set [JuniorSearchQuota v] to [100]
end
end
set [ThinkTimeStart v] to (timer)
set [ThinkTimeLimitMinMax v] to [2]
AlphaBetaMinMax %n %n %n %n %b %b %n %b
set [BestMove v] to (item (1) of [BestMoves v])
if <<(BestMove) = ()> or <(pick random (1) to (100)) > (JuniorSearchQuota)>> then 
CalculateMoves %n
CutoffReorder %n %b
replace item (1) of [MovesIdx v] with (pick random (1) to ([ceiling v] of ((length of [Moves1 v]) * ((JuniorDistQuota) / (100))) ::operators))
ApplyMove %n
CalcBoardAttackedByMove %n
RevertMove %n
repeat until <(IsBlackChecked) = (0)> 
replace item (1) of [MovesIdx v] with (pick random (1) to (length of [Moves1 v]))
ApplyMove %n
CalcBoardAttackedByMove %n
RevertMove %n
end
set [BestMove v] to (item (item (1) of [MovesIdx v]) of [Moves1 v])
end
end
end
broadcast (1 v) and wait
OnProgressChanged %n
wait (0) seconds
IsValidMove %n
if <(ValidMoveRes) = (0)> then 
say (join [Internal Error: No valid move found. Sorry, this should not happen. Maybe you cleared lookup lists in the editor? If you are running a normal game, please export board data and report bug via project comment] (join [ Move: ] [BestMove])) for (10) seconds
broadcast (1 v)
set [IsGameSuspended v] to [1]
ExecuteMovePostProcess
ExitExecution
stop [this script v]
end
think []
GetMoveNotation %n
set [BestMoveAN v] to [MoveNotationRes]
set [GameMoves v] to (join [GameMoves] [BestMove])
set [MovePieceFromIdx v] to ([floor v] of ((BestMove) / (100)) ::operators)
set [MovePieceToIdx v] to ([floor v] of ((BestMove) mod (100)) ::operators)
if <<<(BestMove) = (BlackQueensideCastling)> or <(BestMove) = (BlackKingsideCastling)>> or <<(BestMove) = (WhiteQueensideCastling)> or <(BestMove) = (WhiteKingsideCastling)>>> then 
set [MovePieceSpecial v] to [BestMove]
 else 
set [MovePieceSpecial v] to []
end
wait (0) seconds
broadcast (1 v) and wait
broadcast (1 v)
delete (all) of [Moves1 v]
add [BestMove] to [Moves1 v]
replace item (1) of [MovesIdx v] with [1]
replace item (1) of [MovesCount v] with [1]
ApplyMove %n
DrawBoardAndWait
AddBoardToHistory
add [BestMoveAN] to [GameMovesAN v]
GetRepetitionCount
if <(RepetitionCountRes) > (2)> then 
say [Draw!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
IsTwoKingDraw
if <(TwoKingDrawRes) = (1)> then 
say [Draw!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
IsWhiteKingCheckMate
if <(IsWhiteKingCheckMateRes) = (1)> then 
say [Checkmate!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
IsDraw %n
if <(IsDrawRes) = (1)> then 
say [Draw!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
SayAsync %s %n
broadcast (1 v)
end
if <(item ((BestMove) mod (100)) of [Board v]) = (BlackKing)> then 
set [HasBlackKingMoved v] to [1]
end
if <(item ((BestMove) mod (100)) of [Board v]) = (BlackRook)> then 
if <([floor v] of ((BestMove) / (100)) ::operators) = (item (1) of [VirtualBoard v])> then 
set [HasBlackRookQSMoved v] to [1]
end
if <([floor v] of ((BestMove) / (100)) ::operators) = (item (8) of [VirtualBoard v])> then 
set [HasBlackRookKSMoved v] to [1]
end
end
if <<(BestMove) = (BlackQueensideCastling)> or <(BestMove) = (BlackKingsideCastling)>> then 
set [HasBlackKingMoved v] to [1]
set [HasBlackCastled v] to [1]
end
end
end
end
end
end
ExecuteMovePostProcess
ExitExecution

define ExecuteMovePostProcess
set [MoveFromIdx v] to [-1]
set [MoveToIdx v] to [-1]
set [FromSquareIdx v] to [-1]
set [ToSquareIdx v] to [-1]
broadcast (1 v) and wait
broadcast (1 v) and wait
broadcast (1 v) and wait

when i receive [usermove v]
ExecuteUserMove

when i receive [startgame v]
set [MoveFromIdx v] to [-1]
set [MoveToIdx v] to [-1]
go to x: (240) y: (80)
InitBoard
DrawBoardAndWait
ExecuteInit
if <(IsFlash30Bug) = (0)> then 
SayAsync %s %n
 else 
SayAsync %s %n
end

define ExecuteUserMove
EnterExecution
if <(IsGameSuspended) = (0)> then 
if <<(item (MoveFromIdx) of [Board v]) < (0)> and <not <(MoveFromIdx) = (MoveToIdx)>>> then 
set [UserMove v] to []
if <<(item (MoveFromIdx) of [Board v]) = (WhiteKing)> and <(MoveFromIdx) = (item (61) of [VirtualBoard v])>> then 
if <<(MoveToIdx) = (item (59) of [VirtualBoard v])> and <(item (item (57) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> then 
CalculateMoves %n
if <[Moves2 v] contains [WhiteQueensideCastling] ? ::lists> then 
set [UserMove v] to [WhiteQueensideCastling]
 else 
set [UserMove v] to [6159]
end
end
if <<(MoveToIdx) = (item (63) of [VirtualBoard v])> and <(item (item (64) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> then 
CalculateMoves %n
if <[Moves2 v] contains [WhiteKingsideCastling] ? ::lists> then 
set [UserMove v] to [WhiteKingsideCastling]
 else 
set [UserMove v] to [6163]
end
end
end
if <(UserMove) = ()> then 
set [UserMove v] to (((MoveFromIdx) * (100)) + (MoveToIdx))
if <(length of [UserMove]) = (3)> then 
set [UserMove v] to (join [0] [UserMove])
end
if <<(item (MoveFromIdx) of [Board v]) = (WhitePawn)> and <(MoveFromIdx) < (17)>> then 
set [UserMove v] to (join [UserMove] [.1])
end
end
set [MovePieceFromIdx v] to [MoveFromIdx]
set [MovePieceToIdx v] to [MoveToIdx]
if <<<(UserMove) = (BlackQueensideCastling)> or <(UserMove) = (BlackKingsideCastling)>> or <<(UserMove) = (WhiteQueensideCastling)> or <(UserMove) = (WhiteKingsideCastling)>>> then 
set [MovePieceSpecial v] to [UserMove]
 else 
set [MovePieceSpecial v] to []
end
broadcast (1 v) and wait
broadcast (1 v)
set [FromSquareIdx v] to [-1]
set [ToSquareIdx v] to [-1]
broadcast (1 v) and wait
broadcast (1 v) and wait
CalculateMoves %n
if <not <[Moves2 v] contains [UserMove] ? ::lists>> then 
delete (all) of [Moves2 v]
add [UserMove] to [Moves2 v]
replace item (2) of [MovesIdx v] with [1]
replace item (2) of [MovesCount v] with [1]
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
SayAsync %s %n
broadcast (1 v)
 else 
SayAsync %s %n
broadcast (1 v)
end
RevertMove %n
DrawBoardAndWait
 else 
if <not <(UserMove) = ([floor v] of (UserMove) ::operators)>> then 
say [Please select promotion piece]
broadcast (1 v) and wait
broadcast (1 v) and wait
broadcast (1 v) and wait
say []
if <(SelectedPromotionPiece) = (WhiteQueen)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.1])
 else 
if <(SelectedPromotionPiece) = (WhiteRook)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.2])
 else 
if <(SelectedPromotionPiece) = (WhiteBishop)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.3])
 else 
if <(SelectedPromotionPiece) = (WhiteKnight)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.4])
end
end
end
end
repeat until <(length of [UserMove]) > (5)> 
set [UserMove v] to (join [0] [UserMove])
end
end
GetMoveNotation %n
delete (all) of [Moves2 v]
add [UserMove] to [Moves2 v]
replace item (2) of [MovesIdx v] with [1]
replace item (2) of [MovesCount v] with [1]
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
RevertMove %n
DrawBoardAndWait
SayAsync %s %n
broadcast (1 v)
 else 
think [Thinking...]
DrawBoardAndWait
wait (0) seconds
broadcast (1 v) and wait
set [UserMoveAN v] to [MoveNotationRes]
add [UserMoveAN] to [GameMovesAN v]
set [GameMoves v] to (join [GameMoves] [UserMove])
AddBoardToHistory
IsBlackKingCheckMate
if <(IsBlackKingCheckMateRes) = (1)> then 
say [Checkmate!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
IsDraw %n
if <(IsDrawRes) = (1)> then 
say [Draw!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
GetRepetitionCount
if <(RepetitionCountRes) > (2)> then 
say [Draw!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
IsTwoKingDraw
if <(TwoKingDrawRes) = (1)> then 
say [Draw!]
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
if <(item ((UserMove) mod (100)) of [Board v]) = (WhiteKing)> then 
set [HasWhiteKingMoved v] to [1]
end
if <(item ((UserMove) mod (100)) of [Board v]) = (WhiteRook)> then 
if <([floor v] of ((UserMove) / (100)) ::operators) = (item (57) of [VirtualBoard v])> then 
set [HasWhiteRookQSMoved v] to [1]
end
if <([floor v] of ((UserMove) / (100)) ::operators) = (item (64) of [VirtualBoard v])> then 
set [HasWhiteRookKSMoved v] to [1]
end
end
if <<(UserMove) = (WhiteQueensideCastling)> or <(UserMove) = (WhiteKingsideCastling)>> then 
set [HasWhiteCastled v] to [1]
set [HasWhiteKingMoved v] to [1]
end
ExecuteEngineMove
end
end
end
end
end
end
end
end
ExecuteMovePostProcess
ExitExecution

when i receive [sayasyncmsg v]
say [SayAsyncText] for (SayAsyncDuration) seconds

define SayAsync %s %n
set [SayAsyncText v] to (argument_reporter_string_number)
set [SayAsyncDuration v] to (argument_reporter_string_number)
broadcast (1 v)

define EnterExecution
change [ExecutionDepth v] by (1)
if <(ExecutionDepth) > (0)> then 
set [IsExecutionRunning v] to [1]
end

define ExitExecution
change [ExecutionDepth v] by (-1)
if <not <(ExecutionDepth) > (0)>> then 
set [IsExecutionRunning v] to [0]
end

when i receive [levelchanged v]
if <<(Level) = (3)> and <(IsModeJunior) = (0)>> then 
SayAsync %s %n
 else 
say []
end

define GetSEEMapVal %n
set [SEEMapValRes v] to [0]
set [CurrentPieceSub v] to ([abs v] of (argument_reporter_string_number) ::operators)
if <(CurrentPieceSub) = (BlackPawn)> then 
set [SEEMapValRes v] to [100000]
 else 
if <(CurrentPieceSub) = (BlackKnight)> then 
set [SEEMapValRes v] to [10000]
 else 
if <(CurrentPieceSub) = (BlackBishop)> then 
set [SEEMapValRes v] to [1000]
 else 
if <(CurrentPieceSub) = (BlackRook)> then 
set [SEEMapValRes v] to [100]
 else 
if <(CurrentPieceSub) = (BlackQueen)> then 
set [SEEMapValRes v] to [10]
 else 
if <(CurrentPieceSub) = (BlackKing)> then 
set [SEEMapValRes v] to [1]
end
end
end
end
end
end

define GetSEEPiece %n %n
set [SEEPieceRes v] to [Empty]
if <not <(argument_reporter_string_number) < (100000)>> then 
set [SEEPieceRes v] to [BlackPawn]
 else 
if <not <(argument_reporter_string_number) < (10000)>> then 
set [SEEPieceRes v] to [BlackKnight]
 else 
if <not <(argument_reporter_string_number) < (1000)>> then 
set [SEEPieceRes v] to [BlackBishop]
 else 
if <not <(argument_reporter_string_number) < (100)>> then 
set [SEEPieceRes v] to [BlackRook]
 else 
if <not <(argument_reporter_string_number) < (10)>> then 
set [SEEPieceRes v] to [BlackQueen]
 else 
if <not <(argument_reporter_string_number) < (1)>> then 
set [SEEPieceRes v] to [BlackKing]
end
end
end
end
end
end
if <((argument_reporter_string_number) mod (2)) = (0)> then 
set [SEEPieceRes v] to ((0) - (SEEPieceRes))
end

define ExportBoardFEN
set [ExportDataFEN v] to []
set [ExportDataFENLichess v] to [https://lichess.org/analysis/]
set [Idx v] to [1]
repeat until <(Idx) > (64)> 
if <(IsPlayerBlack) = (0)> then 
set [CurrentPiece v] to (item (Idx) of [Board v])
 else 
set [CurrentPiece v] to ((0) - (item ((65) - (Idx)) of [Board v]))
end
if <(CurrentPiece) = (BlackPawn)> then 
set [CurrentValue v] to [p]
end
if <(CurrentPiece) = (BlackKnight)> then 
set [CurrentValue v] to [n]
end
if <(CurrentPiece) = (BlackBishop)> then 
set [CurrentValue v] to [b]
end
if <(CurrentPiece) = (BlackRook)> then 
set [CurrentValue v] to [r]
end
if <(CurrentPiece) = (BlackQueen)> then 
set [CurrentValue v] to [q]
end
if <(CurrentPiece) = (BlackKing)> then 
set [CurrentValue v] to [k]
end
if <(CurrentPiece) = (WhitePawn)> then 
set [CurrentValue v] to [P]
end
if <(CurrentPiece) = (WhiteKnight)> then 
set [CurrentValue v] to [N]
end
if <(CurrentPiece) = (WhiteBishop)> then 
set [CurrentValue v] to [B]
end
if <(CurrentPiece) = (WhiteRook)> then 
set [CurrentValue v] to [R]
end
if <(CurrentPiece) = (WhiteQueen)> then 
set [CurrentValue v] to [Q]
end
if <(CurrentPiece) = (WhiteKing)> then 
set [CurrentValue v] to [K]
end
if <(CurrentPiece) = (Empty)> then 
set [IdxSub v] to [Idx]
repeat until <<((IdxSub) mod (8)) = (0)> or <<<(IsPlayerBlack) = (0)> and <not <(item ((IdxSub) + (1)) of [Board v]) = (Empty)>>> or <<(IsPlayerBlack) = (1)> and <not <(item ((65) - ((IdxSub) + (1))) of [Board v]) = (Empty)>>>>> 
change [IdxSub v] by (1)
end
set [CurrentValue v] to (((IdxSub) - (Idx)) + (1))
change [Idx v] by ((IdxSub) - (Idx))
end
set [ExportDataFEN v] to (join [ExportDataFEN] [CurrentValue])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [CurrentValue])
if <<((Idx) mod (8)) = (0)> and <(Idx) < (64)>> then 
set [ExportDataFEN v] to (join [ExportDataFEN] [/])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [/])
end
change [Idx v] by (1)
end
if <(IsPlayerBlack) = (0)> then 
set [ExportDataFEN v] to (join [ExportDataFEN] [ w])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [_w])
 else 
set [ExportDataFEN v] to (join [ExportDataFEN] [ b])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [_b])
end

define SEEImpl (Currently not used)
set [SEEMapValWhite v] to (item (argument_reporter_string_number) of [BoardAttackedByWhitePiece v])
set [SEEMapValBlack v] to (item (argument_reporter_string_number) of [BoardAttackedByBlackPiece v])
if <((argument_reporter_string_number) mod (2)) = (0)> then 
set [SEEPieceWhite v] to (argument_reporter_string_number)
set [SEEPieceBlack v] to [Empty]
if <<not <(argument_reporter_string_number) = (WhitePawn)>> or <not <(item (argument_reporter_string_number) of [IdxToCol v]) = (item (argument_reporter_string_number) of [IdxToCol v])>>> then 
GetSEEMapVal %n
change [SEEMapValWhite v] by ((0) - (SEEMapValRes))
end
 else 
set [SEEPieceBlack v] to (argument_reporter_string_number)
set [SEEPieceWhite v] to [Empty]
if <<not <(argument_reporter_string_number) = (BlackPawn)>> or <not <(item (argument_reporter_string_number) of [IdxToCol v]) = (item (argument_reporter_string_number) of [IdxToCol v])>>> then 
GetSEEMapVal %n
change [SEEMapValBlack v] by ((0) - (SEEMapValRes))
end
end
set [SEEMoveDepth v] to ((argument_reporter_string_number) + (1))
if <<<((SEEMoveDepth) mod (2)) = (0)> and <(SEEMapValWhite) > (0)>> or <<((SEEMoveDepth) mod (2)) = (1)> and <(SEEMapValBlack) > (0)>>> then 
if <((SEEMoveDepth) mod (2)) = (0)> then 
GetSEEPiece %n %n
set [SEEPieceWhite v] to [SEEPieceRes]
GetSEEMapVal %n
change [SEEMapValWhite v] by ((0) - (SEEMapValRes))
change [MoveScoreRes v] by ((0) - (SEEPieceBlack))
 else 
GetSEEPiece %n %n
set [SEEPieceBlack v] to [SEEPieceRes]
GetSEEMapVal %n
change [SEEMapValBlack v] by ((0) - (SEEMapValRes))
change [MoveScoreRes v] by ((0) - (SEEPieceWhite))
end
change [SEEMoveDepth v] by (1)
end

define IsValidMove %n
set [ValidMoveRes v] to [1]
if <<<(argument_reporter_string_number) < (0)> or <(argument_reporter_string_number) > (9999)>> or <<<([floor v] of ((argument_reporter_string_number) / (100)) ::operators) = (0)> or <([floor v] of ((argument_reporter_string_number) mod (100)) ::operators) = (0)>> and <not <<<(argument_reporter_string_number) = (BlackQueensideCastling)> or <(argument_reporter_string_number) = (BlackKingsideCastling)>> or <<(argument_reporter_string_number) = (WhiteQueensideCastling)> or <(argument_reporter_string_number) = (WhiteKingsideCastling)>>>>>> then 
set [ValidMoveRes v] to [0]
end

define IsBlackKingCheckMate
set [IsBlackKingCheckMateRes v] to [0]
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (1)> then 
set [IsBlackKingCheckMateRes v] to [1]
CalculateMoves %n
replace item (1) of [MovesIdx v] with [1]
repeat (item (1) of [MovesCount v]) 
if <(IsBlackKingCheckMateRes) = (1)> then 
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (0)> then 
set [IsBlackKingCheckMateRes v] to [0]
end
RevertMove %n
end
replace item (1) of [MovesIdx v] with ((item (1) of [MovesIdx v]) + (1))
end
end

define IsWhiteKingCheckMate
set [IsWhiteKingCheckMateRes v] to [0]
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
set [IsWhiteKingCheckMateRes v] to [1]
CalculateMoves %n
replace item (2) of [MovesIdx v] with [1]
repeat (item (2) of [MovesCount v]) 
if <(IsWhiteKingCheckMateRes) = (1)> then 
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (0)> then 
set [IsWhiteKingCheckMateRes v] to [0]
end
RevertMove %n
end
replace item (2) of [MovesIdx v] with ((item (2) of [MovesIdx v]) + (1))
end
end

define CalculateMovesImpl %n %b %b
if <argument_reporter_boolean> then 
Profile_MethodEnter %n
 else 
if <argument_reporter_boolean> then 
Profile_MethodEnter %n
 else 
Profile_MethodEnter %n
end
end
ClearMoveList %n
set [SourceIdxOuter v] to [1]
set [IsBlackMove v] to ((argument_reporter_string_number) mod (2))
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <(IsBlackMove) = (1)> then 
set [BlackMobilityBonus v] to [0]
 else 
set [WhiteMobilityBonus v] to [0]
end
end
repeat (64) 
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
replace item (SourceIdxOuter) of [PieceMobility v] with [0]
end
if <<<(IsBlackMove) = (1)> and <(item (SourceIdxOuter) of [Board v]) > (0)>> or <<(IsBlackMove) = (0)> and <(item (SourceIdxOuter) of [Board v]) < (0)>>> then 
CalculateMovesForSource %n %n %b %b
end
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
set [CurrentPiece v] to (item (SourceIdxOuter) of [Board v])
if <(IsBlackMove) = (1)> then 
if <(CurrentPiece) = (BlackRook)> then 
change [BlackMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [RookMobilityBonus v])
 else 
if <(CurrentPiece) = (BlackQueen)> then 
change [BlackMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [QueenMobilityBonus v])
 else 
if <(CurrentPiece) = (BlackBishop)> then 
change [BlackMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [BishopMobilityBonus v])
 else 
if <(CurrentPiece) = (BlackKnight)> then 
change [BlackMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [KnightMobilityBonus v])
 else 
if <(CurrentPiece) = (BlackKing)> then 
if <(IsEndgame) = (1)> then 
change [BlackMobilityBonus v] by ((item (SourceIdxOuter) of [PieceMobility v]) * (5))
end
end
end
end
end
end
end
if <(IsBlackMove) = (0)> then 
if <(CurrentPiece) = (WhiteRook)> then 
change [WhiteMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [RookMobilityBonus v])
 else 
if <(CurrentPiece) = (WhiteQueen)> then 
change [WhiteMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [QueenMobilityBonus v])
 else 
if <(CurrentPiece) = (WhiteBishop)> then 
change [WhiteMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [BishopMobilityBonus v])
 else 
if <(CurrentPiece) = (WhiteKnight)> then 
change [WhiteMobilityBonus v] by (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [KnightMobilityBonus v])
 else 
if <(CurrentPiece) = (WhiteKing)> then 
if <(IsEndgame) = (1)> then 
change [WhiteMobilityBonus v] by ((item (SourceIdxOuter) of [PieceMobility v]) * (5))
end
end
end
end
end
end
end
end
change [SourceIdxOuter v] by (1)
end
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <(IsBlackMove) = (1)> then 
if <<(HasBlackKingMoved) = (0)> and <(HasBlackCastled) = (0)>> then 
if <<<<(item (item (1) of [VirtualBoard v]) of [Board v]) = (BlackRook)> and <(item (item (2) of [VirtualBoard v]) of [Board v]) = (Empty)>> and <<(item (item (3) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (4) of [VirtualBoard v]) of [Board v]) = (Empty)>>> and <(item (item (5) of [VirtualBoard v]) of [Board v]) = (BlackKing)>> then 
if <<(item (item (3) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <<(item (item (4) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <(item (item (5) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)>>> then 
if <(HasBlackRookQSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
if <<<(item (item (5) of [VirtualBoard v]) of [Board v]) = (BlackKing)> and <(item (item (6) of [VirtualBoard v]) of [Board v]) = (Empty)>> and <<(item (item (7) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (8) of [VirtualBoard v]) of [Board v]) = (BlackRook)>>> then 
if <<(item (item (5) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <<(item (item (6) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <(item (item (7) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)>>> then 
if <(HasBlackRookKSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
end
 else 
if <<(HasWhiteKingMoved) = (0)> and <(HasWhiteCastled) = (0)>> then 
if <<<(item (item (57) of [VirtualBoard v]) of [Board v]) = (WhiteRook)> and <(item (item (58) of [VirtualBoard v]) of [Board v]) = (Empty)>> and <<(item (item (59) of [VirtualBoard v]) of [Board v]) = (Empty)> and <<(item (item (60) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (61) of [VirtualBoard v]) of [Board v]) = (WhiteKing)>>>> then 
if <<(item (item (59) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <<(item (item (60) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <(item (item (61) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)>>> then 
if <(HasWhiteRookQSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
if <<<(item (item (62) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (61) of [VirtualBoard v]) of [Board v]) = (WhiteKing)>> and <<(item (item (63) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (64) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>>> then 
if <<(item (item (61) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <<(item (item (62) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <(item (item (63) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)>>> then 
if <(HasWhiteRookKSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
end
end
end
if <not <argument_reporter_boolean>> then 
if <(argument_reporter_string_number) = (1)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves1 v])
end
if <(argument_reporter_string_number) = (2)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves2 v])
end
if <(argument_reporter_string_number) = (3)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves3 v])
end
if <(argument_reporter_string_number) = (4)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves4 v])
end
if <(argument_reporter_string_number) = (5)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves5 v])
end
if <(argument_reporter_string_number) = (6)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves6 v])
end
if <(argument_reporter_string_number) = (7)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves7 v])
end
if <(argument_reporter_string_number) = (8)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves8 v])
end
if <(argument_reporter_string_number) = (9)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves9 v])
end
if <(argument_reporter_string_number) = (10)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves10 v])
end
if <(argument_reporter_string_number) = (11)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves11 v])
end
if <(argument_reporter_string_number) = (12)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves12 v])
end
if <(argument_reporter_string_number) = (13)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves13 v])
end
if <(argument_reporter_string_number) = (14)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves14 v])
end
if <(argument_reporter_string_number) = (15)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves15 v])
end
if <(argument_reporter_string_number) = (16)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves16 v])
end
if <(argument_reporter_string_number) = (17)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves17 v])
end
if <(argument_reporter_string_number) = (18)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves18 v])
end
if <(argument_reporter_string_number) = (19)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves19 v])
end
if <(argument_reporter_string_number) = (20)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves20 v])
end
end
if <argument_reporter_boolean> then 
Profile_MethodExit %n
 else 
if <argument_reporter_boolean> then 
Profile_MethodExit %n
 else 
Profile_MethodExit %n
end
end

define GetMoveScore %n %n %n %n %n %n
set [MoveScoreRes v] to [0]
if <((argument_reporter_string_number) mod (2)) = (1)> then 
set [RankFac v] to [1]
 else 
set [RankFac v] to [-1]
end
if <(letter (5) of (argument_reporter_string_number)) = (.)> then 
if <(letter (6) of (argument_reporter_string_number)) = (1)> then 
set [MoveScoreRes v] to ((800) * (RankFac))
end
if <(letter (6) of (argument_reporter_string_number)) = (2)> then 
set [MoveScoreRes v] to ((400) * (RankFac))
end
if <(letter (6) of (argument_reporter_string_number)) = (3)> then 
set [MoveScoreRes v] to ((230) * (RankFac))
end
if <(letter (6) of (argument_reporter_string_number)) = (4)> then 
set [MoveScoreRes v] to ((210) * (RankFac))
end
stop [this script v]
end
if <<<((argument_reporter_string_number) mod (2)) = (0)> and <(item (argument_reporter_string_number) of [BoardAttackedByBlack v]) = (0)>> or <<((argument_reporter_string_number) mod (2)) = (1)> and <(item (argument_reporter_string_number) of [BoardAttackedByWhite v]) = (0)>>> then 
set [IsAttacked v] to [0]
 else 
set [IsAttacked v] to [1]
end
if <<(argument_reporter_string_number) = (Empty)> and <(IsAttacked) = (0)>> then 
if <(argument_reporter_string_number) = (2)> then 
if <[KillerMoves2 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves2 v])) * (RankFac))
stop [this script v]
end
end
if <(argument_reporter_string_number) = (3)> then 
if <[KillerMoves3 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves3 v])) * (RankFac))
stop [this script v]
end
if <(1) = (0)> then 
if <(argument_reporter_string_number) = (item (1) of [Moves1 v])> then 
set [MoveScoreRes v] to ((70) * (RankFac))
stop [this script v]
end
end
end
if <(argument_reporter_string_number) = (4)> then 
if <[KillerMoves4 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves4 v])) * (RankFac))
stop [this script v]
end
if <(1) = (0)> then 
if <(argument_reporter_string_number) = (item (1) of [Moves2 v])> then 
set [MoveScoreRes v] to ((70) * (RankFac))
stop [this script v]
end
end
end
if <(argument_reporter_string_number) = (5)> then 
if <[KillerMoves5 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves5 v])) * (RankFac))
stop [this script v]
end
if <(1) = (0)> then 
if <(argument_reporter_string_number) = (item (1) of [Moves3 v])> then 
set [MoveScoreRes v] to ((70) * (RankFac))
stop [this script v]
end
end
end
if <(argument_reporter_string_number) = (6)> then 
if <[KillerMoves6 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves6 v])) * (RankFac))
stop [this script v]
end
if <(1) = (0)> then 
if <(argument_reporter_string_number) = (item (1) of [Moves4 v])> then 
set [MoveScoreRes v] to ((70) * (RankFac))
stop [this script v]
end
end
if <(argument_reporter_string_number) = (7)> then 
if <[KillerMoves7 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves7 v])) * (RankFac))
stop [this script v]
end
if <(1) = (0)> then 
if <(argument_reporter_string_number) = (item (1) of [Moves5 v])> then 
set [MoveScoreRes v] to ((70) * (RankFac))
stop [this script v]
end
end
if <(argument_reporter_string_number) = (8)> then 
if <[KillerMoves8 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves8 v])) * (RankFac))
stop [this script v]
end
if <(1) = (0)> then 
if <(argument_reporter_string_number) = (item (1) of [Moves6 v])> then 
set [MoveScoreRes v] to ((70) * (RankFac))
stop [this script v]
end
end
end
end
end
if <<<(argument_reporter_string_number) = (BlackQueensideCastling)> or <(argument_reporter_string_number) = (BlackKingsideCastling)>> or <<(argument_reporter_string_number) = (WhiteQueensideCastling)> or <(argument_reporter_string_number) = (WhiteKingsideCastling)>>> then 
set [MoveScoreRes v] to ((25) * (RankFac))
stop [this script v]
end
end
set [MoveScoreRes v] to [0]
GetPosScore %n %n
change [MoveScoreRes v] by ((0) - (PosScoreRes))
if <(IsAttacked) = (0)> then 
GetPosScore %n %n
change [MoveScoreRes v] by (PosScoreRes)
 else 
change [MoveScoreRes v] by ((0) - (argument_reporter_string_number))
end
if <not <(argument_reporter_string_number) = (Empty)>> then 
change [MoveScoreRes v] by ((0) - (argument_reporter_string_number))
GetPosScore %n %n
change [MoveScoreRes v] by ((0) - (PosScoreRes))
end

when gf clicked
hide list [ExportData v]
hide list [ExportMoves v]

define InitKingSafety
delete (all) of [PawnStormBlockedByKing v]
LoadList %s %s
delete (all) of [PawnStormBlockedByPawn v]
LoadList %s %s
delete (all) of [PawnStormBlockedByNone v]
LoadList %s %s
delete (all) of [PawnShelterKingCol v]
LoadList %s %s
delete (all) of [PawnShelterNeighborCol v]
LoadList %s %s

define ImportBoardFEN %s
if <(IsPlayerBlack) = (0)> then 
set [Idx v] to [1]
set [IdxInc v] to [1]
 else 
set [Idx v] to [64]
set [IdxInc v] to [-1]
end
set [IdxString v] to [1]
repeat until <<(Idx) > (64)> or <(Idx) < (1)>> 
set [CurrentValue v] to (letter (IdxString) of (argument_reporter_string_number))
if <<not <(CurrentValue) < (A)>> and <not <(CurrentValue) > (Z)>>> then 
set [CurrentPiece v] to [Empty]
if <(CurrentValue) = (P)> then 
set [CurrentPiece v] to [BlackPawn]
end
if <(CurrentValue) = (N)> then 
set [CurrentPiece v] to [BlackKnight]
end
if <(CurrentValue) = (B)> then 
set [CurrentPiece v] to [BlackBishop]
end
if <(CurrentValue) = (R)> then 
set [CurrentPiece v] to [BlackRook]
end
if <(CurrentValue) = (Q)> then 
set [CurrentPiece v] to [BlackQueen]
end
if <(CurrentValue) = (K)> then 
set [CurrentPiece v] to [BlackKing]
end
IsLowerCase %s
if <(IsLowerCaseRes) = (0)> then 
set [CurrentPiece v] to ((CurrentPiece) * (-1))
end
if <(IsPlayerBlack) = (1)> then 
set [CurrentPiece v] to ((CurrentPiece) * (-1))
end
replace item (Idx) of [Board v] with [CurrentPiece]
change [Idx v] by (IdxInc)
 else 
if <<not <(CurrentValue) < (0)>> and <not <(CurrentValue) > (9)>>> then 
repeat (CurrentValue) 
replace item (Idx) of [Board v] with [Empty]
change [Idx v] by (IdxInc)
end
 else 
if <(CurrentValue) = (/)> then 
repeat until <<<((Idx) mod (8)) = (1)> and <(IsPlayerBlack) = (0)>> or <<((Idx) mod (8)) = (0)> and <(IsPlayerBlack) = (1)>>> 
replace item (Idx) of [Board v] with [Empty]
change [Idx v] by (IdxInc)
end
end
end
end
change [IdxString v] by (1)
end
AddBoardToHistory
DrawBoardAndWait
change [IdxString v] by (1)
set [CurrentValue v] to (letter (IdxString) of (argument_reporter_string_number))
if <<<(CurrentValue) = (B)> and <(IsPlayerBlack) = (0)>> or <<(CurrentValue) = (W)> and <(IsPlayerBlack) = (1)>>> then 
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
say [Checkmate!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
CalculateMoves %n
if <(length of [Moves1 v]) = (0)> then 
say [Draw!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
set [IsGameSuspended v] to [0]
ExecuteEngineMove
end
end
end
if <<<(CurrentValue) = (W)> and <(IsPlayerBlack) = (0)>> or <<(CurrentValue) = (B)> and <(IsPlayerBlack) = (1)>>> then 
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (1)> then 
say [Checkmate!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
CalculateMoves %n
if <(length of [Moves2 v]) = (0)> then 
say [Draw!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
set [IsGameSuspended v] to [0]
end
end
end

define OnProgressChanged %n
if <(argument_reporter_string_number) < (100)> then 
set [ProgressValue v] to (argument_reporter_string_number)
 else 
set [ProgressValue v] to [100]
end
broadcast (1 v)
wait (0) seconds

define Profile_MethodExit %n
if <(IsProfilerEnabled) > (0)> then 
replace item (argument_reporter_string_number) of [Profile_Data v] with ((item (argument_reporter_string_number) of [Profile_Data v]) + (timer))
end

define HasSEEMapVal %n %n
set [HasSEEMapValRes v] to [0]
set [CurrentPieceSub v] to ([abs v] of (argument_reporter_string_number) ::operators)
if <(CurrentPieceSub) = (BlackPawn)> then 
if <<(letter (6) of (argument_reporter_string_number)) > (0)> and <not <(letter (6) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
 else 
if <(CurrentPieceSub) = (BlackKnight)> then 
if <<(letter (5) of (argument_reporter_string_number)) > (0)> and <not <(letter (5) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
 else 
if <(CurrentPieceSub) = (BlackBishop)> then 
if <<(letter (4) of (argument_reporter_string_number)) > (0)> and <not <(letter (4) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
 else 
if <(CurrentPieceSub) = (BlackRook)> then 
if <<(letter (3) of (argument_reporter_string_number)) > (0)> and <not <(letter (3) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
 else 
if <(CurrentPieceSub) = (BlackQueen)> then 
if <<(letter (2) of (argument_reporter_string_number)) > (0)> and <not <(letter (2) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
 else 
if <(CurrentPieceSub) = (BlackKing)> then 
if <<(letter (1) of (argument_reporter_string_number)) > (0)> and <not <(letter (1) of (argument_reporter_string_number)) > (9)>>> then 
set [HasSEEMapValRes v] to [1]
end
end
end
end
end
end
end

define CalcBoardAttackedByMove %n
ClearBoardAttackedByMove %n
CalculateMovesImpl %n %b %b

define Profile_Reset
delete (all) of [Profile_Data v]

define Profile_MethodEnter %n
if <(IsProfilerEnabled) > (0)> then 
repeat until <not <(length of [Profile_Data v]) < (argument_reporter_string_number)>> 
add [0] to [Profile_Data v]
end
replace item (argument_reporter_string_number) of [Profile_Data v] with ((item (argument_reporter_string_number) of [Profile_Data v]) - (timer))
end

define AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
InitAlphaBeta %n %n %b
if <(IsMinMaxTimeout) = (1)> then 
stop [this script v]
end
replace item (argument_reporter_string_number) of [BestHashMoveType v] with []
replace item (argument_reporter_string_number) of [PrevBestHashMove v] with []
replace item (argument_reporter_string_number) of [BestHashMoveMaxDepth v] with (argument_reporter_string_number)
if <argument_reporter_boolean> then 
OnScoreCalc %n %n %n %b %b %b
 else 
OnScoreCalc %n %n %n %b %b %b
end
if <(argument_reporter_string_number) = (argument_reporter_string_number)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [ScoreCalcRes]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
stop [this script v]
end
if <argument_reporter_boolean> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <not <(ScoreCalcRes) < (item (argument_reporter_string_number) of [Betas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
stop [this script v]
end
if <(ScoreCalcRes) > (item (argument_reporter_string_number) of [Alphas v])> then 
replace item (argument_reporter_string_number) of [Alphas v] with [ScoreCalcRes]
end
 else 
if <not <(ScoreCalcRes) > (item (argument_reporter_string_number) of [Alphas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
stop [this script v]
end
if <(ScoreCalcRes) < (item (argument_reporter_string_number) of [Betas v])> then 
replace item (argument_reporter_string_number) of [Betas v] with [ScoreCalcRes]
end
end
end
if <<(item ((argument_reporter_string_number) - (1)) of [TargetPieces v]) = (WhiteKing)> or <(item ((argument_reporter_string_number) - (1)) of [TargetPieces v]) = (BlackKing)>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [ScoreCalcRes]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
stop [this script v]
end
if <<(argument_reporter_string_number) = (1)> and <<<(argument_reporter_string_number) = (2)> or <(argument_reporter_string_number) = (3)>> or <<not <argument_reporter_boolean>> and <(item ((argument_reporter_string_number) - (1)) of [CheckedState v]) = (1)>>>> then 
CalcBoardAttackedByMove %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(IsWhiteChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((100000) - ((argument_reporter_string_number) * (1000)))
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
ClearBoardAttackedByMove %n
stop [this script v]
end
 else 
if <(IsBlackChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((-100000) + ((argument_reporter_string_number) * (1000)))
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
ClearBoardAttackedByMove %n
stop [this script v]
end
end
ClearBoardAttackedByMove %n
end
if <<(argument_reporter_string_number) = (1)> and <<(argument_reporter_string_number) = (2)> or <(argument_reporter_string_number) = (3)>>> then 
GetBoardString
if <[BoardHistory v] contains [GetBoardStringRes] ? ::lists> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
stop [this script v]
end
if <(argument_reporter_string_number) = (2)> then 
IsDraw %n
if <(IsDrawRes) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
stop [this script v]
end
end
end
if <<<(argument_reporter_string_number) = (1)> and <<(argument_reporter_string_number) = (4)> or <(argument_reporter_string_number) = (5)>>> and <not <argument_reporter_boolean>>> then 
if <set [Idx v] to [1]> then 
(1) = (0)
end
set [Idx v] to [1]
repeat until <not <(Idx) < (argument_reporter_string_number)>> 
if <<(CurrentMoveHash) = (item (Idx) of [PreviousMoveHash v])> and <not <(((argument_reporter_string_number) - (1)) mod (2)) = ((Idx) mod (2))>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
stop [this script v]
end
change [Idx v] by (1)
end
end
if <<argument_reporter_boolean> and <(argument_reporter_string_number) > (1)>> then 
GetBestHashMove %s %s
if <<(BestHashMoveResult) = (1)> and <<<not <argument_reporter_boolean>> and <not <<([abs v] of (BestHashMoveScoreResult) ::operators) > ((BlackKing) / (2))> or <(BestHashMoveHorizonResult) < ((argument_reporter_string_number) - (argument_reporter_string_number))>>>> or <<argument_reporter_boolean> and <(BestHashMoveHorizonResult) = (-1)>>>> then 
if <(BestHashMoveTypeResult) = (E)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [BestHashMoveScoreResult]
replace item (argument_reporter_string_number) of [PrevBestHashMove v] with [BestHashMoveMoveResult]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
Profile_IncCounter %n
stop [this script v]
 else 
if <<(BestHashMoveTypeResult) = (A)> and <not <(BestHashMoveScoreResult) > (item (argument_reporter_string_number) of [Alphas v])>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [BestHashMoveScoreResult]
replace item (argument_reporter_string_number) of [PrevBestHashMove v] with [BestHashMoveMoveResult]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
Profile_IncCounter %n
stop [this script v]
 else 
if <<(BestHashMoveTypeResult) = (B)> and <not <(BestHashMoveScoreResult) < (item (argument_reporter_string_number) of [Betas v])>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [BestHashMoveScoreResult]
replace item (argument_reporter_string_number) of [PrevBestHashMove v] with [BestHashMoveMoveResult]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
Profile_IncCounter %n
stop [this script v]
end
end
end
end
end
if <<<(IsEndgame) = (0)> and <(IsInNullMove) = (0)>> and <<<<not <argument_reporter_boolean>> and <(argument_reporter_string_number) > (1)>> and <((argument_reporter_string_number) - (argument_reporter_string_number)) > (1)>> and <<((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)> and <<(item ((argument_reporter_string_number) - (1)) of [PlyExtension v]) = (0)> and <(item ((argument_reporter_string_number) - (2)) of [PlyExtension v]) = (0)>>>>> then 
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <<(BlackMinorCount) > (0)> or <(BlackQueenCount) > (0)>>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <<(WhiteMinorCount) > (0)> or <(WhiteQueenCount) > (0)>>>> then 
change [NullMoveCount v] by (0)
OnScoreCalc %n %n %n %b %b %b
if <<((argument_reporter_string_number) mod (2)) = (0)> and <not <(ScoreCalcRes) < (item (argument_reporter_string_number) of [Betas v])>>> then 
change [NullMoveCount v] by (1)
set [IsInNullMove v] to [1]
ClearMoveList %n
AddToMoveList %n %n
replace item ((argument_reporter_string_number) + (0)) of [MovesIdx v] with [1]
ApplyMove %n
OnScoreCalc %n %n %n %b %b %b
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with (item (argument_reporter_string_number) of [Betas v])
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with ((item (argument_reporter_string_number) of [Betas v]) + (1))
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
RevertMove %n
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
if <<not <(Score) < (item (argument_reporter_string_number) of [Betas v])>> and <not <(Score) > ((BlackKing) / (2))>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
set [IsInNullMove v] to [0]
stop [this script v]
 else 
set [IsInNullMove v] to [0]
end
end
if <<((argument_reporter_string_number) mod (2)) = (1)> and <not <(ScoreCalcRes) > (item (argument_reporter_string_number) of [Alphas v])>>> then 
change [NullMoveCount v] by (1)
set [IsInNullMove v] to [1]
ClearMoveList %n
AddToMoveList %n %n
replace item ((argument_reporter_string_number) + (0)) of [MovesIdx v] with [1]
ApplyMove %n
OnScoreCalc %n %n %n %b %b %b
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with ((item (argument_reporter_string_number) of [Alphas v]) - (1))
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with (item (argument_reporter_string_number) of [Alphas v])
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
RevertMove %n
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
if <<not <(Score) > (item (argument_reporter_string_number) of [Alphas v])>> and <not <(Score) < ((WhiteKing) / (2))>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
set [IsInNullMove v] to [0]
stop [this script v]
 else 
set [IsInNullMove v] to [0]
end
end
end
end
replace item (argument_reporter_string_number) of [PickPhase v] with [1]
replace item (argument_reporter_string_number) of [PickMoveRes v] with [1]
replace item (argument_reporter_string_number) of [CheckedState v] with [0]
repeat until <(item (argument_reporter_string_number) of [PickMoveRes v]) = (0)> 
if <(IsMinMaxTimeout) = (0)> then 
if <not <argument_reporter_boolean>> then 
if <((timer) - (ThinkTimeStart)) > (ThinkTimeLimitMinMax)> then 
set [IsMinMaxTimeout v] to [1]
end
end
end
if <(IsMinMaxTimeout) = (1)> then 
stop [this script v]
end
Profile_MethodEnter %n
PickMove %n %n %b %b %b %b
Profile_MethodExit %n
if <(item (argument_reporter_string_number) of [PickMoveRes v]) = (1)> then 
if <(argument_reporter_string_number) = (1)> then 
add (item (item (1) of [MovesIdx v]) of [Moves1 v]) to [MinMaxPly1EvalMoves v]
if <<argument_reporter_boolean> and <(item (argument_reporter_string_number) of [PickPhase v]) = (3)>> then 
if <<<(IsScratch3) = (0)> or <(1) = (1)>> or <(item (argument_reporter_string_number) of [MovesIdx v]) = (item (argument_reporter_string_number) of [MovesCount v])>> then 
OnProgressChanged %n
end
end
end
replace item (argument_reporter_string_number) of [PlyExtension v] with [0]
if <not <argument_reporter_boolean>> then 
if <<<(argument_reporter_string_number) < (3)> and <<(IsScratch3) = (1)> or <(Level) = (1)>>> or <<(argument_reporter_string_number) < (4)> and <not <<(IsScratch3) = (1)> or <(Level) = (1)>>>>> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
set [IsWhiteChecked v] to [0]
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
replace item (argument_reporter_string_number) of [PlyExtension v] with [1]
end
 else 
set [IsBlackChecked v] to [0]
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (1)> then 
replace item (argument_reporter_string_number) of [PlyExtension v] with [1]
end
end
 else 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
GetCurrentMove %n
if <(item ([floor v] of ((CurrentMove) mod (100)) ::operators) of [BoardAttackedByWhite v]) = (0)> then 
set [IsWhiteChecked v] to [0]
CalculateMovesForSource %n %n %b %b
if <(IsWhiteChecked) = (1)> then 
replace item (argument_reporter_string_number) of [PlyExtension v] with [1]
end
end
 else 
GetCurrentMove %n
if <(item ([floor v] of ((CurrentMove) mod (100)) ::operators) of [BoardAttackedByBlack v]) = (0)> then 
set [IsBlackChecked v] to [0]
CalculateMovesForSource %n %n %b %b
if <(IsBlackChecked) = (1)> then 
replace item (argument_reporter_string_number) of [PlyExtension v] with [1]
end
end
end
end
end
set [IsFutile v] to [0]
if <<<argument_reporter_boolean> and <(1) = (1)>> or <<<<<<not <argument_reporter_boolean>> and <(1) = (1)>> and <((argument_reporter_string_number) - (argument_reporter_string_number)) = (1)>> and <<(item (argument_reporter_string_number) of [MovesIdx v]) > (1)> and <((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)>>> and <<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>>> and <<(item (argument_reporter_string_number) of [CheckedState v]) = (0)> and <(item (argument_reporter_string_number) of [PlyExtension v]) = (0)>>>> then 
if <argument_reporter_boolean> then 
set [FutilityMargin v] to [75]
 else 
set [FutilityMargin v] to (((argument_reporter_string_number) - (argument_reporter_string_number)) * (75))
end
OnScoreCalc %n %n %n %b %b %b
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <not <((ScoreCalcRes) + (FutilityMargin)) > (item (argument_reporter_string_number) of [Alphas v])>> then 
set [IsFutile v] to [1]
end
 else 
if <not <((ScoreCalcRes) - (FutilityMargin)) < (item (argument_reporter_string_number) of [Betas v])>> then 
set [IsFutile v] to [1]
end
end
end
if <(IsFutile) = (1)> then 
change [FutileCount v] by (1)
RevertMove %n
 else 
set [IsReductionAndDone v] to [0]
if <<<not <argument_reporter_boolean>> and <<((argument_reporter_string_number) - (argument_reporter_string_number)) > (1)> or <(1) = (0)>>> and <(item (argument_reporter_string_number) of [MovesIdx v]) > (1)>> then 
GetCurrentMove %n
IsKillerMove %s %s
if <((argument_reporter_string_number) mod (2)) = (1)> then 
set [Score v] to (item (argument_reporter_string_number) of [Alphas v])
if <<<<(1) = (1)> or <(IsInReduction) = (0)>> and <<(IsKillerMoveRes) = (0)> and <((argument_reporter_string_number) - (argument_reporter_string_number)) > (2)>>> and <<<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>> and <<<(item (argument_reporter_string_number) of [PlyExtension v]) = (0)> and <(1) = (1)>> and <<(1) = (0)> or <(([log v] of ((argument_reporter_string_number) - (argument_reporter_string_number)) ::operators) * ([log v] of (item (argument_reporter_string_number) of [MovesIdx v]) ::operators)) > (0.6)>>>>> then 
set [IsInReduction v] to [1]
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with ((item (argument_reporter_string_number) of [Alphas v]) - (1))
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with (item (argument_reporter_string_number) of [Alphas v])
if <<((argument_reporter_string_number) - (argument_reporter_string_number)) > (2)> and <<(([log v] of ((argument_reporter_string_number) - (argument_reporter_string_number)) ::operators) * ([log v] of (item (argument_reporter_string_number) of [MovesIdx v]) ::operators)) > (0.6)> and <(item (argument_reporter_string_number) of [CheckedState v]) = (0)>>> then 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
 else 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
end
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
set [IsReductionAndDone v] to [1]
set [IsInReduction v] to [0]
end
if <not <(Score) < (item (argument_reporter_string_number) of [Alphas v])>> then 
set [IsReductionAndDone v] to [0]
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with ((item (argument_reporter_string_number) of [Alphas v]) - (1))
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with (item (argument_reporter_string_number) of [Alphas v])
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
set [IsReductionAndDone v] to [1]
if <<not <(Score) < (item (argument_reporter_string_number) of [Alphas v])>> and <not <(Score) > (item (argument_reporter_string_number) of [Betas v])>>> then 
set [IsReductionAndDone v] to [0]
end
end
 else 
set [Score v] to (item (argument_reporter_string_number) of [Betas v])
if <<<<(1) = (1)> or <(IsInReduction) = (0)>> and <<(IsKillerMoveRes) = (0)> and <((argument_reporter_string_number) - (argument_reporter_string_number)) > (2)>>> and <<<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>> and <<<(item (argument_reporter_string_number) of [PlyExtension v]) = (0)> and <(1) = (1)>> and <<(1) = (0)> or <(([log v] of ((argument_reporter_string_number) - (argument_reporter_string_number)) ::operators) * ([log v] of (item (argument_reporter_string_number) of [MovesIdx v]) ::operators)) > (0.6)>>>>> then 
set [IsInReduction v] to [1]
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with (item (argument_reporter_string_number) of [Betas v])
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with ((item (argument_reporter_string_number) of [Betas v]) + (1))
if <<((argument_reporter_string_number) - (argument_reporter_string_number)) > (2)> and <<(item (argument_reporter_string_number) of [CheckedState v]) = (0)> and <(([log v] of ((argument_reporter_string_number) - (argument_reporter_string_number)) ::operators) * ([log v] of (item (argument_reporter_string_number) of [MovesIdx v]) ::operators)) > (0.6)>>> then 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
 else 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
end
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
set [IsReductionAndDone v] to [1]
set [IsInReduction v] to [0]
end
if <not <(Score) > (item (argument_reporter_string_number) of [Betas v])>> then 
set [IsReductionAndDone v] to [0]
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with (item (argument_reporter_string_number) of [Betas v])
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with ((item (argument_reporter_string_number) of [Betas v]) + (1))
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
set [IsReductionAndDone v] to [1]
if <<not <(Score) < (item (argument_reporter_string_number) of [Alphas v])>> and <not <(Score) > (item (argument_reporter_string_number) of [Betas v])>>> then 
set [IsReductionAndDone v] to [0]
end
end
end
end
if <(IsReductionAndDone) = (0)> then 
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with (item (argument_reporter_string_number) of [Alphas v])
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with (item (argument_reporter_string_number) of [Betas v])
if <<(argument_reporter_string_number) > (0)> and <(argument_reporter_string_number) = ((argument_reporter_string_number) - (1))>> then 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
 else 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
end
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
end
if <(IsMinMaxTimeout) = (0)> then 
if <(argument_reporter_string_number) = (1)> then 
if <(item ((argument_reporter_string_number) + (1)) of [BestHashMoveType v]) = (E)> then 
replace item (item (item (1) of [MovesIdx v]) of [DeepeningScoreOrderMap v]) of [DeepeningScore v] with [Score]
end
end
if <<argument_reporter_boolean> or <<(argument_reporter_string_number) = ((argument_reporter_string_number) - (1))> and <(item (argument_reporter_string_number) of [PlyExtension v]) = (0)>>> then 
HashOnMoveScore %s %s %s %s %s %s %s
 else 
HashOnMoveScore %s %s %s %s %s %s %s
end
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> then 
set [IsPotentialKillerMove v] to [1]
 else 
set [IsPotentialKillerMove v] to [0]
end
end
RevertMove %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <<(1) = (0)> and <(argument_reporter_string_number) = (1)>> then 
Log %s %s %s %s %s %s %s %s
end
if <(argument_reporter_string_number) > (1)> then 
if <not <(Score) < (item (argument_reporter_string_number) of [Betas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
StoreMove %n %b
stop [this script v]
end
end
if <(Score) > (item (argument_reporter_string_number) of [Alphas v])> then 
replace item (argument_reporter_string_number) of [Alphas v] with [Score]
if <((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)> then 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
 else 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
end
if <<(argument_reporter_string_number) = (1)> and <(IsMinMaxTimeout) = (0)>> then 
if <(Score) < (item (argument_reporter_string_number) of [Betas v])> then 
Log %s %s %s %s %s %s %s %s
delete (all) of [BestMoves v]
add (item (item (1) of [MovesIdx v]) of [Moves1 v]) to [BestMoves v]
delete (all) of [BestMinMaxResults v]
add [Score] to [BestMinMaxResults v]
if <(item (1) of [BestMoves v]) = (BlackKingsideCastling)> then 
set [BestMoveFromIdx v] to (item (5) of [VirtualBoard v])
set [BestMoveToIdx v] to (item (7) of [VirtualBoard v])
 else 
if <(item (1) of [BestMoves v]) = (BlackQueensideCastling)> then 
set [BestMoveFromIdx v] to (item (5) of [VirtualBoard v])
set [BestMoveToIdx v] to (item (3) of [VirtualBoard v])
 else 
set [BestMoveFromIdx v] to ([floor v] of ((item (1) of [BestMoves v]) / (100)) ::operators)
set [BestMoveToIdx v] to ([floor v] of ((item (1) of [BestMoves v]) mod (100)) ::operators)
end
end
broadcast (1 v)
end
end
StoreMove %n %b
end
 else 
if <not <(Score) > (item (argument_reporter_string_number) of [Alphas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
StoreMove %n %b
stop [this script v]
end
if <(Score) < (item (argument_reporter_string_number) of [Betas v])> then 
replace item (argument_reporter_string_number) of [Betas v] with [Score]
if <((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)> then 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
 else 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
end
StoreMove %n %b
end
end
end
end
end
if <((argument_reporter_string_number) mod (2)) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
if <<not <(item (argument_reporter_string_number) of [BestHashMoveType v]) = (E)>> or <((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)>> then 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
end
 else 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
if <<not <(item (argument_reporter_string_number) of [BestHashMoveType v]) = (E)>> or <((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)>> then 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
end
end
if <(item (argument_reporter_string_number) of [MovesCount v]) = (0)> then 
if <argument_reporter_boolean> then 
OnScoreCalc %n %n %n %b %b %b
replace item (argument_reporter_string_number) of [MinMaxResults v] with [ScoreCalcRes]
stop [this script v]
 else 
CalcBoardAttackedByMove %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(IsBlackChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((-100000) + ((argument_reporter_string_number) * (1000)))
stop [this script v]
 else 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
stop [this script v]
end
 else 
if <(IsWhiteChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((100000) - ((argument_reporter_string_number) * (1000)))
stop [this script v]
 else 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
stop [this script v]
end
end
end
end

define OnScoreCalc %n %n %n %b %b %b
Profile_MethodEnter %n
set [ScoreCalcRes v] to [0]
if <(argument_reporter_string_number) = (0)> then 
set [EvalResultCached v] to [0]
set [EvalExtendedResultCached v] to [0]
end
if <<<(argument_reporter_string_number) = (argument_reporter_string_number)> and <(argument_reporter_string_number) < (ExtendedEvaluationMaxDepth)>> or <(argument_reporter_string_number) = (ExtendedEvaluationMaxDepth)>> then 
EvaluateBoard
EvaluateBoardExtended %n
if <(argument_reporter_string_number) = (ExtendedEvaluationMaxDepth)> then 
set [EvalResultCached v] to [EvalResult]
set [EvalExtendedResultCached v] to [EvalExtendedResult]
end
end
if <(argument_reporter_string_number) = (argument_reporter_string_number)> then 
if <(argument_reporter_string_number) < (ExtendedEvaluationMaxDepth)> then 
set [ScoreCalcRes v] to ((EvalResult) + (EvalExtendedResult))
 else 
set [ScoreCalcRes v] to ((EvalResultCached) + (EvalExtendedResultCached))
end
change [ScoreCalcRes v] by ((BlackMobilityBonus) - (WhiteMobilityBonus))
set [Idx v] to ((ExtendedEvaluationMaxDepth) + (1))
repeat until <(Idx) > (argument_reporter_string_number)> 
if <<(IsEndgame) = (1)> and <([abs v] of (item (Idx) of [TargetPieces v]) ::operators) = (BlackPawn)>> then 
change [ScoreCalcRes v] by ((0) - ((1.2) * (item (Idx) of [TargetPieces v])))
 else 
change [ScoreCalcRes v] by ((0) - (item (Idx) of [TargetPieces v]))
end
change [ScoreCalcRes v] by (item (Idx) of [PosScoreDelta v])
if <not <(item (Idx) of [PromotionPieces v]) = (Empty)>> then 
if <((Idx) mod (2)) = (1)> then 
change [ScoreCalcRes v] by ((item (Idx) of [PromotionPieces v]) - (BlackPawn))
 else 
change [ScoreCalcRes v] by ((item (Idx) of [PromotionPieces v]) - (WhitePawn))
end
end
change [Idx v] by (1)
end
if <(1) = (1)> then 
if <argument_reporter_boolean> then 
if <not <(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)>> then 
GetCurrentMove %n
set [TargetIdx v] to ([floor v] of ((CurrentMove) mod (100)) ::operators)
if <<<((argument_reporter_string_number) mod (2)) = (0)> and <(item (TargetIdx) of [BoardAttackedByBlack v]) > (0)>> or <<((argument_reporter_string_number) mod (2)) = (1)> and <(item (TargetIdx) of [BoardAttackedByWhite v]) > (0)>>> then 
change [ScoreCalcRes v] by ((0) - (item (TargetIdx) of [Board v]))
end
end
end
end
end
Profile_MethodExit %n

define AddSpecialMove %s %n
GetMoveScore %n %n %n %n %n %n
if <(argument_reporter_string_number) = (1)> then 
add (argument_reporter_string_number) to [Moves1 v]
add [MoveScoreRes] to [Moves1Score v]
end
if <(argument_reporter_string_number) = (2)> then 
add (argument_reporter_string_number) to [Moves2 v]
add [MoveScoreRes] to [Moves2Score v]
end
if <(argument_reporter_string_number) = (3)> then 
add (argument_reporter_string_number) to [Moves3 v]
add [MoveScoreRes] to [Moves3Score v]
end
if <(argument_reporter_string_number) = (4)> then 
add (argument_reporter_string_number) to [Moves4 v]
add [MoveScoreRes] to [Moves4Score v]
end
if <(argument_reporter_string_number) = (5)> then 
add (argument_reporter_string_number) to [Moves5 v]
add [MoveScoreRes] to [Moves5Score v]
end
if <(argument_reporter_string_number) = (6)> then 
add (argument_reporter_string_number) to [Moves6 v]
add [MoveScoreRes] to [Moves6Score v]
end
if <(argument_reporter_string_number) = (7)> then 
add (argument_reporter_string_number) to [Moves7 v]
add [MoveScoreRes] to [Moves7Score v]
end
if <(argument_reporter_string_number) = (8)> then 
add (argument_reporter_string_number) to [Moves8 v]
add [MoveScoreRes] to [Moves8Score v]
end
if <(argument_reporter_string_number) = (9)> then 
add (argument_reporter_string_number) to [Moves8 v]
add [MoveScoreRes] to [Moves9Score v]
end
if <(argument_reporter_string_number) = (10)> then 
add (argument_reporter_string_number) to [Moves10 v]
add [MoveScoreRes] to [Moves10Score v]
end
if <(argument_reporter_string_number) = (11)> then 
delete (argument_reporter_string_number) of [Moves11 v]
delete (MoveScoreRes) of [Moves11Score v]
end
if <(argument_reporter_string_number) = (12)> then 
delete (argument_reporter_string_number) of [Moves12 v]
delete (MoveScoreRes) of [Moves12Score v]
end
if <(argument_reporter_string_number) = (13)> then 
delete (argument_reporter_string_number) of [Moves13 v]
delete (MoveScoreRes) of [Moves13Score v]
end
if <(argument_reporter_string_number) = (14)> then 
delete (argument_reporter_string_number) of [Moves14 v]
delete (MoveScoreRes) of [Moves14Score v]
end
if <(argument_reporter_string_number) = (15)> then 
delete (argument_reporter_string_number) of [Moves15 v]
delete (MoveScoreRes) of [Moves15Score v]
end
if <(argument_reporter_string_number) = (16)> then 
delete (argument_reporter_string_number) of [Moves16 v]
delete (MoveScoreRes) of [Moves16Score v]
end
if <(argument_reporter_string_number) = (17)> then 
delete (argument_reporter_string_number) of [Moves17 v]
delete (MoveScoreRes) of [Moves17Score v]
end
if <(argument_reporter_string_number) = (18)> then 
delete (argument_reporter_string_number) of [Moves18 v]
delete (MoveScoreRes) of [Moves18Score v]
end
if <(argument_reporter_string_number) = (19)> then 
delete (argument_reporter_string_number) of [Moves19 v]
delete (MoveScoreRes) of [Moves19Score v]
end
if <(argument_reporter_string_number) = (20)> then 
delete (argument_reporter_string_number) of [Moves20 v]
delete (MoveScoreRes) of [Moves20Score v]
end

define DetectFlash30Bug
set [IsFlash30Bug v] to [0]
set [ThinkTimeStart v] to (timer)
repeat (10000) 
end
if <(timer) > ((ThinkTimeStart) + (0.1))> then 
if <(1) = (0)> then 
set [IsFlash30Bug v] to [1]
end
end

define ApplyMove %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with [0]
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with []
replace item (argument_reporter_string_number) of [TargetPieces v] with [Empty]
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
replace item (argument_reporter_string_number) of [PreviousMoveHash v] with [CurrentMoveHash]
GetCurrentMove %n
set [SourceIdx v] to ([floor v] of ((CurrentMove) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((CurrentMove) mod (100)) ::operators)
if <<(SourceIdx) > (0)> and <(TargetIdx) > (0)>> then 
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
if <not <(item (TargetIdx) of [Board v]) = (Empty)>> then 
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
end
GetPosScore %n %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with [PosScoreRes]
GetPosScore %n %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((item (argument_reporter_string_number) of [PosScoreDelta v]) - (PosScoreRes))
GetPosScore %n %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((item (argument_reporter_string_number) of [PosScoreDelta v]) + (PosScoreRes))
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with [TargetIdx]
replace item (argument_reporter_string_number) of [TargetPieces v] with (item (TargetIdx) of [Board v])
replace item (TargetIdx) of [Board v] with (item (SourceIdx) of [Board v])
replace item (SourceIdx) of [Board v] with [Empty]
if <<(item (TargetIdx) of [Board v]) = (BlackPawn)> and <<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <not <(item (SourceIdx) of [IdxToCol v]) = (item (TargetIdx) of [IdxToCol v])>>>> then 
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with ((TargetIdx) - (8))
replace item (argument_reporter_string_number) of [TargetPieces v] with (item ((TargetIdx) - (8)) of [Board v])
replace item ((TargetIdx) - (8)) of [Board v] with [Empty]
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
end
if <<(item (TargetIdx) of [Board v]) = (WhitePawn)> and <<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <not <(item (SourceIdx) of [IdxToCol v]) = (item (TargetIdx) of [IdxToCol v])>>>> then 
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with ((TargetIdx) + (8))
replace item (argument_reporter_string_number) of [TargetPieces v] with (item ((TargetIdx) + (8)) of [Board v])
replace item ((TargetIdx) + (8)) of [Board v] with [Empty]
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
end
if <<(item (TargetIdx) of [Board v]) = (BlackPawn)> and <(TargetIdx) > (56)>> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
set [PromotionVal v] to (letter (6) of [CurrentMove])
if <(PromotionVal) = (1)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackQueen]
end
if <(PromotionVal) = (2)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackRook]
end
if <(PromotionVal) = (3)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackBishop]
end
if <(PromotionVal) = (4)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackKnight]
end
if <not <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>> then 
replace item (TargetIdx) of [Board v] with (item (argument_reporter_string_number) of [PromotionPieces v])
end
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
end
if <<(item (TargetIdx) of [Board v]) = (WhitePawn)> and <(TargetIdx) < (9)>> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
set [PromotionVal v] to (letter (6) of [CurrentMove])
if <(PromotionVal) = (1)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteQueen]
end
if <(PromotionVal) = (2)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteRook]
end
if <(PromotionVal) = (3)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteBishop]
end
if <(PromotionVal) = (4)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteKnight]
end
if <not <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>> then 
replace item (TargetIdx) of [Board v] with (item (argument_reporter_string_number) of [PromotionPieces v])
end
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
end
 else 
if <(CurrentMove) = (WhiteKingsideCastling)> then 
replace item (item (61) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (62) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (63) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (64) of [VirtualBoard v]) of [Board v] with [Empty]
UpdateMoveHashPosScore %n %n %n %b
UpdateMoveHashPosScore %n %n %n %b
 else 
if <(CurrentMove) = (WhiteQueensideCastling)> then 
replace item (item (57) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (59) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (60) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (61) of [VirtualBoard v]) of [Board v] with [Empty]
UpdateMoveHashPosScore %n %n %n %b
UpdateMoveHashPosScore %n %n %n %b
 else 
if <(CurrentMove) = (BlackKingsideCastling)> then 
replace item (item (5) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (6) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (7) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (8) of [VirtualBoard v]) of [Board v] with [Empty]
UpdateMoveHashPosScore %n %n %n %b
UpdateMoveHashPosScore %n %n %n %b
 else 
if <(CurrentMove) = (BlackQueensideCastling)> then 
replace item (item (1) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (3) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (4) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (5) of [VirtualBoard v]) of [Board v] with [Empty]
UpdateMoveHashPosScore %n %n %n %b
UpdateMoveHashPosScore %n %n %n %b
end
end
end
end
end

define AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
set [TargetIdx v] to (((item (argument_reporter_string_number) of [IdxToCol v]) + (argument_reporter_string_number)) + ((((item (argument_reporter_string_number) of [IdxToRow v]) + (argument_reporter_string_number)) - (1)) * (8)))
if <<not <argument_reporter_boolean>> or <<<(item (argument_reporter_string_number) of [Board v]) > (0)> and <(item (TargetIdx) of [Board v]) < (0)>> or <<(item (argument_reporter_string_number) of [Board v]) < (0)> and <(item (TargetIdx) of [Board v]) > (0)>>>> then 
AddMoveImpl %n %n %n %b %b %b %b %b
end

define DrawBoardAndWait
set [ProgressValue v] to [0]
broadcast (1 v) and wait
broadcast (1 v) and wait

define Profile_IncCounter %n
if <(IsProfilerEnabled) > (0)> then 
repeat until <not <(length of [Profile_Data v]) < (argument_reporter_string_number)>> 
add [0] to [Profile_Data v]
end
replace item (argument_reporter_string_number) of [Profile_Data v] with ((item (argument_reporter_string_number) of [Profile_Data v]) + (1))
end

when [p v] key pressed
if <(IsModeProfiler) = (0)> then 
set [IsModeProfiler v] to [1]
show list [Profile_Data v]
show variable [IsProfilerEnabled v]
 else 
set [IsModeProfiler v] to [0]
hide list [Profile_Data v]
hide variable [IsProfilerEnabled v]
end

when [d v] key pressed
if <(IsModeDeepeningDebug) = (0)> then 
set [IsModeDeepeningDebug v] to [1]
show variable [IdxDeepening v]
show variable [BestMinMaxRes v]
show variable [BestMove v]
show variable [PruningAlphaWindow v]
show variable [PruningBetaWindow v]
 else 
set [IsModeDeepeningDebug v] to [0]
hide variable [IdxDeepening v]
hide variable [BestMinMaxRes v]
hide variable [BestMove v]
hide variable [PruningAlphaWindow v]
hide variable [PruningBetaWindow v]
end

when [c v] key pressed
if <(IsModeCompetition) = (0)> then 
set [IsModeCompetition v] to [1]
SayAsync %s %n
 else 
set [IsModeCompetition v] to [0]
SayAsync %s %n
end

define UpdateMoveHashPosScore %n %n %n %b
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
GetPosScore %n %n
if <argument_reporter_boolean> then 
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((item (argument_reporter_string_number) of [PosScoreDelta v]) - (PosScoreRes))
 else 
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((0) - (PosScoreRes))
end
GetPosScore %n %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((item (argument_reporter_string_number) of [PosScoreDelta v]) + (PosScoreRes))

define StoreMove %n %b
if <(1) = (0)> then 
if <argument_reporter_boolean> then 
GetCurrentMove %n
replace item (CurrentMove) of [HistoryTable v] with ((item (CurrentMove) of [HistoryTable v]) + (((10) - (argument_reporter_string_number)) * ((10) - (argument_reporter_string_number))))
end
end
GetCurrentMove %n
if <(argument_reporter_string_number) = (20)> then 
replace item (20) of [PrevBestHashMove v] with (item (item (20) of [MovesIdx v]) of [Moves20 v])
 else 
if <(argument_reporter_string_number) = (19)> then 
replace item (19) of [PrevBestHashMove v] with (item (item (19) of [MovesIdx v]) of [Moves19 v])
 else 
if <(argument_reporter_string_number) = (18)> then 
replace item (18) of [PrevBestHashMove v] with (item (item (18) of [MovesIdx v]) of [Moves18 v])
 else 
if <(argument_reporter_string_number) = (17)> then 
replace item (17) of [PrevBestHashMove v] with (item (item (17) of [MovesIdx v]) of [Moves17 v])
 else 
if <(argument_reporter_string_number) = (16)> then 
replace item (16) of [PrevBestHashMove v] with (item (item (16) of [MovesIdx v]) of [Moves16 v])
 else 
if <(argument_reporter_string_number) = (15)> then 
replace item (15) of [PrevBestHashMove v] with (item (item (15) of [MovesIdx v]) of [Moves15 v])
 else 
if <(argument_reporter_string_number) = (14)> then 
replace item (14) of [PrevBestHashMove v] with (item (item (14) of [MovesIdx v]) of [Moves14 v])
 else 
if <(argument_reporter_string_number) = (13)> then 
replace item (13) of [PrevBestHashMove v] with (item (item (13) of [MovesIdx v]) of [Moves13 v])
 else 
if <(argument_reporter_string_number) = (12)> then 
replace item (12) of [PrevBestHashMove v] with (item (item (12) of [MovesIdx v]) of [Moves12 v])
 else 
if <(argument_reporter_string_number) = (11)> then 
replace item (11) of [PrevBestHashMove v] with (item (item (11) of [MovesIdx v]) of [Moves11 v])
 else 
if <(argument_reporter_string_number) = (10)> then 
replace item (10) of [PrevBestHashMove v] with (item (item (10) of [MovesIdx v]) of [Moves10 v])
 else 
if <(argument_reporter_string_number) = (9)> then 
replace item (9) of [PrevBestHashMove v] with (item (item (9) of [MovesIdx v]) of [Moves9 v])
 else 
if <(argument_reporter_string_number) = (8)> then 
replace item (8) of [PrevBestHashMove v] with (item (item (8) of [MovesIdx v]) of [Moves8 v])
if <argument_reporter_boolean> then 
delete (item # of [CurrentMove] in [KillerMoves8 v]) of [KillerMoves8 v]
add [CurrentMove] to [KillerMoves8 v]
if <(length of [KillerMoves8 v]) > (4)> then 
delete (1) of [KillerMoves8 v]
end
end
 else 
if <(argument_reporter_string_number) = (7)> then 
replace item (7) of [PrevBestHashMove v] with (item (item (7) of [MovesIdx v]) of [Moves7 v])
if <argument_reporter_boolean> then 
delete (item # of [CurrentMove] in [KillerMoves7 v]) of [KillerMoves7 v]
add [CurrentMove] to [KillerMoves7 v]
if <(length of [KillerMoves7 v]) > (4)> then 
delete (1) of [KillerMoves7 v]
end
end
 else 
if <(argument_reporter_string_number) = (6)> then 
replace item (6) of [PrevBestHashMove v] with (item (item (6) of [MovesIdx v]) of [Moves6 v])
if <argument_reporter_boolean> then 
delete (item # of [CurrentMove] in [KillerMoves6 v]) of [KillerMoves6 v]
add [CurrentMove] to [KillerMoves6 v]
if <(length of [KillerMoves6 v]) > (4)> then 
delete (1) of [KillerMoves6 v]
end
end
 else 
if <(argument_reporter_string_number) = (5)> then 
replace item (5) of [PrevBestHashMove v] with (item (item (5) of [MovesIdx v]) of [Moves5 v])
if <argument_reporter_boolean> then 
delete (item # of [CurrentMove] in [KillerMoves5 v]) of [KillerMoves5 v]
add [CurrentMove] to [KillerMoves5 v]
if <(length of [KillerMoves5 v]) > (4)> then 
delete (1) of [KillerMoves5 v]
end
end
 else 
if <(argument_reporter_string_number) = (4)> then 
replace item (4) of [PrevBestHashMove v] with (item (item (4) of [MovesIdx v]) of [Moves4 v])
if <argument_reporter_boolean> then 
delete (item # of [CurrentMove] in [KillerMoves4 v]) of [KillerMoves4 v]
add [CurrentMove] to [KillerMoves4 v]
if <(length of [KillerMoves4 v]) > (4)> then 
delete (1) of [KillerMoves4 v]
end
end
 else 
if <(argument_reporter_string_number) = (3)> then 
replace item (3) of [PrevBestHashMove v] with (item (item (3) of [MovesIdx v]) of [Moves3 v])
if <argument_reporter_boolean> then 
delete (item # of [CurrentMove] in [KillerMoves3 v]) of [KillerMoves3 v]
add [CurrentMove] to [KillerMoves3 v]
if <(length of [KillerMoves3 v]) > (4)> then 
delete (1) of [KillerMoves3 v]
end
end
 else 
if <(argument_reporter_string_number) = (2)> then 
replace item (2) of [PrevBestHashMove v] with (item (item (2) of [MovesIdx v]) of [Moves2 v])
if <argument_reporter_boolean> then 
delete (item # of [CurrentMove] in [KillerMoves2 v]) of [KillerMoves2 v]
add [CurrentMove] to [KillerMoves2 v]
if <(length of [KillerMoves2 v]) > (4)> then 
delete (1) of [KillerMoves2 v]
end
end
 else 
if <(argument_reporter_string_number) = (1)> then 
replace item (1) of [PrevBestHashMove v] with (item (item (1) of [MovesIdx v]) of [Moves1 v])
if <argument_reporter_boolean> then 
delete (item # of [CurrentMove] in [KillerMoves1 v]) of [KillerMoves1 v]
add [CurrentMove] to [KillerMoves1 v]
if <(length of [KillerMoves1 v]) > (4)> then 
delete (1) of [KillerMoves1 v]
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end

define EvaluateBoard
set [EvalResult v] to [0]
set [Idx v] to [1]
repeat (64) 
set [CurrentPiece v] to (item (Idx) of [Board v])
if <not <(CurrentPiece) = (Empty)>> then 
if <<([abs v] of (CurrentPiece) ::operators) = (BlackPawn)> and <(IsEndgame) = (1)>> then 
change [EvalResult v] by ((1.2) * (CurrentPiece))
 else 
change [EvalResult v] by (CurrentPiece)
end
GetPosScore %n %n
change [EvalResult v] by (PosScoreRes)
end
change [Idx v] by (1)
end

define IsDraw %n
CalcBoardAttackedByMove %n
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (1)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (1)>>> then 
set [IsDrawRes v] to [0]
stop [this script v]
end
set [IsDrawRes v] to [1]
CalculateMoves %n
replace item (argument_reporter_string_number) of [MovesIdx v] with [1]
repeat (item (argument_reporter_string_number) of [MovesCount v]) 
if <(IsDrawRes) = (1)> then 
ApplyMove %n
CalcBoardAttackedByMove %n
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (0)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (0)>>> then 
set [IsDrawRes v] to [0]
end
RevertMove %n
end
replace item (argument_reporter_string_number) of [MovesIdx v] with ((item (argument_reporter_string_number) of [MovesIdx v]) + (1))
end

define InitHashLookup
set [HashMoveAge v] to [0]
delete (all) of [PosPieceHashLookup v]
repeat (1024) 
add (pick random (-1073741823) to (1073741824)) to [PosPieceHashLookup v]
end
ClearHashCache

when gf clicked
set [IsScratch3 v] to [0]
set [Scratch3TestVal v] to [1]
repeat (1000) 
set [Scratch3TestVal v] to ((2) * (Scratch3TestVal))
end
if <(join [x] [Scratch3TestVal]) = (x1.0715086071862673e+301)> then 
set [Scratch3TestVal v] to (timer)
wait (0) seconds
set [Scratch3TestVal v] to ((timer) - (Scratch3TestVal))
if <(Scratch3TestVal) > (0)> then 
set [IsScratch3 v] to [1]
end
end

define UndoPrevMove
if <(length of [GameMovesAN v]) > (0)> then 
GetSubstringRight %s %n
if <<(item ([floor v] of ((SubstringRes) mod (100)) ::operators) of [Board v]) > (0)> or <<([floor v] of ((SubstringRes) mod (100)) ::operators) = (BlackQueensideCastling)> or <([floor v] of ((SubstringRes) mod (100)) ::operators) = (BlackKingsideCastling)>>> then 
set [IsBlackMove v] to [1]
 else 
set [IsBlackMove v] to [0]
end
set [CurrentValue v] to (item ((length of [BoardHistory v]) - (1)) of [BoardHistory v])
delete (length of [BoardHistory v]) of [BoardHistory v]
delete (length of [BoardHistory v]) of [BoardHistory v]
delete (length of [BoardHistoryHash v]) of [BoardHistoryHash v]
delete (length of [BoardHistoryHash v]) of [BoardHistoryHash v]
ImportBoardInternal %s
if <<(item (length of [GameMovesAN v]) of [GameMovesAN v]) = (O-O)> or <(item (length of [GameMovesAN v]) of [GameMovesAN v]) = (O-O-O)>> then 
if <(IsBlackMove) = (1)> then 
set [HasBlackCastled v] to [0]
set [HasBlackKingMoved v] to [0]
 else 
set [HasWhiteCastled v] to [0]
set [HasWhiteKingMoved v] to [0]
end
end
if <(letter (1) of (item (length of [GameMovesAN v]) of [GameMovesAN v])) = (K)> then 
if <(IsBlackMove) = (1)> then 
set [HasBlackKingMoved v] to [0]
 else 
set [HasWhiteKingMoved v] to [0]
end
set [Idx v] to ((length of [GameMovesAN v]) - (2))
repeat until <(Idx) < (1)> 
if <(letter (1) of (item (Idx) of [GameMovesAN v])) = (K)> then 
if <(IsBlackMove) = (1)> then 
set [HasBlackKingMoved v] to [1]
 else 
set [HasWhiteKingMoved v] to [0]
end
end
change [Idx v] by (-1)
end
end
delete (length of [GameMovesAN v]) of [GameMovesAN v]
GetSubstringLeft %s %n
set [GameMoves v] to [SubstringRes]
end

define ClearHashCache
if <(IsFlash30Bug) = (1)> then 
stop [this script v]
end
if <(IsScratch3) = (1)> then 
set [HashCacheSize v] to [80000]
 else 
set [HashCacheSize v] to [400000]
end
delete (all) of [HashMovesHash v]
repeat (HashCacheSize) 
add [] to [HashMovesHash v]
end
delete (all) of [HashMovesBestMove v]
repeat (HashCacheSize) 
add [] to [HashMovesBestMove v]
end
delete (all) of [HashMovesScore v]
repeat (HashCacheSize) 
add [] to [HashMovesScore v]
end
delete (all) of [HashMovesDepth v]
repeat (HashCacheSize) 
add [] to [HashMovesDepth v]
end
delete (all) of [HashMovesAge v]
repeat (HashCacheSize) 
add [] to [HashMovesAge v]
end
delete (all) of [HashMovesType v]
repeat (HashCacheSize) 
add [] to [HashMovesType v]
end
delete (all) of [HashMovesChecked v]
repeat (HashCacheSize) 
add [] to [HashMovesChecked v]
end
delete (all) of [HashMovesHorizon v]
repeat (HashCacheSize) 
add [] to [HashMovesHorizon v]
end
delete (all) of [HashMoves2Age v]
repeat (HashCacheSize) 
add [] to [HashMoves2Age v]
end
delete (all) of [HashMoves2Hash v]
repeat (HashCacheSize) 
add [] to [HashMoves2Hash v]
end
delete (all) of [HashMoves2BoardScore v]
repeat (HashCacheSize) 
add [] to [HashMoves2BoardScore v]
end

when [j v] key pressed
if <not <(backdrop [name v] ::looks) = (Intro)>> then 
if <(IsModeJunior) = (0)> then 
set [IsModeJunior v] to [1]
SayAsync %s %n
broadcast (1 v)
 else 
set [IsModeJunior v] to [0]
SayAsync %s %n
broadcast (1 v)
end
end

when gf clicked
set [IsModeJunior v] to [0]
set [IsModeProfiler v] to [0]
set [IsModeDeepeningDebug v] to [0]
set [IsModeCompetition v] to [0]

define InitPawnSquarePreCastling
delete (all) of [PawnPieceSquarePreCastling v]
LoadList %s %s

define GetCurrentMoveHash
set [CurrentMoveHash v] to [0]
set [Idx v] to [1]
repeat (64) 
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
change [Idx v] by (1)
end

define IsKillerMove %s %s
set [IsKillerMoveRes v] to [0]
if <set [IsKillerMoveRes v] to [1]> then 
<<<<(argument_reporter_string_number) = (6)> and <(item (length of [KillerMoves4 v]) of [KillerMoves6 v]) = (argument_reporter_string_number)>> or <<(argument_reporter_string_number) = (5)> and <(item (length of [KillerMoves5 v]) of [KillerMoves5 v]) = (argument_reporter_string_number)>>> or <<<(argument_reporter_string_number) = (7)> and <(item (length of [KillerMoves7 v]) of [KillerMoves7 v]) = (argument_reporter_string_number)>> or <<(argument_reporter_string_number) = (8)> and <(item (length of [KillerMoves8 v]) of [KillerMoves8 v]) = (argument_reporter_string_number)>>>> or <<<<(argument_reporter_string_number) = (1)> and <(item (length of [KillerMoves1 v]) of [KillerMoves1 v]) = (argument_reporter_string_number)>> or <<(argument_reporter_string_number) = (2)> and <(item (length of [KillerMoves2 v]) of [KillerMoves2 v]) = (argument_reporter_string_number)>>> or <<<(argument_reporter_string_number) = (3)> and <(item (length of [KillerMoves3 v]) of [KillerMoves3 v]) = (argument_reporter_string_number)>> or <<(argument_reporter_string_number) = (4)> and <(item (length of [KillerMoves4 v]) of [KillerMoves4 v]) = (argument_reporter_string_number)>>>>
end
