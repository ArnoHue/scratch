define-atomic ClearHashCache
if IsFlash30Bug = 1 then
	stop this script
end
if IsScratch3 = 1 then
	set HashCacheSize to 20000
else
	set HashCacheSize to 80000
end
delete all of HashMovesHash
repeat HashCacheSize
	add "" to HashMovesHash
end
delete all of HashMovesBestMove
repeat HashCacheSize
	add "" to HashMovesBestMove
end
delete all of HashMovesScore
repeat HashCacheSize
	add "" to HashMovesScore
end
delete all of HashMovesDepth
repeat HashCacheSize
	add "" to HashMovesDepth
end
delete all of HashMovesAge
repeat HashCacheSize
	add "" to HashMovesAge
end
delete all of HashMovesType
repeat HashCacheSize
	add "" to HashMovesType
end
delete all of HashMovesChecked
repeat HashCacheSize
	add "" to HashMovesChecked
end

define-atomic OnProgressChanged (Progress)
if Progress < 100 then
	set ProgressValue to Progress
else
	set ProgressValue to 100
end
broadcast "ProgressValueChangedInternal"
wait 0 secs

define-atomic InitHashLookup
set HashMoveAge to 0
delete all of PosPieceHashLookup
repeat 1024
	add pick random -1073741823 to 1073741824 to PosPieceHashLookup
end
ClearHashCache

define-atomic ApplyMove (Depth)
replace item Depth of PosScoreDelta with "0"
replace item Depth of TargetPiecesIdx with ""
replace item Depth of TargetPieces with Empty
replace item Depth of PromotionPieces with Empty
replace item Depth of PreviousMoveHash with CurrentMoveHash
GetCurrentMove (Depth)
set SourceIdx to floor of (CurrentMove / 100)
set TargetIdx to floor of (CurrentMove mod 100)
if SourceIdx > 0 and TargetIdx > 0 then
	GetPosPieceHash (SourceIdx) (item SourceIdx of Board)
	set CurrentMoveHash to CurrentMoveHash - PosPieceHash
	GetPosPieceHash (TargetIdx) (item SourceIdx of Board)
	set CurrentMoveHash to CurrentMoveHash + PosPieceHash
	if not item TargetIdx of Board = Empty then
		GetPosPieceHash (TargetIdx) (item TargetIdx of Board)
		set CurrentMoveHash to CurrentMoveHash - PosPieceHash
	end
	GetPosScore (item SourceIdx of Board) (TargetIdx)
	replace item Depth of PosScoreDelta with PosScoreRes
	GetPosScore (item SourceIdx of Board) (SourceIdx)
	replace item Depth of PosScoreDelta with item Depth of PosScoreDelta - PosScoreRes
	GetPosScore (item TargetIdx of Board) (TargetIdx)
	replace item Depth of PosScoreDelta with item Depth of PosScoreDelta + PosScoreRes
	replace item Depth of TargetPiecesIdx with TargetIdx
	replace item Depth of TargetPieces with item TargetIdx of Board
	replace item TargetIdx of Board with item SourceIdx of Board
	replace item SourceIdx of Board with Empty
	if item TargetIdx of Board = BlackPawn and item Depth of TargetPieces = Empty and not item SourceIdx of IdxToCol = item TargetIdx of IdxToCol then
		replace item Depth of TargetPiecesIdx with TargetIdx - 8
		replace item Depth of TargetPieces with item (TargetIdx - 8) of Board
		replace item TargetIdx - 8 of Board with Empty
		GetPosPieceHash (TargetIdx - 8) (item (TargetIdx - 8) of Board)
		set CurrentMoveHash to CurrentMoveHash - PosPieceHash
	end
	if item TargetIdx of Board = WhitePawn and item Depth of TargetPieces = Empty and not item SourceIdx of IdxToCol = item TargetIdx of IdxToCol then
		replace item Depth of TargetPiecesIdx with TargetIdx + 8
		replace item Depth of TargetPieces with item (TargetIdx + 8) of Board
		replace item TargetIdx + 8 of Board with Empty
		GetPosPieceHash (TargetIdx + 8) (item (TargetIdx + 8) of Board)
		set CurrentMoveHash to CurrentMoveHash - PosPieceHash
	end
	if item TargetIdx of Board = BlackPawn and TargetIdx > 56 then
		replace item Depth of PromotionPieces with Empty
		set PromotionVal to letter 6 of CurrentMove
		if PromotionVal = 1 then
			replace item Depth of PromotionPieces with BlackQueen
		end
		if PromotionVal = 2 then
			replace item Depth of PromotionPieces with BlackRook
		end
		if PromotionVal = 3 then
			replace item Depth of PromotionPieces with BlackBishop
		end
		if PromotionVal = 4 then
			replace item Depth of PromotionPieces with BlackKnight
		end
		if not item Depth of PromotionPieces = Empty then
			replace item TargetIdx of Board with item Depth of PromotionPieces
		end
		GetPosPieceHash (TargetIdx) (BlackPawn)
		set CurrentMoveHash to CurrentMoveHash - PosPieceHash
		GetPosPieceHash (TargetIdx) (item Depth of PromotionPieces)
		set CurrentMoveHash to CurrentMoveHash + PosPieceHash
	end
	if item TargetIdx of Board = WhitePawn and TargetIdx < 9 then
		replace item Depth of PromotionPieces with Empty
		set PromotionVal to letter 6 of CurrentMove
		if PromotionVal = 1 then
			replace item Depth of PromotionPieces with WhiteQueen
		end
		if PromotionVal = 2 then
			replace item Depth of PromotionPieces with WhiteRook
		end
		if PromotionVal = 3 then
			replace item Depth of PromotionPieces with WhiteBishop
		end
		if PromotionVal = 4 then
			replace item Depth of PromotionPieces with WhiteKnight
		end
		if not item Depth of PromotionPieces = Empty then
			replace item TargetIdx of Board with item Depth of PromotionPieces
		end
		GetPosPieceHash (TargetIdx) (WhitePawn)
		set CurrentMoveHash to CurrentMoveHash - PosPieceHash
		GetPosPieceHash (TargetIdx) (item Depth of PromotionPieces)
		set CurrentMoveHash to CurrentMoveHash + PosPieceHash
	end
else
	if CurrentMove = WhiteKingsideCastling then
		replace item item 61 of VirtualBoard of Board with Empty
		replace item item 62 of VirtualBoard of Board with WhiteRook
		replace item item 63 of VirtualBoard of Board with WhiteKing
		replace item item 64 of VirtualBoard of Board with Empty
		UpdateMoveHashPosScore (WhiteKing) (item 61 of VirtualBoard) (item 63 of VirtualBoard) <1 = 0>
		UpdateMoveHashPosScore (WhiteRook) (item 64 of VirtualBoard) (item 62 of VirtualBoard) <1 = 1>
	else
		if CurrentMove = WhiteQueensideCastling then
			replace item item 57 of VirtualBoard of Board with Empty
			replace item item 59 of VirtualBoard of Board with WhiteKing
			replace item item 60 of VirtualBoard of Board with WhiteRook
			replace item item 61 of VirtualBoard of Board with Empty
			UpdateMoveHashPosScore (WhiteKing) (item 61 of VirtualBoard) (item 59 of VirtualBoard) <1 = 0>
			UpdateMoveHashPosScore (WhiteRook) (item 57 of VirtualBoard) (item 59 of VirtualBoard) <1 = 1>
		else
			if CurrentMove = BlackKingsideCastling then
				replace item item 5 of VirtualBoard of Board with Empty
				replace item item 6 of VirtualBoard of Board with BlackRook
				replace item item 7 of VirtualBoard of Board with BlackKing
				replace item item 8 of VirtualBoard of Board with Empty
				UpdateMoveHashPosScore (BlackKing) (item 5 of VirtualBoard) (item 7 of VirtualBoard) <1 = 0>
				UpdateMoveHashPosScore (BlackRook) (item 8 of VirtualBoard) (item 6 of VirtualBoard) <1 = 1>
			else
				if CurrentMove = BlackQueensideCastling then
					replace item item 1 of VirtualBoard of Board with Empty
					replace item item 3 of VirtualBoard of Board with BlackKing
					replace item item 4 of VirtualBoard of Board with BlackRook
					replace item item 5 of VirtualBoard of Board with Empty
					UpdateMoveHashPosScore (BlackKing) (item 5 of VirtualBoard) (item 3 of VirtualBoard) <1 = 0>
					UpdateMoveHashPosScore (BlackRook) (item 1 of VirtualBoard) (item 4 of VirtualBoard) <1 = 1>
				end
			end
		end
	end
end

define-atomic StoreMove (Depth) <IsKiller>
if 1 = 0 then
	if IsKiller then
		GetCurrentMove (Depth)
		replace item CurrentMove of HistoryTable with item CurrentMove of HistoryTable + (10 - Depth) * (10 - Depth)
	end
end
if Depth = 15 then
	replace item 15 of PrevBestHashMove with item item 15 of MovesIdx of Moves15
else
	if Depth = 14 then
		replace item 14 of PrevBestHashMove with item item 14 of MovesIdx of Moves14
	else
		if Depth = 13 then
			replace item 13 of PrevBestHashMove with item item 13 of MovesIdx of Moves13
		else
			if Depth = 12 then
				replace item 12 of PrevBestHashMove with item item 12 of MovesIdx of Moves12
			else
				if Depth = 11 then
					replace item 11 of PrevBestHashMove with item item 11 of MovesIdx of Moves11
				else
					if Depth = 10 then
						replace item 10 of PrevBestHashMove with item item 10 of MovesIdx of Moves10
					else
						if Depth = 9 then
							replace item 9 of PrevBestHashMove with item item 9 of MovesIdx of Moves9
						else
							if Depth = 8 then
								replace item 8 of PrevBestHashMove with item item 8 of MovesIdx of Moves8
							else
								if Depth = 7 then
									replace item 7 of PrevBestHashMove with item item 7 of MovesIdx of Moves7
								else
									if Depth = 6 then
										replace item 6 of PrevBestHashMove with item item 6 of MovesIdx of Moves6
										if IsKiller then
											if not KillerMoves6 contains item item 6 of MovesIdx of Moves6? then
												add item item 6 of MovesIdx of Moves6 to KillerMoves6
												if length of KillerMoves6 > 4 then
													delete 1 of KillerMoves6
												end
											end
										end
									else
										if Depth = 5 then
											replace item 5 of PrevBestHashMove with item item 5 of MovesIdx of Moves5
											if IsKiller then
												if not KillerMoves5 contains item item 5 of MovesIdx of Moves5? then
													add item item 5 of MovesIdx of Moves5 to KillerMoves5
													if length of KillerMoves5 > 4 then
														delete 1 of KillerMoves5
													end
												end
											end
										else
											if Depth = 4 then
												replace item 4 of PrevBestHashMove with item item 4 of MovesIdx of Moves4
												if IsKiller then
													if not KillerMoves4 contains item item 4 of MovesIdx of Moves4? then
														add item item 4 of MovesIdx of Moves4 to KillerMoves4
														if length of KillerMoves4 > 4 then
															delete 1 of KillerMoves4
														end
													end
												end
											else
												if Depth = 3 then
													replace item 3 of PrevBestHashMove with item item 3 of MovesIdx of Moves3
													if IsKiller then
														if not KillerMoves3 contains item item 3 of MovesIdx of Moves3? then
															add item item 3 of MovesIdx of Moves3 to KillerMoves3
															if length of KillerMoves3 > 4 then
																delete 1 of KillerMoves3
															end
														end
													end
												else
													if Depth = 2 then
														replace item 2 of PrevBestHashMove with item item 2 of MovesIdx of Moves2
														if IsKiller then
															if not KillerMoves2 contains item item 2 of MovesIdx of Moves2? then
																add item item 2 of MovesIdx of Moves2 to KillerMoves2
																if length of KillerMoves2 > 4 then
																	delete 1 of KillerMoves2
																end
															end
														end
													else
														if Depth = 1 then
															replace item 1 of PrevBestHashMove with item item 1 of MovesIdx of Moves1
															if IsKiller then
																if not KillerMoves1 contains item item 1 of MovesIdx of Moves1? then
																	add item item 1 of MovesIdx of Moves1 to KillerMoves1
																	if length of KillerMoves1 > 4 then
																		delete 1 of KillerMoves1
																	end
																end
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

define-atomic AddSimpleMoveNoCheck (SourceIdx arg) (DeltaX) (DeltaY) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
set TargetIdx to item SourceIdx arg of IdxToCol + DeltaX + (item SourceIdx arg of IdxToRow + DeltaY - 1) * 8
if not CapturesOnly or <item SourceIdx arg of Board > 0 and item TargetIdx of Board < 0> or <item SourceIdx arg of Board < 0 and item TargetIdx of Board > 0> then
	AddMoveImpl (SourceIdx arg) (TargetIdx) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
end

define-atomic OnScoreCalc (Depth) (MinDepth) (MaxDepth) <ApplyCutoff> <CalcCutoff> <Quiescence>
Profile_MethodEnter (Depth)
set ScoreCalcRes to 0
if Depth = 0 then
	set EvalResult to 0
	set EvalExtendedResult to 0
	delete all of EvalExtended
	repeat 20
		add "" to EvalExtended
	end
end
if <Depth = MaxDepth and Depth < ExtendedEvaluationMaxDepth> or Depth = ExtendedEvaluationMaxDepth then
	EvaluateBoard
	EvaluateBoardExtended (Depth)
end
if Depth = MaxDepth then
	set ScoreCalcRes to EvalResult + EvalExtendedResult
	if Depth > ExtendedEvaluationMaxDepth then
		set Idx to ExtendedEvaluationMaxDepth + 1
		repeat until Idx > Depth
			change ScoreCalcRes by 0 - item Idx of TargetPieces
			change ScoreCalcRes by item Idx of PosScoreDelta
			if not item Idx of PromotionPieces = Empty then
				if Idx mod 2 = 1 then
					change ScoreCalcRes by item Idx of PromotionPieces - BlackPawn
				else
					change ScoreCalcRes by item Idx of PromotionPieces - WhitePawn
				end
			end
			change Idx by 1
		end
	end
	if 1 = 1 then
		if CalcCutoff then
			if not item Depth of TargetPieces = Empty then
				GetCurrentMove (Depth)
				set TargetIdx to floor of (CurrentMove mod 100)
				if <Depth mod 2 = 0 and item TargetIdx of BoardAttackedByBlack > 0> or <Depth mod 2 = 1 and item TargetIdx of BoardAttackedByWhite > 0> then
					change ScoreCalcRes by 0 - item TargetIdx of Board
				end
			end
		end
	end
end
Profile_MethodExit (Depth)

define-atomic InitKingSquareEndgame
delete all of KingPieceSquareEndgame
set KingSquareDefEndgame to "  -30, -25, -20, -15, -15, -20, -25, -30 ,  -20, -15, -10, -5, -5, -10, -15, -20,   -15, -10, -5, 0, 0, -5, -10, -15,   -15, -10, -5, 0, 0, -5, -10, -15,   -15, -10, -5, 0, 0, -5, -10, -15,   -20, -15, -10, -5, -5, -10, -15, -20,   -25, -20, -15, -10, -10, -15, -20, -25,  -30, -25, -20, -15, -15, -20, -25, -30"
LoadList (KingSquareDefEndgame) "KingPieceSquareEndgame"

define-atomic GetSubstringRight [Text] (Count arg)
GetSubstring (Text) (length of Text - Count arg + 1) (length of Text)

define-atomic InitMobilityBonusLookup
delete all of QueenMobilityBonus
delete all of BishopMobilityBonus
delete all of RookMobilityBonus
delete all of KnightMobilityBonus
LoadList "-4,-3,0,0,1,2,3,4,4,5,5,6,6,7,7,7,8,8,9,9,10,11,11,11,12,12,12,13" "QueenMobilityBonus"
LoadList "-5,-2,2,3,4,5,5,6,7,7,8,8,9,10" "BishopMobilityBonus"
LoadList "-6,-3,-1,-1,0,0,1,1,2,2,3,3,4,5,6" "RookMobilityBonus"
LoadList "-8,-6,-1,0,1,2,2,3,4" "KnightMobilityBonus"

define-atomic AddBoardToHistory
GetBoardString
add GetBoardStringRes to BoardHistory

define-atomic GetMoveScore (SourcePiece arg) (TargetPiece arg) (FromIdx) (ToIdx) (Move) (Depth)
set MoveScoreRes to 0
if Depth mod 2 = 1 then
	set RankFac to 1
else
	set RankFac to -1
end
if letter 5 of Move = "." then
	if letter 6 of Move = 1 then
		set MoveScoreRes to 800 * RankFac
	end
	if letter 6 of Move = 2 then
		set MoveScoreRes to 400 * RankFac
	end
	if letter 6 of Move = 3 then
		set MoveScoreRes to 230 * RankFac
	end
	if letter 6 of Move = 4 then
		set MoveScoreRes to 210 * RankFac
	end
	stop this script
end
if <Depth mod 2 = 0 and item ToIdx of BoardAttackedByBlack = 0> or <Depth mod 2 = 1 and item ToIdx of BoardAttackedByWhite = 0> then
	set IsAttacked to 0
else
	set IsAttacked to 1
end
if TargetPiece arg = Empty and IsAttacked = 0 then
	if Depth = 2 then
		if KillerMoves2 contains Move? then
			set MoveScoreRes to 80 * RankFac
			stop this script
		end
	end
	if Depth = 3 then
		if KillerMoves3 contains Move? then
			set MoveScoreRes to 80 * RankFac
			stop this script
		end
		if 1 = 0 then
			if Move = item 1 of Moves1 then
				set MoveScoreRes to 70 * RankFac
				stop this script
			end
			if Move = item 2 of Moves1 then
				set MoveScoreRes to 65 * RankFac
				stop this script
			end
			if Move = item 3 of Moves1 then
				set MoveScoreRes to 60 * RankFac
				stop this script
			end
		end
	end
	if Depth = 4 then
		if KillerMoves4 contains Move? then
			set MoveScoreRes to 80 * RankFac
			stop this script
		end
		if 1 = 0 then
			if Move = item 1 of Moves2 then
				set MoveScoreRes to 70 * RankFac
				stop this script
			end
			if Move = item 2 of Moves2 then
				set MoveScoreRes to 65 * RankFac
				stop this script
			end
			if Move = item 3 of Moves2 then
				set MoveScoreRes to 60 * RankFac
				stop this script
			end
		end
	end
	if Depth = 5 or Depth = 6 then
		if <Depth = 5 and KillerMoves5 contains Move?> or <Depth = 6 and KillerMoves6 contains Move?> then
			set MoveScoreRes to 80 * RankFac
			stop this script
		end
	end
	if Move = BlackQueensideCastling or Move = BlackKingsideCastling or Move = WhiteQueensideCastling or Move = WhiteKingsideCastling then
		set MoveScoreRes to 50 * RankFac
		stop this script
	end
end
set MoveScoreRes to 0
GetPosScore (SourcePiece arg) (FromIdx)
change MoveScoreRes by 0 - PosScoreRes
if IsAttacked = 0 then
	GetPosScore (SourcePiece arg) (ToIdx)
	change MoveScoreRes by PosScoreRes
else
	change MoveScoreRes by 0 - SourcePiece arg
end
if not TargetPiece arg = Empty then
	change MoveScoreRes by 0 - TargetPiece arg
	GetPosScore (TargetPiece arg) (ToIdx)
	change MoveScoreRes by 0 - PosScoreRes
end

define-atomic AlphaBetaMinMax (Alpha) (Beta) (MinDepth) (MaxDepth) <ApplyCutoff> <CalcCutoff> (QuiescenceDepth arg) <ShowProgress>
OnScoreCalc 0 (MinDepth) (MaxDepth - 1) <ApplyCutoff> <CalcCutoff> <1 = 0>
replace item MinDepth of Alphas with Alpha
replace item MinDepth of Betas with Beta
AlphaBetaMinMaxImpl (MinDepth) (MinDepth) (MaxDepth) <ApplyCutoff> <CalcCutoff> (QuiescenceDepth arg) <1 = 0> <1 = 0> <ShowProgress>

define-atomic IsLowerCase [Char]
set Chars to ""
set CharsIdx to 1
repeat length of CharsUpperCase
	if letter CharsIdx of CharsUpperCase = Char then
		set Chars to (join (Chars) (Char))
	else
		set Chars to (join (Chars) (letter CharsIdx of CharsUpperCase))
	end
	change CharsIdx by 1
end
switch costume to "_ABCDEFGHIJKLMNOPQRSTUVWXYZ"
switch costume to (Chars)
if costume # = 1 then
	set IsLowerCaseRes to 0
else
	set IsLowerCaseRes to 1
end

define-atomic ClearBoardAttackedByMove (Depth)
set IsBlackMove to Depth mod 2
set Idx to 1
repeat 64
	if IsBlackMove = 1 then
		replace item Idx of BoardAttackedByBlack with "0"
		replace item Idx of BoardAttackedByBlackPiece with "0"
	else
		replace item Idx of BoardAttackedByWhite with "0"
		replace item Idx of BoardAttackedByWhitePiece with "0"
	end
	change Idx by 1
end
if IsBlackMove = 1 then
	set IsWhiteChecked to 0
else
	set IsBlackChecked to 0
end

define-atomic EnterExecution
change ExecutionDepth by 1
if ExecutionDepth > 0 then
	set IsExecutionRunning to 1
end

define-atomic InitAlphaBeta (Depth) (MaxDepth) <ApplyCutoff>
if Depth = 1 then
	set IsMinMaxTimeout to 0
	if not ApplyCutoff then
		Profile_Reset
	end
	change HashMoveAge by 1
	set CurrentMoveHash to 0
	set Idx to 1
	repeat 64
		GetPosPieceHash (Idx) (item Idx of Board)
		set CurrentMoveHash to CurrentMoveHash + PosPieceHash
		change Idx by 1
	end
	delete all of MinMaxPly1EvalMoves
	if IsScratch3 = 1 then
		set ExtendedEvaluationMaxDepth to 3
	else
		set ExtendedEvaluationMaxDepth to 4
	end
	set BlackMinorCount to 0
	set BlackQueenCount to 0
	set WhiteQueenCount to 0
	set WhiteMinorCount to 0
	set Idx to 1
	repeat 64
		if item Idx of Board = WhiteQueen then
			change WhiteQueenCount by 1
		end
		if item Idx of Board = BlackQueen then
			change BlackQueenCount by 1
		end
		if item Idx of Board = WhiteKnight or item Idx of Board = WhiteBishop or item Idx of Board = WhiteRook then
			change WhiteMinorCount by 1
		end
		if item Idx of Board = BlackKnight or item Idx of Board = BlackBishop or item Idx of Board = BlackRook then
			change BlackMinorCount by 1
		end
		change Idx by 1
	end
	set IsEndgame to 0
	if WhiteQueenCount * 9 + WhiteMinorCount * 4 < 10 or BlackQueenCount * 9 + BlackMinorCount * 4 < 10 then
		set IsEndgame to 1
	end
	set IsEndgame2 to 0
	if WhiteQueenCount + WhiteMinorCount < 2 or BlackQueenCount + BlackMinorCount < 2 then
		set IsEndgame2 to 1
	end
	if 1 = 1 then
		ClearLog
	end
end

define-atomic GetSubstring [Text] (FromIdx) (ToIdx)
set SubstringRes to ""
set IdxString to FromIdx
repeat ToIdx - FromIdx + 1
	set SubstringRes to (join (SubstringRes) (letter IdxString of Text))
	change IdxString by 1
end

define-atomic GetPosScore (Piece) (Idx arg)
set PosScoreRes to 0
if Piece = BlackPawn or Piece = WhitePawn then
	if IsEndgame = 1 then
		if Piece = BlackPawn then
			set PosScoreRes to item (65 - Idx arg) of PawnPieceSquareEndgame
		else
			set PosScoreRes to 0 - item Idx arg of PawnPieceSquareEndgame
		end
	else
		if Piece = BlackPawn then
			if HasBlackCastled = 0 and HasBlackKingMoved = 0 and <HasBlackRookKSMoved = 0 or HasBlackRookQSMoved = 0> then
				set PosScoreRes to item (65 - Idx arg) of PawnPieceSquarePreCastling
			else
				set PosScoreRes to item (65 - Idx arg) of PawnPieceSquare
			end
		else
			if HasWhiteCastled = 0 and HasWhiteKingMoved = 0 and <HasWhiteRookKSMoved = 0 or HasWhiteRookQSMoved = 0> then
				set PosScoreRes to 0 - item Idx arg of PawnPieceSquarePreCastling
			else
				set PosScoreRes to 0 - item Idx arg of PawnPieceSquare
			end
		end
	end
else
	if IsEndgame = 1 then
		if Piece = BlackKing then
			set PosScoreRes to item (65 - Idx arg) of KingPieceSquareEndgame
		else
			if Piece = WhiteKing then
				set PosScoreRes to 0 - item Idx arg of KingPieceSquareEndgame
			end
		end
		if IsEndgame2 = 1 then
			set PosScoreRes to PosScoreRes * 2
		end
	else
		if Piece = BlackKing then
			set PosScoreRes to item (65 - Idx arg) of KingPieceSquare
		else
			if Piece = WhiteKing then
				set PosScoreRes to 0 - item Idx arg of KingPieceSquare
			end
		end
	end
	if Piece = BlackKnight then
		set PosScoreRes to item (65 - Idx arg) of KnightPieceSquare
	else
		if Piece = WhiteKnight then
			set PosScoreRes to 0 - item Idx arg of KnightPieceSquare
		else
			if Piece = BlackBishop then
				set PosScoreRes to item (65 - Idx arg) of BishopPieceSquare
			else
				if Piece = WhiteBishop then
					set PosScoreRes to 0 - item Idx arg of BishopPieceSquare
				else
					if Piece = BlackRook then
						set PosScoreRes to item (65 - Idx arg) of RookPieceSquare
					else
						if Piece = WhiteRook then
							set PosScoreRes to 0 - item Idx arg of RookPieceSquare
						else
							if Piece = BlackQueen then
								set PosScoreRes to item (65 - Idx arg) of QueenPieceSquare
							else
								if Piece = WhiteQueen then
									set PosScoreRes to 0 - item Idx arg of QueenPieceSquare
								end
							end
						end
					end
				end
			end
		end
	end
end

define ExecuteMovePostProcess
set MoveFromIdx to -1
set MoveToIdx to -1
set FromSquareIdx to -1
set ToSquareIdx to -1
broadcast "FromSquareSelected" and wait
broadcast "ToSquareSelected" and wait
broadcast "InputMode" and wait

define-atomic CutoffOnMoveScore (Depth) (Score arg)
if Depth = 1 then
	if Score arg < 0 then
		replace item item 1 of MovesIdx of SortedList with 0 - abs of (Score arg * 10000) + item 1 of MovesIdx
	else
		replace item item 1 of MovesIdx of SortedList with Score arg * 10000 + item 1 of MovesIdx
	end
end
if Depth = 2 then
	if Score arg < 0 then
		replace item item 2 of MovesIdx of SortedListTemp with 0 - abs of (Score arg * 10000) + item 2 of MovesIdx
	else
		replace item item 2 of MovesIdx of SortedListTemp with Score arg * 10000 + item 2 of MovesIdx
	end
end

define ExitExecution
change ExecutionDepth by -1
if not ExecutionDepth > 0 then
	set IsExecutionRunning to 0
end

define ExecuteEngineMove
EnterExecution
if IsGameSuspended = 0 then
	delete all of BestMoves
	CalculateOpeningMoves
	set BestMove to item pick random 1 to length of BestMoves of BestMoves
	IsValidMove (BestMove)
	if ValidMoveRes = 0 then
		think "Thinking..."
		wait 0 secs
		if IsModeJunior = 0 then
			if Level = 1 then
				set ThinkTimeLimit to 5
			else
				if Level = 2 then
					set ThinkTimeLimit to 25
				else
					if IsModeCompetition = 0 then
						if IsEndgame = 0 then
							set ThinkTimeLimit to 45
						else
							set ThinkTimeLimit to 30
						end
					else
						set ThinkTimeLimit to 60
					end
				end
			end
			set ThinkTimeStart to timer
			set IsDeepeningDone to 0
			set IdxDeepening to 2
			set BestMove to ""
			set BestMinMaxRes to ""
			set ProgressPaintEnabled to 1
			repeat until IsDeepeningDone = 1
				delete all of BestMoves
				if IdxDeepening > 2 then
					set ThinkTimeLimitMinMax to ThinkTimeLimit
				else
					set ThinkTimeLimitMinMax to 60
				end
				set QuiescenceDepth to 15 - IdxDeepening
				AlphaBetaMinMax -100000 100000 1 (IdxDeepening + 1) <IdxDeepening > 2> <IdxDeepening = 2> (QuiescenceDepth) <1 = 1>
				if length of BestMoves > 0 and length of item 1 of BestMoves > 0 then
					if BestMove = "" or MinMaxPly1EvalMoves contains BestMove? then
						set BestMove to item 1 of BestMoves
						set BestMinMaxRes to item 1 of BestMinMaxResults
					end
				end
				if IsMinMaxTimeout = 1 or BestMinMaxRes > BlackKing / 2 or BestMinMaxRes < WhiteKing / 2 or IdxDeepening = 15 then
					set IsDeepeningDone to 1
				else
					change IdxDeepening by 1
				end
			end
		else
			delete all of BestMoves
			set ThinkTimeStart to timer
			if Level = 1 then
				CalculateMoves 1
				replace item 1 of MovesIdx with pick random 1 to length of Moves1
				ApplyMove 1
				CalcBoardAttackedByMove 2
				RevertMove 1
				repeat until IsBlackChecked = 0
					replace item 1 of MovesIdx with pick random 1 to length of Moves1
					ApplyMove 1
					CalcBoardAttackedByMove 2
					RevertMove 1
				end
				set BestMove to item item 1 of MovesIdx of Moves1
			else
				if Level = 2 then
					set ThinkTimeLimitMinMax to 2
					AlphaBetaMinMax -100000 100000 1 2 <1 = 1> <1 = 0> 1 <1 = 1>
					set BestMove to item 1 of BestMoves
				else
					set ThinkTimeLimitMinMax to 5
					AlphaBetaMinMax -100000 100000 1 3 <1 = 1> <1 = 0> 3 <1 = 1>
					set BestMove to item 1 of BestMoves
				end
			end
		end
		broadcast "HideBestMove" and wait
		OnProgressChanged 100
		wait 0 secs
	end
	IsValidMove (BestMove)
	if ValidMoveRes = 0 then
		say (join "Internal Error: No valid move found. Sorry, this should not happen. Maybe you cleared lookup lists in the editor? If you are running a normal game, please export board data and report bug via project comment" join " Move: " (BestMove)) for 10 secs
		broadcast "InputMode"
		set IsGameSuspended to 1
		ExecuteMovePostProcess
		ExitExecution
		stop this script
	end
	think ""
	GetMoveNotation (BestMove)
	set BestMoveAN to MoveNotationRes
	set GameMoves to (join (GameMoves) (BestMove))
	set MovePieceFromIdx to floor of (BestMove / 100)
	set MovePieceToIdx to floor of (BestMove mod 100)
	if BestMove = BlackQueensideCastling or BestMove = BlackKingsideCastling or BestMove = WhiteQueensideCastling or BestMove = WhiteKingsideCastling then
		set MovePieceSpecial to BestMove
	else
		set MovePieceSpecial to ""
	end
	wait 0 secs
	broadcast "MovePiece" and wait
	delete all of Moves1
	add BestMove to Moves1
	replace item 1 of MovesIdx with "1"
	replace item 1 of MovesCount with "1"
	ApplyMove 1
	DrawBoardAndWait
	AddBoardToHistory
	add BestMoveAN to GameMovesAN
	GetRepetitionCount
	if RepetitionCountRes > 2 then
		say "Draw!"
		broadcast "InputMode"
		set IsGameSuspended to 1
	else
		IsTwoKingDraw
		if TwoKingDrawRes = 1 then
			say "Draw!"
			broadcast "InputMode"
			set IsGameSuspended to 1
		else
			IsWhiteKingCheckMate
			if IsWhiteKingCheckMateRes = 1 then
				say "Checkmate!"
				broadcast "InputMode"
				set IsGameSuspended to 1
			else
				IsDraw 2
				if IsDrawRes = 1 then
					say "Draw!"
					broadcast "InputMode"
					set IsGameSuspended to 1
				else
					CalcBoardAttackedByMove 1
					if IsWhiteChecked = 1 then
						SayAsync "Check!" 2
					end
					if item (BestMove mod 100) of Board = BlackKing then
						set HasBlackKingMoved to 1
					end
					if item (BestMove mod 100) of Board = BlackRook then
						if floor of (BestMove / 100) = item 1 of VirtualBoard then
							set HasBlackRookQSMoved to 1
						end
						if floor of (BestMove / 100) = item 8 of VirtualBoard then
							set HasBlackRookKSMoved to 1
						end
					end
					if BestMove = BlackQueensideCastling or BestMove = BlackKingsideCastling then
						set HasBlackKingMoved to 1
						set HasBlackCastled to 1
					end
				end
			end
		end
	end
end
ExecuteMovePostProcess
ExitExecution

define ExecuteInit
set ExecutionDepth to 0
set IsExecutionRunning to 0
EnterExecution
if IsPlayerBlack = 1 then
	ExecuteEngineMove
end
ExecuteMovePostProcess
ExitExecution

define-atomic CutoffPostProcess (Depth)
if Depth = 1 then
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with abs of item Idx of SortedList mod 10000
		change Idx by 1
	end
	set Idx to 1
	repeat floor of (length of SortedList / 2)
		set Swap to item Idx of SortedList
		replace item Idx of SortedList with item (length of SortedList - Idx + 1) of SortedList
		replace item length of SortedList - Idx + 1 of SortedList with Swap
		change Idx by 1
	end
	replace item item 1 of SortedList of HistoryTable with item item 1 of SortedList of HistoryTable + (10 - Depth) * (10 - Depth)
end
if Depth = 2 then
	if 1 = 0 then
		QuickSortTemp 1 (length of SortedListTemp)
		set Idx to 1
		repeat length of SortedListTemp
			set CurrentIdx to abs of item Idx of SortedListTemp mod 10000
			repeat until length of CurrentIdx > 3
				set CurrentIdx to (join "0" (CurrentIdx))
			end
			replace item item 1 of MovesIdx of SortedList2 with (join (item item 1 of MovesIdx of SortedList2) (CurrentIdx))
			change Idx by 1
		end
		GetSubstring (item item 1 of MovesIdx of SortedList2) 1 4
		replace item SubstringRes of HistoryTable with item SubstringRes of HistoryTable + (10 - Depth) * (10 - Depth)
	end
end

define-atomic InitMoveLookup
delete all of MoveLookupStraight
delete all of MoveLookupCross
delete all of MoveLookupOffsetsStraight
delete all of MoveLookupOffsetsCross
delete all of MoveLookupKnight
delete all of MoveLookupKing
delete all of MoveLookupIndexOffset
delete all of MoveLookupLineIndexOffset
add "1" to MoveLookupOffsetsStraight
add "0" to MoveLookupOffsetsStraight
add "0" to MoveLookupOffsetsStraight
add "1" to MoveLookupOffsetsStraight
add "-1" to MoveLookupOffsetsStraight
add "0" to MoveLookupOffsetsStraight
add "0" to MoveLookupOffsetsStraight
add "-1" to MoveLookupOffsetsStraight
add "1" to MoveLookupOffsetsCross
add "1" to MoveLookupOffsetsCross
add "1" to MoveLookupOffsetsCross
add "-1" to MoveLookupOffsetsCross
add "-1" to MoveLookupOffsetsCross
add "1" to MoveLookupOffsetsCross
add "-1" to MoveLookupOffsetsCross
add "-1" to MoveLookupOffsetsCross
set Idx to 1
repeat 64
	set IdxSub to 1
	repeat 4
		set X to item Idx of IdxToCol
		set Y to item Idx of IdxToRow
		repeat 8
			change X by item IdxSub of MoveLookupOffsetsStraight
			change Y by item (IdxSub + 1) of MoveLookupOffsetsStraight
			add "-1" to MoveLookupStraight
			if Y > 0 and Y < 9 then
				if X > 0 and X < 9 then
					set TargetIdx to X + (Y - 1) * 8
					replace item last of MoveLookupStraight with TargetIdx
				end
			end
		end
		change IdxSub by 2
	end
	set IdxSub to 1
	repeat 4
		set X to item Idx of IdxToCol
		set Y to item Idx of IdxToRow
		repeat 8
			change X by item IdxSub of MoveLookupOffsetsCross
			change Y by item (IdxSub + 1) of MoveLookupOffsetsCross
			add "-1" to MoveLookupCross
			if Y > 0 and Y < 9 then
				if X > 0 and X < 9 then
					set TargetIdx to X + (Y - 1) * 8
					replace item last of MoveLookupCross with TargetIdx
				end
			end
		end
		change IdxSub by 2
	end
	change Idx by 1
end
set Idx to 1
repeat 64
	insert (Idx - 1) * 8 at Idx of MoveLookupIndexOffset
	insert (Idx - 1) * 32 at Idx of MoveLookupLineIndexOffset
	change Idx by 1
end
set Idx to 1
repeat 64
	set IdxSub to 1
	repeat 8
		GetTargetIdx (Idx) (item IdxSub of KingMoveOffsets) (item (IdxSub + 1) of KingMoveOffsets)
		if not GetTargetIdxRes = -1 then
			add GetTargetIdxRes to MoveLookupKing
		end
		change IdxSub by 2
	end
	repeat until length of MoveLookupKing = Idx * 8
		add "-1" to MoveLookupKing
	end
	set IdxSub to 1
	repeat 8
		GetTargetIdx (Idx) (item IdxSub of KnightMoveOffsets) (item (IdxSub + 1) of KnightMoveOffsets)
		if not GetTargetIdxRes = -1 then
			add GetTargetIdxRes to MoveLookupKnight
		end
		change IdxSub by 2
	end
	repeat until length of MoveLookupKnight = Idx * 8
		add "-1" to MoveLookupKnight
	end
	change Idx by 1
end

define-atomic GetTargetIdx (SourceIdx arg) (DeltaX) (DeltaY)
set GetTargetIdxRes to -1
set X to item SourceIdx arg of IdxToCol + DeltaX
if X > 0 and X < 9 then
	set Y to item SourceIdx arg of IdxToRow + DeltaY
	if Y > 0 and Y < 9 then
		set GetTargetIdxRes to X + (Y - 1) * 8
	end
end

define-atomic IsStringEqual [String1] (StartIdx1) [String2] (StartIdx2)
set IsStringEqualRes to 1
set Offset to 0
repeat until Offset = length of String1 or Offset = length of String2
	if not letter (StartIdx1 + Offset) of String1 = letter (StartIdx2 + Offset) of String2 then
		set IsStringEqualRes to 0
		stop this script
	end
	change Offset by 1
end

define-atomic AddSimpleMove (SourceIdx arg) (DeltaX) (DeltaY) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
set Y to item SourceIdx arg of IdxToRow + DeltaY
if Y > 0 and Y < 9 then
	set X to item SourceIdx arg of IdxToCol + DeltaX
	if X > 0 and X < 9 then
		set TargetIdx to X + (Y - 1) * 8
		if not CapturesOnly or <item SourceIdx arg of Board > 0 and item TargetIdx of Board < 0> or <item SourceIdx arg of Board < 0 and item TargetIdx of Board > 0> then
			AddMoveImpl (SourceIdx arg) (TargetIdx) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
		end
	end
end

define-atomic InitCoordLookup
delete all of IdxToCol
delete all of IdxToRow
set Idx to 1
repeat 64
	add (Idx - 1) mod 8 + 1 to IdxToCol
	add ceiling of (Idx / 8) to IdxToRow
	change Idx by 1
end

define ImportBoardFEN [ImpBoard]
if IsPlayerBlack = 0 then
	set Idx to 1
	set IdxInc to 1
else
	set Idx to 64
	set IdxInc to -1
end
set IdxString to 1
repeat until Idx > 64 or Idx < 1
	set CurrentValue to letter IdxString of ImpBoard
	if not CurrentValue < "A" and not CurrentValue > "Z" then
		set CurrentPiece to Empty
		if CurrentValue = "P" then
			set CurrentPiece to BlackPawn
		end
		if CurrentValue = "N" then
			set CurrentPiece to BlackKnight
		end
		if CurrentValue = "B" then
			set CurrentPiece to BlackBishop
		end
		if CurrentValue = "R" then
			set CurrentPiece to BlackRook
		end
		if CurrentValue = "Q" then
			set CurrentPiece to BlackQueen
		end
		if CurrentValue = "K" then
			set CurrentPiece to BlackKing
		end
		IsLowerCase (CurrentValue)
		if IsLowerCaseRes = 0 then
			set CurrentPiece to CurrentPiece * -1
		end
		if IsPlayerBlack = 1 then
			set CurrentPiece to CurrentPiece * -1
		end
		replace item Idx of Board with CurrentPiece
		change Idx by IdxInc
	else
		if not CurrentValue < 0 and not CurrentValue > 9 then
			repeat CurrentValue
				replace item Idx of Board with Empty
				change Idx by IdxInc
			end
		else
			if CurrentValue = "/" then
				repeat until <Idx mod 8 = 1 and IsPlayerBlack = 0> or <Idx mod 8 = 0 and IsPlayerBlack = 1>
					replace item Idx of Board with Empty
					change Idx by IdxInc
				end
			end
		end
	end
	change IdxString by 1
end
AddBoardToHistory
DrawBoardAndWait
change IdxString by 1
set CurrentValue to letter IdxString of ImpBoard
if <CurrentValue = "B" and IsPlayerBlack = 0> or <CurrentValue = "W" and IsPlayerBlack = 1> then
	CalcBoardAttackedByMove 1
	if IsWhiteChecked = 1 then
		say "Checkmate!" for 5 secs
		set IsGameSuspended to 1
	else
		CalculateMoves 1
		if length of Moves1 = 0 then
			say "Draw!" for 5 secs
			set IsGameSuspended to 1
		else
			set IsGameSuspended to 0
			ExecuteEngineMove
		end
	end
end
if <CurrentValue = "W" and IsPlayerBlack = 0> or <CurrentValue = "B" and IsPlayerBlack = 1> then
	CalcBoardAttackedByMove 2
	if IsBlackChecked = 1 then
		say "Checkmate!" for 5 secs
		set IsGameSuspended to 1
	else
		CalculateMoves 2
		if length of Moves2 = 0 then
			say "Draw!" for 5 secs
			set IsGameSuspended to 1
		else
			set IsGameSuspended to 0
		end
	end
end

define ImportBoardInternal [ImpBoard]
set Idx to 1
set IdxString to 1
set CurrentPiece to ""
repeat until IdxString > length of ImpBoard
	if letter IdxString of ImpBoard = "," then
		replace item Idx of Board with CurrentPiece
		change Idx by 1
		set CurrentPiece to ""
	else
		set CurrentPiece to (join (CurrentPiece) (letter IdxString of ImpBoard))
	end
	change IdxString by 1
end
AddBoardToHistory
DrawBoardAndWait
set IsGameSuspended to 0

define-atomic QuickSortTemp (BeginIdx) (EndIdx)
set QSLower to BeginIdx
set QSUpper to EndIdx
set QSPivot to item floor of ((BeginIdx + EndIdx) / 2) of SortedListTemp
repeat until QSLower > QSUpper
	repeat until not item QSLower of SortedListTemp < QSPivot
		change QSLower by 1
	end
	repeat until not item QSUpper of SortedListTemp > QSPivot
		change QSUpper by -1
	end
	if not QSLower > QSUpper then
		set QSSwap to item QSLower of SortedListTemp
		replace item QSLower of SortedListTemp with item QSUpper of SortedListTemp
		replace item QSUpper of SortedListTemp with QSSwap
		change QSLower by 1
		change QSUpper by -1
	end
end
if BeginIdx < QSUpper then
	QuickSortTemp (BeginIdx) (QSUpper)
end
if QSLower < EndIdx then
	QuickSortTemp (QSLower) (EndIdx)
end

define-atomic CutoffPreProcess (Depth)
if Depth = 1 then
	delete all of SortedList
	repeat until length of SortedList = length of Moves1
		add "" to SortedList
	end
	delete all of SortedList2
	repeat until length of SortedList2 = length of Moves1
		add "" to SortedList2
	end
end
if Depth = 2 then
	if 1 = 0 then
		delete all of SortedListTemp
		repeat until length of SortedListTemp = length of Moves2
			add "" to SortedListTemp
		end
	end
end

define-atomic AddToMoveList (Depth) (Move)
if Depth = 15 then
	add Move to Moves15
	add "0" to Moves15Score
	replace item 15 of MovesCount with length of Moves15
else
	if Depth = 14 then
		add Move to Moves14
		add "0" to Moves14Score
		replace item 14 of MovesCount with length of Moves14
	else
		if Depth = 13 then
			add Move to Moves13
			add "0" to Moves13Score
			replace item 13 of MovesCount with length of Moves13
		else
			if Depth = 12 then
				add Move to Moves12
				add "" to Moves12Score
				replace item 12 of MovesCount with length of Moves12
			else
				if Depth = 11 then
					add Move to Moves11
					add "0" to Moves11Score
					replace item 11 of MovesCount with length of Moves11
				else
					if Depth = 10 then
						add Move to Moves10
						add "0" to Moves10Score
						replace item 10 of MovesCount with length of Moves10
					else
						if Depth = 9 then
							add Move to Moves9
							add "0" to Moves9Score
							replace item 9 of MovesCount with length of Moves9
						else
							if Depth = 8 then
								add Move to Moves8
								add "0" to Moves8Score
								replace item 8 of MovesCount with length of Moves8
							else
								if Depth = 7 then
									add Move to Moves7
									add "0" to Moves7Score
									replace item 7 of MovesCount with length of Moves7
								else
									if Depth = 6 then
										add Move to Moves6
										add "0" to Moves6Score
										replace item 6 of MovesCount with length of Moves6
									else
										if Depth = 5 then
											add Move to Moves5
											add "0" to Moves5Score
											replace item 5 of MovesCount with length of Moves5
										else
											if Depth = 4 then
												add Move to Moves4
												add "0" to Moves4Score
												replace item 4 of MovesCount with length of Moves4
											else
												if Depth = 3 then
													add Move to Moves3
													add "0" to Moves3Score
													replace item 3 of MovesCount with length of Moves3
												else
													if Depth = 2 then
														add Move to Moves2
														add "0" to Moves2Score
														replace item 2 of MovesCount with length of Moves2
													else
														if Depth = 1 then
															add Move to Moves1
															add "0" to Moves1Score
															replace item 1 of MovesCount with length of Moves1
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

define-atomic QuickSort (BeginIdx) (EndIdx)
set QSLower to BeginIdx
set QSUpper to EndIdx
set QSPivot to item floor of ((BeginIdx + EndIdx) / 2) of SortedList
repeat until QSLower > QSUpper
	repeat until not item QSLower of SortedList < QSPivot
		change QSLower by 1
	end
	repeat until not item QSUpper of SortedList > QSPivot
		change QSUpper by -1
	end
	if not QSLower > QSUpper then
		set QSSwap to item QSLower of SortedList
		replace item QSLower of SortedList with item QSUpper of SortedList
		replace item QSUpper of SortedList with QSSwap
		change QSLower by 1
		change QSUpper by -1
	end
end
if BeginIdx < QSUpper then
	QuickSort (BeginIdx) (QSUpper)
end
if QSLower < EndIdx then
	QuickSort (QSLower) (EndIdx)
end

define-atomic GetMoveNotation (Move)
GetVirtualMove (Move)
set MoveNotationRes to ""
if VirtualMove = BlackKingsideCastling or VirtualMove = WhiteKingsideCastling then
	set MoveNotationRes to "O-O"
	stop this script
end
if VirtualMove = BlackQueensideCastling or VirtualMove = WhiteQueensideCastling then
	set MoveNotationRes to "O-O-O"
	stop this script
end
set SourceIdx to floor of (VirtualMove / 100)
set TargetIdx to floor of (VirtualMove mod 100)
set CurrentPiece to item floor of (Move / 100) of Board
Log (SourceIdx) ":" (TargetIdx) ":" (item SourceIdx of IdxToCol) ":" (VirtualMove) ""
if CurrentPiece = BlackBishop or CurrentPiece = WhiteBishop then
	set MoveNotationRes to "B"
end
if CurrentPiece = BlackKing or CurrentPiece = WhiteKing then
	set MoveNotationRes to "K"
end
if CurrentPiece = BlackRook or CurrentPiece = WhiteRook then
	set MoveNotationRes to "R"
end
if CurrentPiece = BlackKnight or CurrentPiece = WhiteKnight then
	set MoveNotationRes to "N"
end
if CurrentPiece = WhiteQueen or CurrentPiece = BlackQueen then
	set MoveNotationRes to "Q"
end
set X to item SourceIdx of IdxToCol
set Y to 9 - item SourceIdx of IdxToRow
set MoveNotationRes to (join (MoveNotationRes) join (letter X of "abcdefgh") (Y))
if not item floor of (Move mod 100) of Board = Empty then
	set MoveNotationRes to (join (MoveNotationRes) "x")
end
set X to item TargetIdx of IdxToCol
set Y to 9 - item TargetIdx of IdxToRow
if <letter 5 of VirtualMove = "."> = ".1" then
	if letter 6 of VirtualMove = 1 then
		set MoveNotationRes to (join (MoveNotationRes) "Q")
	end
	if letter 6 of VirtualMove = 2 then
		set MoveNotationRes to (join (MoveNotationRes) "R")
	end
	if letter 6 of VirtualMove = 3 then
		set MoveNotationRes to (join (MoveNotationRes) "B")
	end
	if letter 6 of VirtualMove = 4 then
		set MoveNotationRes to (join (MoveNotationRes) "N")
	end
else
	set MoveNotationRes to (join (MoveNotationRes) join (letter X of "abcdefgh") (Y))
end

define-atomic AddMoveImpl (SourceIdx arg) (TargetIdx arg) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
if 1 = 0 then
	Profile_MethodEnter (80 + Depth)
end
set TargetPiece to item floor of TargetIdx arg of Board
if <EmptyOK and TargetPiece = Empty> or <BlackOK and TargetPiece > 0> or <WhiteOK and TargetPiece < 0> then
	set SourcePiece to item SourceIdx arg of Board
	if CalcAttackState then
		if SourcePiece > 0 then
			replace item TargetIdx arg of BoardAttackedByBlack with item TargetIdx arg of BoardAttackedByBlack + 1
			if TargetPiece = WhiteKing then
				set IsWhiteChecked to 1
			end
			if 1 = 0 then
				GetSEEMapVal (SourcePiece)
				replace item TargetIdx arg of BoardAttackedByBlackPiece with item TargetIdx arg of BoardAttackedByBlackPiece + SEEMapValRes
			end
		else
			replace item TargetIdx arg of BoardAttackedByWhite with item TargetIdx arg of BoardAttackedByWhite + 1
			if TargetPiece = BlackKing then
				set IsBlackChecked to 1
			end
			if 1 = 0 then
				GetSEEMapVal (SourcePiece)
				replace item TargetIdx arg of BoardAttackedByWhitePiece with item TargetIdx arg of BoardAttackedByWhitePiece + SEEMapValRes
			end
		end
	else
		if CapturesOnly and TargetPiece = Empty and not <<SourcePiece = WhitePawn and item TargetIdx arg of IdxToRow = 1> or <SourcePiece = BlackPawn and item TargetIdx arg of IdxToRow = 8>> then
			if 1 = 0 then
				Profile_MethodExit (80 + Depth)
			end
			stop this script
		end
		if SourcePiece = WhiteKing or SourcePiece = BlackKing then
			if item Depth of BoardAttackedCalculated = 0 then
				set CalculateMovesRequiresAttackRecalc to 1
				if 1 = 0 then
					Profile_MethodExit (80 + Depth)
				end
				stop this script
			end
			if Depth mod 2 = 1 then
				if item TargetIdx arg of BoardAttackedByWhite > 0 then
					if 1 = 0 then
						Profile_MethodExit (80 + Depth)
					end
					stop this script
				end
			else
				if item TargetIdx arg of BoardAttackedByBlack > 0 then
					if 1 = 0 then
						Profile_MethodExit (80 + Depth)
					end
					stop this script
				end
			end
		end
		if not CapturesOnly then
			if <SourcePiece > 0 and item floor of TargetIdx arg of BoardAttackedByWhite = 0> or <SourcePiece < 0 and item floor of TargetIdx arg of BoardAttackedByBlack = 0> then
				replace item SourceIdx arg of PieceMobility with item SourceIdx arg of PieceMobility + 1
			end
		end
		set CurrentMove to SourceIdx arg * 100 + TargetIdx arg
		if SourceIdx arg < 10 then
			set CurrentMove to (join "0" (CurrentMove))
		end
		if <SourcePiece = WhitePawn and item SourceIdx arg of IdxToRow = 2> or <SourcePiece = BlackPawn and item SourceIdx arg of IdxToRow = 7> then
			if CurrentMove = floor of CurrentMove then
				AddMoveImpl (SourceIdx arg) (TargetIdx arg + 0.1) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
				AddMoveImpl (SourceIdx arg) (TargetIdx arg + 0.2) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
				AddMoveImpl (SourceIdx arg) (TargetIdx arg + 0.3) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
				AddMoveImpl (SourceIdx arg) (TargetIdx arg + 0.4) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
				if 1 = 0 then
					Profile_MethodExit (80 + Depth)
				end
				stop this script
			end
		end
		if Depth = 15 then
			if 1 = 1 then
				GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
				add CurrentMove to Moves15
				add MoveScoreRes to Moves15Score
			else
				add CurrentMove to Moves15
				add "0" to Moves15Score
			end
		else
			if Depth = 14 then
				if 1 = 1 then
					GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
					add CurrentMove to Moves14
					add MoveScoreRes to Moves14Score
				else
					add CurrentMove to Moves14
					add "0" to Moves14Score
				end
			else
				if Depth = 13 then
					if 1 = 1 then
						GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
						add CurrentMove to Moves13
						add MoveScoreRes to Moves13Score
					else
						add CurrentMove to Moves13
						add "0" to Moves13Score
					end
				else
					if Depth = 12 then
						if 1 = 1 then
							GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
							add CurrentMove to Moves12
							add MoveScoreRes to Moves12Score
						else
							add CurrentMove to Moves12
							add "0" to Moves12Score
						end
					else
						if Depth = 11 then
							if 1 = 1 then
								GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
								add CurrentMove to Moves11
								add MoveScoreRes to Moves11Score
							else
								add CurrentMove to Moves11
								add "0" to Moves11Score
							end
						else
							if Depth = 10 then
								if 1 = 1 then
									GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
									add CurrentMove to Moves10
									add MoveScoreRes to Moves10Score
								else
									add CurrentMove to Moves10
									add "0" to Moves10Score
								end
							else
								if Depth = 9 then
									if 1 = 1 then
										GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
										add CurrentMove to Moves9
										add MoveScoreRes to Moves9Score
									else
										add CurrentMove to Moves9
										add "0" to Moves9Score
									end
								else
									if Depth = 8 then
										GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
										add CurrentMove to Moves8
										add MoveScoreRes to Moves8Score
									else
										if Depth = 7 then
											GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
											add CurrentMove to Moves7
											add MoveScoreRes to Moves7Score
										else
											if Depth = 6 then
												GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
												add CurrentMove to Moves6
												add MoveScoreRes to Moves6Score
											else
												if Depth = 5 then
													GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
													add CurrentMove to Moves5
													add MoveScoreRes to Moves5Score
												else
													if Depth = 4 then
														GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
														add CurrentMove to Moves4
														add MoveScoreRes to Moves4Score
													else
														if Depth = 3 then
															GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
															add CurrentMove to Moves3
															add MoveScoreRes to Moves3Score
														else
															if Depth = 2 then
																GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
																add CurrentMove to Moves2
																add MoveScoreRes to Moves2Score
															else
																if Depth = 1 then
																	GetMoveScore (SourcePiece) (TargetPiece) (SourceIdx arg) (TargetIdx arg) (CurrentMove) (Depth)
																	add CurrentMove to Moves1
																	add MoveScoreRes to Moves1Score
																end
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end
if 1 = 0 then
	Profile_MethodExit (80 + Depth)
end

define-atomic QuickSortTemp (BeginIdx) (EndIdx)
set QSLower to BeginIdx
set QSUpper to EndIdx
set QSPivot to item floor of ((BeginIdx + EndIdx) / 2) of SortedListTemp
repeat until QSLower > QSUpper
	repeat until not item QSLower of SortedListTemp < QSPivot
		change QSLower by 1
	end
	repeat until not item QSUpper of SortedListTemp > QSPivot
		change QSUpper by -1
	end
	if not QSLower > QSUpper then
		set QSSwap to item QSLower of SortedListTemp
		replace item QSLower of SortedListTemp with item QSUpper of SortedListTemp
		replace item QSUpper of SortedListTemp with QSSwap
		change QSLower by 1
		change QSUpper by -1
	end
end
if BeginIdx < QSUpper then
	QuickSortTemp (BeginIdx) (QSUpper)
end
if QSLower < EndIdx then
	QuickSortTemp (QSLower) (EndIdx)
end

define-atomic ClearMoveList (Depth)
if Depth = 15 then
	delete all of Moves15
	delete all of Moves15Score
	replace item 15 of MovesCount with "0"
else
	if Depth = 14 then
		delete all of Moves14
		delete all of Moves14Score
		replace item 14 of MovesCount with "0"
	else
		if Depth = 13 then
			delete all of Moves13
			delete all of Moves13Score
			replace item 13 of MovesCount with "0"
		else
			if Depth = 12 then
				delete all of Moves12
				delete all of Moves12Score
				replace item 12 of MovesCount with "0"
			else
				if Depth = 11 then
					delete all of Moves11
					delete all of Moves11Score
					replace item 11 of MovesCount with "0"
				else
					if Depth = 10 then
						delete all of Moves10
						delete all of Moves10Score
						replace item 10 of MovesCount with "0"
					else
						if Depth = 9 then
							delete all of Moves9
							delete all of Moves9Score
							replace item 9 of MovesCount with "0"
						else
							if Depth = 8 then
								delete all of Moves8
								delete all of Moves8Score
								replace item 8 of MovesCount with "0"
							else
								if Depth = 7 then
									delete all of Moves7
									delete all of Moves7Score
									replace item 7 of MovesCount with "0"
								else
									if Depth = 6 then
										delete all of Moves6
										delete all of Moves6Score
										replace item 6 of MovesCount with "0"
									else
										if Depth = 5 then
											delete all of Moves5
											delete all of Moves5Score
											replace item 5 of MovesCount with "0"
										else
											if Depth = 4 then
												delete all of Moves4
												delete all of Moves4Score
												replace item 4 of MovesCount with "0"
											else
												if Depth = 3 then
													delete all of Moves3
													delete all of Moves3Score
													replace item 3 of MovesCount with "0"
												else
													if Depth = 2 then
														delete all of Moves2
														delete all of Moves2Score
														replace item 2 of MovesCount with "0"
													else
														if Depth = 1 then
															delete all of Moves1
															delete all of Moves1Score
															replace item 1 of MovesCount with "0"
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

define-atomic GetBestHashMove (HashMove)
set BestHashMoveResult to 0
set BestHashMoveMoveResult to ""
set BestHashMoveScoreResult to ""
set BestHashMoveDepthResult to ""
set BestHashMoveTypeResult to ""
set BestHashMoveCheckedResult to ""
set BestHashMoveExistsCapture to ""
set CurrentIdx to 1
set HashBucket to HashMove mod length of HashMovesHash + 1
repeat until item HashBucket of HashMovesHash = HashMove
	change HashBucket by 1
	if HashBucket > length of HashMovesHash then
		set HashBucket to 1
	end
	change CurrentIdx by 1
	if CurrentIdx > 10 then
		stop this script
	end
end
set BestHashMoveResult to 1
set BestHashMoveMoveResult to item HashBucket of HashMovesBestMove
set BestHashMoveScoreResult to item HashBucket of HashMovesScore
set BestHashMoveDepthResult to item HashBucket of HashMovesDepth
set BestHashMoveTypeResult to item HashBucket of HashMovesType
set BestHashMoveCheckedResult to item HashBucket of HashMovesChecked
set BestHashMoveAge to item HashBucket of HashMovesAge

define-atomic GetXOR (A) (B)
set XORA to A
set XORB to B
set XORVal to 1
set XORResult to 0
repeat until XORA = 0 and XORB = 0
	if not XORA mod 2 = XORB mod 2 then
		change XORResult by XORVal
	end
	set XORA to floor of (XORA / 2)
	set XORB to floor of (XORB / 2)
	set XORVal to XORVal * 2
end

define-atomic AddPossibleEnPassantImpl (SourceIdx arg) (Dir) (Depth) <CalcAttackState>
GetTargetIdx (SourceIdx arg) (Dir) 0
if not GetTargetIdxRes = -1 then
	if <Depth mod 2 = 1 and item GetTargetIdxRes of Board = WhitePawn> or <Depth mod 2 = 0 and item GetTargetIdxRes of Board = BlackPawn> then
		set IsEnPassantAllowed to 0
		if Depth mod 2 = 1 then
			set EnPassantPrevMove to (join (GetTargetIdxRes + 16) (GetTargetIdxRes))
		else
			set EnPassantPrevMove to (join (GetTargetIdxRes - 16) (GetTargetIdxRes))
		end
		GetSubstringRight (GameMoves) 4
		if Depth = 1 and SubstringRes = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 2 and <SubstringRes = EnPassantPrevMove or item item 1 of MovesIdx of Moves1 = EnPassantPrevMove> then
			set IsEnPassantAllowed to 1
		end
		if Depth = 3 and item item 2 of MovesIdx of Moves2 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 4 and item item 3 of MovesIdx of Moves3 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 5 and item item 4 of MovesIdx of Moves4 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 6 and item item 5 of MovesIdx of Moves5 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 7 and item item 6 of MovesIdx of Moves6 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 8 and item item 7 of MovesIdx of Moves7 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 9 and item item 8 of MovesIdx of Moves8 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 10 and item item 9 of MovesIdx of Moves9 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 11 and item item 10 of MovesIdx of Moves10 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 12 and item item 11 of MovesIdx of Moves11 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 13 and item item 12 of MovesIdx of Moves12 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 14 and item item 13 of MovesIdx of Moves13 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if Depth = 15 and item item 14 of MovesIdx of Moves14 = EnPassantPrevMove then
			set IsEnPassantAllowed to 1
		end
		if IsEnPassantAllowed = 1 then
			if CalcAttackState then
				if Depth mod 2 = 1 then
					replace item GetTargetIdxRes of BoardAttackedByBlack with item GetTargetIdxRes of BoardAttackedByBlack + 1
				else
					replace item GetTargetIdxRes of BoardAttackedByWhite with item GetTargetIdxRes of BoardAttackedByWhite + 1
				end
			else
				if Depth mod 2 = 1 then
					AddSpecialMove (join (SourceIdx arg) (GetTargetIdxRes + 8)) (Depth)
				else
					AddSpecialMove (join (SourceIdx arg) (GetTargetIdxRes - 8)) (Depth)
				end
			end
		end
	end
end

define-atomic PickMove (Depth) (MaxDepth) <CalcCutoff> <ApplyCutoff> <Quiescence> <PrevQuiescence>
if item Depth of PickPhase = 1 then
	ClearMoveList (Depth)
	replace item Depth of PickHash with ""
	if ApplyCutoff and Depth > 1 and <not Quiescence or Depth < 13> then
		GetBestHashMove (CurrentMoveHash)
		if BestHashMoveResult = 1 then
			if not BestHashMoveMoveResult = "" and Depth mod 2 = BestHashMoveDepthResult mod 2 then
				set IsLegalMove to 0
				set SourceIdx to floor of (BestHashMoveMoveResult / 100)
				set TargetIdx to floor of (BestHashMoveMoveResult mod 100)
				if SourceIdx > 0 and TargetIdx > 0 then
					ClearBoardAttackedByMove (Depth + 1)
					replace item Depth of BoardAttackedCalculated with "1"
					CalculateMovesForSource (Depth) (SourceIdx) <1 = 0> <Quiescence>
					replace item Depth of BoardAttackedCalculated with "0"
					if Depth = 1 and Moves1 contains BestHashMoveMoveResult? then
						set IsLegalMove to 1
					else
						if Depth = 2 and Moves2 contains BestHashMoveMoveResult? then
							set IsLegalMove to 1
						else
							if Depth = 3 and Moves3 contains BestHashMoveMoveResult? then
								set IsLegalMove to 1
							else
								if Depth = 4 and Moves4 contains BestHashMoveMoveResult? then
									set IsLegalMove to 1
								else
									if Depth = 5 and Moves5 contains BestHashMoveMoveResult? then
										set IsLegalMove to 1
									else
										if Depth = 6 and Moves6 contains BestHashMoveMoveResult? then
											set IsLegalMove to 1
										else
											if Depth = 7 and Moves7 contains BestHashMoveMoveResult? then
												set IsLegalMove to 1
											else
												if Depth = 8 and Moves8 contains BestHashMoveMoveResult? then
													set IsLegalMove to 1
												else
													if Depth = 9 and Moves9 contains BestHashMoveMoveResult? then
														set IsLegalMove to 1
													else
														if Depth = 10 and Moves10 contains BestHashMoveMoveResult? then
															set IsLegalMove to 1
														else
															if Depth = 11 and Moves11 contains BestHashMoveMoveResult? then
																set IsLegalMove to 1
															else
																if Depth = 12 and Moves12 contains BestHashMoveMoveResult? then
																	set IsLegalMove to 1
																else
																	if Depth = 13 and Moves13 contains BestHashMoveMoveResult? then
																		set IsLegalMove to 1
																	else
																		if Depth = 14 and Moves14 contains BestHashMoveMoveResult? then
																			set IsLegalMove to 1
																		else
																			if Depth = 15 and Moves15 contains BestHashMoveMoveResult? then
																				set IsLegalMove to 1
																			end
																		end
																	end
																end
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				else
					set IsLegalMove to 0
				end
				ClearMoveList (Depth)
				if IsLegalMove = 1 then
					replace item Depth of CheckedState with BestHashMoveCheckedResult
					replace item Depth of PickHash with BestHashMoveMoveResult
					AddToMoveList (Depth) (BestHashMoveMoveResult)
					replace item Depth of MovesIdx with "1"
					ApplyMove (Depth)
					replace item Depth of PickPhase with "2"
					replace item Depth of PickMoveRes with "1"
					Profile_IncCounter (160 + Depth)
					stop this script
				end
			end
		end
	end
	replace item Depth of PickPhase with "2"
end
if item Depth of PickPhase = 2 then
	ClearBoardAttackedByMove (Depth + 1)
	replace item Depth of BoardAttackedCalculated with "0"
	replace item Depth of CheckedState with "0"
	if not Quiescence then
		CalcBoardAttackedByMove (Depth + 1)
		replace item Depth of BoardAttackedCalculated with "1"
		if <Depth mod 2 = 1 and IsBlackChecked = 1> or <Depth mod 2 = 0 and IsWhiteChecked = 1> then
			replace item Depth of CheckedState with "1"
		else
			replace item Depth of CheckedState with "0"
		end
	end
	set CalculateMovesRequiresAttackRecalc to 0
	CalculateMovesImpl (Depth) <1 = 0> <Quiescence>
	if Quiescence and CalculateMovesRequiresAttackRecalc = 1 then
		CalcBoardAttackedByMove (Depth + 1)
		replace item Depth of BoardAttackedCalculated with "1"
		if <Depth mod 2 = 1 and IsBlackChecked = 1> or <Depth mod 2 = 0 and IsWhiteChecked = 1> then
			replace item Depth of CheckedState with "1"
		else
			replace item Depth of CheckedState with "0"
		end
		CalculateMovesImpl (Depth) <1 = 0> <Quiescence>
	end
	if CalcCutoff then
		if Depth = 1 then
			delete all of DeepeningScore
			repeat length of Moves1Score
				add "" to DeepeningScore
			end
			delete all of DeepeningScoreOrderMap
			repeat length of Moves1Score
				add "" to DeepeningScoreOrderMap
			end
		end
	end
	if ApplyCutoff then
		if Depth = 1 then
			EvaluateBoard
			set Idx to 1
			repeat length of Moves1Score
				if item Idx of DeepeningScore = "" then
					replace item Idx of Moves1Score with EvalResult + item Idx of Moves1Score
				else
					replace item Idx of Moves1Score with 1000 + item Idx of DeepeningScore
					replace item Idx of DeepeningScore with ""
				end
				change Idx by 1
			end
		end
	end
	CutoffReorder (Depth) <ApplyCutoff>
	replace item Depth of MovesIdx with "0"
	replace item Depth of PickPhase with "3"
end
if item Depth of PickPhase = 3 then
	replace item Depth of MovesIdx with item Depth of MovesIdx + 1
	if not item Depth of MovesIdx > item Depth of MovesCount then
		GetCurrentMove (Depth)
		if CurrentMove = item Depth of PickHash then
			replace item Depth of MovesIdx with item Depth of MovesIdx + 1
		end
		if not item Depth of MovesIdx > item Depth of MovesCount then
			ApplyMove (Depth)
			replace item Depth of PickMoveRes with "1"
			stop this script
		end
	end
	replace item Depth of PickPhase with "4"
	replace item Depth of PickMoveRes with "0"
end
replace item Depth of PickMoveRes with "0"

define-atomic AddLookupMove (SourceIdx arg) (Type) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
set IdxOuter to item SourceIdx arg of MoveLookupIndexOffset
set Count to 1
repeat until Count > 8
	if Type = LookupMoveTypeKnight then
		set TargetIdxOuter to item (IdxOuter + Count) of MoveLookupKnight
	else
		if Type = LookupMoveTypeKing then
			set TargetIdxOuter to item (IdxOuter + Count) of MoveLookupKing
		else
			set TargetIdxOuter to -1
		end
	end
	if not TargetIdxOuter = -1 then
		if not CapturesOnly or <item SourceIdx arg of Board > 0 and item TargetIdxOuter of Board < 0> or <item SourceIdx arg of Board < 0 and item TargetIdxOuter of Board > 0> then
			AddMoveImpl (SourceIdx arg) (TargetIdxOuter) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
		end
		change Count by 1
	else
		set Count to 9
	end
end

define-atomic CalculateOpeningMoves
delete all of BestMoves
if IsImportedBoard = 0 then
	if IsPlayerBlack = 0 then
		set Idx to 1
	else
		set Idx to length of OpeningMoves / 2 + 1
	end
	repeat length of OpeningMoves / 2
		if length of GameMoves < length of item Idx of OpeningMoves then
			set IdxString to 1
			set IsEqual to 1
			repeat length of GameMoves
				if not letter IdxString of GameMoves = letter IdxString of item Idx of OpeningMoves then
					set IsEqual to 0
				end
				change IdxString by 1
			end
			if IsEqual = 1 then
				set BestMove to letter (length of GameMoves + 1) of item Idx of OpeningMoves
				set BestMove to (join (BestMove) (letter (length of GameMoves + 2) of item Idx of OpeningMoves))
				set BestMove to (join (BestMove) (letter (length of GameMoves + 3) of item Idx of OpeningMoves))
				set BestMove to (join (BestMove) (letter (length of GameMoves + 4) of item Idx of OpeningMoves))
				add BestMove to BestMoves
			end
		end
		change Idx by 1
	end
end

define-atomic GetCurrentMove (Depth)
if Depth = 15 then
	set CurrentMove to item item Depth of MovesIdx of Moves15
else
	if Depth = 14 then
		set CurrentMove to item item Depth of MovesIdx of Moves14
	else
		if Depth = 13 then
			set CurrentMove to item item Depth of MovesIdx of Moves13
		else
			if Depth = 12 then
				set CurrentMove to item item Depth of MovesIdx of Moves12
			else
				if Depth = 11 then
					set CurrentMove to item item Depth of MovesIdx of Moves11
				else
					if Depth = 10 then
						set CurrentMove to item item Depth of MovesIdx of Moves10
					else
						if Depth = 9 then
							set CurrentMove to item item Depth of MovesIdx of Moves9
						else
							if Depth = 8 then
								set CurrentMove to item item Depth of MovesIdx of Moves8
							else
								if Depth = 7 then
									set CurrentMove to item item Depth of MovesIdx of Moves7
								else
									if Depth = 6 then
										set CurrentMove to item item Depth of MovesIdx of Moves6
									else
										if Depth = 5 then
											set CurrentMove to item item Depth of MovesIdx of Moves5
										else
											if Depth = 4 then
												set CurrentMove to item item Depth of MovesIdx of Moves4
											else
												if Depth = 3 then
													set CurrentMove to item item Depth of MovesIdx of Moves3
												else
													if Depth = 2 then
														set CurrentMove to item item Depth of MovesIdx of Moves2
													else
														if Depth = 1 then
															set CurrentMove to item item Depth of MovesIdx of Moves1
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

define-atomic InitOpeningBook
delete all of OpeningMoves
add "533711276346122052362736463607225843021962531321" to OpeningMoves
add "533711276346122062260312" to OpeningMoves
add "5337112763460219523627364636072258431220" to OpeningMoves
add "5337112751430722372922285236273643361220" to OpeningMoves
add "5337112758430219554715236255061552441220" to OpeningMoves
add "5337112758430219634612206226031200920722" to OpeningMoves
add "533711276235132163460917" to OpeningMoves
add "533711276235132158430917" to OpeningMoves
add "533711275236273660360219" to OpeningMoves
add "533711195236122837290330" to OpeningMoves
add "53371119523612285843283743370330" to OpeningMoves
add "533713296032021962351523" to OpeningMoves
add "5337132960460722" to OpeningMoves
add "5337132962350722" to OpeningMoves
add "533713296346021962260917263307220092061362610090" to OpeningMoves
add "533713296346021962260917263307226052102633420613" to OpeningMoves
add "533713296346021962260917263307225236293600920613" to OpeningMoves
add "533713296346021962260917263307225843061300921026" to OpeningMoves
add "5337132963460219622609172619121946290436" to OpeningMoves
add "533713296346021962260917261912190092033956481632" to OpeningMoves
add "533713296346021962260917261912195843142252362936" to OpeningMoves
add "533713296346021962260917261912195236293660360436" to OpeningMoves
add "5337132963460219523629364636062759450422" to OpeningMoves
add "533713296346021962350722" to OpeningMoves
add "5337132963460219584307226226063400920090" to OpeningMoves
add "5337132954382938634615316235313946290440" to OpeningMoves
add "533713295438293863461531564031394629072252361220" to OpeningMoves
add "5337132954382938623504406162062752362718" to OpeningMoves
add "53371329543829386346061362350722" to OpeningMoves
add "53371329543829386235072258431119" to OpeningMoves
add "53371329543829385236044061531220634603395648394653464032" to OpeningMoves
add "53371329543806276346122062350722" to OpeningMoves
add "53371329543802196346122062350339" to OpeningMoves
add "533702195236122837280428" to OpeningMoves
add "533715235236061562351220" to OpeningMoves
add "53371523523606156346122062350722" to OpeningMoves
add "53371523523606155843072263460090" to OpeningMoves
add "533713215236122837291127514302195438273643360418" to OpeningMoves
add "5337132152361228372911275143021963460418" to OpeningMoves
add "53371321523612285843063460442837" to OpeningMoves
add "53371321523612285843063437291127" to OpeningMoves
add "5337132152361228584306343728212859520722" to OpeningMoves
add "5337132163461228372821285236072258431119" to OpeningMoves
add "533712205236072258430212634613296253061300921119" to OpeningMoves
add "533712205236072258430212634613296235162400921119" to OpeningMoves
add "533712205236072258430212634613296235061300920090" to OpeningMoves
add "5337122052360722584315235945061554460090" to OpeningMoves
add "5337122052360722584315236235061552440219" to OpeningMoves
add "523612286346072259312237" to OpeningMoves
add "523612286346072253451127" to OpeningMoves
add "523612286346021958431321533707223729221259310613" to OpeningMoves
add "523612286346021959380339" to OpeningMoves
add "523612286346072251351119" to OpeningMoves
add "52361228634613215843072253450219" to OpeningMoves
add "52361228634613215843072253372837" to OpeningMoves
add "523612285135132158430722534509176244283544350634" to OpeningMoves
add "5236122851351321584307225931021253450634" to OpeningMoves
add "523612285345072262441321" to OpeningMoves
add "523612285135111958430722" to OpeningMoves
add "5236122851351119634607225843132159312835" to OpeningMoves
add "523612285938072253451321" to OpeningMoves
add "52360722513515235843061563460090" to OpeningMoves
add "52360722513515236346061555470090" to OpeningMoves
add "52360722513515236346061558430090" to OpeningMoves
add "52360722513513215843063453450090" to OpeningMoves
add "523607225135122063460339" to OpeningMoves
add "523607225135152358430615533712206346009062531329" to OpeningMoves
add "52360722634613215135101858430310" to OpeningMoves
add "52361430513507225843132153450634" to OpeningMoves
add "5236143055470722625515236346061500920090" to OpeningMoves
add "523614306346072255471321" to OpeningMoves
add "5236132151350722634610185547031062550613" to OpeningMoves
add "52361321513507225843063460510090" to OpeningMoves
add "523613215135122858430722" to OpeningMoves
add "494113295345122851350722" to OpeningMoves
add "4933132953370722" to OpeningMoves
add "493313293325122856401127" to OpeningMoves
add "504213295950021951350722" to OpeningMoves
add "503413295950122051350722" to OpeningMoves
add "514313295337072252440219" to OpeningMoves
add "513513295843072255471228" to OpeningMoves
add "513513296346021958430722" to OpeningMoves
add "5446132955390440" to OpeningMoves
add "5438132155390440" to OpeningMoves
add "543812286346152355470615" to OpeningMoves
add "5539132954380440" to OpeningMoves
add "554712286255132951352836" to OpeningMoves
add "5648132953370722" to OpeningMoves
add "5648132949411228" to OpeningMoves
add "564013295337072252440627" to OpeningMoves
add "5640072251351127" to OpeningMoves
add "5640072263460219" to OpeningMoves
add "6346072251351523554706156255009000921220" to OpeningMoves
add "634612285236072251351321" to OpeningMoves
add "6346122858431321" to OpeningMoves
set Count to length of OpeningMoves
set Idx to 1
repeat Count
	add "" to OpeningMoves
	if length of item Idx of OpeningMoves / 4 > 4 then
		set IdxSub to 1
		repeat length of item Idx of OpeningMoves / 4
			GetVirtualMove (join join (letter IdxSub of item Idx of OpeningMoves) (letter (IdxSub + 1) of item Idx of OpeningMoves) join (letter (IdxSub + 2) of item Idx of OpeningMoves) (letter (IdxSub + 3) of item Idx of OpeningMoves))
			replace item last of OpeningMoves with (join (item last of OpeningMoves) (VirtualMove))
			change IdxSub by 4
		end
	end
	change Idx by 1
end

define-atomic LoadList [Data] [ListName]
set IdxString to 1
set CurrentValue to ""
repeat until IdxString > length of Data
	if not letter IdxString of Data = " " and not letter IdxString of Data = "," then
		set CurrentValue to (join (CurrentValue) (letter IdxString of Data))
	end
	if letter IdxString of Data = "," or IdxString = length of Data then
		if ListName = "PawnPieceSquare" then
			add CurrentValue to PawnPieceSquare
		end
		if ListName = "PawnPieceSquareEndgame" then
			add CurrentValue to PawnPieceSquareEndgame
		end
		if ListName = "PawnPieceSquareKingside" then
			add CurrentValue to PawnPieceSquareKingside
		end
		if ListName = "PawnPieceSquareQueenside" then
			add CurrentValue to PawnPieceSquareQueenside
		end
		if ListName = "KingPieceSquare" then
			add CurrentValue to KingPieceSquare
		end
		if ListName = "KingPieceSquareEndgame" then
			add CurrentValue to KingPieceSquareEndgame
		end
		if ListName = "QueenPieceSquare" then
			add CurrentValue to QueenPieceSquare
		end
		if ListName = "RookPieceSquare" then
			add CurrentValue to RookPieceSquare
		end
		if ListName = "BishopPieceSquare" then
			add CurrentValue to BishopPieceSquare
		end
		if ListName = "KnightPieceSquare" then
			add CurrentValue to KnightPieceSquare
		end
		if ListName = "KnightMobilityBonus" then
			add CurrentValue * 2 to KnightMobilityBonus
		end
		if ListName = "BishopMobilityBonus" then
			add CurrentValue * 2 to BishopMobilityBonus
		end
		if ListName = "RookMobilityBonus" then
			add CurrentValue * 2 to RookMobilityBonus
		end
		if ListName = "QueenMobilityBonus" then
			add CurrentValue * 2 to QueenMobilityBonus
		end
		if ListName = "PawnStormBlockedByKing" then
			add CurrentValue to PawnStormBlockedByKing
		end
		if ListName = "PawnStormBlockedByPawn" then
			add CurrentValue to PawnStormBlockedByPawn
		end
		if ListName = "PawnStormBlockedByNone" then
			add CurrentValue to PawnStormBlockedByNone
		end
		if ListName = "PawnShelterKingCol" then
			add CurrentValue to PawnShelterKingCol
		end
		if ListName = "PawnShelterNeighborCol" then
			add CurrentValue to PawnShelterNeighborCol
		end
		if ListName = "DeepeningScore2" then
			add CurrentValue to DeepeningScore2
		end
		set CurrentValue to ""
	end
	change IdxString by 1
end

define-atomic CutoffReorder (Depth) <ApplyCutoff>
if Depth = 1 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves1Score
		if item Idx of Moves1Score < 0 then
			add 0 - abs of item Idx of Moves1Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves1Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of DeepeningScoreOrderMap with abs of item (length of SortedList - Idx + 1) of SortedList mod 10000
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves1
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves1 with item (length of SortedList - Idx + 1) of SortedList
		change Idx by 1
	end
end
if Depth = 2 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves2Score
		if item Idx of Moves2Score < 0 then
			add 0 - abs of item Idx of Moves2Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves2Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves2
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves2 with item Idx of SortedList
		change Idx by 1
	end
end
if Depth = 3 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves3Score
		if item Idx of Moves3Score < 0 then
			add 0 - abs of item Idx of Moves3Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves3Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves3
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves3 with item (length of SortedList - Idx + 1) of SortedList
		change Idx by 1
	end
end
if Depth = 4 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves4Score
		if item Idx of Moves4Score < 0 then
			add 0 - abs of item Idx of Moves4Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves4Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves4
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves4 with item Idx of SortedList
		change Idx by 1
	end
end
if Depth = 5 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves5Score
		if item Idx of Moves5Score < 0 then
			add 0 - abs of item Idx of Moves5Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves5Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves5
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves5 with item (length of SortedList - Idx + 1) of SortedList
		change Idx by 1
	end
end
if Depth = 6 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves6Score
		if item Idx of Moves6Score < 0 then
			add 0 - abs of item Idx of Moves6Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves6Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves6
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves6 with item Idx of SortedList
		change Idx by 1
	end
end
if Depth = 7 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves7Score
		if item Idx of Moves7Score < 0 then
			add 0 - abs of item Idx of Moves7Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves7Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves7
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves7 with item (length of SortedList - Idx + 1) of SortedList
		change Idx by 1
	end
end
if Depth = 8 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves8Score
		if item Idx of Moves8Score < 0 then
			add 0 - abs of item Idx of Moves8Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves8Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves8
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves8 with item Idx of SortedList
		change Idx by 1
	end
end
if Depth = 9 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves9Score
		if item Idx of Moves9Score < 0 then
			add 0 - abs of item Idx of Moves9Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves9Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves9
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves9 with item (length of SortedList - Idx + 1) of SortedList
		change Idx by 1
	end
end
if Depth = 10 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves10Score
		if item Idx of Moves10Score < 0 then
			add 0 - abs of item Idx of Moves10Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves10Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves10
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves10 with item Idx of SortedList
		change Idx by 1
	end
end
if Depth = 11 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves9Score
		if item Idx of Moves11Score < 0 then
			add 0 - abs of item Idx of Moves11Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves11Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves11
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves11 with item (length of SortedList - Idx + 1) of SortedList
		change Idx by 1
	end
end
if Depth = 12 then
	delete all of SortedList
	set Idx to 1
	repeat length of Moves12Score
		if item Idx of Moves12Score < 0 then
			add 0 - abs of item Idx of Moves12Score * 10000 + Idx to SortedList
		else
			add item Idx of Moves12Score * 10000 + Idx to SortedList
		end
		change Idx by 1
	end
	QuickSort 1 (length of SortedList)
	set Idx to 1
	repeat length of SortedList
		replace item Idx of SortedList with item (abs of item Idx of SortedList mod 10000) of Moves12
		change Idx by 1
	end
	set Idx to 1
	repeat length of SortedList
		replace item Idx of Moves12 with item Idx of SortedList
		change Idx by 1
	end
end

define-atomic RevertMove (Depth)
GetCurrentMove (Depth)
set SourceIdx to floor of (CurrentMove / 100)
set TargetIdx to floor of (CurrentMove mod 100)
if SourceIdx > 0 and TargetIdx > 0 then
	replace item SourceIdx of Board with item TargetIdx of Board
	replace item TargetIdx of Board with Empty
	replace item item Depth of TargetPiecesIdx of Board with item Depth of TargetPieces
	if item Depth of PromotionPieces > 0 then
		replace item SourceIdx of Board with BlackPawn
	end
	if item Depth of PromotionPieces < 0 then
		replace item SourceIdx of Board with WhitePawn
	end
else
	if CurrentMove = WhiteKingsideCastling then
		replace item item 61 of VirtualBoard of Board with WhiteKing
		replace item item 62 of VirtualBoard of Board with Empty
		replace item item 63 of VirtualBoard of Board with Empty
		replace item item 64 of VirtualBoard of Board with WhiteRook
	else
		if CurrentMove = WhiteQueensideCastling then
			replace item item 57 of VirtualBoard of Board with WhiteRook
			replace item item 59 of VirtualBoard of Board with Empty
			replace item item 60 of VirtualBoard of Board with Empty
			replace item item 61 of VirtualBoard of Board with WhiteKing
		else
			if CurrentMove = BlackKingsideCastling then
				replace item item 5 of VirtualBoard of Board with BlackKing
				replace item item 6 of VirtualBoard of Board with Empty
				replace item item 7 of VirtualBoard of Board with Empty
				replace item item 8 of VirtualBoard of Board with BlackRook
			else
				if CurrentMove = BlackQueensideCastling then
					replace item item 1 of VirtualBoard of Board with BlackRook
					replace item item 4 of VirtualBoard of Board with Empty
					replace item item 3 of VirtualBoard of Board with Empty
					replace item item 5 of VirtualBoard of Board with BlackKing
				end
			end
		end
	end
end
replace item Depth of PosScoreDelta with "0"
replace item Depth of TargetPiecesIdx with ""
replace item Depth of TargetPieces with Empty
replace item Depth of PromotionPieces with Empty
set CurrentMoveHash to item Depth of PreviousMoveHash

define-atomic EvaluateBoardExtended (Depth)
set BlackKingIdx to 0
set WhiteKingIdx to 0
set EvalExtendedResult to 0
set Idx to 1
repeat 8
	replace item Idx of BlackPawnCount with "0"
	replace item Idx of WhitePawnCount with "0"
	change Idx by 1
end
delete all of PawnAdvancePerCol
repeat 32
	add "0" to PawnAdvancePerCol
end
set Idx to 1
set InvIdx to 64
repeat 64
	set CurrentPiece to item Idx of Board
	if CurrentPiece = WhiteKing then
		set WhiteKingIdx to Idx
	else
		if CurrentPiece = BlackKing then
			set BlackKingIdx to Idx
		end
	end
	if CurrentPiece = BlackPawn then
		set Column to item Idx of IdxToCol
		replace item Column of BlackPawnCount with item Column of BlackPawnCount + 1
		if Idx > 24 then
			if <Column > 1 and item (Idx - 9) of Board = BlackPawn> or <Column < 8 and item (Idx - 7) of Board = BlackPawn> then
				change EvalExtendedResult by 5
			end
		end
		if item (Column + 16) of PawnAdvancePerCol = 0 or item Idx of IdxToRow < item (Column + 16) of PawnAdvancePerCol then
			replace item Column + 16 of PawnAdvancePerCol with item Idx of IdxToRow
		end
		if item (Column + 24) of PawnAdvancePerCol = 0 or item Idx of IdxToRow > item (Column + 24) of PawnAdvancePerCol then
			replace item Column + 24 of PawnAdvancePerCol with item Idx of IdxToRow
		end
	else
		if CurrentPiece = WhitePawn then
			set Column to item Idx of IdxToCol
			replace item Column of WhitePawnCount with item Column of WhitePawnCount + 1
			if Idx < 41 then
				if <Column > 1 and item (Idx + 7) of Board = WhitePawn> or <Column < 8 and item (Idx + 9) of Board = WhitePawn> then
					change EvalExtendedResult by -5
				end
			end
			if item Column of PawnAdvancePerCol = 0 or item Idx of IdxToRow > item Column of PawnAdvancePerCol then
				replace item Column of PawnAdvancePerCol with item Idx of IdxToRow
			end
			if item (Column + 8) of PawnAdvancePerCol = 0 or item Idx of IdxToRow < item (Column + 8) of PawnAdvancePerCol then
				replace item Column + 8 of PawnAdvancePerCol with item Idx of IdxToRow
			end
		end
	end
	change Idx by 1
	change InvIdx by -1
end
set Idx to 1
repeat 8
	if item Idx of BlackPawnCount = 1 then
		if <Idx > 1 and item (Idx - 1) of BlackPawnCount > 0> or <Idx < 8 and item (Idx + 1) of BlackPawnCount > 0> then
			change EvalExtendedResult by 10
		end
	else
		if item Idx of BlackPawnCount > 1 then
			change EvalExtendedResult by -15 * item Idx of BlackPawnCount
		end
	end
	if item Idx of WhitePawnCount = 1 then
		if <Idx > 1 and item (Idx - 1) of WhitePawnCount > 0> or <Idx < 8 and item (Idx + 1) of WhitePawnCount > 0> then
			change EvalExtendedResult by -10
		end
	else
		if item Idx of WhitePawnCount > 1 then
			change EvalExtendedResult by 15 * item Idx of WhitePawnCount
		end
	end
	change Idx by 1
end
if <WhiteQueenCount > 0 or WhiteMinorCount > 2 or IsEndgame = 0> and <not BlackKingIdx = item 5 of VirtualBoard or HasBlackCastled = 1 or HasBlackKingMoved = 1> then
	set KingProtection to 0
	set Column to item BlackKingIdx of IdxToCol - 1
	repeat 3
		if Column > 0 and Column < 9 then
			if item (Column + 16) of PawnAdvancePerCol > 0 then
				if Column = item BlackKingIdx of IdxToCol then
					change KingProtection by item ((item (Column + 16) of PawnAdvancePerCol - item BlackKingIdx of IdxToRow) * 8 + Column) of PawnShelterKingCol
				else
					change KingProtection by item ((item (Column + 16) of PawnAdvancePerCol - item BlackKingIdx of IdxToRow) * 8 + Column) of PawnShelterNeighborCol
				end
			else
				if Column = item BlackKingIdx of IdxToCol then
					change KingProtection by item Column of PawnShelterKingCol
					if item (Column + 0) of PawnAdvancePerCol = 0 then
						change KingProtection by -30
					end
				else
					change KingProtection by item Column of PawnShelterNeighborCol
					if item (Column + 0) of PawnAdvancePerCol = 0 then
						change KingProtection by -15
					end
				end
			end
			if item Column of PawnAdvancePerCol > 0 then
				if item (Column + 16) of PawnAdvancePerCol < item (Column + 8) of PawnAdvancePerCol then
					change KingProtection by 0 - item ((item (Column + 8) of PawnAdvancePerCol - item BlackKingIdx of IdxToRow) * 8 + Column) of PawnStormBlockedByPawn
				else
					if BlackKingIdx + 8 = (item (Column + 8) of PawnAdvancePerCol - 1) * 8 + Column then
						change KingProtection by 0 - item ((item (Column + 8) of PawnAdvancePerCol - item BlackKingIdx of IdxToRow) * 8 + Column) of PawnStormBlockedByKing
					else
						change KingProtection by 0 - item ((item (Column + 8) of PawnAdvancePerCol - item BlackKingIdx of IdxToRow) * 8 + Column) of PawnStormBlockedByNone
					end
					if item (Column + 16) of PawnAdvancePerCol = 0 then
						if Column = item BlackKingIdx of IdxToCol then
							change KingProtection by -20
						else
							change KingProtection by -10
						end
					end
				end
			end
		end
		change Column by 1
	end
	change EvalExtendedResult by KingProtection
end
if <BlackMinorCount > 2 or BlackQueenCount > 0 or IsEndgame = 0> and <not WhiteKingIdx = item 61 of VirtualBoard or HasWhiteCastled = 1 or HasWhiteKingMoved = 1> then
	set KingProtection to 0
	set Column to item WhiteKingIdx of IdxToCol - 1
	repeat 3
		if Column > 0 and Column < 9 then
			if item (Column + 0) of PawnAdvancePerCol > 0 then
				if Column = item WhiteKingIdx of IdxToCol then
					change KingProtection by item ((item WhiteKingIdx of IdxToRow - item (Column + 0) of PawnAdvancePerCol) * 8 + Column) of PawnShelterKingCol
				else
					change KingProtection by item ((item WhiteKingIdx of IdxToRow - item (Column + 0) of PawnAdvancePerCol) * 8 + Column) of PawnShelterNeighborCol
				end
			else
				if Column = item WhiteKingIdx of IdxToCol then
					change KingProtection by item Column of PawnShelterKingCol
					if item (Column + 16) of PawnAdvancePerCol = 0 then
						change KingProtection by -30
					end
				else
					change KingProtection by item Column of PawnShelterNeighborCol
					if item (Column + 16) of PawnAdvancePerCol = 0 then
						change KingProtection by -15
					end
				end
			end
			if item Column of PawnAdvancePerCol > 0 then
				if item (Column + 0) of PawnAdvancePerCol > item (Column + 24) of PawnAdvancePerCol then
					change KingProtection by 0 - item ((item WhiteKingIdx of IdxToRow - item (Column + 24) of PawnAdvancePerCol) * 8 + Column) of PawnStormBlockedByPawn
				else
					if WhiteKingIdx - 8 = (item (Column + 24) of PawnAdvancePerCol - 1) * 8 + Column then
						change KingProtection by 0 - item ((item WhiteKingIdx of IdxToRow - item (Column + 24) of PawnAdvancePerCol) * 8 + Column) of PawnStormBlockedByKing
					else
						change KingProtection by 0 - item ((item WhiteKingIdx of IdxToRow - item (Column + 24) of PawnAdvancePerCol) * 8 + Column) of PawnStormBlockedByNone
					end
					if item (Column + 0) of PawnAdvancePerCol = 0 then
						if Column = item WhiteKingIdx of IdxToCol then
							change KingProtection by -20
						else
							change KingProtection by -10
						end
					end
				end
			end
		end
		change Column by 1
	end
	change EvalExtendedResult by 0 - KingProtection
end

define-atomic CalculateMovesImpl (Depth) <CalcAttackState> <CapturesOnly>
if CalcAttackState then
	Profile_MethodEnter (20 + Depth)
else
	if CapturesOnly then
		Profile_MethodEnter (40 + Depth)
	else
		Profile_MethodEnter (60 + Depth)
	end
end
ClearMoveList (Depth)
set SourceIdxOuter to 1
set IsBlackMove to Depth mod 2
if not CalcAttackState and not CapturesOnly then
	if IsBlackMove = 1 then
		set BlackMobilityBonus to 0
	else
		set WhiteMobilityBonus to 0
	end
end
repeat 64
	if not CalcAttackState and not CapturesOnly then
		replace item SourceIdxOuter of PieceMobility with "0"
	end
	if <IsBlackMove = 1 and item SourceIdxOuter of Board > 0> or <IsBlackMove = 0 and item SourceIdxOuter of Board < 0> then
		CalculateMovesForSource (Depth) (SourceIdxOuter) <CalcAttackState> <CapturesOnly>
	end
	if not CalcAttackState and not CapturesOnly then
		set CurrentPiece to item SourceIdxOuter of Board
		if IsBlackMove = 1 then
			if CurrentPiece = BlackRook then
				change BlackMobilityBonus by item (item SourceIdxOuter of PieceMobility + 1) of RookMobilityBonus
			else
				if CurrentPiece = BlackQueen then
					change BlackMobilityBonus by item (item SourceIdxOuter of PieceMobility + 1) of QueenMobilityBonus
				else
					if CurrentPiece = BlackBishop then
						change BlackMobilityBonus by item (item SourceIdxOuter of PieceMobility + 1) of BishopMobilityBonus
					else
						if CurrentPiece = BlackKnight then
							change BlackMobilityBonus by item (item SourceIdxOuter of PieceMobility + 1) of KnightMobilityBonus
						else
							if CurrentPiece = BlackKing then
								if IsEndgame = 1 then
									change BlackMobilityBonus by item SourceIdxOuter of PieceMobility * 5
								end
							end
						end
					end
				end
			end
		end
		if IsBlackMove = 0 then
			if CurrentPiece = WhiteRook then
				change WhiteMobilityBonus by item (item SourceIdxOuter of PieceMobility + 1) of RookMobilityBonus
			else
				if CurrentPiece = WhiteQueen then
					change WhiteMobilityBonus by item (item SourceIdxOuter of PieceMobility + 1) of QueenMobilityBonus
				else
					if CurrentPiece = WhiteBishop then
						change WhiteMobilityBonus by item (item SourceIdxOuter of PieceMobility + 1) of BishopMobilityBonus
					else
						if CurrentPiece = WhiteKnight then
							change WhiteMobilityBonus by item (item SourceIdxOuter of PieceMobility + 1) of KnightMobilityBonus
						else
							if CurrentPiece = WhiteKing then
								if IsEndgame = 1 then
									change WhiteMobilityBonus by item SourceIdxOuter of PieceMobility * 5
								end
							end
						end
					end
				end
			end
		end
	end
	change SourceIdxOuter by 1
end
if not CalcAttackState and not CapturesOnly then
	if IsBlackMove = 1 then
		if HasBlackKingMoved = 0 and HasBlackCastled = 0 then
			if item item 1 of VirtualBoard of Board = BlackRook and item item 2 of VirtualBoard of Board = Empty and item item 3 of VirtualBoard of Board = Empty and item item 4 of VirtualBoard of Board = Empty and item item 5 of VirtualBoard of Board = BlackKing then
				if item item 3 of VirtualBoard of BoardAttackedByWhite = 0 and item item 4 of VirtualBoard of BoardAttackedByWhite = 0 and item item 5 of VirtualBoard of BoardAttackedByWhite = 0 then
					if HasBlackRookQSMoved = 0 then
						AddSpecialMove (BlackQueensideCastling) (Depth)
					end
				end
			end
			if item item 5 of VirtualBoard of Board = BlackKing and item item 6 of VirtualBoard of Board = Empty and item item 7 of VirtualBoard of Board = Empty and item item 8 of VirtualBoard of Board = BlackRook then
				if item item 5 of VirtualBoard of BoardAttackedByWhite = 0 and item item 6 of VirtualBoard of BoardAttackedByWhite = 0 and item item 7 of VirtualBoard of BoardAttackedByWhite = 0 then
					if HasBlackRookKSMoved = 0 then
						AddSpecialMove (BlackKingsideCastling) (Depth)
					end
				end
			end
		end
	else
		if HasWhiteKingMoved = 0 and HasWhiteCastled = 0 then
			if item item 57 of VirtualBoard of Board = WhiteRook and item item 58 of VirtualBoard of Board = Empty and item item 59 of VirtualBoard of Board = Empty and item item 60 of VirtualBoard of Board = Empty and item item 61 of VirtualBoard of Board = WhiteKing then
				if item item 59 of VirtualBoard of BoardAttackedByBlack = 0 and item item 60 of VirtualBoard of BoardAttackedByBlack = 0 and item item 61 of VirtualBoard of BoardAttackedByBlack = 0 then
					if HasWhiteRookQSMoved = 0 then
						AddSpecialMove (WhiteQueensideCastling) (Depth)
					end
				end
			end
			if item item 62 of VirtualBoard of Board = Empty and item item 61 of VirtualBoard of Board = WhiteKing and item item 63 of VirtualBoard of Board = Empty and item item 64 of VirtualBoard of Board = WhiteRook then
				if item item 61 of VirtualBoard of BoardAttackedByBlack = 0 and item item 62 of VirtualBoard of BoardAttackedByBlack = 0 and item item 63 of VirtualBoard of BoardAttackedByBlack = 0 then
					if HasWhiteRookKSMoved = 0 then
						AddSpecialMove (WhiteKingsideCastling) (Depth)
					end
				end
			end
		end
	end
end
if not CalcAttackState then
	if Depth = 1 then
		replace item Depth of MovesCount with length of Moves1
	end
	if Depth = 2 then
		replace item Depth of MovesCount with length of Moves2
	end
	if Depth = 3 then
		replace item Depth of MovesCount with length of Moves3
	end
	if Depth = 4 then
		replace item Depth of MovesCount with length of Moves4
	end
	if Depth = 5 then
		replace item Depth of MovesCount with length of Moves5
	end
	if Depth = 6 then
		replace item Depth of MovesCount with length of Moves6
	end
	if Depth = 7 then
		replace item Depth of MovesCount with length of Moves7
	end
	if Depth = 8 then
		replace item Depth of MovesCount with length of Moves8
	end
	if Depth = 9 then
		replace item Depth of MovesCount with length of Moves9
	end
	if Depth = 10 then
		replace item Depth of MovesCount with length of Moves10
	end
	if Depth = 11 then
		replace item Depth of MovesCount with length of Moves11
	end
	if Depth = 12 then
		replace item Depth of MovesCount with length of Moves12
	end
	if Depth = 13 then
		replace item Depth of MovesCount with length of Moves13
	end
	if Depth = 14 then
		replace item Depth of MovesCount with length of Moves14
	end
	if Depth = 15 then
		replace item Depth of MovesCount with length of Moves15
	end
end
if CalcAttackState then
	Profile_MethodExit (20 + Depth)
else
	if CapturesOnly then
		Profile_MethodExit (40 + Depth)
	else
		Profile_MethodExit (60 + Depth)
	end
end

define-atomic InitBoard
DetectFlash30Bug
InitKingSafety
InitMobilityBonusLookup
InitCoordLookup
InitHashLookup
InitMoveLookup
FillBoard
hide list BoardHistory
hide list GameMovesAN
hide list ExportData
hide list ExportMoves
set CharsUpperCase to "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
delete all of CharsUpperCaseList
set Idx to 1
repeat length of CharsUpperCaseList
	add letter Idx of CharsUpperCase to CharsUpperCaseList
	change Idx by 1
end
set ExecutionDepth to 0
set IsExecutionRunning to 0
set IsProfilerEnabled to 0
set Level3Depth to 2
set Moves1CaptureCount to 0
set Moves2CaptureCount to 0
set MonTimer1 to 0
set MonTimer2 to 0
set MonTimer3 to 0
set IsDebugMode to 0
set IsEndgame to 0
set IsEndgame2 to 0
set IsImportedBoard to 0
set Empty to 0
set WhiteKing to -20000
set WhiteQueen to -900
set WhiteRook to -500
set WhiteBishop to -330
set WhiteKnight to -310
set WhitePawn to -100
set BlackKing to 20000
set BlackQueen to 900
set BlackRook to 500
set BlackBishop to 330
set BlackKnight to 310
set BlackPawn to 100
set BlackKingsideCastling to "0090"
set WhiteKingsideCastling to "0092"
set BlackQueensideCastling to "0091"
set WhiteQueensideCastling to "0093"
set HasBlackCastled to 0
set HasWhiteKingMoved to 0
set HasWhiteCastled to 0
set HasBlackKingMoved to 0
set HasWhiteRookKSMoved to 0
set HasWhiteRookQSMoved to 0
set HasBlackRookKSMoved to 0
set HasBlackRookQSMoved to 0
set GameMoves to ""
set AddMoveModeDefault to 1
set AddMoveModeAttackRevert to 2
set LineMoveTypeStraight to 1
set LineMoveTypeCross to 2
set LookupMoveTypeKnight to 1
set LookupMoveTypeKing to 2
set IsGameSuspended to 0
delete all of BoardAttackedByWhite
delete all of BoardAttackedByBlack
delete all of KnightMoveOffsets
delete all of KingMoveOffsets
delete all of OpeningMoves
delete all of BoardHistory
delete all of GameMovesAN
delete all of PieceMobility
delete all of BoardAttackedByWhitePiece
delete all of BoardAttackedByBlackPiece
repeat 64
	add "0" to BoardAttackedByWhite
	add "0" to BoardAttackedByBlack
	add "0" to PieceMobility
	add "0" to BoardAttackedByWhitePiece
	add "0" to BoardAttackedByBlackPiece
end
add "-2" to KnightMoveOffsets
add "-1" to KnightMoveOffsets
add "-2" to KnightMoveOffsets
add "1" to KnightMoveOffsets
add "-1" to KnightMoveOffsets
add "-2" to KnightMoveOffsets
add "-1" to KnightMoveOffsets
add "2" to KnightMoveOffsets
add "1" to KnightMoveOffsets
add "-2" to KnightMoveOffsets
add "1" to KnightMoveOffsets
add "2" to KnightMoveOffsets
add "2" to KnightMoveOffsets
add "-1" to KnightMoveOffsets
add "2" to KnightMoveOffsets
add "1" to KnightMoveOffsets
add "-1" to KingMoveOffsets
add "-1" to KingMoveOffsets
add "-1" to KingMoveOffsets
add "0" to KingMoveOffsets
add "-1" to KingMoveOffsets
add "1" to KingMoveOffsets
add "0" to KingMoveOffsets
add "-1" to KingMoveOffsets
add "0" to KingMoveOffsets
add "1" to KingMoveOffsets
add "1" to KingMoveOffsets
add "-1" to KingMoveOffsets
add "1" to KingMoveOffsets
add "0" to KingMoveOffsets
add "1" to KingMoveOffsets
add "1" to KingMoveOffsets
InitOpeningBook
InitKnightSquare
InitPawnSquare
InitPawnSquareEndgame
InitBishopSquare
InitRookSquare
InitQueenSquare
InitKingSquare
InitKingSquareEndgame
InitPawnSquarePreCastling
delete all of Alphas
delete all of Betas
delete all of MinMaxResults
delete all of MovesCount
delete all of MovesIdx
delete all of TargetPieces
delete all of PreviousMoveHash
delete all of BaseHashMove
delete all of BestHashMoveType
delete all of PickMoveRes
delete all of PickPhase
delete all of PickHash
delete all of PrevBestHashMove
delete all of CheckedState
delete all of PromotionPieces
delete all of TargetPiecesIdx
delete all of PosScoreDelta
delete all of BoardAttackedCalculated
repeat 20
	add "" to Alphas
	add "" to Betas
	add "" to MinMaxResults
	add "" to MovesCount
	add "" to MovesIdx
	add "" to TargetPieces
	add "" to PreviousMoveHash
	add "" to BaseHashMove
	add "" to BestHashMoveType
	add "" to PickMoveRes
	add "" to PickPhase
	add "" to PickHash
	add "" to PrevBestHashMove
	add "" to CheckedState
	add "" to PromotionPieces
	add "" to TargetPiecesIdx
	add "" to PosScoreDelta
	add "" to BoardAttackedCalculated
	add "" to CaptureFollowup
end
delete all of BlackPawnCount
delete all of WhitePawnCount
repeat 8
	add "0" to BlackPawnCount
	add "0" to WhitePawnCount
end
delete all of BoardHistory
AddBoardToHistory

define-atomic CalculateMovesForSource (Depth) (SourceIdx arg) <CalcAttackState> <CapturesOnly>
if item SourceIdx arg of Board > 0 or CalcAttackState then
	set DoMoveOnWhite to 1
else
	set DoMoveOnWhite to 0
end
if item SourceIdx arg of Board < 0 or CalcAttackState then
	set DoMoveOnBlack to 1
else
	set DoMoveOnBlack to 0
end
if item SourceIdx arg of Board = BlackPawn then
	if item SourceIdx arg of IdxToRow < 8 then
		if item SourceIdx arg of IdxToCol > 1 then
			AddSimpleMoveNoCheck (SourceIdx arg) -1 1 (Depth) <CalcAttackState> <1 = 1> <CalcAttackState> <CalcAttackState> <CapturesOnly>
		end
		if item SourceIdx arg of IdxToCol < 8 then
			AddSimpleMoveNoCheck (SourceIdx arg) 1 1 (Depth) <CalcAttackState> <1 = 1> <CalcAttackState> <CalcAttackState> <CapturesOnly>
		end
		if not CalcAttackState and not CapturesOnly then
			AddSimpleMoveNoCheck (SourceIdx arg) 0 1 (Depth) <1 = 1> <1 = 0> <1 = 0> <CalcAttackState> <CapturesOnly>
		end
	end
	if item SourceIdx arg of IdxToRow = 2 then
		if not CalcAttackState and not CapturesOnly then
			if item (SourceIdx arg + 8) of Board = Empty then
				AddSimpleMoveNoCheck (SourceIdx arg) 0 2 (Depth) <1 = 1> <1 = 0> <1 = 0> <CalcAttackState> <CapturesOnly>
			end
		end
	else
		if item SourceIdx arg of IdxToRow = 5 then
			AddPossibleEnPassant (SourceIdx arg) (Depth) <CalcAttackState>
		end
	end
else
	if item SourceIdx arg of Board = WhitePawn then
		if item SourceIdx arg of IdxToRow > 1 then
			if item SourceIdx arg of IdxToCol > 1 then
				AddSimpleMoveNoCheck (SourceIdx arg) -1 -1 (Depth) <CalcAttackState> <CalcAttackState> <1 = 1> <CalcAttackState> <CapturesOnly>
			end
			if item SourceIdx arg of IdxToCol < 8 then
				AddSimpleMoveNoCheck (SourceIdx arg) 1 -1 (Depth) <CalcAttackState> <CalcAttackState> <1 = 1> <CalcAttackState> <CapturesOnly>
			end
			if not CalcAttackState and not CapturesOnly then
				AddSimpleMoveNoCheck (SourceIdx arg) 0 -1 (Depth) <1 = 1> <1 = 0> <1 = 0> <CalcAttackState> <CapturesOnly>
			end
		end
		if item SourceIdx arg of IdxToRow = 7 then
			if not CalcAttackState and not CapturesOnly then
				if item (SourceIdx arg - 8) of Board = Empty then
					AddSimpleMoveNoCheck (SourceIdx arg) 0 -2 (Depth) <1 = 1> <1 = 0> <1 = 0> <CalcAttackState> <CapturesOnly>
				end
			end
		else
			if item SourceIdx arg of IdxToRow = 4 then
				AddPossibleEnPassant (SourceIdx arg) (Depth) <CalcAttackState>
			end
		end
	else
		if item SourceIdx arg of Board = BlackKnight or item SourceIdx arg of Board = WhiteKnight then
			AddLookupMove (SourceIdx arg) (LookupMoveTypeKnight) (Depth) <1 = 1> <DoMoveOnWhite = 1> <DoMoveOnBlack = 1> <CalcAttackState> <CapturesOnly>
		else
			if item SourceIdx arg of Board = BlackKing or item SourceIdx arg of Board = WhiteKing then
				AddLookupMove (SourceIdx arg) (LookupMoveTypeKing) (Depth) <1 = 1> <DoMoveOnWhite = 1> <DoMoveOnBlack = 1> <CalcAttackState> <CapturesOnly>
			else
				if item SourceIdx arg of Board = BlackBishop or item SourceIdx arg of Board = WhiteBishop or item SourceIdx arg of Board = BlackQueen or item SourceIdx arg of Board = WhiteQueen then
					AddLineMove (SourceIdx arg) (LineMoveTypeCross) (Depth) <1 = 1> <DoMoveOnWhite = 1> <DoMoveOnBlack = 1> <CalcAttackState> <CapturesOnly>
				end
				if item SourceIdx arg of Board = BlackRook or item SourceIdx arg of Board = WhiteRook or item SourceIdx arg of Board = BlackQueen or item SourceIdx arg of Board = WhiteQueen then
					AddLineMove (SourceIdx arg) (LineMoveTypeStraight) (Depth) <1 = 1> <DoMoveOnWhite = 1> <DoMoveOnBlack = 1> <CalcAttackState> <CapturesOnly>
				end
			end
		end
	end
end

when flag clicked
set IsModeJunior to 0
set IsModeProfiler to 0
set IsModeDeepeningDebug to 0
set IsModeCompetition to 0

define-atomic EvaluateBoard
set BlackBishopCount to 0
set WhiteBishopCount to 0
set EvalResult to 0
set Idx to 1
set InvIdx to 64
set BlackKingIdx to 0
set WhiteKingIdx to 0
repeat 64
	set CurrentPiece to item Idx of Board
	if not CurrentPiece = Empty then
		change EvalResult by CurrentPiece
		GetPosScore (CurrentPiece) (Idx)
		change EvalResult by PosScoreRes
		if CurrentPiece = WhiteKing then
			set WhiteKingIdx to Idx
		else
			if CurrentPiece = BlackKing then
				set BlackKingIdx to Idx
			end
		end
	end
	change Idx by 1
	change InvIdx by -1
end
if 1 = 0 then
	if BlackBishopCount = 2 then
		change EvalResult by 50
	end
	if WhiteBishopCount = 2 then
		change EvalResult by -50
	end
end
if IsImportedBoard = 0 and length of GameMovesAN < 13 then
	if not item item 4 of VirtualBoard of Board = BlackQueen then
		change EvalResult by -10
	end
	if not item item 60 of VirtualBoard of Board = WhiteQueen then
		change EvalResult by 10
	end
end
if IsEndgame = 0 then
	if 1 = 1 then
		if item item 1 of MovesIdx of Moves1 = BlackKingsideCastling or item item 1 of MovesIdx of Moves1 = BlackQueensideCastling then
			change EvalResult by 50
		end
		if item item 3 of MovesIdx of Moves3 = BlackKingsideCastling or item item 3 of MovesIdx of Moves3 = BlackQueensideCastling then
			change EvalResult by 25
		end
		if item item 5 of MovesIdx of Moves5 = BlackKingsideCastling or item item 5 of MovesIdx of Moves5 = BlackQueensideCastling then
			change EvalResult by 10
		end
		if item item 2 of MovesIdx of Moves2 = WhiteKingsideCastling or item item 2 of MovesIdx of Moves2 = WhiteQueensideCastling then
			change EvalResult by -50
		end
		if item item 4 of MovesIdx of Moves4 = WhiteKingsideCastling or item item 4 of MovesIdx of Moves4 = WhiteQueensideCastling then
			change EvalResult by -25
		end
		if item item 6 of MovesIdx of Moves6 = WhiteKingsideCastling or item item 6 of MovesIdx of Moves6 = WhiteQueensideCastling then
			change EvalResult by -10
		end
	end
	if HasBlackCastled = 0 and HasBlackKingMoved = 0 and <HasBlackRookQSMoved = 0 or HasBlackRookKSMoved = 0> then
		if not item item 1 of MovesIdx of Moves1 = BlackQueensideCastling and not item item 3 of MovesIdx of Moves3 = BlackQueensideCastling and not item item 5 of MovesIdx of Moves5 = BlackQueensideCastling then
			if not item item 1 of MovesIdx of Moves1 = BlackKingsideCastling and not item item 3 of MovesIdx of Moves3 = BlackKingsideCastling and not item item 5 of MovesIdx of Moves5 = BlackKingsideCastling then
				if not item item 5 of VirtualBoard of Board = BlackKing or item floor of (item item 3 of MovesIdx of Moves3 mod 100) of Board = BlackKing then
					change EvalResult by -50
				else
					if not item item 1 of VirtualBoard of Board = BlackRook or item floor of (item item 3 of MovesIdx of Moves3 mod 100) of Board = BlackRook then
						change EvalResult by -15
					end
					if not item item 8 of VirtualBoard of Board = BlackRook or item floor of (item item 3 of MovesIdx of Moves3 mod 100) of Board = BlackRook then
						change EvalResult by -15
					end
				end
			end
		end
	end
	if HasWhiteCastled = 0 and HasWhiteKingMoved = 0 and <HasWhiteRookQSMoved = 0 or HasWhiteRookKSMoved = 0> then
		if not item item 2 of MovesIdx of Moves2 = WhiteQueensideCastling and not item item 4 of MovesIdx of Moves4 = WhiteQueensideCastling and not item item 6 of MovesIdx of Moves6 = WhiteQueensideCastling then
			if not item item 2 of MovesIdx of Moves2 = WhiteKingsideCastling and not item item 4 of MovesIdx of Moves4 = WhiteKingsideCastling and not item item 6 of MovesIdx of Moves6 = WhiteKingsideCastling then
				if not item item 61 of VirtualBoard of Board = WhiteKing or item floor of (item item 4 of MovesIdx of Moves4 mod 100) of Board = WhiteKing then
					change EvalResult by 50
				else
					if not item item 57 of VirtualBoard of Board = WhiteRook or item floor of (item item 4 of MovesIdx of Moves4 mod 100) of Board = WhiteRook then
						change EvalResult by 15
					end
					if not item item 64 of VirtualBoard of Board = WhiteRook or item floor of (item item 4 of MovesIdx of Moves4 mod 100) of Board = WhiteRook then
						change EvalResult by 15
					end
				end
			end
		end
	end
end
if IsEndgame = 1 then
	if WhiteQueenCount + WhiteMinorCount = 0 or BlackQueenCount + BlackMinorCount = 0 then
		set Delta to abs of (item WhiteKingIdx of IdxToRow - item BlackKingIdx of IdxToRow) + abs of (item WhiteKingIdx of IdxToCol - item BlackKingIdx of IdxToCol)
		if WhiteQueenCount + WhiteMinorCount < BlackQueenCount + BlackMinorCount then
			change EvalResult by -10 * Delta
		else
			if WhiteQueenCount + WhiteMinorCount > BlackQueenCount + BlackMinorCount then
				change EvalResult by 10 * Delta
			end
		end
	end
end
change EvalResult by BlackMobilityBonus - WhiteMobilityBonus

when p key pressed
if IsModeProfiler = 0 then
	set IsModeProfiler to 1
	show list Profile_Data
	show variable IsProfilerEnabled
else
	set IsModeProfiler to 0
	hide list Profile_Data
	hide variable IsProfilerEnabled
end

define Marker1
CalculateMoves 1
CutoffReorder 1 <>

when flag clicked
set IsScratch3 to 0
set Scratch3TestVal to 1
repeat 1000
	set Scratch3TestVal to 2 * Scratch3TestVal
end
if (join "x" (Scratch3TestVal)) = "x1.0715086071862673e+301" then
	set Scratch3TestVal to timer
	wait 0 secs
	set Scratch3TestVal to timer - Scratch3TestVal
	if Scratch3TestVal > 0 then
		set IsScratch3 to 1
	end
end

define DrawBoardAndWait
set ProgressValue to 0
broadcast "DrawBoard" and wait
broadcast "ProgressValueChanged" and wait

define-atomic AlphaBetaMinMaxImpl (Depth) (MinDepth) (MaxDepth) <ApplyCutoff> <CalcCutoff> (QuiescenceDepth arg) <Quiescence> <PrevQuiescence> <ShowProgress>
replace item Depth of BestHashMoveType with ""
replace item Depth of PrevBestHashMove with ""
InitAlphaBeta (Depth) (MaxDepth) <ApplyCutoff>
if Quiescence then
	OnScoreCalc (Depth - 1) (MinDepth) (Depth - 1) <ApplyCutoff> <CalcCutoff> <Quiescence>
else
	OnScoreCalc (Depth - 1) (MinDepth) (MaxDepth - 1) <ApplyCutoff> <CalcCutoff> <Quiescence>
end
if Depth = MaxDepth then
	replace item Depth of MinMaxResults with ScoreCalcRes
	stop this script
end
if Quiescence then
	if Depth mod 2 = 1 then
		if not ScoreCalcRes < item Depth of Betas then
			replace item Depth of MinMaxResults with item Depth of Betas
			stop this script
		end
		if ScoreCalcRes > item Depth of Alphas then
			replace item Depth of Alphas with ScoreCalcRes
		end
	else
		if not ScoreCalcRes > item Depth of Alphas then
			replace item Depth of MinMaxResults with item Depth of Alphas
			stop this script
		end
		if ScoreCalcRes < item Depth of Betas then
			replace item Depth of Betas with ScoreCalcRes
		end
	end
end
if item (Depth - 1) of TargetPieces = WhiteKing or item (Depth - 1) of TargetPieces = BlackKing then
	replace item Depth of MinMaxResults with ScoreCalcRes
	stop this script
end
if MinDepth = 1 and <Depth = 2 or Depth = 3 or <not PrevQuiescence and item (Depth - 1) of CheckedState = 1>> then
	CalcBoardAttackedByMove (Depth)
	if Depth mod 2 = 1 then
		if IsWhiteChecked = 1 then
			replace item Depth of MinMaxResults with 100000 - Depth * 1000
			stop this script
		end
	else
		if IsBlackChecked = 1 then
			replace item Depth of MinMaxResults with -100000 + Depth * 1000
			stop this script
		end
	end
end
if MinDepth = 1 and Depth = 2 then
	GetBoardString
	if BoardHistory contains GetBoardStringRes? then
		replace item Depth of MinMaxResults with "0"
		stop this script
	end
	IsDraw (Depth)
	if IsDrawRes = 1 then
		replace item Depth of MinMaxResults with "0"
		stop this script
	end
end
if ApplyCutoff and Depth > 1 and Depth < 13 then
	GetBestHashMove (CurrentMoveHash)
	if BestHashMoveResult = 1 and Depth mod 2 = BestHashMoveDepthResult mod 2 and HashMoveAge = BestHashMoveAge then
		if not Depth < BestHashMoveDepthResult then
			Profile_IncCounter (120 + Depth)
			if BestHashMoveTypeResult = "E" then
				replace item Depth of MinMaxResults with BestHashMoveScoreResult
				stop this script
			else
				if BestHashMoveTypeResult = "A" and not BestHashMoveScoreResult > item Depth of Alphas then
					replace item Depth of MinMaxResults with BestHashMoveScoreResult
					stop this script
				else
					if BestHashMoveTypeResult = "B" and not BestHashMoveScoreResult < item Depth of Betas then
						replace item Depth of MinMaxResults with BestHashMoveScoreResult
						stop this script
					end
				end
			end
		end
	end
end
replace item Depth of PickPhase with "1"
replace item Depth of PickMoveRes with "1"
replace item Depth of CheckedState with "0"
repeat until item Depth of PickMoveRes = 0 or IsMinMaxTimeout = 1
	if IsMinMaxTimeout = 0 then
		if not Quiescence then
			if timer - ThinkTimeStart > ThinkTimeLimitMinMax then
				set IsMinMaxTimeout to 1
			end
		end
	end
	if IsMinMaxTimeout = 0 then
		Profile_MethodEnter (100 + Depth)
		PickMove (Depth) (MaxDepth - 1) <CalcCutoff> <ApplyCutoff> <Quiescence> <PrevQuiescence>
		Profile_MethodExit (100 + Depth)
		if item Depth of PickMoveRes = 1 then
			if Depth = 1 then
				if ShowProgress and item Depth of PickPhase = 3 then
					if IsScratch3 = 0 or item Depth of MovesIdx = item Depth of MovesCount then
						OnProgressChanged ((timer - ThinkTimeStart) / ThinkTimeLimit * 100)
					end
				end
			end
			replace item Depth + 1 of Alphas with item Depth of Alphas
			replace item Depth + 1 of Betas with item Depth of Betas
			set IsPlyExtension to 0
			if QuiescenceDepth arg > 0 and Depth = MaxDepth - 1 and <not item Depth of TargetPieces = Empty or 1 = 1> then
				set IsPlyExtension to 0
				if not Quiescence then
					if 1 = 1 then
						GetCurrentMove (Depth)
						if Depth mod 2 = 1 then
							if item floor of (CurrentMove mod 100) of BoardAttackedByWhite = 0 then
								set IsWhiteChecked to 0
								CalculateMovesForSource (Depth + 2) (floor of (CurrentMove mod 100)) <1 = 1> <1 = 0>
								if IsWhiteChecked = 1 then
									set IsPlyExtension to 1
								end
							end
						else
							if item floor of (CurrentMove mod 100) of BoardAttackedByBlack = 0 then
								set IsBlackChecked to 0
								CalculateMovesForSource (Depth + 2) (floor of (CurrentMove mod 100)) <1 = 1> <1 = 0>
								if IsBlackChecked = 1 then
									set IsPlyExtension to 1
								end
							end
						end
					end
				end
				AlphaBetaMinMaxImpl (Depth + 1) (MinDepth) (MaxDepth + 1) <ApplyCutoff> <CalcCutoff> (QuiescenceDepth arg - 1) <IsPlyExtension = 0> <Quiescence> <ShowProgress>
			else
				AlphaBetaMinMaxImpl (Depth + 1) (MinDepth) (MaxDepth) <ApplyCutoff> <CalcCutoff> (QuiescenceDepth arg) <Quiescence> <Quiescence> <ShowProgress>
			end
			set Score to item (Depth + 1) of MinMaxResults
			if Depth = 1 then
				if item (Depth + 1) of BestHashMoveType = "E" then
					replace item item item 1 of MovesIdx of DeepeningScoreOrderMap of DeepeningScore with Score
				end
			end
			if not Quiescence or Depth < 12 then
				HashOnMoveScore (Depth + 1) (Score) (CurrentMoveHash) (item (Depth + 1) of PrevBestHashMove) (item (Depth + 1) of BestHashMoveType) (item Depth of CheckedState)
			end
			if item Depth of TargetPieces = Empty then
				set IsPotentialKillerMove to 1
			else
				set IsPotentialKillerMove to 0
			end
			RevertMove (Depth)
			if Depth mod 2 = 1 then
				if Depth = 1 and IsMinMaxTimeout = 0 then
					add item item 1 of MovesIdx of Moves1 to MinMaxPly1EvalMoves
				end
				if Depth > 1 then
					if not Score < item Depth of Betas then
						replace item Depth of MinMaxResults with item Depth of Betas
						replace item Depth of BestHashMoveType with "B"
						StoreMove (Depth) <IsPotentialKillerMove = 1>
						stop this script
					end
				end
				if Score > item Depth of Alphas then
					replace item Depth of Alphas with Score
					replace item Depth of BestHashMoveType with "E"
					if Depth = 1 and IsMinMaxTimeout = 0 then
						delete all of BestMoves
						add item item 1 of MovesIdx of Moves1 to BestMoves
						delete all of BestMinMaxResults
						add Score to BestMinMaxResults
						if item 1 of BestMoves = BlackKingsideCastling then
							set BestMoveFromIdx to item 5 of VirtualBoard
							set BestMoveToIdx to item 7 of VirtualBoard
						else
							if item 1 of BestMoves = BlackQueensideCastling then
								set BestMoveFromIdx to item 5 of VirtualBoard
								set BestMoveToIdx to item 3 of VirtualBoard
							else
								set BestMoveFromIdx to floor of (item 1 of BestMoves / 100)
								set BestMoveToIdx to floor of (item 1 of BestMoves mod 100)
							end
						end
						broadcast "ShowBestMove"
					end
					StoreMove (Depth) <1 = 0>
				end
			else
				if not Score > item Depth of Alphas then
					replace item Depth of MinMaxResults with item Depth of Alphas
					replace item Depth of BestHashMoveType with "A"
					StoreMove (Depth) <IsPotentialKillerMove = 1>
					stop this script
				end
				if Score < item Depth of Betas then
					replace item Depth of Betas with Score
					replace item Depth of BestHashMoveType with "E"
					StoreMove (Depth) <1 = 0>
				end
			end
		end
	end
end
if IsMinMaxTimeout = 0 then
	if Depth mod 2 = 1 then
		replace item Depth of MinMaxResults with item Depth of Alphas
		if not item Depth of BestHashMoveType = "E" then
			replace item Depth of BestHashMoveType with "A"
		end
	else
		replace item Depth of MinMaxResults with item Depth of Betas
		if not item Depth of BestHashMoveType = "E" then
			replace item Depth of BestHashMoveType with "B"
		end
	end
	if item Depth of MovesCount = 0 then
		if Quiescence then
			OnScoreCalc (Depth - 1) (MinDepth) (Depth - 1) <ApplyCutoff> <CalcCutoff> <Quiescence>
			replace item Depth of MinMaxResults with ScoreCalcRes
			stop this script
		else
			CalcBoardAttackedByMove (Depth + 1)
			if Depth mod 2 = 1 then
				if IsBlackChecked = 1 then
					replace item Depth of MinMaxResults with -100000 + Depth * 1000
					stop this script
				else
					replace item Depth of MinMaxResults with "0"
					stop this script
				end
			else
				if IsWhiteChecked = 1 then
					replace item Depth of MinMaxResults with 100000 - Depth * 1000
					stop this script
				else
					replace item Depth of MinMaxResults with "0"
					stop this script
				end
			end
		end
	end
end

when j key pressed
if IsModeJunior = 0 then
	set IsModeJunior to 1
	SayAsync "Junior mode enabled. Low playing strength on all levels. \"Easy\" plays random moves." 5
else
	set IsModeJunior to 0
	SayAsync "Junior mode disabled. Normal playing strength." 5
end

define-atomic DetectFlash30Bug
set IsFlash30Bug to 0
set ThinkTimeStart to timer
repeat 10000
	...
end
if timer > ThinkTimeStart + 0.1 then
	if 1 = 0 then
		set IsFlash30Bug to 1
	end
end

when d key pressed
if IsModeDeepeningDebug = 0 then
	set IsModeDeepeningDebug to 1
	show variable IdxDeepening
	show variable BestMinMaxRes
	show variable BestMove
else
	set IsModeDeepeningDebug to 0
	hide variable IdxDeepening
	hide variable BestMinMaxRes
	hide variable BestMove
end

when flag clicked
hide list ExportData
hide list ExportMoves

define-atomic CalculateMoves (Depth)
CalcBoardAttackedByMove (Depth + 1)
replace item Depth of BoardAttackedCalculated with "1"
CalculateMovesImpl (Depth) <1 = 0> <1 = 0>
replace item Depth of BoardAttackedCalculated with "0"

define-atomic InitPawnSquarePreCastling
delete all of PawnPieceSquarePreCastling
LoadList " 0, 0, 0, 0, 0, 0, 0, 0, -35, -35, -35, 39, 39, -35, -35, -35, -35, -35, -35, 29, 29, -35, -35, -35, -35, -35, -35, 22, 22, -35, -35, -35, -35, -35, -35, 14, 14, -35, -35, -35, -25, -11, -25, 4, 4, -25, -11, -25,  -21, -21, -6, -1, -1, -6, -21, -21,   0, 0, 0, 0, 0, 0, 0, 0" "PawnPieceSquarePreCastling"

define-atomic Profile_Reset
delete all of Profile_Data

define-atomic QuickSort (BeginIdx) (EndIdx)
set QSLower to BeginIdx
set QSUpper to EndIdx
set QSPivot to item floor of ((BeginIdx + EndIdx) / 2) of SortedList
repeat until QSLower > QSUpper
	repeat until not item QSLower of SortedList < QSPivot
		change QSLower by 1
	end
	repeat until not item QSUpper of SortedList > QSPivot
		change QSUpper by -1
	end
	if not QSLower > QSUpper then
		set QSSwap to item QSLower of SortedList
		replace item QSLower of SortedList with item QSUpper of SortedList
		replace item QSUpper of SortedList with QSSwap
		change QSLower by 1
		change QSUpper by -1
	end
end
if BeginIdx < QSUpper then
	QuickSort (BeginIdx) (QSUpper)
end
if QSLower < EndIdx then
	QuickSort (QSLower) (EndIdx)
end

define-atomic InitBishopSquare
delete all of BishopPieceSquare
set BishopSquareDef to "-20, -18, -16, -14, -14, -16, -18, -20,-10, 11, 1, 1, 1, 1, 11, -10, 1, 11, 21, 26, 26, 21, 11, 1, 1, 21, 21, 26, 26, 21, 21, 1, 1, 1, 16, 21, 21, 16, 1, 1, -25, 6, 16, 11, 11, 16, 6, -25, -28, 11, 6, 1, 1, 6, 11, -28, -30, -25, -20, -20, -20, -20, -25, -30"
LoadList (BishopSquareDef) "BishopPieceSquare"

define-atomic FillBoard
delete all of VirtualBoard
delete all of SwitchedBoard
set Idx to 1
repeat 64
	if IsPlayerBlack = 0 then
		add Idx to VirtualBoard
		add Idx to SwitchedBoard
	else
		add (item Idx of IdxToRow - 1) * 8 + (9 - item Idx of IdxToCol) to VirtualBoard
		add (item Idx of IdxToRow - 1) * 8 + (9 - item Idx of IdxToCol) to SwitchedBoard
	end
	change Idx by 1
end
delete all of Board
repeat 64
	add Empty to Board
end
replace item item 1 of VirtualBoard of Board with BlackRook
replace item item 2 of VirtualBoard of Board with BlackKnight
replace item item 3 of VirtualBoard of Board with BlackBishop
replace item item 4 of VirtualBoard of Board with BlackQueen
replace item item 5 of VirtualBoard of Board with BlackKing
replace item item 6 of VirtualBoard of Board with BlackBishop
replace item item 7 of VirtualBoard of Board with BlackKnight
replace item item 8 of VirtualBoard of Board with BlackRook
set Idx to 9
repeat 8
	replace item item Idx of VirtualBoard of Board with BlackPawn
	change Idx by 1
end
set Idx to 49
repeat 8
	replace item item Idx of VirtualBoard of Board with WhitePawn
	change Idx by 1
end
replace item item 57 of VirtualBoard of Board with WhiteRook
replace item item 58 of VirtualBoard of Board with WhiteKnight
replace item item 59 of VirtualBoard of Board with WhiteBishop
replace item item 60 of VirtualBoard of Board with WhiteQueen
replace item item 61 of VirtualBoard of Board with WhiteKing
replace item item 62 of VirtualBoard of Board with WhiteBishop
replace item item 63 of VirtualBoard of Board with WhiteKnight
replace item item 64 of VirtualBoard of Board with WhiteRook

define ExecuteUserMove
EnterExecution
if IsGameSuspended = 0 then
	if item MoveFromIdx of Board < 0 and not MoveFromIdx = MoveToIdx then
		set UserMove to ""
		if item MoveFromIdx of Board = WhiteKing and MoveFromIdx = item 61 of VirtualBoard then
			if MoveToIdx = item 59 of VirtualBoard and item item 57 of VirtualBoard of Board = WhiteRook then
				CalculateMoves 2
				if Moves2 contains WhiteQueensideCastling? then
					set UserMove to WhiteQueensideCastling
				else
					set UserMove to 6159
				end
			end
			if MoveToIdx = item 63 of VirtualBoard and item item 64 of VirtualBoard of Board = WhiteRook then
				CalculateMoves 2
				if Moves2 contains WhiteKingsideCastling? then
					set UserMove to WhiteKingsideCastling
				else
					set UserMove to 6163
				end
			end
		end
		if UserMove = "" then
			set UserMove to MoveFromIdx * 100 + MoveToIdx
			if length of UserMove = 3 then
				set UserMove to (join "0" (UserMove))
			end
			if item MoveFromIdx of Board = WhitePawn and MoveFromIdx < 17 then
				set UserMove to (join (UserMove) ".1")
			end
		end
		set MovePieceFromIdx to MoveFromIdx
		set MovePieceToIdx to MoveToIdx
		if UserMove = BlackQueensideCastling or UserMove = BlackKingsideCastling or UserMove = WhiteQueensideCastling or UserMove = WhiteKingsideCastling then
			set MovePieceSpecial to UserMove
		else
			set MovePieceSpecial to ""
		end
		broadcast "MovePiece" and wait
		set FromSquareIdx to -1
		set ToSquareIdx to -1
		broadcast "FromSquareSelected" and wait
		broadcast "ToSquareSelected" and wait
		CalculateMoves 2
		if not Moves2 contains UserMove? then
			delete all of Moves2
			add UserMove to Moves2
			replace item 2 of MovesIdx with "1"
			replace item 2 of MovesCount with "1"
			ApplyMove 2
			CalcBoardAttackedByMove 1
			if IsWhiteChecked = 1 then
				SayAsync "Invalid move - Check!" 2
			else
				SayAsync "Invalid move!" 2
			end
			RevertMove 2
			DrawBoardAndWait
		else
			if not UserMove = floor of UserMove then
				say "Please select promotion piece"
				broadcast "CalcMode" and wait
				broadcast "SelectPromotionPieceWhite" and wait
				broadcast "InputMode" and wait
				say ""
				if SelectedPromotionPiece = WhiteQueen then
					set UserMove to (join (floor of UserMove) ".1")
				else
					if SelectedPromotionPiece = WhiteRook then
						set UserMove to (join (floor of UserMove) ".2")
					else
						if SelectedPromotionPiece = WhiteBishop then
							set UserMove to (join (floor of UserMove) ".3")
						else
							if SelectedPromotionPiece = WhiteKnight then
								set UserMove to (join (floor of UserMove) ".4")
							end
						end
					end
				end
				repeat until length of UserMove > 5
					set UserMove to (join "0" (UserMove))
				end
			end
			GetMoveNotation (floor of UserMove)
			delete all of Moves2
			add UserMove to Moves2
			replace item 2 of MovesIdx with "1"
			replace item 2 of MovesCount with "1"
			ApplyMove 2
			CalcBoardAttackedByMove 1
			if IsWhiteChecked = 1 then
				RevertMove 2
				DrawBoardAndWait
				SayAsync "Invalid move - Check!" 2
			else
				think "Thinking..."
				DrawBoardAndWait
				wait 0 secs
				broadcast "CalcMode" and wait
				set UserMoveAN to MoveNotationRes
				add UserMoveAN to GameMovesAN
				set GameMoves to (join (GameMoves) (UserMove))
				AddBoardToHistory
				IsBlackKingCheckMate
				if IsBlackKingCheckMateRes = 1 then
					say "Checkmate!"
					broadcast "InputMode"
					set IsGameSuspended to 1
				else
					IsDraw 1
					if IsDrawRes = 1 then
						say "Draw!"
						broadcast "InputMode"
						set IsGameSuspended to 1
					else
						GetRepetitionCount
						if RepetitionCountRes > 2 then
							say "Draw!"
							broadcast "InputMode"
							set IsGameSuspended to 1
						else
							IsTwoKingDraw
							if TwoKingDrawRes = 1 then
								say "Draw!"
								broadcast "InputMode"
								set IsGameSuspended to 1
							else
								if item (UserMove mod 100) of Board = WhiteKing then
									set HasWhiteKingMoved to 1
								end
								if item (UserMove mod 100) of Board = WhiteRook then
									if floor of (UserMove / 100) = item 57 of VirtualBoard then
										set HasWhiteRookQSMoved to 1
									end
									if floor of (UserMove / 100) = item 64 of VirtualBoard then
										set HasWhiteRookKSMoved to 1
									end
								end
								if UserMove = WhiteQueensideCastling or UserMove = WhiteKingsideCastling then
									set HasWhiteCastled to 1
									set HasWhiteKingMoved to 1
								end
								ExecuteEngineMove
							end
						end
					end
				end
			end
		end
	end
end
ExecuteMovePostProcess
ExitExecution

define-atomic SEEImpl _Currently not used_
set SEEMapValWhite to item ToIdx of BoardAttackedByWhitePiece
set SEEMapValBlack to item ToIdx of BoardAttackedByBlackPiece
if Depth mod 2 = 0 then
	set SEEPieceWhite to SourcePiece
	set SEEPieceBlack to Empty
	if not SourcePiece = WhitePawn or not item FromIdx of IdxToCol = item ToIdx of IdxToCol then
		GetSEEMapVal (SEEPieceWhite)
		change SEEMapValWhite by 0 - SEEMapValRes
	end
else
	set SEEPieceBlack to SourcePiece
	set SEEPieceWhite to Empty
	if not SourcePiece = BlackPawn or not item FromIdx of IdxToCol = item ToIdx of IdxToCol then
		GetSEEMapVal (SEEPieceBlack)
		change SEEMapValBlack by 0 - SEEMapValRes
	end
end
set SEEMoveDepth to Depth + 1
if <SEEMoveDepth mod 2 = 0 and SEEMapValWhite > 0> or <SEEMoveDepth mod 2 = 1 and SEEMapValBlack > 0> then
	if SEEMoveDepth mod 2 = 0 then
		GetSEEPiece (SEEMoveDepth) (SEEMapValWhite)
		set SEEPieceWhite to SEEPieceRes
		GetSEEMapVal (SEEPieceWhite)
		change SEEMapValWhite by 0 - SEEMapValRes
		change MoveScoreRes by 0 - SEEPieceBlack
	else
		GetSEEPiece (SEEMoveDepth) (SEEMapValBlack)
		set SEEPieceBlack to SEEPieceRes
		GetSEEMapVal (SEEPieceBlack)
		change SEEMapValBlack by 0 - SEEMapValRes
		change MoveScoreRes by 0 - SEEPieceWhite
	end
	change SEEMoveDepth by 1
end

define DEPOT

define-atomic GetSubstringLeft [Text] (Count arg)
GetSubstring (Text) 1 (Count arg)

define-atomic RUN_BEFORE_SAVING
delete all of HashMovesChecked
delete all of HashMovesHash
delete all of HashMovesBestMove
delete all of HashMovesScore
delete all of HashMovesDepth
delete all of HashMovesAge
delete all of HashMovesType
delete all of KillerMoves1
delete all of KillerMoves2
delete all of KillerMoves3
delete all of KillerMoves4
delete all of KillerMoves5
delete all of KillerMoves6
delete all of HistoryTable
if 1 = 0 then
	delete all of MoveLookupStraight
	delete all of MoveLookupCross
	delete all of MoveLookupOffsetsStraight
	delete all of MoveLookupOffsetsCross
	delete all of OpeningMoves
	delete all of KnightPieceSquare
	delete all of PawnPieceSquare
	delete all of BishopPieceSquare
	delete all of RookPieceSquare
	delete all of QueenPieceSquare
	delete all of KingPieceSquare
	delete all of KingPieceSquareEndgame
	delete all of OpeningMoves
	delete all of PawnPieceSquareEndgame
	delete all of PosPieceHashLookup
	delete all of BoardHistory
end

define-atomic HashOnMoveScore (Depth) (Score arg) (HashMove) (BestMove arg) [Type] (Checked)
set HashBucket to HashMove mod length of HashMovesHash + 1
set CurrentIdx to 1
repeat until length of item HashBucket of HashMovesHash = 0 or <item HashBucket of HashMovesHash = HashMove and Depth < item HashBucket of HashMovesDepth> or item CurrentIdx of HashMovesAge < HashMoveAge + 1
	change HashBucket by 1
	if HashBucket > length of HashMovesHash then
		set HashBucket to 1
	end
	change CurrentIdx by 1
	if CurrentIdx > 10 then
		stop this script
	end
end
replace item HashBucket of HashMovesHash with HashMove
replace item HashBucket of HashMovesDepth with Depth
replace item HashBucket of HashMovesScore with Score arg
replace item HashBucket of HashMovesBestMove with BestMove arg
replace item HashBucket of HashMovesAge with HashMoveAge
replace item HashBucket of HashMovesType with Type
replace item HashBucket of HashMovesChecked with Checked

define-atomic GetPosPieceHash (Pos) (Piece)
if Piece = BlackBishop then
	set PosPieceHash to item Pos of PosPieceHashLookup
end
if Piece = BlackPawn then
	set PosPieceHash to item (64 + Pos) of PosPieceHashLookup
end
if Piece = BlackQueen then
	set PosPieceHash to item (128 + Pos) of PosPieceHashLookup
end
if Piece = BlackKing then
	set PosPieceHash to item (192 + Pos) of PosPieceHashLookup
end
if Piece = BlackKnight then
	set PosPieceHash to item (256 + Pos) of PosPieceHashLookup
end
if Piece = BlackRook then
	set PosPieceHash to item (320 + Pos) of PosPieceHashLookup
end
if Piece = WhiteBishop then
	set PosPieceHash to item (384 + Pos) of PosPieceHashLookup
end
if Piece = WhiteQueen then
	set PosPieceHash to item (448 + Pos) of PosPieceHashLookup
end
if Piece = WhiteKing then
	set PosPieceHash to item (512 + Pos) of PosPieceHashLookup
end
if Piece = WhitePawn then
	set PosPieceHash to item (576 + Pos) of PosPieceHashLookup
end
if Piece = WhiteKnight then
	set PosPieceHash to item (640 + Pos) of PosPieceHashLookup
end
if Piece = WhiteRook then
	set PosPieceHash to item (704 + Pos) of PosPieceHashLookup
end

define-atomic AddPossibleEnPassant (SourceIdx arg) (Depth) <CalcAttackState>
AddPossibleEnPassantImpl (SourceIdx arg) -1 (Depth) <CalcAttackState>
AddPossibleEnPassantImpl (SourceIdx arg) 1 (Depth) <CalcAttackState>

define-atomic IsTwoKingDraw
set TwoKingDrawRes to 1
set Idx to 1
repeat 64
	if not item Idx of Board = Empty and not item Idx of Board = BlackKing and not item Idx of Board = WhiteKing then
		set TwoKingDrawRes to 0
	end
	change Idx by 1
end

define-atomic Log [Txt1] [Txt2] [Txt3] [Txt4] [Txt5] [Txt6] [Txt7] [Txt8]
add (join (Txt1) join (Txt2) join (Txt3) join (Txt4) join (Txt5) join (Txt6) join (Txt7) (Txt8)) to Logfile

define Profile_MethodExit (Id)
if IsProfilerEnabled > 0 then
	replace item Id of Profile_Data with item Id of Profile_Data + timer
end

define ImportBoard [ImpBoard]
set Level3Depth to 2
set IsImportedBoard to 1
set HasWhiteKingMoved to 0
set HasBlackKingMoved to 0
set HasWhiteCastled to 0
set HasBlackCastled to 0
set HasWhiteRookKSMoved to 0
set HasWhiteRookQSMoved to 0
set HasBlackRookKSMoved to 0
set HasBlackRookQSMoved to 0
set GameMoves to ""
delete all of BoardHistory
delete all of GameMovesAN
set IsFEN to 1
set IdxString to 1
repeat length of ImpBoard
	if letter IdxString of ImpBoard = "," then
		set IsFEN to 0
	end
	change IdxString by 1
end
if IsFEN = 1 then
	ImportBoardFEN (ImpBoard)
else
	ImportBoardInternal (ImpBoard)
end
if not item item 1 of VirtualBoard of Board = BlackRook then
	set HasBlackRookQSMoved to 1
end
if not item item 5 of VirtualBoard of Board = BlackKing then
	set HasBlackKingMoved to 1
end
if not item item 8 of VirtualBoard of Board = BlackRook then
	set HasBlackRookQSMoved to 1
end
if not item item 57 of VirtualBoard of Board = WhiteRook then
	set HasWhiteRookQSMoved to 1
end
if not item item 61 of VirtualBoard of Board = WhiteKing then
	set HasWhiteKingMoved to 1
end
if not item item 64 of VirtualBoard of Board = WhiteRook then
	set HasWhiteRookKSMoved to 1
end

define-atomic InitKnightSquare
delete all of KnightPieceSquare
set KnightSquareDef to "-30, -20, -15, -15, -15, -15, -20, -30,-20, 15, 20, 20, 20, 20, 15, -20,-20, 22, 30, 35, 35, 30, 22, -20,-20, 20, 25, 25, 25, 25, 20, -20,-20,  5, 20, 18, 18, 20,  5, -20,-20,  0, 15, 10, 10, 15,  0, -20, -15, -15, -5, 5,  5, -5, -15, -15, -35, -10,-12,-7, -7,-12, -10, -35"
LoadList (KnightSquareDef) "KnightPieceSquare"

define-atomic GetSEEPiece (Depth) (MapVal)
set SEEPieceRes to Empty
if not MapVal < 100000 then
	set SEEPieceRes to BlackPawn
else
	if not MapVal < 10000 then
		set SEEPieceRes to BlackKnight
	else
		if not MapVal < 1000 then
			set SEEPieceRes to BlackBishop
		else
			if not MapVal < 100 then
				set SEEPieceRes to BlackRook
			else
				if not MapVal < 10 then
					set SEEPieceRes to BlackQueen
				else
					if not MapVal < 1 then
						set SEEPieceRes to BlackKing
					end
				end
			end
		end
	end
end
if Depth mod 2 = 0 then
	set SEEPieceRes to 0 - SEEPieceRes
end

define-atomic GetBoardString
set GetBoardStringRes to ""
set Idx to 1
repeat 64
	set GetBoardStringRes to (join (GetBoardStringRes) join (item Idx of Board) ",")
	change Idx by 1
end

when c key pressed
if IsModeCompetition = 0 then
	set IsModeCompetition to 1
	SayAsync "Think time on Difficult set to 60 seconds" 5
else
	set IsModeCompetition to 0
	SayAsync "Think time on Difficult set to 45/30 seconds" 5
end

define-atomic DrawBoard
set ProgressValue to 0
broadcast "DrawBoard"
broadcast "ProgressValueChanged"

define UndoMove
if length of GameMovesAN > 0 then
	GetSubstringRight (GameMoves) 4
	if item floor of (SubstringRes mod 100) of Board > 0 then
		set IsBlackMove to 1
	else
		set IsBlackMove to 0
	end
	if IsBlackMove = 0 then
		UndoPrevMove
		set IsGameSuspended to 0
	else
		if length of GameMovesAN > 1 then
			UndoPrevMove
			UndoPrevMove
			set IsGameSuspended to 0
		end
	end
end

define-atomic AddSpecialMove [Code] (Depth)
GetMoveScore 0 0 0 0 (Code) (Depth)
if Depth = 1 then
	add Code to Moves1
	add MoveScoreRes to Moves1Score
end
if Depth = 2 then
	add Code to Moves2
	add MoveScoreRes to Moves2Score
end
if Depth = 3 then
	add Code to Moves3
	add MoveScoreRes to Moves3Score
end
if Depth = 4 then
	add Code to Moves4
	add MoveScoreRes to Moves4Score
end
if Depth = 5 then
	add Code to Moves5
	add MoveScoreRes to Moves5Score
end
if Depth = 6 then
	add Code to Moves6
	add MoveScoreRes to Moves6Score
end
if Depth = 7 then
	add Code to Moves7
	add MoveScoreRes to Moves7Score
end
if Depth = 8 then
	add Code to Moves8
	add MoveScoreRes to Moves8Score
end
if Depth = 9 then
	add Code to Moves8
	add MoveScoreRes to Moves9Score
end
if Depth = 10 then
	add Code to Moves10
	add MoveScoreRes to Moves10Score
end
if Depth = 11 then
	delete Code of Moves11
	delete MoveScoreRes of Moves11Score
end
if Depth = 12 then
	delete Code of Moves12
	delete MoveScoreRes of Moves12Score
end
if Depth = 13 then
	delete Code of Moves13
	delete MoveScoreRes of Moves13Score
end
if Depth = 14 then
	delete Code of Moves14
	delete MoveScoreRes of Moves14Score
end
if Depth = 15 then
	delete Code of Moves15
	delete MoveScoreRes of Moves15Score
end

define-atomic InitKingSquare
delete all of KingPieceSquare
set KingSquareDef to "-55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55,-50, -50, -55, -60, -60, -55, -50, -50, -40, -40, -45, -50, -50, -45, -40, -40, -30, -30, -30, -35, -35, -30, -30, -30, -20, 0, 0, -10, -10, 0, 0, -20"
LoadList (KingSquareDef) "KingPieceSquare"

define-atomic Profile_MethodEnter (Id)
if IsProfilerEnabled > 0 then
	repeat until not length of Profile_Data < Id
		add "0" to Profile_Data
	end
	replace item Id of Profile_Data with item Id of Profile_Data - timer
end

define-atomic AddLineMove (SourceIdx arg) (Type) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
set Count to 1
set IdxOuter to item SourceIdx arg of MoveLookupLineIndexOffset
set InvIdxOuter to 8
repeat until Count > 32
	set TargetIdxOuter to -1
	if Type = LineMoveTypeStraight then
		set TargetIdxOuter to item (IdxOuter + Count) of MoveLookupStraight
	end
	if Type = LineMoveTypeCross then
		set TargetIdxOuter to item (IdxOuter + Count) of MoveLookupCross
	end
	set TargetPieceOuter to Empty
	if not TargetIdxOuter = -1 then
		if not CapturesOnly or <item SourceIdx arg of Board > 0 and item TargetIdxOuter of Board < 0> or <item SourceIdx arg of Board < 0 and item TargetIdxOuter of Board > 0> then
			AddMoveImpl (SourceIdx arg) (TargetIdxOuter) (Depth) <EmptyOK> <WhiteOK> <BlackOK> <CalcAttackState> <CapturesOnly>
		end
		set TargetPieceOuter to item TargetIdxOuter of Board
	end
	if TargetIdxOuter = -1 or not TargetPieceOuter = Empty then
		change Count by InvIdxOuter
		set InvIdxOuter to 8
	else
		change Count by 1
		change InvIdxOuter by -1
	end
end

define-atomic GetSEEMapVal (Piece)
set SEEMapValRes to 0
set CurrentPieceSub to abs of Piece
if CurrentPieceSub = BlackPawn then
	set SEEMapValRes to 100000
else
	if CurrentPieceSub = BlackKnight then
		set SEEMapValRes to 10000
	else
		if CurrentPieceSub = BlackBishop then
			set SEEMapValRes to 1000
		else
			if CurrentPieceSub = BlackRook then
				set SEEMapValRes to 100
			else
				if CurrentPieceSub = BlackQueen then
					set SEEMapValRes to 10
				else
					if CurrentPieceSub = BlackKing then
						set SEEMapValRes to 1
					end
				end
			end
		end
	end
end

define-atomic CalcBoardAttackedByMove (Depth)
ClearBoardAttackedByMove (Depth)
CalculateMovesImpl (Depth) <1 = 1> <1 = 0>

define-atomic HasSEEMapVal (MapVal) (Piece)
set HasSEEMapValRes to 0
set CurrentPieceSub to abs of Piece
if CurrentPieceSub = BlackPawn then
	if letter 6 of MapVal > 0 and not letter 6 of MapVal > 9 then
		set HasSEEMapValRes to 1
	end
else
	if CurrentPieceSub = BlackKnight then
		if letter 5 of MapVal > 0 and not letter 5 of MapVal > 9 then
			set HasSEEMapValRes to 1
		end
	else
		if CurrentPieceSub = BlackBishop then
			if letter 4 of MapVal > 0 and not letter 4 of MapVal > 9 then
				set HasSEEMapValRes to 1
			end
		else
			if CurrentPieceSub = BlackRook then
				if letter 3 of MapVal > 0 and not letter 3 of MapVal > 9 then
					set HasSEEMapValRes to 1
				end
			else
				if CurrentPieceSub = BlackQueen then
					if letter 2 of MapVal > 0 and not letter 2 of MapVal > 9 then
						set HasSEEMapValRes to 1
					end
				else
					if CurrentPieceSub = BlackKing then
						if letter 1 of MapVal > 0 and not letter 1 of MapVal > 9 then
							set HasSEEMapValRes to 1
						end
					end
				end
			end
		end
	end
end

define-atomic GetRepetitionCount
set Idx to length of BoardHistory - 1
set RepetitionCountRes to 1
repeat length of BoardHistory - 1
	if item Idx of BoardHistory = item last of BoardHistory then
		change RepetitionCountRes by 1
	end
	change Idx by -1
end

define-atomic ExportMovesPGN
set ExportMovesPGN to ""
set Idx to 1
repeat length of GameMovesAN
	if Idx mod 2 = 1 then
		set ExportMovesPGN to (join (ExportMovesPGN) join ((Idx - 1) / 2 + 1) ". ")
	end
	set ExportMovesPGN to (join (ExportMovesPGN) join (item Idx of GameMovesAN) " ")
	change Idx by 1
end

define UndoPrevMove
if length of GameMovesAN > 0 then
	GetSubstringRight (GameMoves) 4
	if item floor of (SubstringRes mod 100) of Board > 0 or SubstringRes = BlackKingsideCastling or SubstringRes = BlackQueensideCastling then
		set IsBlackMove to 1
	else
		set IsBlackMove to 0
	end
	set CurrentValue to item (length of BoardHistory - 1) of BoardHistory
	delete last of BoardHistory
	delete last of BoardHistory
	ImportBoardInternal (CurrentValue)
	if item last of GameMovesAN = "O-O" or item last of GameMovesAN = "O-O-O" then
		if IsBlackMove = 1 then
			set HasBlackCastled to 0
			set HasBlackKingMoved to 0
		else
			set HasWhiteCastled to 0
			set HasWhiteKingMoved to 0
		end
	end
	if letter 1 of item last of GameMovesAN = "K" then
		if IsBlackMove = 1 then
			set HasBlackKingMoved to 0
		else
			set HasWhiteKingMoved to 0
		end
		set Idx to length of GameMovesAN - 2
		repeat until Idx < 1
			if letter 1 of item Idx of GameMovesAN = "K" then
				if IsBlackMove = 1 then
					set HasBlackKingMoved to 1
				else
					set HasWhiteKingMoved to 0
				end
			end
			change Idx by -1
		end
	end
	delete last of GameMovesAN
	GetSubstringLeft (GameMoves) (length of GameMoves - 4)
	set GameMoves to SubstringRes
end

define-atomic InitPawnSquare
delete all of PawnPieceSquare
set PawnSquareDef to "0, 0, 0, 0, 0, 0, 0, 0, 7, 11, 23, 39, 39, 23, 11, 7,  -5, 1, 14, 29, 29, 14, 1, -5,  -14, -8, 6, 22, 22, 6, -8, -14,  -21, -16, -1, 14, 14, -1, -16, -21,  -26, -21, -6, 4, 4, -6, -21, -26,  -31, -26, -11, -1, -1, -11, -26, -31,  0, 0, 0, 0, 0, 0, 0, 0"
LoadList (PawnSquareDef) "PawnPieceSquare"

define-atomic Profile_IncCounter (Id)
if IsProfilerEnabled > 0 then
	repeat until not length of Profile_Data < Id
		add "0" to Profile_Data
	end
	replace item Id of Profile_Data with item Id of Profile_Data + 1
end

when I receive "UserMove"
ExecuteUserMove

define-atomic InitRookSquare
delete all of RookPieceSquare
set RookSquareDef to "-8, -6, 2, 7, 7, 2, -6, -8,2, 2, 7, 12, 12, 7, 2, 2, -8, -6, 6, 10, 10, 6, -6, -8, -8, -6, 6, 8, 8, 6, -6, -8, -8, -6, 6, 7, 7, 6, -6, -8, -8, -6, 6, 7, 7, 6, -6, -8, -8, -6, 2, 7, 7, 2, -6, -8, -8, -6, 2, 7, 7, 2, -6, -8"
LoadList (RookSquareDef) "RookPieceSquare"

define-atomic InitPawnSquareEndgame
delete all of PawnPieceSquareEndgame
set PawnSquareDefEndgame to " 100, 90, 80, 75, 75, 80, 90, 100,  65, 55, 45, 40, 40, 45, 55, 65,  35, 25, 15, 10, 10, 15, 25, 35,  20, 10, 0, -5, -5, 0, 10, 20,  10, 0, -10, -15, -15, -10, 0, 10,  5, -10, -20, -25, -25, -20, -10, 5,  5, -10, -20, -25, -25, -20, -10, 5,  0, 0, 0, 0, 0, 0, 0, 0"
LoadList (PawnSquareDefEndgame) "PawnPieceSquareEndgame"

define-atomic ClearLog
delete all of Logfile

define-atomic GetVirtualMove (Move)
if IsPlayerBlack = 0 then
	set VirtualMove to Move
else
	if not Move < "0100" and not Move > 6499 then
		set VirtualMove to 65 - floor of (Move mod 100)
		repeat until length of VirtualMove > 1
			set VirtualMove to (join "0" (VirtualMove))
		end
		set VirtualMove to (join (65 - floor of (Move / 100)) (VirtualMove))
		repeat until length of VirtualMove > 3
			set VirtualMove to (join "0" (VirtualMove))
		end
		if letter 5 of Move = "." then
			set VirtualMove to (join (VirtualMove) join (letter 5 of Move) (letter 6 of Move))
		end
	else
		if Move = BlackKingsideCastling then
			set VirtualMove to WhiteKingsideCastling
		else
			if Move = BlackQueensideCastling then
				set VirtualMove to WhiteQueensideCastling
			else
				if Move = WhiteKingsideCastling then
					set VirtualMove to BlackKingsideCastling
				else
					if Move = WhiteQueensideCastling then
						set VirtualMove to BlackQueensideCastling
					end
				end
			end
		end
	end
end

define-atomic InitQueenSquare
delete all of QueenPieceSquare
set QueenSquareDef to "4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,-6, -6, -1, 4, 4, -1, -6, -6, -16, -11, -1, 4, 4, -1, -11, -16, -26, -16, -6, 4, 4, -6, -16, -26"
LoadList (QueenSquareDef) "QueenPieceSquare"

when I receive "ProgressValueChangedInternal"
broadcast "ProgressValueChanged" and wait

when I receive "SquareClicked"
if IsExecutionRunning = 0 and IsGameSuspended = 0 then
	if MoveFromIdx = -1 then
		if item SquareClickedIdx of Board < 0 then
			set MoveFromIdx to SquareClickedIdx
			set FromSquareIdx to SquareClickedIdx
			broadcast "FromSquareSelected" and wait
		end
	else
		if MoveToIdx = -1 then
			set MoveToIdx to SquareClickedIdx
			set ToSquareIdx to SquareClickedIdx
			broadcast "ToSquareSelected" and wait
			broadcast "UserMove"
		else
			set MoveFromIdx to -1
			set MoveToIdx to -1
		end
	end
end

when I receive "LevelChanged"
if Level = 3 and IsModeJunior = 0 then
	SayAsync "Please note: Level \"Difficult\" has a think time of around 45 seconds. To the creator's knowledge, it is one of the strongest chess engines on Scratch." 5
else
	say ""
end

when I receive "StageClicked"
hide list ExportData
hide list ExportMoves
if IsExecutionRunning = 0 then
	say ""
end

when I receive "Undo"
UndoMove
say ""

when I receive "Import"
ask "Please paste FEN data or GoK data into the text field for import from your clipboard via Ctrl-V" and wait
if length of answer > 0 then
	ImportBoard (answer)
end

define-atomic ExportBoardFEN
set ExportDataFEN to ""
set ExportDataFENLichess to "https://lichess.org/analysis/"
set Idx to 1
repeat until Idx > 64
	if IsPlayerBlack = 0 then
		set CurrentPiece to item Idx of Board
	else
		set CurrentPiece to 0 - item (65 - Idx) of Board
	end
	if CurrentPiece = BlackPawn then
		set CurrentValue to "p"
	end
	if CurrentPiece = BlackKnight then
		set CurrentValue to "n"
	end
	if CurrentPiece = BlackBishop then
		set CurrentValue to "b"
	end
	if CurrentPiece = BlackRook then
		set CurrentValue to "r"
	end
	if CurrentPiece = BlackQueen then
		set CurrentValue to "q"
	end
	if CurrentPiece = BlackKing then
		set CurrentValue to "k"
	end
	if CurrentPiece = WhitePawn then
		set CurrentValue to "P"
	end
	if CurrentPiece = WhiteKnight then
		set CurrentValue to "N"
	end
	if CurrentPiece = WhiteBishop then
		set CurrentValue to "B"
	end
	if CurrentPiece = WhiteRook then
		set CurrentValue to "R"
	end
	if CurrentPiece = WhiteQueen then
		set CurrentValue to "Q"
	end
	if CurrentPiece = WhiteKing then
		set CurrentValue to "K"
	end
	if CurrentPiece = Empty then
		set IdxSub to Idx
		repeat until IdxSub mod 8 = 0 or <IsPlayerBlack = 0 and not item (IdxSub + 1) of Board = Empty> or <IsPlayerBlack = 1 and not item (65 - IdxSub + 1) of Board = Empty>
			change IdxSub by 1
		end
		set CurrentValue to IdxSub - Idx + 1
		change Idx by IdxSub - Idx
	end
	set ExportDataFEN to (join (ExportDataFEN) (CurrentValue))
	set ExportDataFENLichess to (join (ExportDataFENLichess) (CurrentValue))
	if Idx mod 8 = 0 and Idx < 64 then
		set ExportDataFEN to (join (ExportDataFEN) "/")
		set ExportDataFENLichess to (join (ExportDataFENLichess) "/")
	end
	change Idx by 1
end
if IsPlayerBlack = 0 then
	set ExportDataFEN to (join (ExportDataFEN) " w")
	set ExportDataFENLichess to (join (ExportDataFENLichess) "_w")
else
	set ExportDataFEN to (join (ExportDataFEN) " b")
	set ExportDataFENLichess to (join (ExportDataFENLichess) "_b")
end

when I receive "Export"
ExportBoardFEN
delete all of ExportData
add ExportDataFEN to ExportData
add ExportDataFENLichess to ExportData
add item last of BoardHistory to ExportData
show list ExportData
SayAsync "You can copy FEN data, lichess.org URL or GoK data to your clipboard via Ctrl-C" 5

if <> then
	...
end

(HasWhiteCastled)

(CurrentPiece)

when I receive "ShowMoves"
ExportMovesPGN
delete all of ExportMoves
add ExportMovesPGN to ExportMoves
show list ExportMoves
SayAsync "You can copy PGN data to your clipboard via Ctrl-C" 5

define-atomic InitKingSafety
delete all of PawnStormBlockedByKing
LoadList "0,0,0,0,0,0,0,0,-92,25,28,23,23,28,25,-92,-87,56,53,48,48,53,56,-87,24,16,17,22,22,17,16,24,16,5,11,6,6,11,5,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0," "PawnStormBlockedByKing"
delete all of PawnStormBlockedByPawn
LoadList "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,37,42,46,46,42,37,10,8,11,7,9,9,7,11,8,0,1,0,6,6,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0," "PawnStormBlockedByPawn"
delete all of PawnStormBlockedByNone
LoadList "0,0,0,0,0,0,0,0,30,27,21,30,30,21,27,30,54,61,45,53,53,45,61,54,19,11,17,20,20,17,11,19,13,5,10,12,12,10,5,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0," "PawnStormBlockedByNone"
delete all of PawnShelterKingCol
LoadList "-34,-38,-41,-24,-24,-41,-38,-34,0,0,0,0,0,0,0,0,-2,-14,-24,-14,-14,-24,-14,-2,-9,-35,-38,-23,-23,-38,-35,-9,-28,-37,-27,-31,-31,-27,-37,-28,-32,-38,-40,-34,-34,-40,-38,-32,-33,-40,-42,-37,-37,-42,-40,-33,0,0,0,0,0,0,0,0," "PawnShelterKingCol"
delete all of PawnShelterNeighborCol
LoadList "-31,-34,-39,-28,-28,-39,-34,-31,0,0,0,-2,-2,0,0,0,-6,-13,-27,-16,-16,-27,-13,-6,-16,-31,-36,-25,-25,-36,-31,-16,-29,-32,-25,-29,-29,-25,-32,-29,-31,-35,-37,-30,-30,-37,-35,-31,-32,-38,-39,-31,-31,-39,-38,-32,0,0,0,0,0,0,0,0," "PawnShelterNeighborCol"

(SourceIdx)

when I receive "StartGame"
set MoveFromIdx to -1
set MoveToIdx to -1
go to x: 240 y: 80
InitBoard
DrawBoardAndWait
if IsFlash30Bug = 0 then
	SayAsync "Please click a piece, then click a target field to move" 5
else
	SayAsync "Your browser is affacted by the Flash V30 performance bug. Adobe and MIT are working on a fix. See project comments for details. In the meantime please stay on level \"Easy\". Thank you for your understanding! Please click a piece, then click a target field to move." 15
end
ExecuteInit

when I receive "SayAsyncMsg"
say SayAsyncText for SayAsyncDuration secs

define SayAsync [Text] (Duration)
set SayAsyncText to Text
set SayAsyncDuration to Duration
broadcast "SayAsyncMsg"

define-atomic UpdateMoveHashPosScore (Piece) (SourceIdx arg) (TargetIdx arg) <PosScoreUpdate>
GetPosPieceHash (SourceIdx arg) (Piece)
set CurrentMoveHash to CurrentMoveHash - PosPieceHash
GetPosPieceHash (TargetIdx arg) (Piece)
set CurrentMoveHash to CurrentMoveHash + PosPieceHash
GetPosScore (Piece) (SourceIdx arg)
if PosScoreUpdate then
	replace item Depth of PosScoreDelta with item Depth of PosScoreDelta - PosScoreRes
else
	replace item Depth of PosScoreDelta with 0 - PosScoreRes
end
GetPosScore (Piece) (TargetIdx arg)
replace item Depth of PosScoreDelta with item Depth of PosScoreDelta + PosScoreRes

define-atomic IsValidMove (Move)
set ValidMoveRes to 1
if Move < 0 or Move > 9999 or <<floor of (Move / 100) = 0 or floor of (Move mod 100) = 0> and not <Move = BlackQueensideCastling or Move = BlackKingsideCastling or Move = WhiteQueensideCastling or Move = WhiteKingsideCastling>> then
	set ValidMoveRes to 0
end

define-atomic IsBlackKingCheckMate
set IsBlackKingCheckMateRes to 0
CalcBoardAttackedByMove 2
if IsBlackChecked = 1 then
	set IsBlackKingCheckMateRes to 1
	CalculateMoves 1
	replace item 1 of MovesIdx with "1"
	repeat item 1 of MovesCount
		if IsBlackKingCheckMateRes = 1 then
			ApplyMove 1
			CalcBoardAttackedByMove 2
			if IsBlackChecked = 0 then
				set IsBlackKingCheckMateRes to 0
			end
			RevertMove 1
		end
		replace item 1 of MovesIdx with item 1 of MovesIdx + 1
	end
end

define-atomic IsDraw (Depth)
CalcBoardAttackedByMove (Depth + 1)
if <Depth mod 2 = 1 and IsBlackChecked = 1> or <Depth mod 2 = 0 and IsWhiteChecked = 1> then
	set IsDrawRes to 0
	stop this script
end
set IsDrawRes to 1
CalculateMoves (Depth)
replace item Depth of MovesIdx with "1"
repeat item Depth of MovesCount
	if IsDrawRes = 1 then
		ApplyMove (Depth)
		CalcBoardAttackedByMove (Depth + 1)
		if <Depth mod 2 = 1 and IsBlackChecked = 0> or <Depth mod 2 = 0 and IsWhiteChecked = 0> then
			set IsDrawRes to 0
		end
		RevertMove (Depth)
	end
	replace item Depth of MovesIdx with item Depth of MovesIdx + 1
end

define-atomic IsWhiteKingCheckMate
set IsWhiteKingCheckMateRes to 0
CalcBoardAttackedByMove 1
if IsWhiteChecked = 1 then
	set IsWhiteKingCheckMateRes to 1
	CalculateMoves 2
	replace item 2 of MovesIdx with "1"
	repeat item 2 of MovesCount
		if IsWhiteKingCheckMateRes = 1 then
			ApplyMove 2
			CalcBoardAttackedByMove 1
			if IsWhiteChecked = 0 then
				set IsWhiteKingCheckMateRes to 0
			end
			RevertMove 2
		end
		replace item 2 of MovesIdx with item 2 of MovesIdx + 1
	end
end
