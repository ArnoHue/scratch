//----- Green flag events ---------------------------------------------------------------------------------------------

WhenGreenFlagClicked()
{
    If is compiled?
    {
        IsScratch3 = 0;
    }
    Else
    {
        IsScratch3 = 1;
    }
    List.DeleteAll(Logfile);
    List.Hide(Logfile);
    List.Hide(ExportData);
    List.Hide(ExportMoves);
}


//----- Key pressed events --------------------------------------------------------------------------------------------

WhenKeyPressed(k)
{
    List.Hide(Logfile);
}

WhenKeyPressed(l)
{
    List.Show(Logfile);
}

WhenKeyPressed(m)
{
    List.DeleteAll(Logfile);
}

WhenKeyPressed(p)
{
    If (IsModeProfiler == 0)
    {
        IsModeProfiler = 1;
        List.Show(Profile_Data);
        Variable.Show(IsProfilerEnabled);
    }
    Else
    {
        IsModeProfiler = 0;
        List.Hide(Profile_Data);
        Variable.Hide(IsProfilerEnabled);
    }
}

WhenKeyPressed(d)
{
    If (IsModeDeepeningDebug == 0)
    {
        IsModeDeepeningDebug = 1;
        Variable.Show(IdxDeepening);
        Variable.Show(BestMinMaxRes);
        Variable.Show(BestMove);
        Variable.Show(PruningAlphaWindow);
        Variable.Show(PruningBetaWindow);
    }
    Else
    {
        IsModeDeepeningDebug = 0;
        Variable.Hide(IdxDeepening);
        Variable.Hide(BestMinMaxRes);
        Variable.Hide(BestMove);
        Variable.Hide(PruningAlphaWindow);
        Variable.Hide(PruningBetaWindow);
    }
}

WhenKeyPressed(c)
{
    If (IsModeCompetition == 0)
    {
        IsModeCompetition = 1;
        Call SayAsync("Think time on Difficult set to 40 seconds")(5);
    }
    Else
    {
        IsModeCompetition = 0;
        Call SayAsync("Think time on Difficult set to 20/15 seconds")(5);
    }
}

WhenKeyPressed(j)
{
    If (Not ((Backdrop.GetNumberName(name) == "Intro")))
    {
        Call SwitchMode;
    }
}

WhenKeyPressed(v)
{
    Call SayAsync("Game of Kings Chess Version 3.93 (18.05.2022) by ArnoHu")(5);
}


//----- Broadcast received events -------------------------------------------------------------------------------------

WhenBroadcastReceived(evaluationvaluechangedinternal)
{
    Event.BroadcastAndWait("evaluationvaluechanged");
}

WhenBroadcastReceived(export)
{
    If (IsExecutionRunning == 0)
    {
        Call ExportBoardFEN;
        List.DeleteItem(ExportData, all);
        List.Add(ExportData, "DATA EXPORT");
        List.Add(ExportData, "Select data row by triple-clicking. You can then copy to");
        List.Add(ExportData, "clipboard by right-click / Copy or by pressing Ctrl-C.");
        List.Add(ExportData, "");
        List.Add(ExportData, "PGN (Game Protocol):");
        Call ExportMovesPGN;
        List.Add(ExportData, ExportMovesPGN);
        List.Add(ExportData, "");
        List.Add(ExportData, "FEN (Current Board):");
        List.Add(ExportData, ExportDataFEN);
        List.Add(ExportData, "");
        List.Add(ExportData, "Board Analysis Link (lichess.org)");
        List.Add(ExportData, ExportDataFENLichess);
        List.Show(ExportData);
        If (1 == 0)
        {
            Call SayAsync("You can copy FEN data, lichess.org URL or PGN data to your clipboard via Ctrl-C. Select data by triple-click.")(5);
        }
    }
}

WhenBroadcastReceived(fromsquareselected)
{
    If ((IsModeJunior == 1) And (Not ((FromSquareIdx == -1))))
    {
        BestMoveFromIdx = FromSquareIdx;
        List.DeleteAll(UserMoveTargets);
        Call CalculateMoves(2);
        List.ReplaceItem(MovesIdx, 2, 1);
        IdxOuter2 = 1;
        Repeat (MovesCount[2])
        {
            Call GetCurrentMove(2);
            If (floor((CurrentMove / 100)) == FromSquareIdx)
            {
                Call ApplyMove(2);
                Call CalcBoardAttackedByMove(3);
                Call RevertMove(2);
                If (IsWhiteChecked == 0)
                {
                    List.Add(UserMoveTargets, floor((CurrentMove % 100)));
                }
            }
            Else
            {
                If (Board[FromSquareIdx] == WhiteKing)
                {
                    If (CurrentMove == WhiteKingsideCastling)
                    {
                        List.Add(UserMoveTargets, VirtualBoard[63]);
                    }
                    Else
                    {
                        If (CurrentMove == WhiteQueensideCastling)
                        {
                            List.Add(UserMoveTargets, VirtualBoard[59]);
                        }
                    }
                }
            }
            List.ReplaceItem(MovesIdx, 2, (MovesIdx[2] + 1));
        }
        Call DrawBoardAndWait;
        Event.BroadcastAndWait("StampUserMoveTargets");
    }
}

WhenBroadcastReceived(import)
{
    If (IsExecutionRunning == 0)
    {
        Sensing.Ask("Board data import. Please paste FEN data from your clipboard into the text field by pressing Ctrl-V.");
        If (Variable.Length(Sensing.Answer()) > 0)
        {
            Call ImportBoard(Sensing.Answer());
        }
    }
}

WhenBroadcastReceived(progressvaluechangedinternal)
{
    Event.BroadcastAndWait("progressvaluechanged");
}

WhenBroadcastReceived(sayasyncmsg)
{
    Looks.Say(SayAsyncText, SayAsyncDuration);
}

WhenBroadcastReceived(showmoves)
{
    Call ExportMovesPGN;
    List.DeleteItem(ExportMoves, all);
    List.Add(ExportMoves, ExportMovesPGN);
    List.Show(ExportMoves);
    Call SayAsync("You can copy PGN data to your clipboard via Ctrl-C")(5);
}

WhenBroadcastReceived(squareclicked)
{
    If ((IsExecutionRunning == 0) And (IsGameSuspended == 0))
    {
        If (Board[SquareClickedIdx] < 0)
        {
            MoveFromIdx = SquareClickedIdx;
            FromSquareIdx = SquareClickedIdx;
            Event.BroadcastAndWait("fromsquareselected");
        }
        Else
        {
            If ((Not ((MoveFromIdx == -1))) And (Not ((FromSquareIdx == -1))))
            {
                MoveToIdx = SquareClickedIdx;
                ToSquareIdx = SquareClickedIdx;
                Event.BroadcastAndWait("tosquareselected");
                Event.Broadcast("usermove");
            }
        }
    }
}

WhenBroadcastReceived(stageclicked)
{
    List.Hide(ExportData);
    List.Hide(ExportMoves);
    If (IsExecutionRunning == 0)
    {
        Looks.Say("");
    }
}

WhenBroadcastReceived(startgame)
{
    Event.Broadcast("calcmode");
    IsModeJunior = 0;
    IsModeProfiler = 0;
    IsModeDeepeningDebug = 0;
    IsModeCompetition = 0;
    MoveFromIdx = -1;
    MoveToIdx = -1;
    ProgressValue = 0;
    EvaluationValue = 0;
    Motion.GoToXY(240, 80);
    Call InitBoard;
    Call DrawBoardAndWait;
    Call ExecuteInit;
    Event.Broadcast("inputmode");
}

WhenBroadcastReceived(switchmode)
{
    If (IsExecutionRunning == 0)
    {
        Call SwitchMode;
    }
}

WhenBroadcastReceived(triggerrestart)
{
    Looks.Say("");
}

WhenBroadcastReceived(undo)
{
    If (IsExecutionRunning == 0)
    {
        Call UndoMove;
        Call OnEvaluationChanged(0);
        Looks.Say("");
    }
}

WhenBroadcastReceived(usermove)
{
    Call ExecuteUserMove;
}


//----- Custom blocks -------------------------------------------------------------------------------------------------

Define AddBoardToHistory (warp=true)
{
    Call GetBoardString;
    List.Add(BoardHistory, GetBoardStringRes);
    Call GetCurrentBoardHash;
    List.Add(BoardHistoryHash, CurrentBoardHash);
}

Define AddLineMove(string SourceIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool LineMoveTypeStraight) (warp=true)
{
    SourcePieceOuter = Board[SourceIdx];
    IdxOuter = MoveLookupLineIndexOffset[SourceIdx];
    Count = 1;
    InvIdxOuter = 8;
    If CalcAttackState
    {
        List.DeleteAll(KingAttackLinesTemp);
    }
    Repeat Until (Count > 32)
    {
        If LineMoveTypeStraight
        {
            TargetIdxOuter = MoveLookupStraight[(IdxOuter + Count)];
        }
        Else
        {
            TargetIdxOuter = MoveLookupCross[(IdxOuter + Count)];
        }
        If (TargetIdxOuter == -1)
        {
            Count += InvIdxOuter;
            InvIdxOuter = 8;
            If CalcAttackState
            {
                List.DeleteAll(KingAttackLinesTemp);
            }
        }
        Else
        {
            If (Board[TargetIdxOuter] == 0)
            {
                If CapturesOnly
                {
                    If (Operator.LetterOf(CheckedStateAttackLines[Depth], TargetIdxOuter) == 1)
                    {
                        Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly);
                    }
                    Else
                    {
                        Call IsQuiescentCheck(SourcePieceOuter)(TargetIdxOuter)(Depth);
                        If (IsQuiescentCheckRes == 1)
                        {
                            Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly);
                            List.ReplaceItem(CalcMovesScoreList, List.Length(CalcMovesScoreList), "*");
                        }
                    }
                }
                Else
                {
                    Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly);
                    If CalcAttackState
                    {
                        List.Add(KingAttackLinesTemp, TargetIdxOuter);
                    }
                }
                Count += 1;
                InvIdxOuter += -1;
            }
            Else
            {
                If CalcAttackState
                {
                    Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly);
                    IsXRay = 0;
                    TargetPieceOuter = Board[TargetIdxOuter];
                    If (SourcePieceOuter > 0)
                    {
                        If (TargetPieceOuter > BlackPawn)
                        {
                            If LineMoveTypeStraight
                            {
                                If ((TargetPieceOuter == BlackQueen) Or (TargetPieceOuter == BlackRook))
                                {
                                    IsXRay = 1;
                                }
                            }
                            Else
                            {
                                If ((TargetPieceOuter == BlackQueen) Or (TargetPieceOuter == BlackBishop))
                                {
                                    IsXRay = 1;
                                }
                            }
                        }
                        Else
                        {
                            If (TargetPieceOuter == WhiteKing)
                            {
                                Idx = 1;
                                Repeat (List.Length(KingAttackLinesTemp))
                                {
                                    List.Add(KingAttackLines, KingAttackLinesTemp[Idx]);
                                    Idx += 1;
                                }
                            }
                        }
                    }
                    Else
                    {
                        If (TargetPieceOuter < WhitePawn)
                        {
                            If LineMoveTypeStraight
                            {
                                If ((TargetPieceOuter == WhiteQueen) Or (TargetPieceOuter == WhiteRook))
                                {
                                    IsXRay = 1;
                                }
                            }
                            Else
                            {
                                If ((TargetPieceOuter == WhiteQueen) Or (TargetPieceOuter == WhiteBishop))
                                {
                                    IsXRay = 1;
                                }
                            }
                        }
                        Else
                        {
                            If (TargetPieceOuter == BlackKing)
                            {
                                Idx = 1;
                                Repeat (List.Length(KingAttackLinesTemp))
                                {
                                    List.Add(KingAttackLines, KingAttackLinesTemp[Idx]);
                                    Idx += 1;
                                }
                            }
                        }
                    }
                    If (IsXRay == 1)
                    {
                        Count += 1;
                        InvIdxOuter += -1;
                    }
                    Else
                    {
                        Count += InvIdxOuter;
                        InvIdxOuter = 8;
                    }
                    List.DeleteAll(KingAttackLinesTemp);
                }
                Else
                {
                    If (SourcePieceOuter > 0)
                    {
                        If (Board[TargetIdxOuter] < 0)
                        {
                            Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly);
                        }
                    }
                    Else
                    {
                        If (Board[TargetIdxOuter] > 0)
                        {
                            Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly);
                        }
                    }
                    Count += InvIdxOuter;
                    InvIdxOuter = 8;
                }
            }
        }
    }
}

Define AddLookupMove(string SourceIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool LookupMoveTypeKing) (warp=true)
{
    SourcePieceOuter = Board[SourceIdx];
    IdxOuter = MoveLookupIndexOffset[SourceIdx];
    Count = 1;
    Repeat (8)
    {
        If LookupMoveTypeKing
        {
            TargetIdxOuter = MoveLookupKing[(IdxOuter + Count)];
        }
        Else
        {
            TargetIdxOuter = MoveLookupKnight[(IdxOuter + Count)];
        }
        If (TargetIdxOuter == -1)
        {
            Stop(this script);
        }
        If CalcAttackState
        {
            Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
        }
        Else
        {
            If (Board[TargetIdxOuter] == 0)
            {
                If (Not (CapturesOnly))
                {
                    Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                }
                Else
                {
                    If LookupMoveTypeKing
                    {
                        If (CheckedState[Depth] == 1)
                        {
                            Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                        }
                    }
                    Else
                    {
                        If (Operator.LetterOf(CheckedStateAttackLines[Depth], TargetIdxOuter) == 1)
                        {
                            Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                        }
                        Else
                        {
                            Call IsQuiescentCheck(SourcePieceOuter)(TargetIdxOuter)(Depth);
                            If (IsQuiescentCheckRes == 1)
                            {
                                Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                                List.ReplaceItem(CalcMovesScoreList, List.Length(CalcMovesScoreList), "*");
                            }
                        }
                    }
                }
            }
            Else
            {
                If (SourcePieceOuter > 0)
                {
                    If (Board[TargetIdxOuter] < 0)
                    {
                        Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                    }
                }
                Else
                {
                    If (Board[TargetIdxOuter] > 0)
                    {
                        Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                    }
                }
            }
        }
        Count += 1;
    }
}

Define AddMoveImpl(string SourceIdx)(string TargetIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    If CalcAttackState
    {
        If (Board[SourceIdx] > 0)
        {
            List.ReplaceItem(BoardAttackedByBlack, TargetIdx, (BoardAttackedByBlack[TargetIdx] + 1));
            If ((BoardAttackedByBlackPiece[TargetIdx] == 0) Or (BoardAttackedByBlackPiece[TargetIdx] > Board[SourceIdx]))
            {
                List.ReplaceItem(BoardAttackedByBlackPiece, TargetIdx, Board[SourceIdx]);
            }
            If (Board[TargetIdx] == WhiteKing)
            {
                IsWhiteChecked = 1;
            }
        }
        Else
        {
            List.ReplaceItem(BoardAttackedByWhite, TargetIdx, (BoardAttackedByWhite[TargetIdx] + 1));
            If ((BoardAttackedByWhitePiece[TargetIdx] == 0) Or (BoardAttackedByWhitePiece[TargetIdx] < Board[SourceIdx]))
            {
                List.ReplaceItem(BoardAttackedByWhitePiece, TargetIdx, Board[SourceIdx]);
            }
            If (Board[TargetIdx] == BlackKing)
            {
                IsBlackChecked = 1;
            }
        }
    }
    Else
    {
        If (SourceIdx < 10)
        {
            CurrentMove = Operator.Join(0, ((SourceIdx * 100) + TargetIdx));
        }
        Else
        {
            CurrentMove = ((SourceIdx * 100) + TargetIdx);
        }
        If (abs(Board[SourceIdx]) == BlackPawn)
        {
            If ((IdxToRank[TargetIdx] == 1) Or (IdxToRank[TargetIdx] == 8))
            {
                List.ReplaceItem(PawnPromotionFile, Depth, IdxToFile[TargetIdx]);
                Call AddSpecialMove(Operator.Join(CurrentMove, .1))(Depth);
                Call AddSpecialMove(Operator.Join(CurrentMove, .2))(Depth);
                Call AddSpecialMove(Operator.Join(CurrentMove, .3))(Depth);
                Call AddSpecialMove(Operator.Join(CurrentMove, .4))(Depth);
                Stop(this script);
            }
        }
        Else
        {
            If (Not (CapturesOnly))
            {
                If ((Depth % 2) == 1)
                {
                    If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], TargetIdx) == 0)
                    {
                        List.ReplaceItem(PieceMobility, SourceIdx, (PieceMobility[SourceIdx] + 1));
                    }
                }
                Else
                {
                    If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], TargetIdx) == 0)
                    {
                        List.ReplaceItem(PieceMobility, SourceIdx, (PieceMobility[SourceIdx] + 1));
                    }
                }
            }
        }
        Call GetMoveScore(Board[SourceIdx])(Board[TargetIdx])(SourceIdx)(TargetIdx)(CurrentMove)(Depth)(CapturesOnly);
        List.Add(CalcMovesMoveList, CurrentMove);
        List.Add(CalcMovesScoreList, MoveScoreRes);
    }
}

Define AddMoveImplLookup(string SourceIdx)(string TargetIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool IsKing) (warp=true)
{
    If IsKing
    {
        If (Not (CalcAttackState))
        {
            If (BoardAttackedCalculated[Depth] == 0)
            {
                CalculateMovesRequiresAttackRecalc = 1;
                Stop(this script);
            }
            If ((Depth % 2) == 1)
            {
                If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], TargetIdx) > 0)
                {
                    Stop(this script);
                }
            }
            Else
            {
                If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], TargetIdx) > 0)
                {
                    Stop(this script);
                }
            }
        }
    }
    Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)(CalcAttackState)(CapturesOnly);
}

Define AddMoveToList(string Move)(string Score)(string Depth) (warp=true)
{
    If (Depth < 6)
    {
        If (Depth == 5)
        {
            List.Add(Moves5, Move);
            List.Add(Moves5Score, Score);
            List.ReplaceItem(MovesCount, 5, List.Length(Moves5));
        }
        Else
        {
            If (Depth == 4)
            {
                List.Add(Moves4, Move);
                List.Add(Moves4Score, Score);
                List.ReplaceItem(MovesCount, 4, List.Length(Moves4));
            }
            Else
            {
                If (Depth == 3)
                {
                    List.Add(Moves3, Move);
                    List.Add(Moves3Score, Score);
                    List.ReplaceItem(MovesCount, 3, List.Length(Moves3));
                }
                Else
                {
                    If (Depth == 2)
                    {
                        List.Add(Moves2, Move);
                        List.Add(Moves2Score, Score);
                        List.ReplaceItem(MovesCount, 2, List.Length(Moves2));
                    }
                    Else
                    {
                        If (Depth == 1)
                        {
                            List.Add(Moves1, Move);
                            List.Add(Moves1Score, Score);
                            List.ReplaceItem(MovesCount, 1, List.Length(Moves1));
                        }
                    }
                }
            }
        }
    }
    Else
    {
        If (Depth < 11)
        {
            If (Depth == 6)
            {
                List.Add(Moves6, Move);
                List.Add(Moves6Score, Score);
                List.ReplaceItem(MovesCount, 6, List.Length(Moves6));
            }
            Else
            {
                If (Depth == 7)
                {
                    List.Add(Moves7, Move);
                    List.Add(Moves7Score, Score);
                    List.ReplaceItem(MovesCount, 7, List.Length(Moves7));
                }
                Else
                {
                    If (Depth == 8)
                    {
                        List.Add(Moves8, Move);
                        List.Add(Moves8Score, Score);
                        List.ReplaceItem(MovesCount, 8, List.Length(Moves8));
                    }
                    Else
                    {
                        If (Depth == 9)
                        {
                            List.Add(Moves9, Move);
                            List.Add(Moves9Score, Score);
                            List.ReplaceItem(MovesCount, 9, List.Length(Moves9));
                        }
                        Else
                        {
                            If (Depth == 10)
                            {
                                List.Add(Moves10, Move);
                                List.Add(Moves10Score, Score);
                                List.ReplaceItem(MovesCount, 10, List.Length(Moves10));
                            }
                        }
                    }
                }
            }
        }
        Else
        {
            If (Depth < 16)
            {
                If (Depth == 11)
                {
                    List.Add(Moves11, Move);
                    List.Add(Moves11Score, Score);
                    List.ReplaceItem(MovesCount, 11, List.Length(Moves11));
                }
                Else
                {
                    If (Depth == 12)
                    {
                        List.Add(Moves12, Move);
                        List.Add(Moves12Score, Score);
                        List.ReplaceItem(MovesCount, 12, List.Length(Moves12));
                    }
                    Else
                    {
                        If (Depth == 13)
                        {
                            List.Add(Moves13, Move);
                            List.Add(Moves13Score, Score);
                            List.ReplaceItem(MovesCount, 13, List.Length(Moves13));
                        }
                        Else
                        {
                            If (Depth == 14)
                            {
                                List.Add(Moves14, Move);
                                List.Add(Moves14Score, Score);
                                List.ReplaceItem(MovesCount, 14, List.Length(Moves14));
                            }
                            Else
                            {
                                If (Depth == 15)
                                {
                                    List.Add(Moves15, Move);
                                    List.Add(Moves15Score, Score);
                                    List.ReplaceItem(MovesCount, 15, List.Length(Moves15));
                                }
                            }
                        }
                    }
                }
            }
            Else
            {
                If (Depth == 16)
                {
                    List.Add(Moves16, Move);
                    List.Add(Moves16Score, Score);
                    List.ReplaceItem(MovesCount, 16, List.Length(Moves16));
                }
                Else
                {
                    If (Depth == 17)
                    {
                        List.Add(Moves17, Move);
                        List.Add(Moves17Score, Score);
                        List.ReplaceItem(MovesCount, 17, List.Length(Moves17));
                    }
                    Else
                    {
                        If (Depth == 18)
                        {
                            List.Add(Moves18, Move);
                            List.Add(Moves18Score, Score);
                            List.ReplaceItem(MovesCount, 18, List.Length(Moves18));
                        }
                        Else
                        {
                            If (Depth == 19)
                            {
                                List.Add(Moves19, Move);
                                List.Add(Moves19Score, Score);
                                List.ReplaceItem(MovesCount, 19, List.Length(Moves19));
                            }
                            Else
                            {
                                If (Depth == 20)
                                {
                                    List.Add(Moves20, Move);
                                    List.Add(Moves20Score, Score);
                                    List.ReplaceItem(MovesCount, 20, List.Length(Moves20));
                                }
                                Else
                                {
                                    If (Depth == 21)
                                    {
                                        List.Add(Moves21, Move);
                                        List.Add(Moves21Score, Score);
                                        List.ReplaceItem(MovesCount, 21, List.Length(Moves21));
                                    }
                                    Else
                                    {
                                        If (Depth == 22)
                                        {
                                            List.Add(Moves22, Move);
                                            List.Add(Moves22Score, Score);
                                            List.ReplaceItem(MovesCount, 22, List.Length(Moves22));
                                        }
                                        Else
                                        {
                                            If (Depth == 23)
                                            {
                                                List.Add(Moves23, Move);
                                                List.Add(Moves23Score, Score);
                                                List.ReplaceItem(MovesCount, 23, List.Length(Moves23));
                                            }
                                            Else
                                            {
                                                If (Depth == 24)
                                                {
                                                    List.Add(Moves24, Move);
                                                    List.Add(Moves24Score, Score);
                                                    List.ReplaceItem(MovesCount, 24, List.Length(Moves24));
                                                }
                                                Else
                                                {
                                                    If (Depth == 25)
                                                    {
                                                        List.Add(Moves25, Move);
                                                        List.Add(Moves25Score, Score);
                                                        List.ReplaceItem(MovesCount, 25, List.Length(Moves25));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

Define AddPossibleEnPassantImpl(string SourceIdx)(string Dir)(string Depth) (warp=true)
{
    Call GetTargetIdx(SourceIdx)(Dir)(0);
    If (Not ((GetTargetIdxRes == -1)))
    {
        If ((((Depth % 2) == 1) And (Board[GetTargetIdxRes] == WhitePawn)) Or (((Depth % 2) == 0) And (Board[GetTargetIdxRes] == BlackPawn)))
        {
            IsEnPassantAllowed = 0;
            If ((Depth % 2) == 1)
            {
                EnPassantPrevMove = Operator.Join((GetTargetIdxRes + 16), GetTargetIdxRes);
            }
            Else
            {
                EnPassantPrevMove = Operator.Join((GetTargetIdxRes - 16), GetTargetIdxRes);
            }
            If (Depth == 1)
            {
                Call GetSubstringRight(GameMoves)(4);
                If (SubstringRes == EnPassantPrevMove)
                {
                    IsEnPassantAllowed = 1;
                }
            }
            Else
            {
                If (Depth == 2)
                {
                    Call GetSubstringRight(GameMoves)(4);
                    If ((SubstringRes == EnPassantPrevMove) Or (Moves1[MovesIdx[1]] == EnPassantPrevMove))
                    {
                        IsEnPassantAllowed = 1;
                    }
                }
                Else
                {
                    Call GetCurrentMove((Depth - 1));
                    If (CurrentMove == EnPassantPrevMove)
                    {
                        IsEnPassantAllowed = 1;
                    }
                }
            }
            If (IsEnPassantAllowed == 1)
            {
                If ((Depth % 2) == 1)
                {
                    Call AddSpecialMove(Operator.Join(SourceIdx, (GetTargetIdxRes + 8)))(Depth);
                }
                Else
                {
                    Call AddSpecialMove(Operator.Join(SourceIdx, (GetTargetIdxRes - 8)))(Depth);
                }
            }
        }
    }
}

Define AddSpecialMove(string Move)(string Depth) (warp=true)
{
    Call GetSpecialMoveScore(Move)(Depth);
    List.Add(CalcMovesMoveList, Move);
    List.Add(CalcMovesScoreList, MoveScoreRes);
}

Define AlphaBetaMinMax(string Alpha)(string Beta)(string MinDepth)(string MaxDepth)(bool InitialDeepening)(string QuiescenceDepth)(bool ShowProgress) (warp=true)
{
    Call OnScoreCalc(0)(MinDepth)((MaxDepth - 1))((1 == 0));
    List.ReplaceItem(Alphas, MinDepth, Alpha);
    List.ReplaceItem(Betas, MinDepth, Beta);
    Call AlphaBetaMinMaxImpl(MinDepth)(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)((1 == 0))((1 == 0))(ShowProgress);
}

Define AlphaBetaMinMaxImpl(string Depth)(string MinDepth)(string MaxDepth)(bool InitialDeepening)(string QuiescenceDepth)(bool Quiescence)(bool PrevQuiescence)(bool ShowProgress) (warp=true)
{
    List.ReplaceItem(MinMaxResults, Depth, "");
    List.ReplaceItem(BestMoves, Depth, "");
    If (IsMinMaxTimeout == 1)
    {
        Stop(this script);
    }
    If Quiescence
    {
        List.ReplaceItem(Quiescence, Depth, 1);
    }
    Else
    {
        List.ReplaceItem(Quiescence, Depth, 0);
    }
    List.ReplaceItem(PawnPromotionFile, Depth, "");
    If (Depth > 1)
    {
        If (TargetPieces[(Depth - 1)] == WhiteKing)
        {
            List.ReplaceItem(MinMaxResults, Depth, (100000 - (Depth * 1000)));
            Stop(this script);
        }
        Else
        {
            If (TargetPieces[(Depth - 1)] == BlackKing)
            {
                List.ReplaceItem(MinMaxResults, Depth, (-100000 + (Depth * 1000)));
                Stop(this script);
            }
        }
    }
    If ((MinDepth == 1) And (Depth > 1))
    {
        If ((Depth == 2) Or (CheckedState[(Depth - 1)] == 1))
        {
            Call CalcBoardAttackedByMoveChecked(Depth);
            If ((Depth % 2) == 1)
            {
                If (IsWhiteChecked == 1)
                {
                    List.ReplaceItem(MinMaxResults, Depth, (100000 - (Depth * 1000)));
                    Stop(this script);
                }
            }
            Else
            {
                If (IsBlackChecked == 1)
                {
                    List.ReplaceItem(MinMaxResults, Depth, (-100000 + (Depth * 1000)));
                    Stop(this script);
                }
            }
        }
    }
    If (Depth == MaxDepth)
    {
        Call OnScoreCalc((Depth - 1))(MinDepth)((MaxDepth - 1))(PrevQuiescence);
        List.ReplaceItem(MinMaxResults, Depth, ScoreCalcRes);
        Stop(this script);
    }
    If Quiescence
    {
        Call OnScoreCalc((Depth - 1))(MinDepth)((Depth - 1))(PrevQuiescence);
        If (PutsInCheck[(Depth - 1)] == 0)
        {
            List.ReplaceItem(MinMaxResults, Depth, ScoreCalcRes);
            If ((Depth % 2) == 1)
            {
                If (Not ((ScoreCalcRes < Betas[Depth])))
                {
                    List.ReplaceItem(MinMaxResults, Depth, Betas[Depth]);
                    Stop(this script);
                }
                If (ScoreCalcRes > Alphas[Depth])
                {
                    List.ReplaceItem(Alphas, Depth, ScoreCalcRes);
                }
            }
            Else
            {
                If (Not ((ScoreCalcRes > Alphas[Depth])))
                {
                    List.ReplaceItem(MinMaxResults, Depth, Alphas[Depth]);
                    Stop(this script);
                }
                If (ScoreCalcRes < Betas[Depth])
                {
                    List.ReplaceItem(Betas, Depth, ScoreCalcRes);
                }
            }
        }
        Else
        {
            If ((Depth % 2) == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, (-100000 + (Depth * 1000)));
            }
            Else
            {
                List.ReplaceItem(MinMaxResults, Depth, (100000 - (Depth * 1000)));
            }
        }
    }
    Else
    {
        Call OnScoreCalc((Depth - 1))(MinDepth)((MaxDepth - 1))(PrevQuiescence);
    }
    List.ReplaceItem(AlphasOld, Depth, Alphas[Depth]);
    List.ReplaceItem(BetasOld, Depth, Betas[Depth]);
    List.ReplaceItem(PutsInCheck, Depth, 0);
    If (Depth == 1)
    {
        Call InitAlphaBeta(Depth)(MaxDepth)(InitialDeepening);
        Call CalcBoardAttackedByMove(1);
        Call StoreAttackInfo(1)(1);
        Call CalcBoardAttackedByMove(2);
        Call StoreAttackInfo(2)(1);
        List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
        Call CalculateMovesImplWrapper(1)((1 == 0))((1 == 0));
        Call CalculateMovesImplWrapper(2)((1 == 0))((1 == 0));
        List.ReplaceItem(WhiteMobBonus, 1, WhiteMobBonus[2]);
    }
    Else
    {
        List.ReplaceItem(BoardAttackedByBlackSnapshot, Depth, BoardAttackedByBlackSnapshot[(Depth - 1)]);
        List.ReplaceItem(BoardAttackedByBlackPieceSnapshot, Depth, BoardAttackedByBlackPieceSnapshot[(Depth - 1)]);
        List.ReplaceItem(BoardAttackedByWhiteSnapshot, Depth, BoardAttackedByWhiteSnapshot[(Depth - 1)]);
        List.ReplaceItem(BoardAttackedByWhitePieceSnapshot, Depth, BoardAttackedByWhitePieceSnapshot[(Depth - 1)]);
        List.ReplaceItem(BoardAttackedCalculated, Depth, 0);
        List.ReplaceItem(CheckedState, Depth, PutsInCheck[(Depth - 1)]);
        List.ReplaceItem(CheckedStateAttackLines, Depth, "");
        List.ReplaceItem(BlackMobBonus, Depth, BlackMobBonus[(Depth - 1)]);
        List.ReplaceItem(WhiteMobBonus, Depth, WhiteMobBonus[(Depth - 1)]);
    }
    If (Depth > 1)
    {
        If ((Not (PrevQuiescence)) And (IsEndgame == 1))
        {
            Call IsDrawByMaterial;
            If (IsDrawRes == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, 0);
                Stop(this script);
            }
        }
        If (((Not (PrevQuiescence)) And ((Depth == 2) Or (Depth == 3))) And (IsEndgame2 == 1))
        {
            Call IsDrawByStalemate(Depth);
            If (IsDrawRes == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, 0);
                Stop(this script);
            }
        }
        If ((IsInNullMove == 0) And ((TargetPieces[(Depth - 1)] == 0) And ((Not (PrevQuiescence)) Or (TargetPieces[(Depth - 2)] == 0))))
        {
            Count = 1;
            Idx = (Depth - 2);
            Repeat Until (Idx < 1)
            {
                If (CurrentBoardHash == PreviousBoardHash[Idx])
                {
                    Count += 1;
                }
                Idx += -2;
            }
            Idx = ((List.Length(BoardHistoryHash) - 1) + (Depth % 2));
            Repeat Until (Idx < 1)
            {
                If (CurrentBoardHash == BoardHistoryHash[Idx])
                {
                    Count += 1;
                }
                Idx += -2;
            }
            If (Count > 2)
            {
                List.ReplaceItem(MinMaxResults, Depth, 0);
                Stop(this script);
            }
        }
        If (IsEndgame == 1)
        {
            If (Not (PrevQuiescence))
            {
                If (((WhiteQueenCount + WhiteMinorCount) == 0) And ((BlackQueenCount + BlackMinorCount) == 0))
                {
                    If ((BlackPawnCount + WhitePawnCount) == 1)
                    {
                        Idx = 1;
                        Repeat (64)
                        {
                            If ((Board[Idx] == WhitePawn) And (((Depth % 2) == 0) And (IdxToRank[Idx] > 2)))
                            {
                                If ((IdxToFile[Idx] == 1) Or (IdxToFile[Idx] == 8))
                                {
                                    If ((IdxToFile[Idx] == IdxToFile[BlackKingIdx]) And (IdxToRank[BlackKingIdx] < IdxToRank[Idx]))
                                    {
                                        List.ReplaceItem(MinMaxResults, Depth, 0);
                                        Stop(this script);
                                    }
                                }
                                Else
                                {
                                    If ((Board[(Idx - 8)] == BlackKing) Or (Board[(Idx - 16)] == BlackKing))
                                    {
                                        If (((Depth % 2) == 1) Or ((Not ((Board[(Idx - 1)] == WhiteKing))) And (Not ((Board[(Idx + 1)] == WhiteKing)))))
                                        {
                                            List.ReplaceItem(MinMaxResults, Depth, 0);
                                            Stop(this script);
                                        }
                                    }
                                }
                            }
                            Else
                            {
                                If ((Board[Idx] == BlackPawn) And (((Depth % 2) == 1) And (IdxToRank[Idx] < 7)))
                                {
                                    If ((IdxToFile[Idx] == 1) Or (IdxToFile[Idx] == 8))
                                    {
                                        If ((IdxToFile[Idx] == IdxToFile[WhiteKingIdx]) And (IdxToRank[WhiteKingIdx] > IdxToRank[Idx]))
                                        {
                                            List.ReplaceItem(MinMaxResults, Depth, 0);
                                            Stop(this script);
                                        }
                                    }
                                    Else
                                    {
                                        If ((Board[(Idx + 8)] == WhiteKing) Or (Board[(Idx + 16)] == WhiteKing))
                                        {
                                            If (((Depth % 2) == 0) Or ((Not ((Board[(Idx - 1)] == BlackKing))) And (Not ((Board[(Idx + 1)] == BlackKing)))))
                                            {
                                                List.ReplaceItem(MinMaxResults, Depth, 0);
                                                Stop(this script);
                                            }
                                        }
                                    }
                                }
                            }
                            Idx += 1;
                        }
                    }
                }
            }
        }
    }
    If ((Depth > 1) And (Not (List.ContainsItem(BoardHistoryHash, CurrentBoardHash))))
    {
        Call TTProbeNode(CurrentBoardHash)(Depth);
        If (TTProbeRes == 1)
        {
            If ((((Not ((TTProbeNodeScoreRes == ""))) And (Not ((TTProbeNodeScoreRes == 0)))) And (Not ((abs(TTProbeNodeScoreRes) > (BlackKing / 2))))) And ((((Not (Quiescence)) And (Not ((TTProbeHorizonRes == -1)))) And (Not ((TTProbeHorizonRes < (MaxDepth - Depth))))) Or (Quiescence And (TTProbeHorizonRes == -1))))
            {
                If ((TTProbeNodeTypeRes == "E") Or (((TTProbeNodeTypeRes == "A") And (Not ((TTProbeNodeScoreRes > Alphas[Depth])))) Or ((TTProbeNodeTypeRes == "B") And (Not ((TTProbeNodeScoreRes < Betas[Depth]))))))
                {
                    List.ReplaceItem(MinMaxResults, Depth, TTProbeNodeScoreRes);
                    If (IsProfilerEnabled > 0)
                    {
                        Call Profile_IncCounter((180 + Depth));
                    }
                    Stop(this script);
                }
            }
        }
    }
    If (Not (Quiescence))
    {
        If (((IsInNullMove == 0) And (IsEndgame == 0)) And (((Depth > 1) And ((MaxDepth - Depth) > 1)) And (((Betas[Depth] - Alphas[Depth]) == 1) And ((CheckedState[(Depth - 1)] == 0) And (CheckedState[Depth] == 0)))))
        {
            IsInNullMove += 1;
            If ((((Depth % 2) == 0) And ((WhiteMinorCount > 0) Or (WhiteQueenCount > 0))) Or (((Depth % 2) == 1) And ((BlackMinorCount > 0) Or (BlackQueenCount > 0))))
            {
                Call OnScoreCalc((Depth - 1))(MinDepth)((Depth - 1))(Quiescence);
                If (((Depth % 2) == 1) And (Not ((ScoreCalcRes < Betas[Depth]))))
                {
                    Call ClearMoveList((Depth + 0));
                    Call AddMoveToList(0000)(0)((Depth + 0));
                    List.ReplaceItem(MovesIdx, (Depth + 0), 1);
                    Call ApplyMove((Depth + 0));
                    Call OnScoreCalc((Depth + 0))(MinDepth)((MaxDepth - 1))(Quiescence);
                    List.ReplaceItem(Alphas, (Depth + 1), (Betas[Depth] - 1));
                    List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                    If ((MaxDepth - Depth) > 2)
                    {
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth - 1))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                    }
                    Else
                    {
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth - 0))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                    }
                    Score = MinMaxResults[(Depth + 1)];
                    Call RevertMove((Depth + 0));
                    If ((Not ((Score < Betas[Depth]))) And (Not ((abs(Score) > (BlackKing / 2)))))
                    {
                        List.ReplaceItem(MinMaxResults, Depth, Betas[Depth]);
                        IsInNullMove += -1;
                        Stop(this script);
                    }
                }
                If (((Depth % 2) == 0) And (Not ((ScoreCalcRes > Alphas[Depth]))))
                {
                    Call ClearMoveList((Depth + 0));
                    Call AddMoveToList(0000)(0)((Depth + 0));
                    List.ReplaceItem(MovesIdx, (Depth + 0), 1);
                    Call ApplyMove((Depth + 0));
                    Call OnScoreCalc((Depth + 0))(MinDepth)((MaxDepth - 1))(Quiescence);
                    List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                    List.ReplaceItem(Betas, (Depth + 1), (Alphas[Depth] + 1));
                    If ((MaxDepth - Depth) > 2)
                    {
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth - 1))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                    }
                    Else
                    {
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth - 0))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                    }
                    Score = MinMaxResults[(Depth + 1)];
                    Call RevertMove((Depth + 0));
                    If ((Not ((Score > Alphas[Depth]))) And (Not ((abs(Score) > (BlackKing / 2)))))
                    {
                        List.ReplaceItem(MinMaxResults, Depth, Alphas[Depth]);
                        IsInNullMove += -1;
                        Stop(this script);
                    }
                }
            }
            IsInNullMove += -1;
        }
    }
    List.ReplaceItem(PickPhase, Depth, 1);
    List.ReplaceItem(PickMoveRes, Depth, 1);
    Repeat Until (PickMoveRes[Depth] == 0)
    {
        If ((Not (Quiescence)) And (Depth < 5))
        {
            If ((IsMinMaxTimeout == 0) And (Not (InitialDeepening)))
            {
                If (((Sensing.DaysSince2000() * 86400) - ThinkTimeStart) > ThinkTimeLimitMinMax)
                {
                    IsMinMaxTimeout = 1;
                }
            }
        }
        If (IsMinMaxTimeout == 1)
        {
            Stop(this script);
        }
        If (IsProfilerEnabled > 0)
        {
            Call Profile_MethodEnter((150 + Depth));
        }
        Call PickMove(Depth)((MaxDepth - 1))(InitialDeepening)(Quiescence)(PrevQuiescence);
        If (IsProfilerEnabled > 0)
        {
            Call Profile_MethodExit((150 + Depth));
        }
        If (PickMoveRes[Depth] == 1)
        {
            If (ShowProgress And (Depth < 3))
            {
                CurrentValue = (Sensing.DaysSince2000() * 86400);
                If (CurrentValue > (PrevProgressUpdate + 1))
                {
                    Call OnProgressChanged((((CurrentValue - ThinkTimeStart) / ThinkTimeLimitMinMax) * 100));
                    PrevProgressUpdate = CurrentValue;
                }
            }
            List.ReplaceItem(PutsInCheck, Depth, 0);
            List.ReplaceItem(PutsInFork, Depth, 0);
            List.ReplaceItem(PlyExtension, Depth, 0);
            Call TTProbeNode(CurrentBoardHash)((Depth + 1));
            If ((TTProbeRes == 1) And (Not ((TTProbeCheckedRes == ""))))
            {
                List.ReplaceItem(PutsInCheck, Depth, TTProbeCheckedRes);
            }
            Else
            {
                If (Depth < 24)
                {
                    SourceIdxOuter = floor((AppliedMove[Depth] % 100));
                    If ((Depth % 2) == 1)
                    {
                        If (Not ((MovePosLookupBlack[((PieceIdxLookup[Board[SourceIdxOuter]] * 10000) + ((SourceIdxOuter * 100) + WhiteKingIdx))] == "")))
                        {
                            IsWhiteChecked = 0;
                            Call CalculateMovesForSource((Depth + 2))(SourceIdxOuter)((1 == 1))((1 == 0));
                            List.ReplaceItem(PutsInCheck, Depth, IsWhiteChecked);
                        }
                    }
                    Else
                    {
                        If (Not ((MovePosLookupWhite[((PieceIdxLookup[(0 - Board[SourceIdxOuter])] * 10000) + ((SourceIdxOuter * 100) + BlackKingIdx))] == "")))
                        {
                            IsBlackChecked = 0;
                            Call CalculateMovesForSource((Depth + 2))(SourceIdxOuter)((1 == 1))((1 == 0));
                            List.ReplaceItem(PutsInCheck, Depth, IsBlackChecked);
                        }
                    }
                    If (PutsInCheck[Depth] == 1)
                    {
                        Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(1)(-1)("")("")("")("")("");
                    }
                }
            }
            If ((Not (Quiescence)) And (Depth < 5))
            {
                Call ClearMoveList((Depth + 2));
                Call CalculateMovesForSourceEx((Depth + 2))(floor((AppliedMove[Depth] % 100)))((1 == 0))((1 == 1));
                Count = 0;
                List.ReplaceItem(MovesIdx, (Depth + 2), 1);
                Repeat (MovesCount[(Depth + 2)])
                {
                    Call GetCurrentMove((Depth + 2));
                    If (Board[floor((CurrentMove % 100))] > 0)
                    {
                        If (abs(Board[floor((CurrentMove / 100))]) < abs(Board[floor((CurrentMove % 100))]))
                        {
                            Count += 1;
                        }
                    }
                    List.ReplaceItem(MovesIdx, (Depth + 2), (MovesIdx[(Depth + 2)] + 1));
                }
                If (Count > 1)
                {
                    List.ReplaceItem(PutsInFork, Depth, 1);
                }
                If (((MaxDepth - Depth) == 1) And (Not ((PlyExtension[(Depth - 2)] == 1))))
                {
                    Idx = Depth;
                    Repeat Until (Idx < 1)
                    {
                        If (PutsInFork[Idx] == 1)
                        {
                            List.ReplaceItem(PlyExtension, Depth, 1);
                        }
                        Idx += -1;
                    }
                }
            }
            IsFutile = 0;
            If ((Quiescence Or ((((Depth > 2) And ((MaxDepth - Depth) < 3)) And ((MovesIdx[Depth] > 1) And ((Betas[Depth] - Alphas[Depth]) == 1))) And ((TargetPieces[Depth] == Empty) And (PromotionPieces[Depth] == Empty)))) And ((CheckedState[Depth] == 0) And (PutsInCheck[Depth] == 0)))
            {
                If Quiescence
                {
                    FutilityMargin = 125;
                }
                Else
                {
                    FutilityMargin = ((MaxDepth - Depth) * 75);
                }
                List.ReplaceItem(PosScoreDeltaSum, Depth, (PosScoreDeltaSum[(Depth - 1)] + PosScoreDelta[Depth]));
                List.ReplaceItem(CapturesDeltaSum, Depth, (CapturesDeltaSum[(Depth - 1)] + (TargetPieces[Depth] - PromotionPieces[Depth])));
                If ((IsEndgame == 1) And (abs(TargetPieces[Depth]) == BlackPawn))
                {
                    List.ReplaceItem(CapturesDeltaSum, Depth, (CapturesDeltaSum[Depth] + (TargetPieces[Depth] * 0.2)));
                }
                List.ReplaceItem(EvalExtended1, Depth, EvalExtended1[(Depth - 1)]);
                List.ReplaceItem(EvalExtended2, Depth, EvalExtended2[(Depth - 1)]);
                List.ReplaceItem(EvalExtended3, Depth, EvalExtended3[(Depth - 1)]);
                ScoreCalcRes = ((EvalResultBase + ((EvalExtended1[Depth] + EvalExtended2[Depth]) + EvalExtended3[Depth])) + ((PosScoreDeltaSum[Depth] - CapturesDeltaSum[Depth]) + (BlackMobBonus[Depth] - WhiteMobBonus[Depth])));
                If ((Depth % 2) == 1)
                {
                    If (Not (((ScoreCalcRes + FutilityMargin) > Alphas[Depth])))
                    {
                        IsFutile = 1;
                    }
                }
                Else
                {
                    If (Not (((ScoreCalcRes - FutilityMargin) < Betas[Depth])))
                    {
                        IsFutile = 1;
                    }
                }
            }
            If (IsFutile == 1)
            {
                Call RevertMove(Depth);
            }
            Else
            {
                IsReductionAndDone = 0;
                If ((Not (Quiescence)) And (IsMinMaxTimeout == 0))
                {
                    If (((MaxDepth > 2) And (((MaxDepth - Depth) > 1) Or (PlyExtension[Depth] == 1))) And (MovesIdx[Depth] > 1))
                    {
                        If ((Depth % 2) == 1)
                        {
                            Score = (Alphas[Depth] + 1);
                            If (((MaxDepth - Depth) > 2) And (CheckedState[Depth] == 0))
                            {
                                If ((TargetPieces[Depth] == 0) And (PromotionPieces[Depth] == 0))
                                {
                                    If ((PutsInCheck[Depth] == 0) And ((Betas[Depth] - Alphas[Depth]) == 1))
                                    {
                                        If (((MaxDepth < 7) And ((MovesIdx[Depth] / MovesCount[Depth]) > 0.2)) Or ((MaxDepth > 6) And (MovesIdx[Depth] > 2)))
                                        {
                                            List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                                            List.ReplaceItem(Betas, (Depth + 1), (Alphas[Depth] + 1));
                                            Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth - 1))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                                            Score = MinMaxResults[(Depth + 1)];
                                            IsReductionAndDone = 1;
                                        }
                                    }
                                }
                            }
                            If ((Score > Alphas[Depth]) And (IsMinMaxTimeout == 0))
                            {
                                List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                                List.ReplaceItem(Betas, (Depth + 1), (Alphas[Depth] + 1));
                                Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth + PlyExtension[Depth]))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                                Score = MinMaxResults[(Depth + 1)];
                                IsReductionAndDone = 1;
                                If ((Score > Alphas[Depth]) And (Score < Betas[Depth]))
                                {
                                    IsReductionAndDone = 0;
                                }
                            }
                        }
                        Else
                        {
                            Score = (Betas[Depth] - 1);
                            If (((MaxDepth - Depth) > 2) And (CheckedState[Depth] == 0))
                            {
                                If ((TargetPieces[Depth] == 0) And (PromotionPieces[Depth] == 0))
                                {
                                    If ((PutsInCheck[Depth] == 0) And ((Betas[Depth] - Alphas[Depth]) == 1))
                                    {
                                        If (((MaxDepth < 7) And ((MovesIdx[Depth] / MovesCount[Depth]) > 0.2)) Or ((MaxDepth > 6) And (MovesIdx[Depth] > 2)))
                                        {
                                            List.ReplaceItem(Alphas, (Depth + 1), (Betas[Depth] - 1));
                                            List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                                            Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth - 1))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                                            Score = MinMaxResults[(Depth + 1)];
                                            IsReductionAndDone = 1;
                                        }
                                    }
                                }
                            }
                            If ((Score < Betas[Depth]) And (IsMinMaxTimeout == 0))
                            {
                                List.ReplaceItem(Alphas, (Depth + 1), (Betas[Depth] - 1));
                                List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                                Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth + PlyExtension[Depth]))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                                Score = MinMaxResults[(Depth + 1)];
                                IsReductionAndDone = 1;
                                If ((Score > Alphas[Depth]) And (Score < Betas[Depth]))
                                {
                                    IsReductionAndDone = 0;
                                }
                            }
                        }
                    }
                }
                If ((IsReductionAndDone == 0) And (IsMinMaxTimeout == 0))
                {
                    List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                    List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                    If ((QuiescenceDepth > 0) And (Depth == (MaxDepth - 1)))
                    {
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth + 1))(InitialDeepening)((QuiescenceDepth - 1))((Quiescence Or (PlyExtension[Depth] == 0)))(Quiescence)(ShowProgress);
                    }
                    Else
                    {
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                    }
                    Score = MinMaxResults[(Depth + 1)];
                    IsReductionAndDone = 0;
                }
                If (TargetPieces[Depth] == Empty)
                {
                    IsPotentialKillerMove = 1;
                }
                Else
                {
                    IsPotentialKillerMove = 0;
                }
                Call RevertMove(Depth);
                If (IsMinMaxTimeout == 1)
                {
                    Stop(this script);
                }
                If ((Depth % 2) == 1)
                {
                    If (Depth == 1)
                    {
                        List.Add(MinMaxPly1EvalMoves, Moves1[MovesIdx[1]]);
                    }
                    If ((Score > MinMaxResults[Depth]) Or (MinMaxResults[Depth] == ""))
                    {
                        List.ReplaceItem(MinMaxResults, Depth, Score);
                        If (Score > Alphas[Depth])
                        {
                            Call GetCurrentMove(Depth);
                            List.ReplaceItem(BestMoves, Depth, CurrentMove);
                            If Quiescence
                            {
                                If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (Score < Betas[Depth]))
                                {
                                    List.ReplaceItem(Alphas, Depth, Score);
                                }
                                Else
                                {
                                    List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                    List.ReplaceItem(PickPhase, Depth, 4);
                                }
                            }
                            Else
                            {
                                List.ReplaceItem(Alphas, Depth, Score);
                                If (Not ((Score < Betas[Depth])))
                                {
                                    If (Depth > 1)
                                    {
                                        If (IsPotentialKillerMove == 1)
                                        {
                                            Call StoreKillerMove(Depth)(CurrentMove);
                                        }
                                        List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                        List.ReplaceItem(PickPhase, Depth, 4);
                                    }
                                }
                                Else
                                {
                                    If ((Depth == 1) And (IsMinMaxTimeout == 0))
                                    {
                                        Call OnEvaluationChanged(Score);
                                        List.DeleteItem(MinMaxValuesRes, all);
                                        List.Add(MinMaxValuesRes, Score);
                                        If (Score > -98000)
                                        {
                                            If (1 == 1)
                                            {
                                                Call Log((Operator.Round((((Sensing.DaysSince2000() * 86400) - ThinkTimeStart) * 1000)) / 1000))(":")((MaxDepth - 1))(":")(Moves1[MovesIdx[1]])(":")(Score)("");
                                            }
                                            List.DeleteItem(MinMaxMovesRes, all);
                                            List.Add(MinMaxMovesRes, Moves1[MovesIdx[1]]);
                                            List.ReplaceItem(DeepeningScore, DeepeningScoreOrderMap[MovesIdx[1]], ((MaxDepth * 100000) + (10000 + Score)));
                                            If (MinMaxMovesRes[1] == BlackKingsideCastling)
                                            {
                                                BestMoveFromIdx = VirtualBoard[5];
                                                BestMoveToIdx = VirtualBoard[7];
                                            }
                                            Else
                                            {
                                                If (MinMaxMovesRes[1] == BlackQueensideCastling)
                                                {
                                                    BestMoveFromIdx = VirtualBoard[5];
                                                    BestMoveToIdx = VirtualBoard[3];
                                                }
                                                Else
                                                {
                                                    BestMoveFromIdx = floor((MinMaxMovesRes[1] / 100));
                                                    BestMoveToIdx = floor((MinMaxMovesRes[1] % 100));
                                                }
                                            }
                                            Event.Broadcast("showbestmove");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                Else
                {
                    If ((Score < MinMaxResults[Depth]) Or (MinMaxResults[Depth] == ""))
                    {
                        List.ReplaceItem(MinMaxResults, Depth, Score);
                        If (Score < Betas[Depth])
                        {
                            Call GetCurrentMove(Depth);
                            List.ReplaceItem(BestMoves, Depth, CurrentMove);
                            If Quiescence
                            {
                                If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (Score > Alphas[Depth]))
                                {
                                    List.ReplaceItem(Betas, Depth, Score);
                                }
                                Else
                                {
                                    List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                    List.ReplaceItem(PickPhase, Depth, 4);
                                }
                            }
                            Else
                            {
                                List.ReplaceItem(Betas, Depth, Score);
                                If (Not ((Score > Alphas[Depth])))
                                {
                                    If (IsPotentialKillerMove == 1)
                                    {
                                        Call StoreKillerMove(Depth)(CurrentMove);
                                    }
                                    List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                    List.ReplaceItem(PickPhase, Depth, 4);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    If ((Depth % 2) == 1)
    {
        If (Not ((MinMaxResults[Depth] < Betas[Depth])))
        {
            List.ReplaceItem(ScoreTypes, Depth, "B");
        }
        Else
        {
            If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (((Not (Quiescence)) And (Not ((BestMoves[Depth] == "")))) Or (Quiescence And (MinMaxResults[Depth] > AlphasOld[Depth]))))
            {
                List.ReplaceItem(ScoreTypes, Depth, "E");
            }
            Else
            {
                List.ReplaceItem(ScoreTypes, Depth, "A");
            }
        }
    }
    Else
    {
        If (Not ((MinMaxResults[Depth] > Alphas[Depth])))
        {
            List.ReplaceItem(ScoreTypes, Depth, "A");
        }
        Else
        {
            If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (((Not (Quiescence)) And (Not ((BestMoves[Depth] == "")))) Or (Quiescence And (MinMaxResults[Depth] < BetasOld[Depth]))))
            {
                List.ReplaceItem(ScoreTypes, Depth, "E");
            }
            Else
            {
                List.ReplaceItem(ScoreTypes, Depth, "B");
            }
        }
    }
    If (Quiescence And ((MovesCount[Depth] == 0) And (CheckedState[Depth] == 1)))
    {
        List.ReplaceItem(ScoreTypes, Depth, "E");
        If ((Depth % 2) == 1)
        {
            List.ReplaceItem(MinMaxResults, Depth, (-100000 + (Depth * 1000)));
        }
        Else
        {
            List.ReplaceItem(MinMaxResults, Depth, (100000 - (Depth * 1000)));
        }
    }
    If ((Not (Quiescence)) And (MovesCount[Depth] == 0))
    {
        List.ReplaceItem(ScoreTypes, Depth, "E");
        Call CalcBoardAttackedByMoveChecked((Depth + 1));
        If (((Depth + 1) % 2) == 1)
        {
            If (IsWhiteChecked == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, (100000 - (Depth * 1000)));
            }
            Else
            {
                List.ReplaceItem(MinMaxResults, Depth, 0);
            }
        }
        Else
        {
            If (IsBlackChecked == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, (-100000 + (Depth * 1000)));
            }
            Else
            {
                List.ReplaceItem(MinMaxResults, Depth, 0);
            }
        }
    }
    If (BoardAttackedCalculated[Depth] == 1)
    {
        If ((Depth % 2) == 1)
        {
            BoardAttackedString = BoardAttackedByWhiteSnapshot[Depth];
            BoardAttackedString2 = BoardAttackedByWhitePieceSnapshot[Depth];
        }
        Else
        {
            BoardAttackedString = BoardAttackedByBlackSnapshot[Depth];
            BoardAttackedString2 = BoardAttackedByBlackPieceSnapshot[Depth];
        }
        CurrentValue = CheckedState[Depth];
        CurrentValue2 = CheckedStateAttackLines[Depth];
    }
    Else
    {
        BoardAttackedString = "";
        BoardAttackedString2 = "";
        CurrentValue = "";
        CurrentValue2 = "";
    }
    If Quiescence
    {
        Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])(BestMoves[Depth])(ScoreTypes[Depth])(CurrentValue)(-1)("")("")(BoardAttackedString)(BoardAttackedString2)(CurrentValue2);
    }
    Else
    {
        Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])(BestMoves[Depth])(ScoreTypes[Depth])(CurrentValue)((MaxDepth - Depth))(BlackMobBonus[Depth])(WhiteMobBonus[Depth])(BoardAttackedString)(BoardAttackedString2)(CurrentValue2);
    }
}

Define ApplyMove(num Depth) (warp=true)
{
    List.ReplaceItem(PreviousBoardHash, Depth, CurrentBoardHash);
    Call GetCurrentMove(Depth);
    List.ReplaceItem(AppliedMove, Depth, CurrentMove);
    SourceIdx = floor((CurrentMove / 100));
    If (SourceIdx > 0)
    {
        TargetIdx = floor((CurrentMove % 100));
        SourcePiece = Board[SourceIdx];
        TargetPiece = Board[TargetIdx];
        List.ReplaceItem(SourcePieces, Depth, SourcePiece);
        List.ReplaceItem(TargetPiecesIdx, Depth, TargetIdx);
        List.ReplaceItem(TargetPieces, Depth, TargetPiece);
        List.ReplaceItem(PromotionPieces, Depth, 0);
        List.ReplaceItem(Board, TargetIdx, SourcePiece);
        List.ReplaceItem(Board, SourceIdx, 0);
        If (SourcePiece > 0)
        {
            IdxSub = ((PieceIdxLookup[SourcePiece] * 10000) + ((SourceIdx * 100) + TargetIdx));
            List.ReplaceItem(PosScoreDelta, Depth, MovePosLookupBlack[IdxSub]);
            CurrentBoardHash += MoveHashLookupBlack[IdxSub];
            If (SourcePiece == BlackPawn)
            {
                If (Not ((IdxToFile[SourceIdx] == IdxToFile[TargetIdx])))
                {
                    List.ReplaceItem(BlackPawnCount, IdxToFile[SourceIdx], (BlackPawnCount[IdxToFile[SourceIdx]] - 1));
                    List.ReplaceItem(BlackPawnCount, IdxToFile[TargetIdx], (BlackPawnCount[IdxToFile[TargetIdx]] + 1));
                    If (TargetPieces[Depth] == Empty)
                    {
                        List.ReplaceItem(TargetPiecesIdx, Depth, (TargetIdx - 8));
                        List.ReplaceItem(TargetPieces, Depth, Board[(TargetIdx - 8)]);
                        TargetPiece = Board[(TargetIdx - 8)];
                        List.ReplaceItem(Board, (TargetIdx - 8), Empty);
                        Call GetPiecePosHash(Board[(TargetIdx - 8)])((TargetIdx - 8));
                        CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                    }
                }
                If (TargetIdx > 56)
                {
                    List.ReplaceItem(PromotionPieces, Depth, Empty);
                    PromotionVal = Operator.LetterOf(CurrentMove, 6);
                    If (PromotionVal == 1)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, BlackQueen);
                    }
                    If (PromotionVal == 2)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, BlackRook);
                    }
                    If (PromotionVal == 3)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, BlackBishop);
                    }
                    If (PromotionVal == 4)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, BlackKnight);
                    }
                    If (Not ((PromotionPieces[Depth] == Empty)))
                    {
                        List.ReplaceItem(Board, TargetIdx, PromotionPieces[Depth]);
                    }
                    Call GetPiecePosHash(BlackPawn)(SourceIdx);
                    CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                    Call GetPiecePosHash(PromotionPieces[Depth])(TargetIdx);
                    CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
                }
            }
            Else
            {
                If (SourcePiece == BlackKing)
                {
                    BlackKingIdx = TargetIdx;
                }
            }
        }
        Else
        {
            IdxSub = ((PieceIdxLookup[(0 - SourcePiece)] * 10000) + ((SourceIdx * 100) + TargetIdx));
            List.ReplaceItem(PosScoreDelta, Depth, MovePosLookupWhite[IdxSub]);
            CurrentBoardHash += MoveHashLookupWhite[IdxSub];
            If (SourcePiece == WhitePawn)
            {
                If (Not ((IdxToFile[SourceIdx] == IdxToFile[TargetIdx])))
                {
                    List.ReplaceItem(WhitePawnCount, IdxToFile[SourceIdx], (WhitePawnCount[IdxToFile[SourceIdx]] - 1));
                    List.ReplaceItem(WhitePawnCount, IdxToFile[TargetIdx], (WhitePawnCount[IdxToFile[TargetIdx]] + 1));
                    If (TargetPieces[Depth] == Empty)
                    {
                        List.ReplaceItem(TargetPiecesIdx, Depth, (TargetIdx + 8));
                        List.ReplaceItem(TargetPieces, Depth, Board[(TargetIdx + 8)]);
                        TargetPiece = Board[(TargetIdx + 8)];
                        List.ReplaceItem(Board, (TargetIdx + 8), Empty);
                        Call GetPiecePosHash(Board[(TargetIdx + 8)])((TargetIdx + 8));
                        CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                    }
                }
                If (TargetIdx < 9)
                {
                    List.ReplaceItem(PromotionPieces, Depth, Empty);
                    PromotionVal = Operator.LetterOf(CurrentMove, 6);
                    If (PromotionVal == 1)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, WhiteQueen);
                    }
                    If (PromotionVal == 2)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, WhiteRook);
                    }
                    If (PromotionVal == 3)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, WhiteBishop);
                    }
                    If (PromotionVal == 4)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, WhiteKnight);
                    }
                    If (Not ((PromotionPieces[Depth] == Empty)))
                    {
                        List.ReplaceItem(Board, TargetIdx, PromotionPieces[Depth]);
                    }
                    Call GetPiecePosHash(WhitePawn)(SourceIdx);
                    CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                    Call GetPiecePosHash(PromotionPieces[Depth])(TargetIdx);
                    CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
                }
            }
            Else
            {
                If (SourcePiece == WhiteKing)
                {
                    WhiteKingIdx = TargetIdx;
                }
            }
        }
        If (TargetPiece > 0)
        {
            IdxSub = ((PieceIdxLookup[TargetPiece] * 10000) + (TargetIdx * 100));
            List.ReplaceItem(PosScoreDelta, Depth, (PosScoreDelta[Depth] + MovePosLookupBlack[IdxSub]));
            CurrentBoardHash += MoveHashLookupBlack[IdxSub];
            If (TargetPiece == BlackPawn)
            {
                List.ReplaceItem(BlackPawnCount, IdxToFile[TargetPiecesIdx[Depth]], (BlackPawnCount[IdxToFile[TargetPiecesIdx[Depth]]] - 1));
            }
        }
        Else
        {
            If (TargetPiece < 0)
            {
                IdxSub = ((PieceIdxLookup[(0 - TargetPiece)] * 10000) + (TargetIdx * 100));
                List.ReplaceItem(PosScoreDelta, Depth, (PosScoreDelta[Depth] + MovePosLookupWhite[IdxSub]));
                CurrentBoardHash += MoveHashLookupWhite[IdxSub];
                If (TargetPiece == WhitePawn)
                {
                    List.ReplaceItem(WhitePawnCount, IdxToFile[TargetPiecesIdx[Depth]], (WhitePawnCount[IdxToFile[TargetPiecesIdx[Depth]]] - 1));
                }
            }
        }
    }
    Else
    {
        List.ReplaceItem(PosScoreDelta, Depth, 0);
        List.ReplaceItem(SourcePieces, Depth, Empty);
        List.ReplaceItem(TargetPiecesIdx, Depth, "");
        List.ReplaceItem(TargetPieces, Depth, Empty);
        List.ReplaceItem(PromotionPieces, Depth, Empty);
        If (CurrentMove == WhiteKingsideCastling)
        {
            List.ReplaceItem(SourcePieces, Depth, WhiteKing);
            List.ReplaceItem(Board, VirtualBoard[61], Empty);
            List.ReplaceItem(Board, VirtualBoard[62], WhiteRook);
            List.ReplaceItem(Board, VirtualBoard[63], WhiteKing);
            List.ReplaceItem(Board, VirtualBoard[64], Empty);
            WhiteKingIdx = VirtualBoard[63];
            Call UpdateMoveHashPosScore(WhiteKing)(VirtualBoard[61])(VirtualBoard[63])((1 == 0));
            Call UpdateMoveHashPosScore(WhiteRook)(VirtualBoard[64])(VirtualBoard[62])((1 == 1));
        }
        Else
        {
            If (CurrentMove == WhiteQueensideCastling)
            {
                List.ReplaceItem(SourcePieces, Depth, WhiteKing);
                List.ReplaceItem(Board, VirtualBoard[57], Empty);
                List.ReplaceItem(Board, VirtualBoard[59], WhiteKing);
                List.ReplaceItem(Board, VirtualBoard[60], WhiteRook);
                List.ReplaceItem(Board, VirtualBoard[61], Empty);
                WhiteKingIdx = VirtualBoard[59];
                Call UpdateMoveHashPosScore(WhiteKing)(VirtualBoard[61])(VirtualBoard[59])((1 == 0));
                Call UpdateMoveHashPosScore(WhiteRook)(VirtualBoard[57])(VirtualBoard[59])((1 == 1));
            }
            Else
            {
                If (CurrentMove == BlackKingsideCastling)
                {
                    List.ReplaceItem(SourcePieces, Depth, BlackKing);
                    List.ReplaceItem(Board, VirtualBoard[5], Empty);
                    List.ReplaceItem(Board, VirtualBoard[6], BlackRook);
                    List.ReplaceItem(Board, VirtualBoard[7], BlackKing);
                    List.ReplaceItem(Board, VirtualBoard[8], Empty);
                    BlackKingIdx = VirtualBoard[3];
                    Call UpdateMoveHashPosScore(BlackKing)(VirtualBoard[5])(VirtualBoard[7])((1 == 0));
                    Call UpdateMoveHashPosScore(BlackRook)(VirtualBoard[8])(VirtualBoard[6])((1 == 1));
                }
                Else
                {
                    If (CurrentMove == BlackQueensideCastling)
                    {
                        List.ReplaceItem(SourcePieces, Depth, BlackKing);
                        List.ReplaceItem(Board, VirtualBoard[1], Empty);
                        List.ReplaceItem(Board, VirtualBoard[3], BlackKing);
                        List.ReplaceItem(Board, VirtualBoard[4], BlackRook);
                        List.ReplaceItem(Board, VirtualBoard[5], Empty);
                        BlackKingIdx = VirtualBoard[5];
                        Call UpdateMoveHashPosScore(BlackKing)(VirtualBoard[5])(VirtualBoard[3])((1 == 0));
                        Call UpdateMoveHashPosScore(BlackRook)(VirtualBoard[1])(VirtualBoard[4])((1 == 1));
                    }
                }
            }
        }
    }
}

Define CalcBoardAttackedByMove(string Depth) (warp=true)
{
    Call ClearBoardAttackedByMove(Depth);
    Call CalculateMovesImplWrapper(Depth)((1 == 1))((1 == 0));
}

Define CalcBoardAttackedByMoveChecked(string Depth) (warp=true)
{
    Call TTProbeNode(CurrentBoardHash)((Depth + 1));
    If ((TTProbeRes == 1) And (Not ((TTProbeCheckedRes == ""))))
    {
        If ((Depth % 2) == 1)
        {
            IsWhiteChecked = TTProbeCheckedRes;
        }
        Else
        {
            IsBlackChecked = TTProbeCheckedRes;
        }
    }
    Else
    {
        Call CalcBoardAttackedByMove(Depth);
        Call StoreAttackInfo(Depth)((Depth + 1));
        If ((Depth % 2) == 1)
        {
            Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(CheckedState[(Depth + 1)])(-1)("")("")(BoardAttackedByBlackSnapshot[(Depth + 1)])(BoardAttackedByBlackPieceSnapshot[(Depth + 1)])(CheckedStateAttackLines[(Depth + 1)]);
        }
        Else
        {
            Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(CheckedState[(Depth + 1)])(-1)("")("")(BoardAttackedByWhiteSnapshot[(Depth + 1)])(BoardAttackedByWhitePieceSnapshot[(Depth + 1)])(CheckedStateAttackLines[(Depth + 1)]);
        }
    }
}

Define CalcBoardStats (warp=true)
{
    BlackKingIdx = "";
    WhiteKingIdx = "";
    CurrentBoardHash = 0;
    Idx = 1;
    Repeat (8)
    {
        List.ReplaceItem(BlackPawnCount, Idx, 0);
        List.ReplaceItem(WhitePawnCount, Idx, 0);
        Idx += 1;
    }
    Idx = 1;
    Repeat (64)
    {
        If (Board[Idx] == WhitePawn)
        {
            List.ReplaceItem(WhitePawnCount, IdxToFile[Idx], (WhitePawnCount[IdxToFile[Idx]] + 1));
        }
        Else
        {
            If (Board[Idx] == BlackPawn)
            {
                List.ReplaceItem(BlackPawnCount, IdxToFile[Idx], (BlackPawnCount[IdxToFile[Idx]] + 1));
            }
            Else
            {
                If (Board[Idx] == WhiteKing)
                {
                    WhiteKingIdx = Idx;
                }
                Else
                {
                    If (Board[Idx] == BlackKing)
                    {
                        BlackKingIdx = Idx;
                    }
                }
            }
        }
        Call GetPiecePosHash(Board[Idx])(Idx);
        CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
        Idx += 1;
    }
    BlackMinorCount = 0;
    BlackQueenCount = 0;
    BlackPawnCount = 0;
    BlackRookCount = 0;
    BlackBishopCount = 0;
    WhiteQueenCount = 0;
    WhiteMinorCount = 0;
    WhitePawnCount = 0;
    WhiteRookCount = 0;
    WhiteBishopCount = 0;
    Idx = 1;
    Repeat (64)
    {
        If (Board[Idx] == WhiteQueen)
        {
            WhiteQueenCount += 1;
        }
        If (Board[Idx] == BlackQueen)
        {
            BlackQueenCount += 1;
        }
        If ((Board[Idx] == WhiteKnight) Or ((Board[Idx] == WhiteBishop) Or (Board[Idx] == WhiteRook)))
        {
            WhiteMinorCount += 1;
            If (Board[Idx] == WhiteRook)
            {
                WhiteRookCount += 1;
            }
            If (Board[Idx] == WhiteBishop)
            {
                WhiteBishopCount += 1;
            }
        }
        If ((Board[Idx] == BlackKnight) Or ((Board[Idx] == BlackBishop) Or (Board[Idx] == BlackRook)))
        {
            BlackMinorCount += 1;
            If (Board[Idx] == BlackRook)
            {
                BlackRookCount += 1;
            }
            If (Board[Idx] == BlackBishop)
            {
                BlackBishopCount += 1;
            }
        }
        If (Board[Idx] == WhitePawn)
        {
            WhitePawnCount += 1;
        }
        If (Board[Idx] == BlackPawn)
        {
            BlackPawnCount += 1;
        }
        Idx += 1;
    }
    If (((WhiteQueenCount + WhiteMinorCount) < 2) Or ((BlackQueenCount + BlackMinorCount) < 2))
    {
        IsEndgame2 = 1;
        IsEndgame = 1;
    }
    Else
    {
        If ((((WhiteQueenCount * 9) + (WhiteMinorCount * 4)) < 10) Or (((BlackQueenCount * 9) + (BlackMinorCount * 4)) < 10))
        {
            IsEndgame2 = 0;
            IsEndgame = 1;
        }
        Else
        {
            IsEndgame2 = 0;
            IsEndgame = 0;
        }
    }
    If ((HasBlackCastled == 0) And ((HasBlackKingMoved == 0) And ((HasBlackRookKSMoved == 0) Or (HasBlackRookQSMoved == 0))))
    {
        IsBlackCastlingPossible = 1;
    }
    Else
    {
        IsBlackCastlingPossible = 0;
    }
    If ((HasWhiteCastled == 0) And ((HasWhiteKingMoved == 0) And ((HasWhiteRookKSMoved == 0) Or (HasWhiteRookQSMoved == 0))))
    {
        IsWhiteCastlingPossible = 1;
    }
    Else
    {
        IsWhiteCastlingPossible = 0;
    }
}

Define CalculateMoves(num Depth) (warp=true)
{
    Call CalcBoardAttackedByMove((Depth + 1));
    Call StoreAttackInfo((Depth + 1))(Depth);
    List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
    Call CalculateMovesImplWrapper(Depth)((1 == 0))((1 == 0));
    List.ReplaceItem(BoardAttackedCalculated, Depth, 0);
}

Define CalculateMovesForSource(num Depth)(num SourceIdx)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    SourcePieceOuter2 = Board[SourceIdx];
    If (SourcePieceOuter2 == BlackPawn)
    {
        If (CalcAttackState Or (Board[(SourceIdx + 7)] < 0))
        {
            If (IdxToFile[SourceIdx] > 1)
            {
                Call AddMoveImpl(SourceIdx)((SourceIdx + 7))(Depth)(CalcAttackState)(CapturesOnly);
            }
        }
        If (CalcAttackState Or (Board[(SourceIdx + 9)] < 0))
        {
            If (IdxToFile[SourceIdx] < 8)
            {
                Call AddMoveImpl(SourceIdx)((SourceIdx + 9))(Depth)(CalcAttackState)(CapturesOnly);
            }
        }
        If (Not (CalcAttackState))
        {
            If (Board[(SourceIdx + 8)] == 0)
            {
                If CapturesOnly
                {
                    If ((IdxToRank[SourceIdx] == 7) Or (Operator.LetterOf(CheckedStateAttackLines[Depth], (SourceIdx + 8)) == 1))
                    {
                        Call AddMoveImpl(SourceIdx)((SourceIdx + 8))(Depth)(CalcAttackState)(CapturesOnly);
                    }
                    Else
                    {
                        Call IsQuiescentCheck(SourcePieceOuter2)((SourceIdx + 8))(Depth);
                        If (IsQuiescentCheckRes == 1)
                        {
                            Call AddMoveImpl(SourceIdx)((SourceIdx + 8))(Depth)(CalcAttackState)(CapturesOnly);
                            List.ReplaceItem(CalcMovesScoreList, List.Length(CalcMovesScoreList), "*");
                        }
                    }
                }
                Else
                {
                    Call AddMoveImpl(SourceIdx)((SourceIdx + 8))(Depth)(CalcAttackState)(CapturesOnly);
                }
                If ((IdxToRank[SourceIdx] == 2) And (Board[(SourceIdx + 16)] == 0))
                {
                    If CapturesOnly
                    {
                        If (Operator.LetterOf(CheckedStateAttackLines[Depth], (SourceIdx + 16)) == 1)
                        {
                            Call AddMoveImpl(SourceIdx)((SourceIdx + 16))(Depth)(CalcAttackState)(CapturesOnly);
                        }
                        Else
                        {
                            Call IsQuiescentCheck(SourcePieceOuter2)((SourceIdx + 16))(Depth);
                            If (IsQuiescentCheckRes == 1)
                            {
                                Call AddMoveImpl(SourceIdx)((SourceIdx + 16))(Depth)(CalcAttackState)(CapturesOnly);
                                List.ReplaceItem(CalcMovesScoreList, List.Length(CalcMovesScoreList), "*");
                            }
                        }
                    }
                    Else
                    {
                        Call AddMoveImpl(SourceIdx)((SourceIdx + 16))(Depth)(CalcAttackState)(CapturesOnly);
                    }
                }
            }
        }
        If (IdxToRank[SourceIdx] == 5)
        {
            If (Not (CalcAttackState))
            {
                If (Board[(SourceIdx - 1)] == WhitePawn)
                {
                    If (IdxToFile[SourceIdx] > 1)
                    {
                        Call AddPossibleEnPassantImpl(SourceIdx)(-1)(Depth);
                    }
                }
                If (Board[(SourceIdx + 1)] == WhitePawn)
                {
                    If (IdxToFile[SourceIdx] < 8)
                    {
                        Call AddPossibleEnPassantImpl(SourceIdx)(1)(Depth);
                    }
                }
            }
        }
    }
    Else
    {
        If (SourcePieceOuter2 == WhitePawn)
        {
            If (CalcAttackState Or (Board[(SourceIdx - 9)] > 0))
            {
                If (IdxToFile[SourceIdx] > 1)
                {
                    Call AddMoveImpl(SourceIdx)((SourceIdx - 9))(Depth)(CalcAttackState)(CapturesOnly);
                }
            }
            If (CalcAttackState Or (Board[(SourceIdx - 7)] > 0))
            {
                If (IdxToFile[SourceIdx] < 8)
                {
                    Call AddMoveImpl(SourceIdx)((SourceIdx - 7))(Depth)(CalcAttackState)(CapturesOnly);
                }
            }
            If (Not (CalcAttackState))
            {
                If (Board[(SourceIdx - 8)] == 0)
                {
                    If CapturesOnly
                    {
                        If ((IdxToRank[SourceIdx] == 2) Or (Operator.LetterOf(CheckedStateAttackLines[Depth], (SourceIdx - 8)) == 1))
                        {
                            Call AddMoveImpl(SourceIdx)((SourceIdx - 8))(Depth)(CalcAttackState)(CapturesOnly);
                        }
                        Else
                        {
                            Call IsQuiescentCheck(SourcePieceOuter2)((SourceIdx - 8))(Depth);
                            If (IsQuiescentCheckRes == 1)
                            {
                                Call AddMoveImpl(SourceIdx)((SourceIdx - 8))(Depth)(CalcAttackState)(CapturesOnly);
                                List.ReplaceItem(CalcMovesScoreList, List.Length(CalcMovesScoreList), "*");
                            }
                        }
                    }
                    Else
                    {
                        Call AddMoveImpl(SourceIdx)((SourceIdx - 8))(Depth)(CalcAttackState)(CapturesOnly);
                    }
                    If ((IdxToRank[SourceIdx] == 7) And (Board[(SourceIdx - 16)] == 0))
                    {
                        If CapturesOnly
                        {
                            If (Operator.LetterOf(CheckedStateAttackLines[Depth], (SourceIdx - 16)) == 1)
                            {
                                Call AddMoveImpl(SourceIdx)((SourceIdx - 16))(Depth)(CalcAttackState)(CapturesOnly);
                            }
                            Else
                            {
                                Call IsQuiescentCheck(SourcePieceOuter2)((SourceIdx - 16))(Depth);
                                If (IsQuiescentCheckRes == 1)
                                {
                                    Call AddMoveImpl(SourceIdx)((SourceIdx - 16))(Depth)(CalcAttackState)(CapturesOnly);
                                    List.ReplaceItem(CalcMovesScoreList, List.Length(CalcMovesScoreList), "*");
                                }
                            }
                        }
                        Else
                        {
                            Call AddMoveImpl(SourceIdx)((SourceIdx - 16))(Depth)(CalcAttackState)(CapturesOnly);
                        }
                    }
                }
            }
            If (IdxToRank[SourceIdx] == 4)
            {
                If (Not (CalcAttackState))
                {
                    If (Board[(SourceIdx - 1)] == BlackPawn)
                    {
                        If (IdxToFile[SourceIdx] > 1)
                        {
                            Call AddPossibleEnPassantImpl(SourceIdx)(-1)(Depth);
                        }
                    }
                    If (Board[(SourceIdx + 1)] == BlackPawn)
                    {
                        If (IdxToFile[SourceIdx] < 8)
                        {
                            Call AddPossibleEnPassantImpl(SourceIdx)(1)(Depth);
                        }
                    }
                }
            }
        }
        Else
        {
            SourcePieceOuter2 = abs(SourcePieceOuter2);
            If (SourcePieceOuter2 == BlackRook)
            {
                Call AddLineMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 1));
            }
            Else
            {
                If (SourcePieceOuter2 == BlackBishop)
                {
                    Call AddLineMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 0));
                }
                Else
                {
                    If (SourcePieceOuter2 == BlackKnight)
                    {
                        Call AddLookupMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 0));
                    }
                    Else
                    {
                        If (SourcePieceOuter2 == BlackKing)
                        {
                            Call AddLookupMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 1));
                        }
                        Else
                        {
                            If (SourcePieceOuter2 == BlackQueen)
                            {
                                Call AddLineMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 1));
                                Call AddLineMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 0));
                            }
                        }
                    }
                }
            }
        }
    }
}

Define CalculateMovesForSourceEx(string Depth)(string SourceIdx)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    List.DeleteAll(CalcMovesMoveList);
    List.DeleteAll(CalcMovesScoreList);
    Call CalculateMovesForSource(Depth)(SourceIdx)(CalcAttackState)(CapturesOnly);
    Call SortMoveList(Depth);
    List.ReplaceItem(MovesCount, Depth, List.Length(CalcMovesMoveList));
}

Define CalculateMovesImpl(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool IsBlackMove) (warp=true)
{
    If ((Not (CalcAttackState)) And (Not (CapturesOnly)))
    {
        If IsBlackMove
        {
            List.ReplaceItem(BlackMobBonus, Depth, 0);
        }
        Else
        {
            List.ReplaceItem(WhiteMobBonus, Depth, 0);
        }
        List.DeleteAll(PieceMobility);
        Repeat (64)
        {
            List.Add(PieceMobility, 0);
        }
    }
    List.DeleteAll(CalcMovesScoreList);
    List.DeleteAll(CalcMovesMoveList);
    List.DeleteAll(CurrentKillerMoves);
    If (Depth == 6)
    {
        List.Add(CurrentKillerMoves, KillerMoves6[1]);
        List.Add(CurrentKillerMoves, KillerMoves6[2]);
        List.Add(CurrentKillerMoves, KillerMoves6[3]);
        List.Add(CurrentKillerMoves, KillerMoves6[4]);
    }
    Else
    {
        If (Depth == 5)
        {
            List.Add(CurrentKillerMoves, KillerMoves5[1]);
            List.Add(CurrentKillerMoves, KillerMoves5[2]);
            List.Add(CurrentKillerMoves, KillerMoves5[3]);
            List.Add(CurrentKillerMoves, KillerMoves5[4]);
        }
        Else
        {
            If (Depth == 4)
            {
                List.Add(CurrentKillerMoves, KillerMoves4[1]);
                List.Add(CurrentKillerMoves, KillerMoves4[2]);
                List.Add(CurrentKillerMoves, KillerMoves4[3]);
                List.Add(CurrentKillerMoves, KillerMoves4[4]);
            }
            Else
            {
                If (Depth == 3)
                {
                    List.Add(CurrentKillerMoves, KillerMoves3[1]);
                    List.Add(CurrentKillerMoves, KillerMoves3[2]);
                    List.Add(CurrentKillerMoves, KillerMoves3[3]);
                    List.Add(CurrentKillerMoves, KillerMoves3[4]);
                }
                Else
                {
                    If (Depth == 2)
                    {
                        List.Add(CurrentKillerMoves, KillerMoves2[1]);
                        List.Add(CurrentKillerMoves, KillerMoves2[2]);
                        List.Add(CurrentKillerMoves, KillerMoves2[3]);
                        List.Add(CurrentKillerMoves, KillerMoves2[4]);
                    }
                    Else
                    {
                        If (Depth == 7)
                        {
                            List.Add(CurrentKillerMoves, KillerMoves7[1]);
                            List.Add(CurrentKillerMoves, KillerMoves7[2]);
                            List.Add(CurrentKillerMoves, KillerMoves7[3]);
                            List.Add(CurrentKillerMoves, KillerMoves7[4]);
                        }
                        Else
                        {
                            If (Depth == 8)
                            {
                                List.Add(CurrentKillerMoves, KillerMoves8[1]);
                                List.Add(CurrentKillerMoves, KillerMoves8[2]);
                                List.Add(CurrentKillerMoves, KillerMoves8[3]);
                                List.Add(CurrentKillerMoves, KillerMoves8[4]);
                            }
                        }
                    }
                }
            }
        }
    }
    SourceIdxOuter = 1;
    Repeat (64)
    {
        If ((IsBlackMove And (Board[SourceIdxOuter] > 0)) Or ((Not (IsBlackMove)) And (Board[SourceIdxOuter] < 0)))
        {
            Call CalculateMovesForSource(Depth)(SourceIdxOuter)(CalcAttackState)(CapturesOnly);
            If (((Not (CalcAttackState)) And (Not (CapturesOnly))) And (Not ((abs(Board[SourceIdxOuter]) == BlackPawn))))
            {
                CurrentPiece = Board[SourceIdxOuter];
                If IsBlackMove
                {
                    If (IsEndgame == 0)
                    {
                        If (CurrentPiece == BlackRook)
                        {
                            List.ReplaceItem(BlackMobBonus, Depth, (BlackMobBonus[Depth] + RookMobilityBonus[(PieceMobility[SourceIdxOuter] + 1)]));
                        }
                        Else
                        {
                            If (CurrentPiece == BlackBishop)
                            {
                                List.ReplaceItem(BlackMobBonus, Depth, (BlackMobBonus[Depth] + BishopMobilityBonus[(PieceMobility[SourceIdxOuter] + 1)]));
                            }
                            Else
                            {
                                If (CurrentPiece == BlackKnight)
                                {
                                    List.ReplaceItem(BlackMobBonus, Depth, (BlackMobBonus[Depth] + KnightMobilityBonus[(PieceMobility[SourceIdxOuter] + 1)]));
                                }
                                Else
                                {
                                    If (CurrentPiece == BlackQueen)
                                    {
                                        List.ReplaceItem(BlackMobBonus, Depth, (BlackMobBonus[Depth] + QueenMobilityBonus[(PieceMobility[SourceIdxOuter] + 1)]));
                                    }
                                }
                            }
                        }
                    }
                    Else
                    {
                        If (IsEndgame2 == 1)
                        {
                            If ((CurrentPiece == BlackKing) And ((BlackQueenCount == 0) And (BlackMinorCount == 0)))
                            {
                                List.ReplaceItem(BlackMobBonus, Depth, (BlackMobBonus[Depth] + (PieceMobility[SourceIdxOuter] * 10)));
                            }
                        }
                    }
                }
                Else
                {
                    If ((Not (CalcAttackState)) And (Not (CapturesOnly)))
                    {
                        If (IsEndgame == 0)
                        {
                            If (CurrentPiece == WhiteRook)
                            {
                                List.ReplaceItem(WhiteMobBonus, Depth, (WhiteMobBonus[Depth] + RookMobilityBonus[(PieceMobility[SourceIdxOuter] + 1)]));
                            }
                            Else
                            {
                                If (CurrentPiece == WhiteBishop)
                                {
                                    List.ReplaceItem(WhiteMobBonus, Depth, (WhiteMobBonus[Depth] + BishopMobilityBonus[(PieceMobility[SourceIdxOuter] + 1)]));
                                }
                                Else
                                {
                                    If (CurrentPiece == WhiteKnight)
                                    {
                                        List.ReplaceItem(WhiteMobBonus, Depth, (WhiteMobBonus[Depth] + KnightMobilityBonus[(PieceMobility[SourceIdxOuter] + 1)]));
                                    }
                                    Else
                                    {
                                        If (CurrentPiece == WhiteQueen)
                                        {
                                            List.ReplaceItem(WhiteMobBonus, Depth, (WhiteMobBonus[Depth] + QueenMobilityBonus[(PieceMobility[SourceIdxOuter] + 1)]));
                                        }
                                    }
                                }
                            }
                        }
                        Else
                        {
                            If (IsEndgame2 == 1)
                            {
                                If ((CurrentPiece == WhiteKing) And ((WhiteQueenCount == 0) And (WhiteMinorCount == 0)))
                                {
                                    List.ReplaceItem(WhiteMobBonus, Depth, (WhiteMobBonus[Depth] + (PieceMobility[SourceIdxOuter] * 10)));
                                }
                            }
                        }
                    }
                }
            }
        }
        SourceIdxOuter += 1;
    }
    If ((Not (CalcAttackState)) And (Not (CapturesOnly)))
    {
        If IsBlackMove
        {
            If ((HasBlackKingMoved == 0) And (HasBlackCastled == 0))
            {
                If ((((Board[VirtualBoard[1]] == BlackRook) And (Board[VirtualBoard[2]] == Empty)) And ((Board[VirtualBoard[3]] == Empty) And (Board[VirtualBoard[4]] == Empty))) And (Board[VirtualBoard[5]] == BlackKing))
                {
                    If ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[3]) == 0) And ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[4]) == 0) And (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[5]) == 0)))
                    {
                        If (HasBlackRookQSMoved == 0)
                        {
                            Call AddSpecialMove(BlackQueensideCastling)(Depth);
                        }
                    }
                }
                If (((Board[VirtualBoard[5]] == BlackKing) And (Board[VirtualBoard[6]] == Empty)) And ((Board[VirtualBoard[7]] == Empty) And (Board[VirtualBoard[8]] == BlackRook)))
                {
                    If ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[5]) == 0) And ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[6]) == 0) And (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[7]) == 0)))
                    {
                        If (HasBlackRookKSMoved == 0)
                        {
                            Call AddSpecialMove(BlackKingsideCastling)(Depth);
                        }
                    }
                }
            }
        }
        Else
        {
            If ((HasWhiteKingMoved == 0) And (HasWhiteCastled == 0))
            {
                If (((Board[VirtualBoard[57]] == WhiteRook) And (Board[VirtualBoard[58]] == Empty)) And ((Board[VirtualBoard[59]] == Empty) And ((Board[VirtualBoard[60]] == Empty) And (Board[VirtualBoard[61]] == WhiteKing))))
                {
                    If ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[59]) == 0) And ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[60]) == 0) And (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[61]) == 0)))
                    {
                        If (HasWhiteRookQSMoved == 0)
                        {
                            Call AddSpecialMove(WhiteQueensideCastling)(Depth);
                        }
                    }
                }
                If (((Board[VirtualBoard[62]] == Empty) And (Board[VirtualBoard[61]] == WhiteKing)) And ((Board[VirtualBoard[63]] == Empty) And (Board[VirtualBoard[64]] == WhiteRook)))
                {
                    If ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[61]) == 0) And ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[62]) == 0) And (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[63]) == 0)))
                    {
                        If (HasWhiteRookKSMoved == 0)
                        {
                            Call AddSpecialMove(WhiteKingsideCastling)(Depth);
                        }
                    }
                }
            }
        }
    }
    If (Not (CalcAttackState))
    {
        If (CapturesOnly And (Depth < 24))
        {
            IdxOuter2 = 1;
            Repeat Until (IdxOuter2 > List.Length(CalcMovesMoveList))
            {
                If (CalcMovesScoreList[IdxOuter2] == "*")
                {
                    SourceIdxOuter = floor((CalcMovesMoveList[IdxOuter2] / 100));
                    TargetIdxOuter = floor((CalcMovesMoveList[IdxOuter2] % 100));
                    Call ClearMoveList((Depth + 2));
                    Call AddMoveToList(CalcMovesMoveList[IdxOuter2])(0)((Depth + 2));
                    List.ReplaceItem(MovesCount, (Depth + 2), 1);
                    List.ReplaceItem(MovesIdx, (Depth + 2), 1);
                    Call ApplyMove((Depth + 2));
                    If ((Depth % 2) == 1)
                    {
                        IsWhiteChecked = 0;
                        Call CalculateMovesForSource((Depth + 4))(TargetIdxOuter)((1 == 1))((1 == 0));
                        If (IsWhiteChecked == 1)
                        {
                            Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(1)(-1)("")("")("")("")("");
                            Call RevertMove((Depth + 2));
                            Call GetMoveScore(SourceIdxOuter)(TargetIdxOuter)(Board[SourceIdxOuter])(Board[TargetIdxOuter])(CalcMovesMoveList[IdxOuter2])(Depth)((1 == 1));
                            List.ReplaceItem(CalcMovesScoreList, IdxOuter2, MoveScoreRes);
                            IdxOuter2 += 1;
                        }
                        Else
                        {
                            Call RevertMove((Depth + 2));
                            List.DeleteItem(CalcMovesMoveList, IdxOuter2);
                            List.DeleteItem(CalcMovesScoreList, IdxOuter2);
                        }
                    }
                    Else
                    {
                        IsBlackChecked = 0;
                        Call CalculateMovesForSource((Depth + 4))(TargetIdxOuter)((1 == 1))((1 == 0));
                        If (IsBlackChecked == 1)
                        {
                            Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(1)(-1)("")("")("")("")("");
                            Call RevertMove((Depth + 2));
                            Call GetMoveScore(SourceIdxOuter)(TargetIdxOuter)(Board[SourceIdxOuter])(Board[TargetIdxOuter])(CalcMovesMoveList[IdxOuter2])(Depth)((1 == 1));
                            List.ReplaceItem(CalcMovesScoreList, IdxOuter2, MoveScoreRes);
                            IdxOuter2 += 1;
                        }
                        Else
                        {
                            Call RevertMove((Depth + 2));
                            List.DeleteItem(CalcMovesMoveList, IdxOuter2);
                            List.DeleteItem(CalcMovesScoreList, IdxOuter2);
                        }
                    }
                }
                Else
                {
                    IdxOuter2 += 1;
                }
            }
        }
        If (Depth == 1)
        {
            If (List.Length(DeepeningScore) == 0)
            {
                Repeat (List.Length(CalcMovesScoreList))
                {
                    List.Add(DeepeningScoreOrderMap, "");
                    List.Add(DeepeningScore, "");
                }
            }
            Else
            {
                Call EvaluateBoard;
                Idx = 1;
                Repeat (List.Length(CalcMovesScoreList))
                {
                    If (DeepeningScore[Idx] == "")
                    {
                        List.ReplaceItem(CalcMovesScoreList, Idx, (EvalResult + CalcMovesScoreList[Idx]));
                    }
                    Else
                    {
                        List.ReplaceItem(CalcMovesScoreList, Idx, DeepeningScore[Idx]);
                    }
                    Idx += 1;
                }
            }
        }
        Call SortMoveList(Depth);
        List.ReplaceItem(MovesCount, Depth, List.Length(CalcMovesMoveList));
    }
}

Define CalculateMovesImplWrapper(string Depth)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    If (IsProfilerEnabled == 1)
    {
        If CalcAttackState
        {
            Call Profile_MethodEnter((30 + Depth));
        }
        Else
        {
            If CapturesOnly
            {
                Call Profile_MethodEnter((60 + Depth));
            }
            Else
            {
                Call Profile_MethodEnter((90 + Depth));
            }
        }
    }
    Call CalculateMovesImpl(Depth)(CalcAttackState)(CapturesOnly)(((Depth % 2) == 1));
    If (IsProfilerEnabled == 1)
    {
        If CalcAttackState
        {
            Call Profile_MethodExit((30 + Depth));
        }
        Else
        {
            If CapturesOnly
            {
                Call Profile_MethodExit((60 + Depth));
            }
            Else
            {
                Call Profile_MethodExit((90 + Depth));
            }
        }
    }
}

Define CalculateOpeningMoves (warp=true)
{
    List.DeleteItem(MinMaxMovesRes, all);
    If (IsImportedBoard == 0)
    {
        If (IsPlayerBlack == 0)
        {
            Idx = 1;
        }
        Else
        {
            Idx = ((List.Length(OpeningMoves) / 2) + 1);
        }
        Repeat ((List.Length(OpeningMoves) / 2))
        {
            If (Variable.Length(GameMoves) < Variable.Length(OpeningMoves[Idx]))
            {
                IdxString = 1;
                IsEqual = 1;
                Repeat (Variable.Length(GameMoves))
                {
                    If (Not ((Operator.LetterOf(GameMoves, IdxString) == Operator.LetterOf(OpeningMoves[Idx], IdxString))))
                    {
                        IsEqual = 0;
                    }
                    IdxString += 1;
                }
                If (IsEqual == 1)
                {
                    BestMove = Operator.LetterOf(OpeningMoves[Idx], (Variable.Length(GameMoves) + 1));
                    BestMove = Operator.Join(BestMove, Operator.LetterOf(OpeningMoves[Idx], (Variable.Length(GameMoves) + 2)));
                    BestMove = Operator.Join(BestMove, Operator.LetterOf(OpeningMoves[Idx], (Variable.Length(GameMoves) + 3)));
                    BestMove = Operator.Join(BestMove, Operator.LetterOf(OpeningMoves[Idx], (Variable.Length(GameMoves) + 4)));
                    List.Add(MinMaxMovesRes, BestMove);
                }
            }
            Idx += 1;
        }
    }
}

Define ClearBoardAttackedByMove(num Depth) (warp=true)
{
    If ((Depth % 2) == 1)
    {
        List.DeleteAll(BoardAttackedByBlack);
        List.DeleteAll(BoardAttackedByBlackPiece);
        Repeat (64)
        {
            List.Add(BoardAttackedByBlack, 0);
            List.Add(BoardAttackedByBlackPiece, 0);
        }
        IsWhiteChecked = 0;
    }
    Else
    {
        List.DeleteAll(BoardAttackedByWhite);
        List.DeleteAll(BoardAttackedByWhitePiece);
        Repeat (64)
        {
            List.Add(BoardAttackedByWhite, 0);
            List.Add(BoardAttackedByWhitePiece, 0);
        }
        IsBlackChecked = 0;
    }
    List.DeleteAll(KingAttackLines);
}

Define ClearLog (warp=true)
{
    List.DeleteItem(Logfile, all);
}

Define ClearMoveList(num Depth) (warp=true)
{
    If (Depth < 6)
    {
        If (Depth == 5)
        {
            List.DeleteItem(Moves5, all);
            List.DeleteItem(Moves5Score, all);
            List.ReplaceItem(MovesCount, 5, 0);
        }
        Else
        {
            If (Depth == 4)
            {
                List.DeleteItem(Moves4, all);
                List.DeleteItem(Moves4Score, all);
                List.ReplaceItem(MovesCount, 4, 0);
            }
            Else
            {
                If (Depth == 3)
                {
                    List.DeleteItem(Moves3, all);
                    List.DeleteItem(Moves3Score, all);
                    List.ReplaceItem(MovesCount, 3, 0);
                }
                Else
                {
                    If (Depth == 2)
                    {
                        List.DeleteItem(Moves2, all);
                        List.DeleteItem(Moves2Score, all);
                        List.ReplaceItem(MovesCount, 2, 0);
                    }
                    Else
                    {
                        If (Depth == 1)
                        {
                            List.DeleteItem(Moves1, all);
                            List.DeleteItem(Moves1Score, all);
                            List.ReplaceItem(MovesCount, 1, 0);
                        }
                    }
                }
            }
        }
    }
    Else
    {
        If (Depth < 11)
        {
            If (Depth == 6)
            {
                List.DeleteItem(Moves6, all);
                List.DeleteItem(Moves6Score, all);
                List.ReplaceItem(MovesCount, 6, 0);
            }
            Else
            {
                If (Depth == 7)
                {
                    List.DeleteItem(Moves7, all);
                    List.DeleteItem(Moves7Score, all);
                    List.ReplaceItem(MovesCount, 7, 0);
                }
                Else
                {
                    If (Depth == 8)
                    {
                        List.DeleteItem(Moves8, all);
                        List.DeleteItem(Moves8Score, all);
                        List.ReplaceItem(MovesCount, 8, 0);
                    }
                    Else
                    {
                        If (Depth == 9)
                        {
                            List.DeleteItem(Moves9, all);
                            List.DeleteItem(Moves9Score, all);
                            List.ReplaceItem(MovesCount, 9, 0);
                        }
                        Else
                        {
                            If (Depth == 10)
                            {
                                List.DeleteItem(Moves10, all);
                                List.DeleteItem(Moves10Score, all);
                                List.ReplaceItem(MovesCount, 10, 0);
                            }
                        }
                    }
                }
            }
        }
        Else
        {
            If (Depth < 16)
            {
                If (Depth == 11)
                {
                    List.DeleteItem(Moves11, all);
                    List.DeleteItem(Moves11Score, all);
                    List.ReplaceItem(MovesCount, 11, 0);
                }
                Else
                {
                    If (Depth == 12)
                    {
                        List.DeleteItem(Moves12, all);
                        List.DeleteItem(Moves12Score, all);
                        List.ReplaceItem(MovesCount, 12, 0);
                    }
                    Else
                    {
                        If (Depth == 13)
                        {
                            List.DeleteItem(Moves13, all);
                            List.DeleteItem(Moves13Score, all);
                            List.ReplaceItem(MovesCount, 13, 0);
                        }
                        Else
                        {
                            If (Depth == 14)
                            {
                                List.DeleteItem(Moves14, all);
                                List.DeleteItem(Moves14Score, all);
                                List.ReplaceItem(MovesCount, 14, 0);
                            }
                            Else
                            {
                                If (Depth == 15)
                                {
                                    List.DeleteItem(Moves15, all);
                                    List.DeleteItem(Moves15Score, all);
                                    List.ReplaceItem(MovesCount, 15, 0);
                                }
                            }
                        }
                    }
                }
            }
            Else
            {
                If (Depth == 16)
                {
                    List.DeleteItem(Moves16, all);
                    List.DeleteItem(Moves16Score, all);
                    List.ReplaceItem(MovesCount, 16, 0);
                }
                Else
                {
                    If (Depth == 17)
                    {
                        List.DeleteItem(Moves17, all);
                        List.DeleteItem(Moves17Score, all);
                        List.ReplaceItem(MovesCount, 17, 0);
                    }
                    Else
                    {
                        If (Depth == 18)
                        {
                            List.DeleteItem(Moves18, all);
                            List.DeleteItem(Moves18Score, all);
                            List.ReplaceItem(MovesCount, 18, 0);
                        }
                        Else
                        {
                            If (Depth == 19)
                            {
                                List.DeleteItem(Moves19, all);
                                List.DeleteItem(Moves19Score, all);
                                List.ReplaceItem(MovesCount, 19, 0);
                            }
                            Else
                            {
                                If (Depth == 20)
                                {
                                    List.DeleteItem(Moves20, all);
                                    List.DeleteItem(Moves20Score, all);
                                    List.ReplaceItem(MovesCount, 20, 0);
                                }
                                Else
                                {
                                    If (Depth == 21)
                                    {
                                        List.DeleteItem(Moves21, all);
                                        List.DeleteItem(Moves21Score, all);
                                        List.ReplaceItem(MovesCount, 21, 0);
                                    }
                                    Else
                                    {
                                        If (Depth == 22)
                                        {
                                            List.DeleteItem(Moves22, all);
                                            List.DeleteItem(Moves22Score, all);
                                            List.ReplaceItem(MovesCount, 22, 0);
                                        }
                                        Else
                                        {
                                            If (Depth == 23)
                                            {
                                                List.DeleteItem(Moves23, all);
                                                List.DeleteItem(Moves23Score, all);
                                                List.ReplaceItem(MovesCount, 23, 0);
                                            }
                                            Else
                                            {
                                                If (Depth == 24)
                                                {
                                                    List.DeleteItem(Moves24, all);
                                                    List.DeleteItem(Moves24Score, all);
                                                    List.ReplaceItem(MovesCount, 24, 0);
                                                }
                                                Else
                                                {
                                                    If (Depth == 25)
                                                    {
                                                        List.DeleteItem(Moves25, all);
                                                        List.DeleteItem(Moves25Score, all);
                                                        List.ReplaceItem(MovesCount, 25, 0);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

Define ClearTT (warp=true)
{
    List.DeleteItem(TTNodeHash, all);
    List.DeleteItem(TTNodeBestMove, all);
    List.DeleteItem(TTNodeScore, all);
    List.DeleteItem(TTNodeDepth, all);
    List.DeleteItem(TTNodeAge, all);
    List.DeleteItem(TTNodeType, all);
    List.DeleteItem(TTNodeChecked, all);
    List.DeleteItem(TTNodeHorizon, all);
    List.DeleteItem(TTNodeBlackMobility, all);
    List.DeleteItem(TTNodeWhiteMobility, all);
    List.DeleteItem(TTBoardAge, all);
    List.DeleteItem(TTBoardHash, all);
    List.DeleteItem(TTBoardScore1, all);
    List.DeleteItem(TTBoardScore2, all);
    List.DeleteItem(TTBoardScore3, all);
    List.DeleteItem(TTNodeBoardAttackedByOpp, all);
    List.DeleteItem(TTNodeBoardAttackedByOppPiece, all);
    If (IsScratch3 == 1)
    {
        Count = 200000;
    }
    Else
    {
        Count = 2000000;
    }
    Repeat (Count)
    {
        List.Add(TTNodeHash, "");
        List.Add(TTNodeBestMove, "");
        List.Add(TTNodeScore, "");
        List.Add(TTNodeDepth, "");
        List.Add(TTNodeAge, "");
        List.Add(TTNodeType, "");
        List.Add(TTNodeChecked, "");
        List.Add(TTNodeHorizon, "");
        List.Add(TTNodeBlackMobility, "");
        List.Add(TTNodeWhiteMobility, "");
        List.Add(TTBoardAge, "");
        List.Add(TTBoardHash, "");
        List.Add(TTBoardScore1, "");
        List.Add(TTBoardScore2, "");
        List.Add(TTBoardScore3, "");
        List.Add(TTNodeBoardAttackedByOpp, "");
        List.Add(TTNodeBoardAttackedByOppPiece, "");
    }
}

Define DrawBoard (warp=true)
{
    ProgressValue = 0;
    Event.Broadcast("drawboard");
    Event.Broadcast("progressvaluechanged");
    Event.Broadcast("evaluationvaluechanged");
}

Define DrawBoardAndWait (warp=false)
{
    Idx += 1;
    ProgressValue = 0;
    Event.BroadcastAndWait("drawboard");
    Event.BroadcastAndWait("progressvaluechanged");
    Event.BroadcastAndWait("evaluationvaluechanged");
}

Define EnterExecution (warp=true)
{
    ExecutionDepth += 1;
    If (ExecutionDepth > 0)
    {
        IsExecutionRunning = 1;
    }
}

Define EvaluateBoard (warp=true)
{
    EvalResult = 0;
    Idx = 1;
    Repeat (64)
    {
        CurrentPiece = Board[Idx];
        If (Not ((CurrentPiece == Empty)))
        {
            If ((abs(CurrentPiece) == BlackPawn) And (IsEndgame == 1))
            {
                EvalResult += (1.2 * CurrentPiece);
            }
            Else
            {
                EvalResult += CurrentPiece;
            }
            Call GetPiecePosScore(CurrentPiece)(Idx);
            EvalResult += PosScoreRes;
        }
        Idx += 1;
    }
}

Define EvaluateBoardExtended1(string Depth) (warp=true)
{
    If (IsProfilerEnabled > 0)
    {
        Call Profile_MethodEnter((240 + Depth));
    }
    Call TTProbeBoard(CurrentBoardHash);
    If ((TTProbeRes == 1) And (Not ((TTProbeBoardScore1Res == ""))))
    {
        EvalExtendedResult1 = TTProbeBoardScore1Res;
        If (IsProfilerEnabled > 0)
        {
            Call Profile_MethodExit((240 + Depth));
        }
        Stop(this script);
    }
    BlackKingEndgameTargetIdx = 0;
    WhiteKingEndgameTargetIdx = 0;
    EvalExtendedResult1 = 0;
    List.DeleteItem(PawnAdvancePerFile, all);
    Repeat (32)
    {
        List.Add(PawnAdvancePerFile, 0);
    }
    Idx = 1;
    Repeat (64)
    {
        If (abs(Board[Idx]) == BlackPawn)
        {
            If (Board[Idx] > 0)
            {
                File = IdxToFile[Idx];
                Rank = IdxToRank[Idx];
                If (Idx > 16)
                {
                    If (((File > 1) And (Board[(Idx - 9)] == BlackPawn)) Or ((File < 8) And (Board[(Idx - 7)] == BlackPawn)))
                    {
                        If (Board[(Idx + 8)] == WhitePawn)
                        {
                            EvalExtendedResult1 += (2 * ((Rank - 2) * ((IsEndgame + IsEndgame2) + 1)));
                        }
                        Else
                        {
                            EvalExtendedResult1 += (5 * ((Rank - 2) * ((IsEndgame + IsEndgame2) + 1)));
                        }
                    }
                }
                If ((PawnAdvancePerFile[(File + 16)] == 0) Or (Rank < PawnAdvancePerFile[(File + 16)]))
                {
                    List.ReplaceItem(PawnAdvancePerFile, (File + 16), Rank);
                }
                If (Rank > PawnAdvancePerFile[(File + 24)])
                {
                    List.ReplaceItem(PawnAdvancePerFile, (File + 24), Rank);
                }
            }
            Else
            {
                File = IdxToFile[Idx];
                Rank = IdxToRank[Idx];
                If (Idx < 49)
                {
                    If (((File > 1) And (Board[(Idx + 7)] == WhitePawn)) Or ((File < 8) And (Board[(Idx + 9)] == WhitePawn)))
                    {
                        If (Board[(Idx - 8)] == BlackPawn)
                        {
                            EvalExtendedResult1 += (-2 * ((7 - Rank) * ((IsEndgame + IsEndgame2) + 1)));
                        }
                        Else
                        {
                            EvalExtendedResult1 += (-5 * ((7 - Rank) * ((IsEndgame + IsEndgame2) + 1)));
                        }
                    }
                }
                If (Rank > PawnAdvancePerFile[File])
                {
                    List.ReplaceItem(PawnAdvancePerFile, File, Rank);
                }
                If ((PawnAdvancePerFile[(File + 8)] == 0) Or (Rank < PawnAdvancePerFile[(File + 8)]))
                {
                    List.ReplaceItem(PawnAdvancePerFile, (File + 8), Rank);
                }
            }
        }
        If (abs(Board[Idx]) == BlackQueen)
        {
            If (((List.Length(GameMovesAN) + Depth) < 16) And (IsImportedBoard == 0))
            {
                If (Board[Idx] > 0)
                {
                    If (IdxToRank[Idx] > 2)
                    {
                        EvalExtendedResult1 += Operator.Round((-80 * ((16 - (List.Length(GameMovesAN) + Depth)) / 16)));
                    }
                }
                Else
                {
                    If (IdxToRank[Idx] < 7)
                    {
                        EvalExtendedResult1 += Operator.Round((80 * ((16 - (List.Length(GameMovesAN) + Depth)) / 16)));
                    }
                }
            }
        }
        Idx += 1;
    }
    Idx = 1;
    BlackRank = 1;
    WhiteRank = 8;
    Repeat (8)
    {
        If ((IsEndgame == 1) Or (1 == 1))
        {
            WhitePawnBackwardRank = PawnAdvancePerFile[Idx];
            WhitePawnForwardRank = PawnAdvancePerFile[(Idx + 8)];
            BlackPawnBackwardRank = PawnAdvancePerFile[(Idx + 16)];
            BlackPawnForwardRank = PawnAdvancePerFile[(Idx + 24)];
            If ((WhitePawnForwardRank < 6) And (WhitePawnForwardRank > 0))
            {
                If ((WhitePawnForwardRank < BlackPawnBackwardRank) Or (BlackPawnBackwardRank == 0))
                {
                    EvalExtendedResult1 += (-10 * (6 - WhitePawnForwardRank));
                    LeftOppPawnRank = PawnAdvancePerFile[((Idx + 16) - 1)];
                    RightOppPawnRank = PawnAdvancePerFile[((Idx + 16) + 1)];
                    If ((((Idx == 1) Or (LeftOppPawnRank == 0)) Or (WhitePawnForwardRank < LeftOppPawnRank)) And (((Idx == 8) Or (RightOppPawnRank == 0)) Or (WhitePawnForwardRank < RightOppPawnRank)))
                    {
                        If (Not ((PawnPromotionFile[2] == Idx)))
                        {
                            EvalExtendedResult1 += (-15 * (6 - WhitePawnForwardRank));
                        }
                        If ((BlackKingEndgameTargetIdx == 0) Or (WhitePawnForwardRank < WhiteRank))
                        {
                            WhiteRank = WhitePawnForwardRank;
                            BlackKingEndgameTargetIdx = (0 + Idx);
                        }
                    }
                }
            }
            If (BlackPawnForwardRank > 3)
            {
                If (BlackPawnForwardRank > WhitePawnBackwardRank)
                {
                    EvalExtendedResult1 += (10 * (BlackPawnForwardRank - 3));
                    LeftOppPawnRank = PawnAdvancePerFile[(Idx - 1)];
                    RightOppPawnRank = PawnAdvancePerFile[(Idx + 1)];
                    If ((((Idx == 1) Or (LeftOppPawnRank == 0)) Or (BlackPawnForwardRank > LeftOppPawnRank)) And (((Idx == 8) Or (RightOppPawnRank == 0)) Or (BlackPawnForwardRank > RightOppPawnRank)))
                    {
                        If (Not ((PawnPromotionFile[1] == Idx)))
                        {
                            EvalExtendedResult1 += (15 * (BlackPawnForwardRank - 3));
                        }
                        If ((WhiteKingEndgameTargetIdx == 0) Or (BlackPawnForwardRank > BlackRank))
                        {
                            BlackRank = BlackPawnForwardRank;
                            WhiteKingEndgameTargetIdx = (56 + Idx);
                        }
                    }
                }
            }
        }
        If (BlackPawnCount[Idx] > 1)
        {
            EvalExtendedResult1 += (-30 * (BlackPawnCount[Idx] - 1));
        }
        If (WhitePawnCount[Idx] > 1)
        {
            EvalExtendedResult1 += (30 * (WhitePawnCount[Idx] - 1));
        }
        Idx += 1;
    }
    If (IsEndgame == 0)
    {
        KingProtection = 0;
        KingRank = IdxToRank[BlackKingIdx];
        KingFile = IdxToFile[BlackKingIdx];
        If (KingFile == 1)
        {
            KingFile = 2;
        }
        Else
        {
            If (KingFile == 8)
            {
                KingFile = 7;
            }
        }
        File = (KingFile - 1);
        Repeat (3)
        {
            WhitePawnForwardRank = PawnAdvancePerFile[(File + 8)];
            BlackPawnBackwardRank = PawnAdvancePerFile[(File + 16)];
            If ((BlackPawnBackwardRank > 0) And (KingRank < BlackPawnBackwardRank))
            {
                KingProtection += PawnShelter[(((File - 1) * 8) + BlackPawnBackwardRank)];
            }
            Else
            {
                KingProtection += PawnShelter[(((File - 1) * 8) + 1)];
            }
            If ((WhitePawnForwardRank > 0) And (KingRank < WhitePawnForwardRank))
            {
                CurrentValue = (0 - PawnStorm[(((File - 1) * 8) + WhitePawnForwardRank)]);
                If ((BlackPawnBackwardRank > 0) And (BlackPawnBackwardRank < WhitePawnForwardRank))
                {
                    KingProtection += Operator.Round((CurrentValue * 0.5));
                }
                Else
                {
                    KingProtection += CurrentValue;
                }
            }
            Else
            {
                KingProtection += (0 - PawnStorm[(((File - 1) * 8) + 1)]);
            }
            File += 1;
        }
        If (IsBlackCastlingPossible == 1)
        {
            EvalExtendedResult1 += Operator.Round(((KingProtection * 0.5) + (WhiteQueenCount * 0)));
        }
        Else
        {
            EvalExtendedResult1 += Operator.Round(((KingProtection * 0.5) + (WhiteQueenCount * 0.5)));
        }
    }
    If (IsEndgame == 0)
    {
        KingProtection = 0;
        KingRank = IdxToRank[WhiteKingIdx];
        KingFile = IdxToFile[WhiteKingIdx];
        If (KingFile == 1)
        {
            KingFile = 2;
        }
        Else
        {
            If (KingFile == 8)
            {
                KingFile = 7;
            }
        }
        File = (KingFile - 1);
        Repeat (3)
        {
            WhitePawnBackwardRank = PawnAdvancePerFile[File];
            BlackPawnForwardRank = PawnAdvancePerFile[(File + 24)];
            If ((WhitePawnBackwardRank > 0) And (KingRank > WhitePawnBackwardRank))
            {
                KingProtection += PawnShelter[(((File - 1) * 8) + (9 - WhitePawnBackwardRank))];
            }
            Else
            {
                KingProtection += PawnShelter[(((File - 1) * 8) + 1)];
            }
            If ((BlackPawnForwardRank > 0) And (KingRank > BlackPawnForwardRank))
            {
                CurrentValue = (0 - PawnStorm[(((File - 1) * 8) + (9 - BlackPawnForwardRank))]);
                If ((WhitePawnBackwardRank > 0) And (WhitePawnBackwardRank > BlackPawnForwardRank))
                {
                    KingProtection += Operator.Round((CurrentValue * 0.5));
                }
                Else
                {
                    KingProtection += CurrentValue;
                }
            }
            Else
            {
                KingProtection += (0 - PawnStorm[(((File - 1) * 8) + 1)]);
            }
            File += 1;
        }
        If (IsWhiteCastlingPossible == 1)
        {
            EvalExtendedResult1 += (0 - Operator.Round(((KingProtection * 0.5) + (BlackQueenCount * 0))));
        }
        Else
        {
            EvalExtendedResult1 += (0 - Operator.Round(((KingProtection * 0.5) + (BlackQueenCount * 0.5))));
        }
    }
    If ((IsEndgame == 1) And ((PawnPromotionFile[1] == "") And (PawnPromotionFile[2] == "")))
    {
        If ((BlackKingEndgameTargetIdx == 0) Or (((BlackQueenCount * 3) + BlackMinorCount) > ((WhiteQueenCount * 3) + WhiteMinorCount)))
        {
            BlackKingEndgameTargetIdx = WhiteKingEndgameTargetIdx;
        }
        If ((WhiteKingEndgameTargetIdx == 0) Or (((WhiteQueenCount * 3) + WhiteMinorCount) > ((BlackQueenCount * 3) + BlackMinorCount)))
        {
            WhiteKingEndgameTargetIdx = BlackKingEndgameTargetIdx;
        }
        If (Not ((BlackKingEndgameTargetIdx == 0)))
        {
            Delta = abs((IdxToRank[BlackKingEndgameTargetIdx] - IdxToRank[BlackKingIdx]));
            If (Delta < abs((IdxToFile[BlackKingEndgameTargetIdx] - IdxToFile[BlackKingIdx])))
            {
                Delta = abs((IdxToFile[BlackKingEndgameTargetIdx] - IdxToFile[BlackKingIdx]));
            }
            EvalExtendedResult1 += (-25 * Delta);
        }
        If (Not ((WhiteKingEndgameTargetIdx == 0)))
        {
            Delta = abs((IdxToRank[WhiteKingEndgameTargetIdx] - IdxToRank[WhiteKingIdx]));
            If (Delta < abs((IdxToFile[WhiteKingEndgameTargetIdx] - IdxToFile[WhiteKingIdx])))
            {
                Delta = abs((IdxToFile[WhiteKingEndgameTargetIdx] - IdxToFile[WhiteKingIdx]));
            }
            EvalExtendedResult1 += (25 * Delta);
        }
        If (IsEndgame2 == 1)
        {
            Delta = abs((IdxToRank[WhiteKingIdx] - IdxToRank[BlackKingIdx]));
            If (Delta < abs((IdxToFile[WhiteKingIdx] - IdxToFile[BlackKingIdx])))
            {
                Delta = abs((IdxToFile[WhiteKingIdx] - IdxToFile[BlackKingIdx]));
            }
            If (((WhiteQueenCount + WhiteMinorCount) == 0) And (BlackKingEndgameTargetIdx == 0))
            {
                EvalExtendedResult1 += (-35 * Delta);
            }
            If (((BlackQueenCount + BlackMinorCount) == 0) And (WhiteKingEndgameTargetIdx == 0))
            {
                EvalExtendedResult1 += (35 * Delta);
            }
        }
    }
    Call TTStoreBoard(CurrentBoardHash)(EvalExtendedResult1)("")("");
    If (IsProfilerEnabled > 0)
    {
        Call Profile_MethodExit((240 + Depth));
    }
}

Define EvaluateBoardExtended2(string Depth) (warp=true)
{
    EvalExtendedResult2 = 0;
    If ((HasBlackCastled == 0) And ((IsEndgame == 0) Or ((BlackMinorCount > 2) Or (BlackQueenCount > 0))))
    {
        HasBlackCastledStateLocal = 0;
        If (IsBlackCastlingPossible == 1)
        {
            If ((Moves1[MovesIdx[1]] == BlackKingsideCastling) Or (Moves1[MovesIdx[1]] == BlackQueensideCastling))
            {
                HasBlackCastledStateLocal = 1;
            }
            Else
            {
                If (Depth > 2)
                {
                    If ((Moves3[MovesIdx[3]] == BlackKingsideCastling) Or (Moves3[MovesIdx[3]] == BlackQueensideCastling))
                    {
                        HasBlackCastledStateLocal = 2;
                    }
                    Else
                    {
                        If (Depth > 4)
                        {
                            If ((Moves5[MovesIdx[5]] == BlackKingsideCastling) Or (Moves5[MovesIdx[5]] == BlackQueensideCastling))
                            {
                                HasBlackCastledStateLocal = 3;
                            }
                            Else
                            {
                                If (Depth > 6)
                                {
                                    If ((Moves7[MovesIdx[7]] == BlackKingsideCastling) Or (Moves7[MovesIdx[7]] == BlackQueensideCastling))
                                    {
                                        HasBlackCastledStateLocal = 4;
                                    }
                                    Else
                                    {
                                        If (Depth > 8)
                                        {
                                            If ((Moves9[MovesIdx[9]] == BlackKingsideCastling) Or (Moves9[MovesIdx[9]] == BlackQueensideCastling))
                                            {
                                                HasBlackCastledStateLocal = 5;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        If (HasBlackCastledStateLocal > 0)
        {
            If (HasBlackCastledStateLocal == 1)
            {
                KingProtection = 90;
            }
            Else
            {
                KingProtection = 80;
            }
        }
        Else
        {
            If ((IsBlackCastlingPossible == 1) And (Not (List.ContainsItem(SourcePieces, BlackKing))))
            {
                If (Not (List.ContainsItem(SourcePieces, BlackRook)))
                {
                    KingProtection = 70;
                }
                Else
                {
                    If ((Board[VirtualBoard[1]] == BlackRook) Or (Board[VirtualBoard[8]] == BlackRook))
                    {
                        KingProtection = 40;
                    }
                    Else
                    {
                        KingProtection = 0;
                    }
                }
            }
            Else
            {
                KingProtection = 0;
            }
        }
        EvalExtendedResult2 += Operator.Round(((KingProtection * 0.5) + (WhiteQueenCount * 0.5)));
        If (IdxToRank[BlackKingIdx] == 1)
        {
            If (IdxToFile[BlackKingIdx] < 4)
            {
                If ((Board[1] == BlackRook) Or (Board[2] == BlackRook))
                {
                    If ((BlackKingIdx == 2) Or (BlackKingIdx == 3))
                    {
                        EvalExtendedResult2 += -50;
                    }
                }
                Else
                {
                    If ((Board[9] == BlackRook) Or (Board[10] == BlackRook))
                    {
                        If ((Board[10] == BlackPawn) Or (Board[11] == BlackPawn))
                        {
                            EvalExtendedResult2 += -50;
                        }
                    }
                }
            }
            Else
            {
                If ((Board[7] == BlackRook) Or (Board[8] == BlackRook))
                {
                    If ((BlackKingIdx == 6) Or (BlackKingIdx == 7))
                    {
                        EvalExtendedResult2 += -50;
                    }
                }
                Else
                {
                    If ((Board[15] == BlackRook) Or (Board[16] == BlackRook))
                    {
                        If ((Board[14] == BlackPawn) Or (Board[15] == BlackPawn))
                        {
                            EvalExtendedResult2 += -50;
                        }
                    }
                }
            }
        }
    }
    If ((HasWhiteCastled == 0) And ((IsEndgame == 0) Or ((WhiteMinorCount > 2) Or (WhiteQueenCount > 0))))
    {
        HasWhiteCastledStateLocal = 0;
        If (IsWhiteCastlingPossible == 1)
        {
            If (Depth > 1)
            {
                If ((Moves2[MovesIdx[2]] == WhiteKingsideCastling) Or (Moves2[MovesIdx[2]] == WhiteQueensideCastling))
                {
                    HasWhiteCastledStateLocal = 1;
                }
                If (Depth > 3)
                {
                    If ((Moves4[MovesIdx[4]] == WhiteKingsideCastling) Or (Moves4[MovesIdx[4]] == WhiteQueensideCastling))
                    {
                        HasWhiteCastledStateLocal = 2;
                    }
                    If (Depth > 5)
                    {
                        If ((Moves6[MovesIdx[6]] == WhiteKingsideCastling) Or (Moves6[MovesIdx[6]] == WhiteQueensideCastling))
                        {
                            HasWhiteCastledStateLocal = 3;
                        }
                        If (Depth > WhiteRook)
                        {
                            If ((Moves8[MovesIdx[8]] == WhiteKingsideCastling) Or (Moves8[MovesIdx[8]] == WhiteQueensideCastling))
                            {
                                HasWhiteCastledStateLocal = 4;
                            }
                            If (Depth > 9)
                            {
                                If ((Moves10[MovesIdx[10]] == WhiteKingsideCastling) Or (Moves10[MovesIdx[10]] == WhiteQueensideCastling))
                                {
                                    HasWhiteCastledStateLocal = 5;
                                }
                            }
                        }
                    }
                }
            }
        }
        If (HasWhiteCastledStateLocal > 0)
        {
            If (HasWhiteCastledStateLocal == 1)
            {
                KingProtection = 90;
            }
            Else
            {
                KingProtection = 80;
            }
        }
        Else
        {
            If ((IsWhiteCastlingPossible == 1) And (Not (List.ContainsItem(SourcePieces, WhiteKing))))
            {
                If (Not (List.ContainsItem(SourcePieces, WhiteRook)))
                {
                    KingProtection = 70;
                }
                Else
                {
                    If ((Board[VirtualBoard[64]] == WhiteRook) Or (Board[VirtualBoard[57]] == WhiteRook))
                    {
                        KingProtection = 40;
                    }
                    Else
                    {
                        KingProtection = 0;
                    }
                }
            }
            Else
            {
                KingProtection = 0;
            }
        }
        EvalExtendedResult2 += (0 - Operator.Round(((KingProtection * 0.5) + (BlackQueenCount * 0.5))));
        If (IdxToRank[WhiteKingIdx] == 8)
        {
            If (IdxToFile[WhiteKingIdx] < 4)
            {
                If ((Board[57] == WhiteRook) Or (Board[58] == WhiteRook))
                {
                    If ((WhiteKingIdx == 58) Or (WhiteKingIdx == 59))
                    {
                        EvalExtendedResult2 += 50;
                    }
                }
                Else
                {
                    If ((Board[49] == WhiteRook) Or (Board[50] == WhiteRook))
                    {
                        If ((Board[50] == WhitePawn) Or (Board[51] == WhitePawn))
                        {
                            EvalExtendedResult2 += 50;
                        }
                    }
                }
            }
            Else
            {
                If ((Board[63] == WhiteRook) Or (Board[64] == WhiteRook))
                {
                    If ((WhiteKingIdx == 62) Or (WhiteKingIdx == 63))
                    {
                        EvalExtendedResult2 += 50;
                    }
                }
                Else
                {
                    If ((Board[55] == WhiteRook) Or (Board[56] == WhiteRook))
                    {
                        If ((Board[54] == WhitePawn) Or (Board[55] == WhitePawn))
                        {
                            EvalExtendedResult2 += 50;
                        }
                    }
                }
            }
        }
    }
}

Define EvaluateBoardExtended3(string Depth) (warp=true)
{
    EvalExtendedResult3 = 0;
    If (IsEndgame == 1)
    {
        Stop(this script);
    }
    If (IsProfilerEnabled > 0)
    {
        Call Profile_MethodEnter((270 + Depth));
    }
    Call TTProbeBoard(CurrentBoardHash);
    If ((TTProbeRes == 1) And (Not ((TTProbeBoardScore3Res == ""))))
    {
        EvalExtendedResult3 = TTProbeBoardScore3Res;
        If (IsProfilerEnabled > 0)
        {
            Call Profile_MethodExit((270 + Depth));
        }
        Stop(this script);
    }
    If (1 == 1)
    {
        Rank = (IdxToRank[BlackKingIdx] - 1);
        File = (IdxToFile[BlackKingIdx] - 1);
        Repeat (3)
        {
            If ((Rank > 0) And (Rank < 9))
            {
                Repeat (3)
                {
                    If ((File > 0) And (File < 9))
                    {
                        Idx = (((Rank - 1) * 8) + File);
                        If (Not ((Idx == BlackKingIdx)))
                        {
                            If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], Idx) > 0)
                            {
                                EvalExtendedResult3 += -15;
                                If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], Idx) > 1)
                                {
                                    EvalExtendedResult3 += -30;
                                    If (Operator.LetterOf(BoardAttackedByBlackPieceSnapshot[Depth], Idx) < PieceIdxLookup[BlackQueen])
                                    {
                                        EvalExtendedResult3 += 20;
                                    }
                                }
                            }
                        }
                    }
                    File += 1;
                }
                File += -3;
            }
            Rank += 1;
        }
    }
    If (1 == 1)
    {
        Rank = (IdxToRank[WhiteKingIdx] - 1);
        File = (IdxToFile[WhiteKingIdx] - 1);
        Repeat (3)
        {
            If ((Rank > 0) And (Rank < 9))
            {
                Repeat (3)
                {
                    If ((File > 0) And (File < 9))
                    {
                        Idx = (((Rank - 1) * 8) + File);
                        If (Not ((Idx == WhiteKingIdx)))
                        {
                            If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], Idx) > 0)
                            {
                                EvalExtendedResult3 += 15;
                                If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], Idx) > 1)
                                {
                                    EvalExtendedResult3 += 30;
                                    If (Operator.LetterOf(BoardAttackedByWhitePieceSnapshot[Depth], Idx) < PieceIdxLookup[BlackQueen])
                                    {
                                        EvalExtendedResult3 += -20;
                                    }
                                }
                            }
                        }
                    }
                    File += 1;
                }
                File += -3;
            }
            Rank += 1;
        }
    }
    Call TTStoreBoard(CurrentBoardHash)("")("")(EvalExtendedResult3);
    If (IsProfilerEnabled > 0)
    {
        Call Profile_MethodExit((270 + Depth));
    }
}

Define ExecuteEngineMove (warp=false)
{
    Call EnterExecution;
    If (IsGameSuspended == 0)
    {
        Event.Broadcast("OpeningBookHide");
        List.DeleteItem(MinMaxMovesRes, all);
        BestMove = "";
        If (IsModeJunior == 0)
        {
            Call CalculateOpeningMoves;
            If (List.Length(MinMaxMovesRes) > 0)
            {
                Event.Broadcast("OpeningBookShow");
            }
            BestMove = MinMaxMovesRes[Operator.Random(1 / List.Length(MinMaxMovesRes))];
        }
        Call IsValidMove(BestMove);
        If (ValidMoveRes == 0)
        {
            Looks.Think("Thinking...");
            Control.Wait(0);
            Call InitAlphaBeta(1)(1)((1 == 1));
            If (IsModeJunior == 0)
            {
                If (Level == 1)
                {
                    ThinkTimeLimit = 5;
                }
                Else
                {
                    If (Level == 2)
                    {
                        ThinkTimeLimit = 10;
                    }
                    Else
                    {
                        If (IsModeCompetition == 0)
                        {
                            If (IsEndgame == 0)
                            {
                                ThinkTimeLimit = 20;
                            }
                            Else
                            {
                                ThinkTimeLimit = 15;
                            }
                        }
                        Else
                        {
                            ThinkTimeLimit = 40;
                        }
                    }
                }
                ThinkTimeStart = (Sensing.DaysSince2000() * 86400);
                IsDeepeningDone = 0;
                IdxDeepening = 1;
                BestMove = "";
                BestMinMaxRes = "";
                If (Level == 1)
                {
                    List.DeleteItem(MinMaxMovesRes, all);
                    Call AlphaBetaMinMax(-100000)(100000)(1)((IdxDeepening + 1))((1 == 1))(10)((1 == 1));
                    If (List.Length(MinMaxMovesRes) > 0)
                    {
                        BestMove = MinMaxMovesRes[1];
                        BestMinMaxRes = MinMaxValuesRes[1];
                    }
                    If (Not (((BestMinMaxRes > (BlackKing / 2)) Or (BestMinMaxRes < (WhiteKing / 2)))))
                    {
                        IdxDeepening += 1;
                        List.DeleteItem(MinMaxMovesRes, all);
                        Call AlphaBetaMinMax(-100000)(100000)(1)((IdxDeepening + 1))((1 == 0))(10)((1 == 1));
                        If (List.Length(MinMaxMovesRes) > 0)
                        {
                            BestMove = MinMaxMovesRes[1];
                            BestMinMaxRes = MinMaxValuesRes[1];
                        }
                    }
                }
                Else
                {
                    Repeat Until (IsDeepeningDone == 1)
                    {
                        IsDone = 0;
                        QuiescenceDepth = (25 - IdxDeepening);
                        If (IdxDeepening < 4)
                        {
                            ThinkTimeLimitMinMax = (ThinkTimeLimit * 3);
                        }
                        Else
                        {
                            ThinkTimeLimitMinMax = ThinkTimeLimit;
                        }
                        If (((IsScratch3 == 1) And (IdxDeepening > 99)) Or ((IsScratch3 == 0) And (IdxDeepening > 99)))
                        {
                            If (IsScratch3 == 1)
                            {
                                If ((IdxDeepening % 2) == 0)
                                {
                                    PruningAlphaWindow = 30;
                                    PruningBetaWindow = 10;
                                }
                                Else
                                {
                                    PruningAlphaWindow = 10;
                                    PruningBetaWindow = 30;
                                }
                            }
                            Else
                            {
                                If ((IdxDeepening % 2) == 0)
                                {
                                    PruningAlphaWindow = 30;
                                    PruningBetaWindow = 10;
                                }
                                Else
                                {
                                    PruningAlphaWindow = 10;
                                    PruningBetaWindow = 30;
                                }
                            }
                            Repeat Until ((IsDone == 1) Or (IsMinMaxTimeout == 1))
                            {
                                PruningAlpha = (BestMinMaxRes - PruningAlphaWindow);
                                PruningBeta = (BestMinMaxRes + PruningBetaWindow);
                                List.DeleteItem(MinMaxMovesRes, all);
                                Call AlphaBetaMinMax(PruningAlpha)(PruningBeta)(1)((IdxDeepening + 1))((IdxDeepening == 1))(QuiescenceDepth)((1 == 1));
                                If (Not ((MinMaxResults[1] > PruningAlpha)))
                                {
                                    TTProbeCurrentAge += -1;
                                    PruningAlphaWindow = 100000;
                                    PruningBetaWindow = 100000;
                                }
                                Else
                                {
                                    If (Not ((MinMaxResults[1] < PruningBeta)))
                                    {
                                        TTProbeCurrentAge += -1;
                                        PruningAlphaWindow = 100000;
                                        PruningBetaWindow = 100000;
                                    }
                                    Else
                                    {
                                        IsDone = 1;
                                    }
                                }
                            }
                        }
                        Else
                        {
                            List.DeleteItem(MinMaxMovesRes, all);
                            Call AlphaBetaMinMax(-100000)(100000)(1)((IdxDeepening + 1))((IdxDeepening == 1))(QuiescenceDepth)((1 == 1));
                            IsDone = 1;
                        }
                        If (IsDone == 1)
                        {
                            If ((List.Length(MinMaxMovesRes) > 0) And (Variable.Length(MinMaxMovesRes[1]) > 0))
                            {
                                If ((BestMove == "") Or List.ContainsItem(MinMaxPly1EvalMoves, BestMove))
                                {
                                    BestMove = MinMaxMovesRes[1];
                                    BestMinMaxRes = MinMaxValuesRes[1];
                                    Call OnEvaluationChanged(BestMinMaxRes);
                                }
                            }
                        }
                        If (((IsMinMaxTimeout == 1) Or (IdxDeepening == 25)) Or (abs(BestMinMaxRes) > (BlackKing / 2)))
                        {
                            IsDeepeningDone = 1;
                        }
                        Else
                        {
                            IdxDeepening += 1;
                        }
                    }
                }
            }
            Else
            {
                List.DeleteItem(MinMaxMovesRes, all);
                If (Level == 1)
                {
                    JuniorDistQuota = 50;
                    JuniorSearchQuota = 1;
                }
                Else
                {
                    If (Level == 2)
                    {
                        JuniorDistQuota = 20;
                        JuniorSearchQuota = 50;
                    }
                    Else
                    {
                        JuniorDistQuota = 1;
                        JuniorSearchQuota = 100;
                    }
                }
                ThinkTimeStart = (Sensing.DaysSince2000() * 86400);
                ThinkTimeLimitMinMax = 2;
                Call AlphaBetaMinMax(-100000)(100000)(1)(2)((1 == 0))(10)((1 == 1));
                BestMove = MinMaxMovesRes[1];
                If ((BestMove == "") Or (Operator.Random(1 / 100) > JuniorSearchQuota))
                {
                    Call CalculateMoves(1);
                    List.ReplaceItem(MovesIdx, 1, Operator.Random(1 / ceiling((List.Length(Moves1) * (JuniorDistQuota / 100)))));
                    Call ApplyMove(1);
                    Call CalcBoardAttackedByMove(2);
                    Call RevertMove(1);
                    Repeat Until (IsBlackChecked == 0)
                    {
                        List.ReplaceItem(MovesIdx, 1, Operator.Random(1 / List.Length(Moves1)));
                        Call ApplyMove(1);
                        Call CalcBoardAttackedByMove(2);
                        Call RevertMove(1);
                    }
                    BestMove = Moves1[MovesIdx[1]];
                }
            }
        }
        Event.BroadcastAndWait("hidebestmove");
        Call OnProgressChanged(100);
        Control.Wait(0);
        Call IsValidMove(BestMove);
        If (ValidMoveRes == 0)
        {
            Looks.Say(Operator.Join("Internal Error: No valid move found. Sorry, this should not happen. Maybe you cleared lookup lists in the editor? If you are running a normal game, please export board data and report bug via project comment", Operator.Join(" Move: ", BestMove)), 10);
            Event.Broadcast("inputmode");
            IsGameSuspended = 1;
            Call ExecuteMovePostProcess;
            Call ExitExecution;
            Stop(this script);
        }
        Looks.Think("");
        MovePieceFromIdx = floor((BestMove / 100));
        MovePieceToIdx = floor((BestMove % 100));
        If (((BestMove == BlackQueensideCastling) Or (BestMove == BlackKingsideCastling)) Or ((BestMove == WhiteQueensideCastling) Or (BestMove == WhiteKingsideCastling)))
        {
            MovePieceSpecial = BestMove;
        }
        Else
        {
            MovePieceSpecial = "";
        }
        Control.Wait(0);
        Event.BroadcastAndWait("movepiece");
        Event.Broadcast("SoundMove");
        GameMoves = Operator.Join(GameMoves, BestMove);
        Call GetMoveNotation(BestMove);
        List.Add(GameMovesAN, MoveNotationRes);
        List.DeleteItem(Moves1, all);
        List.Add(Moves1, BestMove);
        List.ReplaceItem(MovesIdx, 1, 1);
        List.ReplaceItem(MovesCount, 1, 1);
        Call ApplyMove(1);
        Call DrawBoardAndWait;
        Call AddBoardToHistory;
        Call GetRepetitionCount;
        If (RepetitionCountRes > 2)
        {
            Looks.Say("Draw!");
            Event.Broadcast("SoundDraw");
            Event.Broadcast("inputmode");
            IsGameSuspended = 1;
        }
        Else
        {
            Call IsDrawByMaterial;
            If (IsDrawRes == 1)
            {
                Looks.Say("Draw!");
                Event.Broadcast("SoundDraw");
                Event.Broadcast("inputmode");
                IsGameSuspended = 1;
            }
            Else
            {
                Call IsWhiteKingCheckMate;
                If (IsWhiteKingCheckMateRes == 1)
                {
                    Looks.Say("Checkmate!");
                    Event.Broadcast("SoundCheckmate");
                    Event.Broadcast("inputmode");
                    IsGameSuspended = 1;
                }
                Else
                {
                    Call IsDrawByStalemate(2);
                    If (IsDrawRes == 1)
                    {
                        Looks.Say("Draw!");
                        Event.Broadcast("SoundDraw");
                        Event.Broadcast("inputmode");
                        IsGameSuspended = 1;
                    }
                    Else
                    {
                        Call CalcBoardAttackedByMove(1);
                        If (IsWhiteChecked == 1)
                        {
                            Call SayAsync("Check!")(2);
                            Event.Broadcast("SoundCheck");
                        }
                        If (Board[(BestMove % 100)] == BlackKing)
                        {
                            HasBlackKingMoved = 1;
                        }
                        If (Board[(BestMove % 100)] == BlackRook)
                        {
                            If (floor((BestMove / 100)) == VirtualBoard[1])
                            {
                                HasBlackRookQSMoved = 1;
                            }
                            If (floor((BestMove / 100)) == VirtualBoard[8])
                            {
                                HasBlackRookKSMoved = 1;
                            }
                        }
                        If ((BestMove == BlackQueensideCastling) Or (BestMove == BlackKingsideCastling))
                        {
                            HasBlackKingMoved = 1;
                            HasBlackCastled = 1;
                        }
                    }
                }
            }
        }
    }
    Call ExecuteMovePostProcess;
    Call ExitExecution;
}

Define ExecuteInit (warp=false)
{
    ExecutionDepth = 0;
    IsExecutionRunning = 0;
    Call EnterExecution;
    If (IsPlayerBlack == 1)
    {
        Call ExecuteEngineMove;
    }
    Call ExecuteMovePostProcess;
    Call ExitExecution;
}

Define ExecuteMovePostProcess (warp=false)
{
    MoveFromIdx = -1;
    MoveToIdx = -1;
    FromSquareIdx = -1;
    ToSquareIdx = -1;
    Event.BroadcastAndWait("fromsquareselected");
    Event.BroadcastAndWait("tosquareselected");
    Event.BroadcastAndWait("inputmode");
}

Define ExecuteUserMove (warp=false)
{
    Call EnterExecution;
    If (IsGameSuspended == 0)
    {
        If ((Board[MoveFromIdx] < 0) And (Not ((MoveFromIdx == MoveToIdx))))
        {
            UserMove = "";
            If ((Board[MoveFromIdx] == WhiteKing) And (MoveFromIdx == VirtualBoard[61]))
            {
                If ((MoveToIdx == VirtualBoard[59]) And (Board[VirtualBoard[57]] == WhiteRook))
                {
                    Call CalculateMoves(2);
                    If List.ContainsItem(Moves2, WhiteQueensideCastling)
                    {
                        UserMove = WhiteQueensideCastling;
                    }
                    Else
                    {
                        UserMove = 6159;
                    }
                }
                If ((MoveToIdx == VirtualBoard[63]) And (Board[VirtualBoard[64]] == WhiteRook))
                {
                    Call CalculateMoves(2);
                    If List.ContainsItem(Moves2, WhiteKingsideCastling)
                    {
                        UserMove = WhiteKingsideCastling;
                    }
                    Else
                    {
                        UserMove = 6163;
                    }
                }
            }
            If (UserMove == "")
            {
                UserMove = ((MoveFromIdx * 100) + MoveToIdx);
                If (Variable.Length(UserMove) == 3)
                {
                    UserMove = Operator.Join(0, UserMove);
                }
                If ((Board[MoveFromIdx] == WhitePawn) And (MoveFromIdx < 17))
                {
                    UserMove = Operator.Join(UserMove, .1);
                }
            }
            MovePieceFromIdx = MoveFromIdx;
            MovePieceToIdx = MoveToIdx;
            If (((UserMove == BlackQueensideCastling) Or (UserMove == BlackKingsideCastling)) Or ((UserMove == WhiteQueensideCastling) Or (UserMove == WhiteKingsideCastling)))
            {
                MovePieceSpecial = UserMove;
            }
            Else
            {
                MovePieceSpecial = "";
            }
            Event.BroadcastAndWait("movepiece");
            Event.Broadcast("SoundMove");
            FromSquareIdx = -1;
            ToSquareIdx = -1;
            Event.BroadcastAndWait("fromsquareselected");
            Event.BroadcastAndWait("tosquareselected");
            Call CalculateMoves(2);
            If (Not (List.ContainsItem(Moves2, UserMove)))
            {
                List.DeleteItem(Moves2, all);
                List.Add(Moves2, UserMove);
                List.ReplaceItem(MovesIdx, 2, 1);
                List.ReplaceItem(MovesCount, 2, 1);
                Call ApplyMove(2);
                Call CalcBoardAttackedByMove(1);
                If (IsWhiteChecked == 1)
                {
                    Call SayAsync("Invalid move - Check!")(2);
                    Event.Broadcast("SoundInvalidMoveCheck");
                }
                Else
                {
                    Call SayAsync("Invalid move!")(2);
                    Event.Broadcast("SoundInvalidMove");
                }
                Call RevertMove(2);
                Call DrawBoardAndWait;
            }
            Else
            {
                If (Not ((UserMove == floor(UserMove))))
                {
                    Looks.Say("Please select promotion piece");
                    Event.BroadcastAndWait("calcmode");
                    Event.BroadcastAndWait("selectpromotionpiecewhite");
                    Event.BroadcastAndWait("inputmode");
                    Looks.Say("");
                    If (SelectedPromotionPiece == WhiteQueen)
                    {
                        UserMove = Operator.Join(floor(UserMove), .1);
                    }
                    Else
                    {
                        If (SelectedPromotionPiece == WhiteRook)
                        {
                            UserMove = Operator.Join(floor(UserMove), .2);
                        }
                        Else
                        {
                            If (SelectedPromotionPiece == WhiteBishop)
                            {
                                UserMove = Operator.Join(floor(UserMove), .3);
                            }
                            Else
                            {
                                If (SelectedPromotionPiece == WhiteKnight)
                                {
                                    UserMove = Operator.Join(floor(UserMove), .4);
                                }
                            }
                        }
                    }
                    Repeat Until (Variable.Length(UserMove) > 5)
                    {
                        UserMove = Operator.Join(0, UserMove);
                    }
                }
                Call GetMoveNotation(floor(UserMove));
                List.DeleteItem(Moves2, all);
                List.Add(Moves2, UserMove);
                List.ReplaceItem(MovesIdx, 2, 1);
                List.ReplaceItem(MovesCount, 2, 1);
                Call ApplyMove(2);
                Call CalcBoardAttackedByMove(1);
                If (IsWhiteChecked == 1)
                {
                    Call RevertMove(2);
                    Call DrawBoardAndWait;
                    Call SayAsync("Invalid move - Check!")(2);
                    Event.Broadcast("SoundInvalidMoveCheck");
                }
                Else
                {
                    List.Add(GameMovesAN, MoveNotationRes);
                    GameMoves = Operator.Join(GameMoves, UserMove);
                    Looks.Think("Thinking...");
                    Call DrawBoardAndWait;
                    Control.Wait(0);
                    Event.BroadcastAndWait("calcmode");
                    Call AddBoardToHistory;
                    Call IsBlackKingCheckMate;
                    If (IsBlackKingCheckMateRes == 1)
                    {
                        Looks.Say("Checkmate!");
                        Event.Broadcast("SoundCheckmate");
                        Event.Broadcast("inputmode");
                        IsGameSuspended = 1;
                    }
                    Else
                    {
                        Call IsDrawByStalemate(1);
                        If (IsDrawRes == 1)
                        {
                            Looks.Say("Draw!");
                            Event.Broadcast("SoundDraw");
                            Event.Broadcast("inputmode");
                            IsGameSuspended = 1;
                        }
                        Else
                        {
                            Call GetRepetitionCount;
                            If (RepetitionCountRes > 2)
                            {
                                Looks.Say("Draw!");
                                Event.Broadcast("SoundDraw");
                                Event.Broadcast("inputmode");
                                IsGameSuspended = 1;
                            }
                            Else
                            {
                                Call IsDrawByMaterial;
                                If (IsDrawRes == 1)
                                {
                                    Looks.Say("Draw!");
                                    Event.Broadcast("SoundDraw");
                                    Event.Broadcast("inputmode");
                                    IsGameSuspended = 1;
                                }
                                Else
                                {
                                    If (Board[(UserMove % 100)] == WhiteKing)
                                    {
                                        HasWhiteKingMoved = 1;
                                    }
                                    If (Board[(UserMove % 100)] == WhiteRook)
                                    {
                                        If (floor((UserMove / 100)) == VirtualBoard[57])
                                        {
                                            HasWhiteRookQSMoved = 1;
                                        }
                                        If (floor((UserMove / 100)) == VirtualBoard[64])
                                        {
                                            HasWhiteRookKSMoved = 1;
                                        }
                                    }
                                    If ((UserMove == WhiteQueensideCastling) Or (UserMove == WhiteKingsideCastling))
                                    {
                                        HasWhiteCastled = 1;
                                        HasWhiteKingMoved = 1;
                                    }
                                    Call ExecuteEngineMove;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    Call ExecuteMovePostProcess;
    Call ExitExecution;
}

Define ExitExecution (warp=false)
{
    ExecutionDepth += -1;
    If (Not ((ExecutionDepth > 0)))
    {
        IsExecutionRunning = 0;
    }
}

Define ExportBoardFEN (warp=true)
{
    ExportDataFEN = "";
    ExportDataFENLichess = "https://lichess.org/analysis/";
    Idx = 1;
    Repeat Until (Idx > 64)
    {
        If (IsPlayerBlack == 0)
        {
            CurrentPiece = Board[Idx];
        }
        Else
        {
            CurrentPiece = (0 - Board[(65 - Idx)]);
        }
        If (CurrentPiece == BlackPawn)
        {
            CurrentValue = "p";
        }
        If (CurrentPiece == BlackKnight)
        {
            CurrentValue = "n";
        }
        If (CurrentPiece == BlackBishop)
        {
            CurrentValue = "b";
        }
        If (CurrentPiece == BlackRook)
        {
            CurrentValue = "r";
        }
        If (CurrentPiece == BlackQueen)
        {
            CurrentValue = "q";
        }
        If (CurrentPiece == BlackKing)
        {
            CurrentValue = "k";
        }
        If (CurrentPiece == WhitePawn)
        {
            CurrentValue = "P";
        }
        If (CurrentPiece == WhiteKnight)
        {
            CurrentValue = "N";
        }
        If (CurrentPiece == WhiteBishop)
        {
            CurrentValue = "B";
        }
        If (CurrentPiece == WhiteRook)
        {
            CurrentValue = "R";
        }
        If (CurrentPiece == WhiteQueen)
        {
            CurrentValue = "Q";
        }
        If (CurrentPiece == WhiteKing)
        {
            CurrentValue = "K";
        }
        If (CurrentPiece == Empty)
        {
            IdxSub = Idx;
            Repeat Until (((IdxSub % 8) == 0) Or (((IsPlayerBlack == 0) And (Not ((Board[(IdxSub + 1)] == Empty)))) Or ((IsPlayerBlack == 1) And (Not ((Board[(65 - (IdxSub + 1))] == Empty))))))
            {
                IdxSub += 1;
            }
            CurrentValue = ((IdxSub - Idx) + 1);
            Idx += (IdxSub - Idx);
        }
        ExportDataFEN = Operator.Join(ExportDataFEN, CurrentValue);
        ExportDataFENLichess = Operator.Join(ExportDataFENLichess, CurrentValue);
        If (((Idx % 8) == 0) And (Idx < 64))
        {
            ExportDataFEN = Operator.Join(ExportDataFEN, "/");
            ExportDataFENLichess = Operator.Join(ExportDataFENLichess, "/");
        }
        Idx += 1;
    }
    If (IsPlayerBlack == 0)
    {
        ExportDataFEN = Operator.Join(ExportDataFEN, " w");
        ExportDataFENLichess = Operator.Join(ExportDataFENLichess, "_w");
    }
    Else
    {
        ExportDataFEN = Operator.Join(ExportDataFEN, " b");
        ExportDataFENLichess = Operator.Join(ExportDataFENLichess, "_b");
    }
}

Define ExportMovesPGN (warp=true)
{
    ExportMovesPGN = "";
    Idx = 1;
    Repeat (List.Length(GameMovesAN))
    {
        If ((Idx % 2) == 1)
        {
            ExportMovesPGN = Operator.Join(ExportMovesPGN, Operator.Join((((Idx - 1) / 2) + 1), ". "));
        }
        ExportMovesPGN = Operator.Join(ExportMovesPGN, Operator.Join(GameMovesAN[Idx], " "));
        Idx += 1;
    }
}

Define FillBoard (warp=true)
{
    List.DeleteItem(VirtualBoard, all);
    Idx = 1;
    Repeat (64)
    {
        If (IsPlayerBlack == 0)
        {
            List.Add(VirtualBoard, Idx);
        }
        Else
        {
            List.Add(VirtualBoard, (((IdxToRank[Idx] - 1) * 8) + (9 - IdxToFile[Idx])));
        }
        Idx += 1;
    }
    List.DeleteItem(Board, all);
    Repeat (64)
    {
        List.Add(Board, Empty);
    }
    List.ReplaceItem(Board, VirtualBoard[1], BlackRook);
    List.ReplaceItem(Board, VirtualBoard[2], BlackKnight);
    List.ReplaceItem(Board, VirtualBoard[3], BlackBishop);
    List.ReplaceItem(Board, VirtualBoard[4], BlackQueen);
    List.ReplaceItem(Board, VirtualBoard[5], BlackKing);
    List.ReplaceItem(Board, VirtualBoard[6], BlackBishop);
    List.ReplaceItem(Board, VirtualBoard[7], BlackKnight);
    List.ReplaceItem(Board, VirtualBoard[8], BlackRook);
    Idx = 9;
    Repeat (8)
    {
        List.ReplaceItem(Board, VirtualBoard[Idx], BlackPawn);
        Idx += 1;
    }
    Idx = 49;
    Repeat (8)
    {
        List.ReplaceItem(Board, VirtualBoard[Idx], WhitePawn);
        Idx += 1;
    }
    List.ReplaceItem(Board, VirtualBoard[57], WhiteRook);
    List.ReplaceItem(Board, VirtualBoard[58], WhiteKnight);
    List.ReplaceItem(Board, VirtualBoard[59], WhiteBishop);
    List.ReplaceItem(Board, VirtualBoard[60], WhiteQueen);
    List.ReplaceItem(Board, VirtualBoard[61], WhiteKing);
    List.ReplaceItem(Board, VirtualBoard[62], WhiteBishop);
    List.ReplaceItem(Board, VirtualBoard[63], WhiteKnight);
    List.ReplaceItem(Board, VirtualBoard[64], WhiteRook);
}

Define GetBoardString (warp=true)
{
    GetBoardStringRes = "";
    Idx = 1;
    Repeat (64)
    {
        GetBoardStringRes = Operator.Join(GetBoardStringRes, Operator.Join(Board[Idx], ","));
        Idx += 1;
    }
}

Define GetCurrentBoardHash (warp=true)
{
    CurrentBoardHash = 0;
    Idx = 1;
    Repeat (64)
    {
        Call GetPiecePosHash(Board[Idx])(Idx);
        CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
        Idx += 1;
    }
}

Define GetCurrentMove(num Depth) (warp=true)
{
    CurrentMove = "";
    If (Depth < 6)
    {
        If (Depth == 5)
        {
            CurrentMove = Moves5[MovesIdx[Depth]];
        }
        Else
        {
            If (Depth == 4)
            {
                CurrentMove = Moves4[MovesIdx[Depth]];
            }
            Else
            {
                If (Depth == 3)
                {
                    CurrentMove = Moves3[MovesIdx[Depth]];
                }
                Else
                {
                    If (Depth == 2)
                    {
                        CurrentMove = Moves2[MovesIdx[Depth]];
                    }
                    Else
                    {
                        If (Depth == 1)
                        {
                            CurrentMove = Moves1[MovesIdx[Depth]];
                        }
                    }
                }
            }
        }
    }
    Else
    {
        If (Depth < 11)
        {
            If (Depth == 6)
            {
                CurrentMove = Moves6[MovesIdx[Depth]];
            }
            Else
            {
                If (Depth == 7)
                {
                    CurrentMove = Moves7[MovesIdx[Depth]];
                }
                Else
                {
                    If (Depth == 8)
                    {
                        CurrentMove = Moves8[MovesIdx[Depth]];
                    }
                    Else
                    {
                        If (Depth == 9)
                        {
                            CurrentMove = Moves9[MovesIdx[Depth]];
                        }
                        Else
                        {
                            If (Depth == 10)
                            {
                                CurrentMove = Moves10[MovesIdx[Depth]];
                            }
                        }
                    }
                }
            }
        }
        Else
        {
            If (Depth < 16)
            {
                If (Depth == 11)
                {
                    CurrentMove = Moves11[MovesIdx[Depth]];
                }
                Else
                {
                    If (Depth == 12)
                    {
                        CurrentMove = Moves12[MovesIdx[Depth]];
                    }
                    Else
                    {
                        If (Depth == 13)
                        {
                            CurrentMove = Moves13[MovesIdx[Depth]];
                        }
                        Else
                        {
                            If (Depth == 14)
                            {
                                CurrentMove = Moves14[MovesIdx[Depth]];
                            }
                            Else
                            {
                                If (Depth == 15)
                                {
                                    CurrentMove = Moves15[MovesIdx[Depth]];
                                }
                            }
                        }
                    }
                }
            }
            Else
            {
                If (Depth == 16)
                {
                    CurrentMove = Moves16[MovesIdx[Depth]];
                }
                Else
                {
                    If (Depth == 17)
                    {
                        CurrentMove = Moves17[MovesIdx[Depth]];
                    }
                    Else
                    {
                        If (Depth == 18)
                        {
                            CurrentMove = Moves18[MovesIdx[Depth]];
                        }
                        Else
                        {
                            If (Depth == 19)
                            {
                                CurrentMove = Moves19[MovesIdx[Depth]];
                            }
                            Else
                            {
                                If (Depth == 20)
                                {
                                    CurrentMove = Moves20[MovesIdx[Depth]];
                                }
                                Else
                                {
                                    If (Depth == 21)
                                    {
                                        CurrentMove = Moves21[MovesIdx[Depth]];
                                    }
                                    Else
                                    {
                                        If (Depth == 22)
                                        {
                                            CurrentMove = Moves22[MovesIdx[Depth]];
                                        }
                                        Else
                                        {
                                            If (Depth == 23)
                                            {
                                                CurrentMove = Moves23[MovesIdx[Depth]];
                                            }
                                            Else
                                            {
                                                If (Depth == 24)
                                                {
                                                    CurrentMove = Moves24[MovesIdx[Depth]];
                                                }
                                                Else
                                                {
                                                    If (Depth == 25)
                                                    {
                                                        CurrentMove = Moves25[MovesIdx[Depth]];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

Define GetMoveNotation(num Move) (warp=true)
{
    Call GetVirtualMove(Move);
    MoveNotationRes = "";
    If ((VirtualMove == BlackKingsideCastling) Or (VirtualMove == WhiteKingsideCastling))
    {
        MoveNotationRes = "O-O";
        Stop(this script);
    }
    If ((VirtualMove == BlackQueensideCastling) Or (VirtualMove == WhiteQueensideCastling))
    {
        MoveNotationRes = "O-O-O";
        Stop(this script);
    }
    SourceIdx = floor((VirtualMove / 100));
    TargetIdx = floor((VirtualMove % 100));
    CurrentPiece = Board[floor((Move / 100))];
    If ((CurrentPiece == BlackBishop) Or (CurrentPiece == WhiteBishop))
    {
        MoveNotationRes = "B";
    }
    If ((CurrentPiece == BlackKing) Or (CurrentPiece == WhiteKing))
    {
        MoveNotationRes = "K";
    }
    If ((CurrentPiece == BlackRook) Or (CurrentPiece == WhiteRook))
    {
        MoveNotationRes = "R";
    }
    If ((CurrentPiece == BlackKnight) Or (CurrentPiece == WhiteKnight))
    {
        MoveNotationRes = "N";
    }
    If ((CurrentPiece == WhiteQueen) Or (CurrentPiece == BlackQueen))
    {
        MoveNotationRes = "Q";
    }
    X = IdxToFile[SourceIdx];
    Y = (9 - IdxToRank[SourceIdx]);
    MoveNotationRes = Operator.Join(MoveNotationRes, Operator.Join(Operator.LetterOf("abcdefgh", X), Y));
    If (Not ((Board[floor((Move % 100))] == Empty)))
    {
        MoveNotationRes = Operator.Join(MoveNotationRes, "x");
    }
    X = IdxToFile[TargetIdx];
    Y = (9 - IdxToRank[TargetIdx]);
    If ((Operator.LetterOf(VirtualMove, 5) == ".") == .1)
    {
        If (Operator.LetterOf(VirtualMove, 6) == 1)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "Q");
        }
        If (Operator.LetterOf(VirtualMove, 6) == 2)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "R");
        }
        If (Operator.LetterOf(VirtualMove, 6) == 3)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "B");
        }
        If (Operator.LetterOf(VirtualMove, 6) == 4)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "N");
        }
    }
    Else
    {
        MoveNotationRes = Operator.Join(MoveNotationRes, Operator.Join(Operator.LetterOf("abcdefgh", X), Y));
    }
}

Define GetMoveScore(string SourcePiece)(string TargetPiece)(string FromIdx)(string ToIdx)(string Move)(string Depth)(bool CapturesOnly) (warp=true)
{
    If (TargetPiece == 0)
    {
        If List.ContainsItem(CurrentKillerMoves, Move)
        {
            If (SourcePiece > 0)
            {
                MoveScoreRes = (80 + List.IndexOf(CurrentKillerMoves, Move));
                Stop(this script);
            }
            Else
            {
                MoveScoreRes = (-80 - List.IndexOf(CurrentKillerMoves, Move));
                Stop(this script);
            }
        }
        MoveScoreRes = 0;
    }
    Else
    {
        If (Not ((abs(TargetPiece) < abs(SourcePiece))))
        {
            MoveScoreRes = ((0 - SourcePiece) - (10 * TargetPiece));
            Stop(this script);
        }
        MoveScoreRes = (0 - TargetPiece);
    }
    If (SourcePiece > 0)
    {
        If (Not (CapturesOnly))
        {
            If ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], FromIdx) > 0) And ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], FromIdx) == 0) Or (PieceIdxLookup[SourcePiece] > Operator.LetterOf(BoardAttackedByWhitePieceSnapshot[Depth], FromIdx))))
            {
                If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], ToIdx) == 0)
                {
                    MoveScoreRes += SourcePiece;
                }
            }
            Else
            {
                If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], ToIdx) > 0)
                {
                    MoveScoreRes += (0 - SourcePiece);
                }
            }
        }
        MoveScoreRes += MovePosLookupBlack[((PieceIdxLookup[SourcePiece] * 10000) + Move)];
    }
    Else
    {
        If (Not (CapturesOnly))
        {
            If ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], FromIdx) > 0) And ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], FromIdx) == 0) Or (PieceIdxLookup[(0 - SourcePiece)] > Operator.LetterOf(BoardAttackedByBlackPieceSnapshot[Depth], FromIdx))))
            {
                If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], ToIdx) == 0)
                {
                    MoveScoreRes += SourcePiece;
                }
            }
            Else
            {
                If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], ToIdx) > 0)
                {
                    MoveScoreRes += (0 - SourcePiece);
                }
            }
        }
        MoveScoreRes += MovePosLookupWhite[((PieceIdxLookup[(0 - SourcePiece)] * 10000) + Move)];
    }
}

Define GetPiecePosHash(string Piece)(string Pos) (warp=true)
{
    PiecePosHash = 0;
    If ((Pos > 0) And (Not ((Piece == 0))))
    {
        If (Piece == BlackPawn)
        {
            PiecePosHash = PosPieceHashLookup[(64 + Pos)];
        }
        Else
        {
            If (Piece == WhitePawn)
            {
                PiecePosHash = PosPieceHashLookup[(576 + Pos)];
            }
            Else
            {
                If (Piece == BlackBishop)
                {
                    PiecePosHash = PosPieceHashLookup[Pos];
                }
                Else
                {
                    If (Piece == WhiteBishop)
                    {
                        PiecePosHash = PosPieceHashLookup[(384 + Pos)];
                    }
                    Else
                    {
                        If (Piece == BlackKnight)
                        {
                            PiecePosHash = PosPieceHashLookup[(256 + Pos)];
                        }
                        Else
                        {
                            If (Piece == WhiteKnight)
                            {
                                PiecePosHash = PosPieceHashLookup[(640 + Pos)];
                            }
                            Else
                            {
                                If (Piece == BlackQueen)
                                {
                                    PiecePosHash = PosPieceHashLookup[(128 + Pos)];
                                }
                                Else
                                {
                                    If (Piece == WhiteQueen)
                                    {
                                        PiecePosHash = PosPieceHashLookup[(448 + Pos)];
                                    }
                                    Else
                                    {
                                        If (Piece == BlackRook)
                                        {
                                            PiecePosHash = PosPieceHashLookup[(320 + Pos)];
                                        }
                                        Else
                                        {
                                            If (Piece == WhiteRook)
                                            {
                                                PiecePosHash = PosPieceHashLookup[(704 + Pos)];
                                            }
                                            Else
                                            {
                                                If (Piece == BlackKing)
                                                {
                                                    PiecePosHash = PosPieceHashLookup[(192 + Pos)];
                                                }
                                                Else
                                                {
                                                    If (Piece == WhiteKing)
                                                    {
                                                        PiecePosHash = PosPieceHashLookup[(512 + Pos)];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

Define GetPiecePosScore(string Piece)(string Idx) (warp=true)
{
    PosScoreRes = 0;
    If ((Idx > 0) And (Not ((Piece == 0))))
    {
        If (Piece == BlackPawn)
        {
            If (IsEndgame == 0)
            {
                If (IsBlackCastlingPossible == 1)
                {
                    PosScoreRes = PawnPieceSquarePreCastling[(65 - Idx)];
                }
                Else
                {
                    PosScoreRes = PawnPieceSquare[(65 - Idx)];
                }
            }
            Else
            {
                PosScoreRes = PawnPieceSquareEndgame[(65 - Idx)];
            }
        }
        Else
        {
            If (Piece == WhitePawn)
            {
                If (IsEndgame == 0)
                {
                    If (IsWhiteCastlingPossible == 1)
                    {
                        PosScoreRes = (0 - PawnPieceSquarePreCastling[Idx]);
                    }
                    Else
                    {
                        PosScoreRes = (0 - PawnPieceSquare[Idx]);
                    }
                }
                Else
                {
                    PosScoreRes = (0 - PawnPieceSquareEndgame[Idx]);
                }
            }
            Else
            {
                If (IsEndgame == 0)
                {
                    If (Piece == BlackBishop)
                    {
                        PosScoreRes = BishopPieceSquare[(65 - Idx)];
                    }
                    Else
                    {
                        If (Piece == WhiteBishop)
                        {
                            PosScoreRes = (0 - BishopPieceSquare[Idx]);
                        }
                        Else
                        {
                            If (Piece == BlackKnight)
                            {
                                PosScoreRes = KnightPieceSquare[(65 - Idx)];
                            }
                            Else
                            {
                                If (Piece == WhiteKnight)
                                {
                                    PosScoreRes = (0 - KnightPieceSquare[Idx]);
                                }
                                Else
                                {
                                    If (Piece == BlackQueen)
                                    {
                                        PosScoreRes = QueenPieceSquare[(65 - Idx)];
                                    }
                                    Else
                                    {
                                        If (Piece == WhiteQueen)
                                        {
                                            PosScoreRes = (0 - QueenPieceSquare[Idx]);
                                        }
                                        Else
                                        {
                                            If (Piece == BlackRook)
                                            {
                                                PosScoreRes = RookPieceSquare[(65 - Idx)];
                                            }
                                            Else
                                            {
                                                If (Piece == WhiteRook)
                                                {
                                                    PosScoreRes = (0 - RookPieceSquare[Idx]);
                                                }
                                                Else
                                                {
                                                    If (Piece == BlackKing)
                                                    {
                                                        PosScoreRes = KingPieceSquare[(65 - Idx)];
                                                    }
                                                    Else
                                                    {
                                                        If (Piece == WhiteKing)
                                                        {
                                                            PosScoreRes = (0 - KingPieceSquare[Idx]);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                Else
                {
                    If (Piece == BlackKing)
                    {
                        If ((BlackPawnCount == 0) And ((BlackQueenCount == 0) And (BlackMinorCount == 0)))
                        {
                            PosScoreRes = (6 * KingPieceSquareEndgame[(65 - Idx)]);
                        }
                        Else
                        {
                            PosScoreRes = (1 * KingPieceSquareEndgame[(65 - Idx)]);
                        }
                    }
                    Else
                    {
                        If (Piece == WhiteKing)
                        {
                            If ((WhitePawnCount == 0) And ((WhiteQueenCount == 0) And (WhiteMinorCount == 0)))
                            {
                                PosScoreRes = (6 * (0 - KingPieceSquareEndgame[Idx]));
                            }
                            Else
                            {
                                PosScoreRes = (1 * (0 - KingPieceSquareEndgame[Idx]));
                            }
                        }
                    }
                }
            }
        }
    }
}

Define GetRepetitionCount (warp=true)
{
    RepetitionCountRes = 1;
    Idx = (List.Length(BoardHistory) - 2);
    Repeat Until (Idx < 1)
    {
        If (BoardHistory[Idx] == BoardHistory[last])
        {
            RepetitionCountRes += 1;
        }
        Idx += -2;
    }
}

Define GetSpecialMoveScore(string Move)(string Depth) (warp=true)
{
    MoveScoreRes = 0;
    If ((Move == BlackQueensideCastling) Or (Move == BlackKingsideCastling))
    {
        MoveScoreRes = 50;
        Stop(this script);
    }
    Else
    {
        If ((Move == WhiteQueensideCastling) Or (Move == WhiteKingsideCastling))
        {
            MoveScoreRes = -50;
            Stop(this script);
        }
    }
    If (Variable.Length(Move) == 6)
    {
        If ((Depth % 2) == 1)
        {
            OrderFac = 1;
        }
        Else
        {
            OrderFac = -1;
        }
        If (Operator.LetterOf(Move, 6) == 1)
        {
            MoveScoreRes = (800 * OrderFac);
        }
        Else
        {
            If (Operator.LetterOf(Move, 6) == 2)
            {
                MoveScoreRes = (400 * OrderFac);
            }
            Else
            {
                If (Operator.LetterOf(Move, 6) == 3)
                {
                    MoveScoreRes = (220 * OrderFac);
                }
                Else
                {
                    MoveScoreRes = (200 * OrderFac);
                }
            }
        }
    }
}

Define GetSubstring(string Text)(num FromIdx)(num ToIdx) (warp=true)
{
    SubstringRes = "";
    IdxString = FromIdx;
    Repeat (((ToIdx - FromIdx) + 1))
    {
        SubstringRes = Operator.Join(SubstringRes, Operator.LetterOf(Text, IdxString));
        IdxString += 1;
    }
}

Define GetSubstringLeft(string Text)(num Count) (warp=true)
{
    Call GetSubstring(Text)(1)(Count);
}

Define GetSubstringRight(string Text)(num Count) (warp=true)
{
    Call GetSubstring(Text)(((Variable.Length(Text) - Count) + 1))(Variable.Length(Text));
}

Define GetTargetIdx(num SourceIdx)(num DeltaX)(num DeltaY) (warp=true)
{
    GetTargetIdxRes = -1;
    X = (IdxToFile[SourceIdx] + DeltaX);
    If ((X > 0) And (X < 9))
    {
        Y = (IdxToRank[SourceIdx] + DeltaY);
        If ((Y > 0) And (Y < 9))
        {
            GetTargetIdxRes = (X + ((Y - 1) * 8));
        }
    }
}

Define GetVirtualMove(num Move) (warp=true)
{
    If (IsPlayerBlack == 0)
    {
        VirtualMove = Move;
    }
    Else
    {
        If ((Not ((Move < 0100))) And (Not ((Move > 6499))))
        {
            VirtualMove = (65 - floor((Move % 100)));
            Repeat Until (Variable.Length(VirtualMove) > 1)
            {
                VirtualMove = Operator.Join(0, VirtualMove);
            }
            VirtualMove = Operator.Join((65 - floor((Move / 100))), VirtualMove);
            Repeat Until (Variable.Length(VirtualMove) > 3)
            {
                VirtualMove = Operator.Join(0, VirtualMove);
            }
            If (Operator.LetterOf(Move, 5) == ".")
            {
                VirtualMove = Operator.Join(VirtualMove, Operator.Join(Operator.LetterOf(Move, 5), Operator.LetterOf(Move, 6)));
            }
        }
        Else
        {
            If (Move == BlackKingsideCastling)
            {
                VirtualMove = WhiteKingsideCastling;
            }
            Else
            {
                If (Move == BlackQueensideCastling)
                {
                    VirtualMove = WhiteQueensideCastling;
                }
                Else
                {
                    If (Move == WhiteKingsideCastling)
                    {
                        VirtualMove = BlackKingsideCastling;
                    }
                    Else
                    {
                        If (Move == WhiteQueensideCastling)
                        {
                            VirtualMove = BlackQueensideCastling;
                        }
                    }
                }
            }
        }
    }
}

Define ImportBoard(string ImpBoard) (warp=false)
{
    Call ExportBoardFEN;
    Call ImportBoardFEN(ImpBoard);
    Call CalcBoardStats;
    If ((BlackKingIdx == "") Or (WhiteKingIdx == ""))
    {
        Call SayAsync("Invalid FEN data")(5);
        Call ImportBoardFEN(ExportDataFEN);
        Call CalcBoardStats;
    }
    Else
    {
        IsImportedBoard = 1;
        HasWhiteKingMoved = 0;
        HasBlackKingMoved = 0;
        HasWhiteCastled = 0;
        HasBlackCastled = 0;
        HasWhiteRookKSMoved = 0;
        HasWhiteRookQSMoved = 0;
        HasBlackRookKSMoved = 0;
        HasBlackRookQSMoved = 0;
        GameMoves = "";
        List.DeleteItem(BoardHistory, all);
        List.DeleteItem(BoardHistoryHash, all);
        List.DeleteItem(GameMovesAN, all);
        If (Not ((Board[VirtualBoard[1]] == BlackRook)))
        {
            HasBlackRookQSMoved = 1;
        }
        If (Not ((Board[VirtualBoard[5]] == BlackKing)))
        {
            HasBlackKingMoved = 1;
        }
        If (Not ((Board[VirtualBoard[8]] == BlackRook)))
        {
            HasBlackRookQSMoved = 1;
        }
        If (Not ((Board[VirtualBoard[57]] == WhiteRook)))
        {
            HasWhiteRookQSMoved = 1;
        }
        If (Not ((Board[VirtualBoard[61]] == WhiteKing)))
        {
            HasWhiteKingMoved = 1;
        }
        If (Not ((Board[VirtualBoard[64]] == WhiteRook)))
        {
            HasWhiteRookKSMoved = 1;
        }
        Call AddBoardToHistory;
        Call DrawBoardAndWait;
        IdxString += 1;
        CurrentValue = Operator.LetterOf(ImpBoard, IdxString);
        If (((CurrentValue == "B") And (IsPlayerBlack == 0)) Or ((CurrentValue == "W") And (IsPlayerBlack == 1)))
        {
            Call CalcBoardAttackedByMove(1);
            If (IsWhiteChecked == 1)
            {
                Looks.Say("Checkmate!", 5);
                IsGameSuspended = 1;
            }
            Else
            {
                Call CalculateMoves(1);
                If (List.Length(Moves1) == 0)
                {
                    Looks.Say("Draw!", 5);
                    IsGameSuspended = 1;
                }
                Else
                {
                    IsGameSuspended = 0;
                    Call ExecuteEngineMove;
                }
            }
        }
        If (((CurrentValue == "W") And (IsPlayerBlack == 0)) Or ((CurrentValue == "B") And (IsPlayerBlack == 1)))
        {
            Call CalcBoardAttackedByMove(2);
            If (IsBlackChecked == 1)
            {
                Looks.Say("Checkmate!", 5);
                IsGameSuspended = 1;
            }
            Else
            {
                Call CalculateMoves(2);
                If (List.Length(Moves2) == 0)
                {
                    Looks.Say("Draw!", 5);
                    IsGameSuspended = 1;
                }
                Else
                {
                    IsGameSuspended = 0;
                }
            }
        }
    }
}

Define ImportBoardFEN(string ImpBoard) (warp=false)
{
    Idx = 1;
    Repeat (64)
    {
        List.ReplaceItem(Board, Idx, Empty);
        Idx += 1;
    }
    If (IsPlayerBlack == 0)
    {
        Idx = 1;
        IdxInc = 1;
    }
    Else
    {
        Idx = 64;
        IdxInc = -1;
    }
    IdxString = 1;
    Repeat Until (((Idx > 64) Or (Idx < 1)) Or (IdxString > Variable.Length(ImpBoard)))
    {
        CurrentValue = Operator.LetterOf(ImpBoard, IdxString);
        If ((Not ((CurrentValue < "A"))) And (Not ((CurrentValue > "Z"))))
        {
            CurrentPiece = Empty;
            If (CurrentValue == "P")
            {
                CurrentPiece = BlackPawn;
            }
            If (CurrentValue == "N")
            {
                CurrentPiece = BlackKnight;
            }
            If (CurrentValue == "B")
            {
                CurrentPiece = BlackBishop;
            }
            If (CurrentValue == "R")
            {
                CurrentPiece = BlackRook;
            }
            If (CurrentValue == "Q")
            {
                CurrentPiece = BlackQueen;
            }
            If (CurrentValue == "K")
            {
                CurrentPiece = BlackKing;
            }
            Call IsLowerCase(CurrentValue);
            If (IsLowerCaseRes == 0)
            {
                CurrentPiece = (CurrentPiece * -1);
            }
            If (IsPlayerBlack == 1)
            {
                CurrentPiece = (CurrentPiece * -1);
            }
            List.ReplaceItem(Board, Idx, CurrentPiece);
            Idx += IdxInc;
        }
        Else
        {
            If ((Not ((CurrentValue < 0))) And (Not ((CurrentValue > 9))))
            {
                Repeat (CurrentValue)
                {
                    List.ReplaceItem(Board, Idx, Empty);
                    Idx += IdxInc;
                }
            }
            Else
            {
                If (CurrentValue == "/")
                {
                    Repeat Until ((((Idx % 8) == 1) And (IsPlayerBlack == 0)) Or (((Idx % 8) == 0) And (IsPlayerBlack == 1)))
                    {
                        List.ReplaceItem(Board, Idx, Empty);
                        Idx += IdxInc;
                    }
                }
            }
        }
        IdxString += 1;
    }
}

Define ImportBoardImpl(string ImpBoard) (warp=true)
{
    Idx = 1;
    IdxString = 1;
    CurrentPiece = "";
    Repeat Until (IdxString > Variable.Length(ImpBoard))
    {
        If (Operator.LetterOf(ImpBoard, IdxString) == ",")
        {
            List.ReplaceItem(Board, Idx, CurrentPiece);
            Idx += 1;
            CurrentPiece = "";
        }
        Else
        {
            CurrentPiece = Operator.Join(CurrentPiece, Operator.LetterOf(ImpBoard, IdxString));
        }
        IdxString += 1;
    }
}

Define InitAlphaBeta(string Depth)(string MaxDepth)(bool InitialDeepening) (warp=true)
{
    If (Depth == 1)
    {
        IsInNullMove = 0;
        IsMinMaxTimeout = 0;
        If InitialDeepening
        {
            Call Profile_Reset;
        }
        List.DeleteItem(MinMaxPly1EvalMoves, all);
        TTProbeCurrentAge += 1;
        Call CalcBoardStats;
        Call Log((Operator.Round((((Sensing.DaysSince2000() * 86400) - ThinkTimeStart) * 1000)) / 1000))(":")((MaxDepth - 1))("")("")("")("")("");
        Call InitMovePosLookup;
        If InitialDeepening
        {
            Call Log((Operator.Round((((Sensing.DaysSince2000() * 86400) - ThinkTimeStart) * 1000)) / 1000))(":")((MaxDepth - 1))(":")(" InitLookup done")("")("")("");
        }
    }
}

Define InitBishopSquare (warp=true)
{
    List.DeleteItem(BishopPieceSquare, all);
    Call LoadList("-20, -18, -16, -14, -14, -16, -18, -20,-10, 11, 1, 1, 1, 1, 11, -10, 1, 11, 21, 26, 26, 21, 11, 1, 1, 21, 21, 26, 26, 21, 21, 1, 1, 1, 16, 21, 21, 16, 1, 1, -25, 6, 16, 11, 11, 16, 6, -25, -28, 11, 6, 1, 1, 6, 11, -28, -30, -25, -20, -20, -20, -20, -25, -30")("BishopPieceSquare");
}

Define InitBoard (warp=true)
{
    IsInUndo = 0;
    ExecutionDepth = 0;
    IsExecutionRunning = 0;
    IsProfilerEnabled = 0;
    IsEndgame = 0;
    IsEndgame2 = 0;
    IsImportedBoard = 0;
    BlackKingsideCastling = 0090;
    WhiteKingsideCastling = 0092;
    BlackQueensideCastling = 0091;
    WhiteQueensideCastling = 0093;
    HasBlackCastled = 0;
    HasWhiteKingMoved = 0;
    HasWhiteCastled = 0;
    HasBlackKingMoved = 0;
    HasWhiteRookKSMoved = 0;
    HasWhiteRookQSMoved = 0;
    HasBlackRookKSMoved = 0;
    HasBlackRookQSMoved = 0;
    GameMoves = "";
    IsGameSuspended = 0;
    PrevProgressUpdate = 0;
    Empty = 0;
    WhiteKing = -20000;
    WhiteQueen = -900;
    WhiteRook = -500;
    WhiteBishop = -350;
    WhiteKnight = -330;
    WhitePawn = -100;
    BlackKing = 20000;
    BlackQueen = 900;
    BlackRook = 500;
    BlackBishop = 350;
    BlackKnight = 330;
    BlackPawn = 100;
    List.DeleteItem(PieceIdxLookup, all);
    Idx = 1;
    Repeat (20000)
    {
        List.Add(PieceIdxLookup, "");
        Idx += 1;
    }
    List.ReplaceItem(PieceIdxLookup, BlackPawn, 1);
    List.ReplaceItem(PieceIdxLookup, BlackKnight, 2);
    List.ReplaceItem(PieceIdxLookup, BlackBishop, 3);
    List.ReplaceItem(PieceIdxLookup, BlackRook, 4);
    List.ReplaceItem(PieceIdxLookup, BlackQueen, 5);
    List.ReplaceItem(PieceIdxLookup, BlackKing, 6);
    Call InitKingSafety;
    Call InitMobilityBonusLookup;
    Call InitCoordLookup;
    Call InitHashLookup;
    Call InitMoveLookup;
    Call InitKnightSquare;
    Call InitPawnSquare;
    Call InitPawnSquareEndgame;
    Call InitBishopSquare;
    Call InitRookSquare;
    Call InitQueenSquare;
    Call InitKingSquare;
    Call InitKingSquareEndgame;
    Call InitPawnSquarePreCastling;
    Call FillBoard;
    Call InitOpeningBook;
    List.Hide(BoardHistory);
    List.Hide(GameMovesAN);
    List.Hide(ExportData);
    List.Hide(ExportMoves);
    CharsUpperCase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    List.DeleteItem(CharsUpperCaseList, all);
    Idx = 1;
    Repeat (List.Length(CharsUpperCaseList))
    {
        List.Add(CharsUpperCaseList, Operator.LetterOf(CharsUpperCase, Idx));
        Idx += 1;
    }
    List.DeleteItem(BoardHistory, all);
    List.DeleteItem(BoardHistoryHash, all);
    List.DeleteItem(GameMovesAN, all);
    List.DeleteItem(BoardAttackedByWhite, all);
    List.DeleteItem(BoardAttackedByBlack, all);
    List.DeleteItem(PieceMobility, all);
    List.DeleteItem(BoardAttackedByWhitePiece, all);
    List.DeleteItem(BoardAttackedByBlackPiece, all);
    Repeat (64)
    {
        List.Add(BoardAttackedByWhite, 0);
        List.Add(BoardAttackedByBlack, 0);
        List.Add(PieceMobility, 0);
        List.Add(BoardAttackedByWhitePiece, 0);
        List.Add(BoardAttackedByBlackPiece, 0);
    }
    List.DeleteItem(Alphas, all);
    List.DeleteItem(Betas, all);
    List.DeleteItem(AlphasOld, all);
    List.DeleteItem(BetasOld, all);
    List.DeleteItem(MinMaxResults, all);
    List.DeleteItem(MovesCount, all);
    List.DeleteItem(MovesIdx, all);
    List.DeleteItem(TargetPieces, all);
    List.DeleteItem(PreviousBoardHash, all);
    List.DeleteItem(ScoreTypes, all);
    List.DeleteItem(PickMoveRes, all);
    List.DeleteItem(PickPhase, all);
    List.DeleteItem(PickedMove, all);
    List.DeleteItem(BestMoves, all);
    List.DeleteItem(CheckedState, all);
    List.DeleteItem(CheckedStateAttackLines, all);
    List.DeleteItem(PromotionPieces, all);
    List.DeleteItem(TargetPiecesIdx, all);
    List.DeleteItem(PosScoreDelta, all);
    List.DeleteItem(BoardAttackedCalculated, all);
    List.DeleteItem(PutsInCheck, all);
    List.DeleteItem(PawnPromotionFile, all);
    List.DeleteItem(EvalExtended1, all);
    List.DeleteItem(PlyExtension, all);
    List.DeleteItem(SourcePieces, all);
    List.DeleteItem(EvalExtended2, all);
    List.DeleteItem(EvalExtended3, all);
    List.DeleteItem(BlackMobBonus, all);
    List.DeleteItem(WhiteMobBonus, all);
    List.DeleteItem(AppliedMove, all);
    List.DeleteItem(CapturesDeltaSum, all);
    List.DeleteItem(PosScoreDeltaSum, all);
    List.DeleteItem(PutsInFork, all);
    List.DeleteItem(BoardAttackedByBlackPieceSnapshot, all);
    List.DeleteItem(BoardAttackedByBlackSnapshot, all);
    List.DeleteItem(BoardAttackedByWhitePieceSnapshot, all);
    List.DeleteItem(BoardAttackedByWhiteSnapshot, all);
    List.DeleteItem(Quiescence, all);
    Repeat (30)
    {
        List.Add(Alphas, "");
        List.Add(Betas, "");
        List.Add(AlphasOld, "");
        List.Add(BetasOld, "");
        List.Add(MinMaxResults, "");
        List.Add(MovesCount, "");
        List.Add(MovesIdx, "");
        List.Add(TargetPieces, "");
        List.Add(PreviousBoardHash, "");
        List.Add(ScoreTypes, "");
        List.Add(PickMoveRes, "");
        List.Add(PickPhase, "");
        List.Add(PickedMove, "");
        List.Add(BestMoves, "");
        List.Add(CheckedState, "");
        List.Add(CheckedStateAttackLines, "");
        List.Add(PromotionPieces, "");
        List.Add(TargetPiecesIdx, "");
        List.Add(PosScoreDelta, "");
        List.Add(BoardAttackedCalculated, "");
        List.Add(PutsInCheck, "");
        List.Add(PawnPromotionFile, "");
        List.Add(EvalExtended1, "");
        List.Add(PlyExtension, "");
        List.Add(SourcePieces, "");
        List.Add(EvalExtended2, "");
        List.Add(EvalExtended3, "");
        List.Add(BlackMobBonus, "");
        List.Add(WhiteMobBonus, "");
        List.Add(AppliedMove, "");
        List.Add(CapturesDeltaSum, "");
        List.Add(PosScoreDeltaSum, "");
        List.Add(PutsInFork, "");
        List.Add(BoardAttackedByBlackPieceSnapshot, "");
        List.Add(BoardAttackedByBlackSnapshot, "");
        List.Add(BoardAttackedByWhitePieceSnapshot, "");
        List.Add(BoardAttackedByWhiteSnapshot, "");
        List.Add(Quiescence, "");
    }
    List.DeleteItem(BlackPawnCount, all);
    List.DeleteItem(WhitePawnCount, all);
    Repeat (8)
    {
        List.Add(BlackPawnCount, 0);
        List.Add(WhitePawnCount, 0);
    }
    Call InvalidateMovePosLookup;
    Call AddBoardToHistory;
}

Define InitCoordLookup (warp=true)
{
    List.DeleteItem(IdxToFile, all);
    List.DeleteItem(IdxToRank, all);
    Idx = 1;
    Repeat (64)
    {
        List.Add(IdxToFile, (((Idx - 1) % 8) + 1));
        List.Add(IdxToRank, ceiling((Idx / 8)));
        Idx += 1;
    }
}

Define InitHashLookup (warp=true)
{
    TTProbeCurrentAge = 0;
    List.DeleteItem(PosPieceHashLookup, all);
    Repeat (1024)
    {
        List.Add(PosPieceHashLookup, Operator.Random((1 - ((65536 * 65536) * (65536 * 1))) / ((65536 * 65536) * (65536 * 1))));
    }
    Call ClearTT;
}

Define InitKingSafety (warp=true)
{
    List.DeleteItem(PawnStorm, all);
    Call LoadList("42, -134, -87, 44, 27, 21, 24, 0, 21, -8, 58, 22, 18, -3, 11, 0,  2, 24, 76, 17, 3, -7, -1, 0, -5, -7, 42, 7, 1, -3, -8, 0, -5, -7, 42, 7, 1, -3, -8, 0,  2, 24, 76, 17, 3, -7, -1, 0, 21, -8, 58, 22, 18, -3, 11, 0, 42, -134, -87, 44, 27, 21, 24, 0,")("PawnStorm");
    List.DeleteItem(PawnShelter, all);
    Call LoadList("-3, 38, 44, 27, 18, 8, 12, 0, -20, 29, 16, -23, -14, -5, -30, 0, -5, 35, 11, -1, 15, 1, -21, 0, -18, -6, -14, -24, -23, -31, -78, 0, -18, -6, -14, -24, -23, -31, -78, 0, -5, 35, 11, -1, 15, 1, -21, 0, -20, 29, 16, -23, -14, -5, -30, 0, -3, 38, 44, 27, 18, 8, 12, 0,")("PawnShelter");
}

Define InitKingSquare (warp=true)
{
    List.DeleteItem(KingPieceSquare, all);
    Call LoadList("-55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55, -55, -55, -60, -70, -70, -60, -55, -55,-50, -50, -55, -60, -60, -55, -50, -50, -40, -40, -45, -50, -50, -45, -40, -40, -30, -30, -30, -35, -35, -30, -30, -30, -20, 0, 0, -10, -10, 0, 0, -20")("KingPieceSquare");
}

Define InitKingSquareEndgame (warp=true)
{
    List.DeleteItem(KingPieceSquareEndgame, all);
    Call LoadList("  -30, -25, -20, -15, -15, -20, -25, -30 ,  -20, -15, -10, -5, -5, -10, -15, -20,   -15, -10, -5, 0, 0, -5, -10, -15,   -15, -10, -5, 0, 0, -5, -10, -15,   -15, -10, -5, 0, 0, -5, -10, -15,   -20, -15, -10, -5, -5, -10, -15, -20,   -25, -20, -15, -10, -10, -15, -20, -25,  -30, -25, -20, -15, -15, -20, -25, -30")("KingPieceSquareEndgame");
}

Define InitKnightSquare (warp=true)
{
    List.DeleteItem(KnightPieceSquare, all);
    Call LoadList("-30, -20, -15, -15, -15, -15, -20, -30,-20, 15, 20, 20, 20, 20, 15, -20,-20, 22, 30, 35, 35, 30, 22, -20,-20, 20, 25, 25, 25, 25, 20, -20,-20,  5, 20, 18, 18, 20,  5, -20,-20,  0, 15, 10, 10, 15,  0, -20, -15, -15, -5, 5,  5, -5, -15, -15, -35, -10,-12,-7, -7,-12, -10, -35")("KnightPieceSquare");
}

Define InitMobilityBonusLookup (warp=true)
{
    List.DeleteItem(QueenMobilityBonus, all);
    List.DeleteItem(BishopMobilityBonus, all);
    List.DeleteItem(RookMobilityBonus, all);
    List.DeleteItem(KnightMobilityBonus, all);
    Call LoadList("-4,-3,0,0,1,2,3,4,4,5,5,6,6,7,7,7,8,8,9,9,10,11,11,11,12,12,12,13")("QueenMobilityBonus");
    Call LoadList("-5,-2,2,3,4,5,5,6,7,7,8,8,9,10")("BishopMobilityBonus");
    Call LoadList("-6,-3,-1,-1,0,0,1,1,2,2,3,3,4,5,6")("RookMobilityBonus");
    Call LoadList("-8,-6,-1,0,1,2,2,3,4")("KnightMobilityBonus");
}

Define InitMoveLookup (warp=true)
{
    List.DeleteItem(KnightMoveOffsets, all);
    List.DeleteItem(KingMoveOffsets, all);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 1);
    List.DeleteItem(MoveLookupStraight, all);
    List.DeleteItem(MoveLookupCross, all);
    List.DeleteItem(MoveLookupOffsetsStraight, all);
    List.DeleteItem(MoveLookupOffsetsCross, all);
    List.DeleteItem(MoveLookupKnight, all);
    List.DeleteItem(MoveLookupKing, all);
    List.DeleteItem(MoveLookupIndexOffset, all);
    List.DeleteItem(MoveLookupLineIndexOffset, all);
    List.Add(MoveLookupOffsetsStraight, 1);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, 1);
    List.Add(MoveLookupOffsetsStraight, -1);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, -1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, -1);
    List.Add(MoveLookupOffsetsCross, -1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, -1);
    List.Add(MoveLookupOffsetsCross, -1);
    Idx = 1;
    Repeat (64)
    {
        IdxSub = 1;
        Repeat (4)
        {
            X = IdxToFile[Idx];
            Y = IdxToRank[Idx];
            Repeat (8)
            {
                X += MoveLookupOffsetsStraight[IdxSub];
                Y += MoveLookupOffsetsStraight[(IdxSub + 1)];
                List.Add(MoveLookupStraight, -1);
                If ((Y > 0) And (Y < 9))
                {
                    If ((X > 0) And (X < 9))
                    {
                        TargetIdx = (X + ((Y - 1) * 8));
                        List.ReplaceItem(MoveLookupStraight, last, TargetIdx);
                    }
                }
            }
            IdxSub += 2;
        }
        IdxSub = 1;
        Repeat (4)
        {
            X = IdxToFile[Idx];
            Y = IdxToRank[Idx];
            Repeat (8)
            {
                X += MoveLookupOffsetsCross[IdxSub];
                Y += MoveLookupOffsetsCross[(IdxSub + 1)];
                List.Add(MoveLookupCross, -1);
                If ((Y > 0) And (Y < 9))
                {
                    If ((X > 0) And (X < 9))
                    {
                        TargetIdx = (X + ((Y - 1) * 8));
                        List.ReplaceItem(MoveLookupCross, last, TargetIdx);
                    }
                }
            }
            IdxSub += 2;
        }
        Idx += 1;
    }
    Idx = 1;
    Repeat (64)
    {
        List.InsertItem(MoveLookupIndexOffset, Idx, ((Idx - 1) * 8));
        List.InsertItem(MoveLookupLineIndexOffset, Idx, ((Idx - 1) * 32));
        Idx += 1;
    }
    Idx = 1;
    Repeat (64)
    {
        IdxSub = 1;
        Repeat (8)
        {
            Call GetTargetIdx(Idx)(KingMoveOffsets[IdxSub])(KingMoveOffsets[(IdxSub + 1)]);
            If (Not ((GetTargetIdxRes == -1)))
            {
                List.Add(MoveLookupKing, GetTargetIdxRes);
            }
            IdxSub += 2;
        }
        Repeat Until (List.Length(MoveLookupKing) == (Idx * 8))
        {
            List.Add(MoveLookupKing, -1);
        }
        IdxSub = 1;
        Repeat (8)
        {
            Call GetTargetIdx(Idx)(KnightMoveOffsets[IdxSub])(KnightMoveOffsets[(IdxSub + 1)]);
            If (Not ((GetTargetIdxRes == -1)))
            {
                List.Add(MoveLookupKnight, GetTargetIdxRes);
            }
            IdxSub += 2;
        }
        Repeat Until (List.Length(MoveLookupKnight) == (Idx * 8))
        {
            List.Add(MoveLookupKnight, -1);
        }
        Idx += 1;
    }
}

Define InitMovePosLookup (warp=true)
{
    MetaState = Operator.Join(IsBlackCastlingPossible, Operator.Join(IsWhiteCastlingPossible, Operator.Join(IsEndgame, IsEndgame2)));
    If (BlackQueenCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (WhiteQueenCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (BlackMinorCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (WhiteMinorCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (BlackPawnCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (WhitePawnCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (Not ((MetaState == PrevMetaState)))
    {
        PrevMetaState = MetaState;
        IdxOuter = 1;
        Repeat (List.Length(TTNodeScore))
        {
            List.ReplaceItem(TTNodeScore, IdxOuter, "");
            IdxOuter += 1;
        }
        IdxOuter = 1;
        Repeat (List.Length(TTBoardScore1))
        {
            List.ReplaceItem(TTBoardScore1, IdxOuter, "");
            List.ReplaceItem(TTBoardScore2, IdxOuter, "");
            List.ReplaceItem(TTBoardScore3, IdxOuter, "");
            IdxOuter += 1;
        }
        If (((Not ((List.Length(MovePosLookupBlack) == 100000))) Or (Not ((List.Length(MovePosLookupWhite) == 100000)))) Or ((Not ((List.Length(MoveHashLookupBlack) == 100000))) Or (Not ((List.Length(MoveHashLookupWhite) == 100000)))))
        {
            List.DeleteAll(MovePosLookupBlack);
            List.DeleteAll(MovePosLookupWhite);
            List.DeleteAll(MoveHashLookupBlack);
            List.DeleteAll(MoveHashLookupWhite);
            Repeat (100000)
            {
                List.Add(MovePosLookupBlack, "");
                List.Add(MovePosLookupWhite, "");
                List.Add(MoveHashLookupBlack, "");
                List.Add(MoveHashLookupWhite, "");
            }
        }
        List.DeleteAll(Pieces);
        List.Add(Pieces, BlackKing);
        List.Add(Pieces, BlackQueen);
        List.Add(Pieces, BlackRook);
        List.Add(Pieces, BlackBishop);
        List.Add(Pieces, BlackKnight);
        List.Add(Pieces, BlackPawn);
        List.Add(Pieces, WhiteKing);
        List.Add(Pieces, WhiteQueen);
        List.Add(Pieces, WhiteRook);
        List.Add(Pieces, WhiteBishop);
        List.Add(Pieces, WhiteKnight);
        List.Add(Pieces, WhitePawn);
        IdxOuter = 1;
        Repeat (List.Length(Pieces))
        {
            SourcePiece = Pieces[IdxOuter];
            SourceIdx = 0;
            Repeat (65)
            {
                Call GetPiecePosScore(SourcePiece)(SourceIdx);
                PosScoreRes2 = PosScoreRes;
                Call GetPiecePosHash(SourcePiece)(SourceIdx);
                PiecePosHash2 = PiecePosHash;
                TargetIdx = 0;
                Repeat (65)
                {
                    IsLegalMove = 0;
                    If (SourcePiece == WhitePawn)
                    {
                        If (((abs((IdxToFile[TargetIdx] - IdxToFile[SourceIdx])) < 2) And ((IdxToRank[TargetIdx] - IdxToRank[SourceIdx]) > -3)) And ((IdxToRank[TargetIdx] - IdxToRank[SourceIdx]) < 0))
                        {
                            IsLegalMove = 1;
                        }
                    }
                    Else
                    {
                        If (SourcePiece == BlackPawn)
                        {
                            If (((abs((IdxToFile[TargetIdx] - IdxToFile[SourceIdx])) < 2) And ((IdxToRank[TargetIdx] - IdxToRank[SourceIdx]) < 3)) And ((IdxToRank[TargetIdx] - IdxToRank[SourceIdx]) > 0))
                            {
                                IsLegalMove = 1;
                            }
                        }
                        Else
                        {
                            If (abs(SourcePiece) == BlackKing)
                            {
                                If ((abs((IdxToRank[TargetIdx] - IdxToRank[SourceIdx])) < 2) And (abs((IdxToFile[TargetIdx] - IdxToFile[SourceIdx])) < 2))
                                {
                                    IsLegalMove = 1;
                                }
                            }
                            Else
                            {
                                If (abs(SourcePiece) == BlackKnight)
                                {
                                    If ((abs((IdxToRank[TargetIdx] - IdxToRank[SourceIdx])) < 3) And (abs((IdxToFile[TargetIdx] - IdxToFile[SourceIdx])) < 3))
                                    {
                                        IsLegalMove = 1;
                                    }
                                }
                                Else
                                {
                                    If ((abs(SourcePiece) == BlackQueen) Or (abs(SourcePiece) == BlackRook))
                                    {
                                        If (((IdxToRank[TargetIdx] - IdxToRank[SourceIdx]) == 0) Or ((IdxToFile[TargetIdx] - IdxToFile[SourceIdx]) == 0))
                                        {
                                            IsLegalMove = 1;
                                        }
                                    }
                                    If ((abs(SourcePiece) == BlackQueen) Or (abs(SourcePiece) == BlackBishop))
                                    {
                                        If (abs((IdxToRank[TargetIdx] - IdxToRank[SourceIdx])) == abs((IdxToFile[TargetIdx] - IdxToFile[SourceIdx])))
                                        {
                                            IsLegalMove = 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    If ((IsLegalMove == 1) Or ((SourceIdx == 0) Or (TargetIdx == 0)))
                    {
                        Call GetPiecePosScore(SourcePiece)(TargetIdx);
                        Call GetPiecePosHash(SourcePiece)(TargetIdx);
                        If (SourcePiece > 0)
                        {
                            IdxOuter2 = ((PieceIdxLookup[SourcePiece] * 10000) + ((SourceIdx * 100) + TargetIdx));
                            List.ReplaceItem(MovePosLookupBlack, IdxOuter2, (PosScoreRes - PosScoreRes2));
                            List.ReplaceItem(MoveHashLookupBlack, IdxOuter2, (PiecePosHash - PiecePosHash2));
                        }
                        Else
                        {
                            IdxOuter2 = ((PieceIdxLookup[(0 - SourcePiece)] * 10000) + ((SourceIdx * 100) + TargetIdx));
                            List.ReplaceItem(MovePosLookupWhite, IdxOuter2, (PosScoreRes - PosScoreRes2));
                            List.ReplaceItem(MoveHashLookupWhite, IdxOuter2, (PiecePosHash - PiecePosHash2));
                        }
                    }
                    TargetIdx += 1;
                }
                SourceIdx += 1;
            }
            IdxOuter += 1;
        }
    }
}

Define InitOpeningBook (warp=true)
{
    List.DeleteItem(OpeningMoves, all);
    List.Add(OpeningMoves, 533711276346122052362736463607225843021962531321);
    List.Add(OpeningMoves, 533711276346122052362736514336435843072262351321);
    List.Add(OpeningMoves, 533711276346132152362736463602195843091754462129);
    List.Add(OpeningMoves, 5337112763461220622603124933021900921321);
    List.Add(OpeningMoves, 5337112763460219523627364636072258431220);
    List.Add(OpeningMoves, 5337112763460219622613210092071362610917266212285244152337282128);
    List.Add(OpeningMoves, 5337112751430722372922285236273643361220);
    List.Add(OpeningMoves, 5337112758430219554715236255061552441220);
    List.Add(OpeningMoves, 5337112758430219634612206226031200920722);
    List.Add(OpeningMoves, 5337112762351321634609170092102635530310);
    List.Add(OpeningMoves, 533711276235132158430917493306136346041100920219523627364636072236191019);
    List.Add(OpeningMoves, 533711275236273660360219364407225843132163460411);
    List.Add(OpeningMoves, 5337111952361228372903305843132155393023635319275640163253380219);
    List.Add(OpeningMoves, 533711195236122858432837433703303747302363460212);
    List.Add(OpeningMoves, 5337111952361228372919273627132159450212);
    List.Add(OpeningMoves, 533713296032021962351523324607226353061552440090);
    List.Add(OpeningMoves, 533713296046072262350219635312205648032135211421);
    List.Add(OpeningMoves, 533713296235072252440219634606275843122059311624);
    List.Add(OpeningMoves, 5337132962350219524407225931061363460090009216243140153140472232);
    List.Add(OpeningMoves, 533713295843072254381228382922376346061360533743);
    List.Add(OpeningMoves, 5337132958430722623522376032372035420219);
    List.Add(OpeningMoves, 533713296346021962260917263307220092061362610090);
    List.Add(OpeningMoves, 533713296346021962260917263307226053102633420613);
    List.Add(OpeningMoves, 533713296346021962260917263307225236293600920613);
    List.Add(OpeningMoves, 533713296346021962260917263307225843061300921026);
    List.Add(OpeningMoves, 5337132963460219622609172619121946290436);
    List.Add(OpeningMoves, 53371329634602196226091726191219009203395648393255393223);
    List.Add(OpeningMoves, 533713296346021962260917261912195843142252362936);
    List.Add(OpeningMoves, 533713296346021962260917261912195236293660360436);
    List.Add(OpeningMoves, 5337132963460219523629364636062759450422);
    List.Add(OpeningMoves, 53371329634602195236293662350627514336445034271849330917);
    List.Add(OpeningMoves, 533713296346021962350722463112283728102635260428);
    List.Add(OpeningMoves, 53371329634602196235072246311228372819253526111928191019);
    List.Add(OpeningMoves, 5337132963460219584307226226063400920090);
    List.Add(OpeningMoves, 53371329634602195843072252362936463622374337041354461430);
    List.Add(OpeningMoves, 53371329634602195843072246291929523629193628192954382923372922072820112029200422);
    List.Add(OpeningMoves, 533713295438293863461531623531394629044061620219);
    List.Add(OpeningMoves, 53371329543829386346153162353139009239466046062763640440523627365938142258431220);
    List.Add(OpeningMoves, 5337132954382938634615315640313946290722523612202944223759380615);
    List.Add(OpeningMoves, 5337132954382938623504406162062752362718634640325938122058430339);
    List.Add(OpeningMoves, 53371329543829386346061362350722584300900092021952360917);
    List.Add(OpeningMoves, 5337132954382938623507225843111937291228292228352215061560530321);
    List.Add(OpeningMoves, 5337132954382938523604406153122063460339593839465346072262440219);
    List.Add(OpeningMoves, 533713295438293862351228352807225843063463463443524311192842);
    List.Add(OpeningMoves, 5337132954380627634612206235072238292029462904363514050629443637);
    List.Add(OpeningMoves, 53371329543802196346122062350339009219363829364655463948);
    List.Add(OpeningMoves, 533702195236122837280428634603396253009151352832);
    List.Add(OpeningMoves, 53370219634613296226091726331026334207220092223762611430);
    List.Add(OpeningMoves, 5337072237292228523612206346033962531119);
    List.Add(OpeningMoves, 533715235236061562351220634607226053009000920339);
    List.Add(OpeningMoves, 5337152352360615634612206235072260530090009203393729202936292228);
    List.Add(OpeningMoves, 53371523523606155843072263460090372922055938122056480212);
    List.Add(OpeningMoves, 533713215236122837291127514302195438273643360418);
    List.Add(OpeningMoves, 53371321523612283729112751430219634604186253273643360713);
    List.Add(OpeningMoves, 533713215236122858430634604428374437072237400428);
    List.Add(OpeningMoves, 53371321523612285843063437291127494134435043071360390090);
    List.Add(OpeningMoves, 53371321523612285843063437282128595207224941342043262013);
    List.Add(OpeningMoves, 53371321634612283728212852360722584311196244062059310090);
    List.Add(OpeningMoves, 5337122052360722584302126346132955392239646339226235162459451119);
    List.Add(OpeningMoves, 5337122052360722584302126346132962351624009211194933041160530613);
    List.Add(OpeningMoves, 5337122052360722584302126346132962530613009200906261111949330925);
    List.Add(OpeningMoves, 5337122052360722584315235945061554460090605213293628111900931928);
    List.Add(OpeningMoves, 533712205236072258431523623506156346021956480090594522373514061443372028);
    List.Add(OpeningMoves, 5337122837280428584328255236111963460722);
    List.Add(OpeningMoves, 52361228634607225931223731401127362702195852372751431523);
    List.Add(OpeningMoves, 5236122863460722534511275135273645361523584306156253009000920219);
    List.Add(OpeningMoves, 5236122863460219584313215337072237292212593106135640121860521624);
    List.Add(OpeningMoves, 52361228634602195938033953451321513506345843071356483932);
    List.Add(OpeningMoves, 523612286346072251351119584313215931061353450090);
    List.Add(OpeningMoves, 52361228634613215843072253450219624409170092063449413420);
    List.Add(OpeningMoves, 52361228634613215843072259310613312213225337283743370090);
    List.Add(OpeningMoves, 523612285135132158430722534509176244283544350634);
    List.Add(OpeningMoves, 5236122851351321584307225931021253450634);
    List.Add(OpeningMoves, 52361228534507226244132163461127514302195852061300920090);
    List.Add(OpeningMoves, 52361228513511195843072263461321593106135345009062440212);
    List.Add(OpeningMoves, 52361228513511196346072258431321593106135345009062440212);
    List.Add(OpeningMoves, 52361228593807225345132163460620462902125852009051431127);
    List.Add(OpeningMoves, 52360722513515235843061563460090533712206253132936280925);
    List.Add(OpeningMoves, 523607225135152363460615554700905843122835282228);
    List.Add(OpeningMoves, 52360722513515236346061558430090533712206253132900920219);
    List.Add(OpeningMoves, 52360722513513215843063453450090624412286346112700920219);
    List.Add(OpeningMoves, 5236072251351220634603395345021256483932584313295539322362551119);
    List.Add(OpeningMoves, 523607225135152358430615533712206346009062531329);
    List.Add(OpeningMoves, 52360722634613215135101858430310534506346253009060510219);
    List.Add(OpeningMoves, 523607226346122851351321584311195345021260510620);
    List.Add(OpeningMoves, 523607225135132163461228584306346033021953450090);
    List.Add(OpeningMoves, 52360722513513216346101855470310625506130092009058432237);
    List.Add(OpeningMoves, 523614305135072258431321534506346253009063462237);
    List.Add(OpeningMoves, 52361430554707226255152363460615009200905135122058430405);
    List.Add(OpeningMoves, 5236143063460722554713215135122862551119009206205042041359500090);
    List.Add(OpeningMoves, 52361321513507226346101855470310625506130092009058432237);
    List.Add(OpeningMoves, 52361321513507225843063460510090634610185931031000933443);
    List.Add(OpeningMoves, 52361321513512285843072263461119534502126051062062440090);
    List.Add(OpeningMoves, 5236132936290219634604135938133438523450584306345758504158424125);
    List.Add(OpeningMoves, 523613293629021963460413593813343852345058431934463606275758504158424125);
    List.Add(OpeningMoves, 4941132953451228513507225034032135271119);
    List.Add(OpeningMoves, 4933132953370722524412283728222855470620);
    List.Add(OpeningMoves, 493313293325122856401127403202195733072233400425);
    List.Add(OpeningMoves, 504213295950021951350722534512283528222849410620);
    List.Add(OpeningMoves, 503413295950122051350722584306135345009063460339);
    List.Add(OpeningMoves, 584312285337283643531329);
    List.Add(OpeningMoves, 514313295337072252440219604612205648032162530412);
    List.Add(OpeningMoves, 513513295843072255471228352822286255284350431119);
    List.Add(OpeningMoves, 51351329634602195843072255470627625500900092122052440330);
    List.Add(OpeningMoves, 5135132955471228352807226255222852441119);
    List.Add(OpeningMoves, 5135132953370722584306275244122062530219);
    List.Add(OpeningMoves, 513511275843021955471523625506156346072200920090523627364636193660361220);
    List.Add(OpeningMoves, 524412285547132962550722);
    List.Add(OpeningMoves, 53451329523629364536122863460722);
    List.Add(OpeningMoves, 54461329533706275843122043280219);
    List.Add(OpeningMoves, 54461329533707225244062755391624);
    List.Add(OpeningMoves, 54381321634612285345112750420219);
    List.Add(OpeningMoves, 543812286346152355470615625507220092009052441127);
    List.Add(OpeningMoves, 55391329625512285135283560331119);
    List.Add(OpeningMoves, 554712286255132951352836524411275438062038292029);
    List.Add(OpeningMoves, 56481329533707225244122859312837312204224437062763462218);
    List.Add(OpeningMoves, 56481329494112285345072250341127342609174133031259500620);
    List.Add(OpeningMoves, 564013295337072252440627625312205143021249330925);
    List.Add(OpeningMoves, 5640072251351127584302195345132152360917);
    List.Add(OpeningMoves, 56400722634602194032122852361321);
    List.Add(OpeningMoves, 6346072251351523554706156255009000921220);
    List.Add(OpeningMoves, 6346072251351321523612285843061359380090);
    List.Add(OpeningMoves, 634612285236072251351321584306135931009053451624);
    List.Add(OpeningMoves, 634612285843132152360722593106135345009062441624);
    List.Add(OpeningMoves, 6346122846631329634629374663072258432836435802195244374451440620);
    Count = List.Length(OpeningMoves);
    Idx = 1;
    Repeat (Count)
    {
        List.Add(OpeningMoves, "");
        If ((Variable.Length(OpeningMoves[Idx]) / 4) > 4)
        {
            IdxSub = 1;
            Repeat ((Variable.Length(OpeningMoves[Idx]) / 4))
            {
                Call GetVirtualMove(Operator.Join(Operator.Join(Operator.LetterOf(OpeningMoves[Idx], IdxSub), Operator.LetterOf(OpeningMoves[Idx], (IdxSub + 1))), Operator.Join(Operator.LetterOf(OpeningMoves[Idx], (IdxSub + 2)), Operator.LetterOf(OpeningMoves[Idx], (IdxSub + 3)))));
                List.ReplaceItem(OpeningMoves, last, Operator.Join(OpeningMoves[last], VirtualMove));
                IdxSub += 4;
            }
        }
        Idx += 1;
    }
}

Define InitPawnSquare (warp=true)
{
    List.DeleteItem(PawnPieceSquare, all);
    Call LoadList("0, 0, 0, 0, 0, 0, 0, 0, 7, 11, 23, 39, 39, 23, 11, 7,  -5, 1, 14, 29, 29, 14, 1, -5,  -14, -8, 6, 22, 22, 6, -8, -14,  -21, -16, -1, 14, 14, -1, -16, -21,  -26, -21, -6, 4, 4, -6, -21, -26,  -31, -26, -11, -1, -1, -11, -26, -31,  0, 0, 0, 0, 0, 0, 0, 0")("PawnPieceSquare");
}

Define InitPawnSquareEndgame (warp=true)
{
    List.DeleteItem(PawnPieceSquareEndgame, all);
    Call LoadList(" 100, 90, 80, 75, 75, 80, 90, 100,  65, 55, 45, 40, 40, 45, 55, 65,  35, 25, 15, 10, 10, 15, 25, 35,  20, 10, 0, -5, -5, 0, 10, 20,  10, 0, -10, -15, -15, -10, 0, 10,  5, -10, -20, -25, -25, -20, -10, 5,  5, -10, -20, -25, -25, -20, -10, 5,  0, 0, 0, 0, 0, 0, 0, 0")("PawnPieceSquareEndgame");
}

Define InitPawnSquarePreCastling (warp=true)
{
    List.DeleteItem(PawnPieceSquarePreCastling, all);
    Call LoadList(" 0, 0, 0, 0, 0, 0, 0, 0, -35, -35, -35, 39, 39, -35, -35, -35, -35, -35, -35, 29, 29, -35, -35, -35, -35, -35, -35, 22, 22, -35, -35, -35, -35, -35, -35, 14, 14, -35, -35, -35, -25, -11, -25, 4, 4, -25, -11, -25,  -21, -21, -6, -1, -1, -6, -21, -21,   0, 0, 0, 0, 0, 0, 0, 0")("PawnPieceSquarePreCastling");
}

Define InitQueenSquare (warp=true)
{
    List.DeleteItem(QueenPieceSquare, all);
    Call LoadList("4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,-6, -6, -1, 4, 4, -1, -6, -6, -16, -11, -1, 4, 4, -1, -11, -16, -26, -16, -6, 4, 4, -6, -16, -26")("QueenPieceSquare");
}

Define InitRookSquare (warp=true)
{
    List.DeleteItem(RookPieceSquare, all);
    Call LoadList("-8, -6, 2, 7, 7, 2, -6, -8,2, 2, 7, 12, 12, 7, 2, 2, -8, -6, 6, 10, 10, 6, -6, -8, -8, -6, 6, 8, 8, 6, -6, -8, -8, -6, 6, 7, 7, 6, -6, -8, -8, -6, 6, 7, 7, 6, -6, -8, -8, -6, 2, 7, 7, 2, -6, -8, -8, -6, 2, 7, 7, 2, -6, -8")("RookPieceSquare");
}

Define InvalidateMovePosLookup (warp=true)
{
    PrevMetaState = "";
}

Define IsBlackKingCheckMate (warp=true)
{
    IsBlackKingCheckMateRes = 0;
    Call CalcBoardAttackedByMove(2);
    If (IsBlackChecked == 1)
    {
        IsBlackKingCheckMateRes = 1;
        Call CalculateMoves(1);
        List.ReplaceItem(MovesIdx, 1, 1);
        Repeat (MovesCount[1])
        {
            If (IsBlackKingCheckMateRes == 1)
            {
                Call ApplyMove(1);
                Call CalcBoardAttackedByMove(2);
                If (IsBlackChecked == 0)
                {
                    IsBlackKingCheckMateRes = 0;
                }
                Call RevertMove(1);
            }
            List.ReplaceItem(MovesIdx, 1, (MovesIdx[1] + 1));
        }
    }
}

Define IsDrawByMaterial (warp=true)
{
    IsDrawRes = 0;
    CurrentValue = 0;
    CurrentValue2 = 0;
    Idx = 1;
    Repeat (64)
    {
        CurrentPiece = Board[Idx];
        If (Not ((CurrentPiece == 0)))
        {
            If ((CurrentPiece == BlackBishop) Or (CurrentPiece == BlackKnight))
            {
                CurrentValue += 1;
            }
            Else
            {
                If ((CurrentPiece == WhiteBishop) Or (CurrentPiece == WhiteKnight))
                {
                    CurrentValue2 += 1;
                }
                Else
                {
                    If (Not ((abs(CurrentPiece) == BlackKing)))
                    {
                        Stop(this script);
                    }
                }
            }
        }
        Idx += 1;
    }
    If ((CurrentValue + CurrentValue2) < 2)
    {
        IsDrawRes = 1;
    }
}

Define IsDrawByStalemate(string Depth) (warp=true)
{
    Call CalcBoardAttackedByMoveChecked((Depth + 1));
    If ((((Depth % 2) == 1) And (IsBlackChecked == 1)) Or (((Depth % 2) == 0) And (IsWhiteChecked == 1)))
    {
        IsDrawRes = 0;
        Stop(this script);
    }
    IsDrawRes = 1;
    Call CalculateMoves(Depth);
    List.ReplaceItem(MovesIdx, Depth, 1);
    Repeat (MovesCount[Depth])
    {
        If (IsDrawRes == 1)
        {
            Call ApplyMove(Depth);
            Call CalcBoardAttackedByMoveChecked((Depth + 1));
            If ((((Depth % 2) == 1) And (IsBlackChecked == 0)) Or (((Depth % 2) == 0) And (IsWhiteChecked == 0)))
            {
                IsDrawRes = 0;
            }
            Call RevertMove(Depth);
        }
        List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
    }
}

Define IsLowerCase(string Char) (warp=true)
{
    Chars = "";
    CharsIdx = 1;
    Repeat (Variable.Length(CharsUpperCase))
    {
        If (Operator.LetterOf(CharsUpperCase, CharsIdx) == Char)
        {
            Chars = Operator.Join(Chars, Char);
        }
        Else
        {
            Chars = Operator.Join(Chars, Operator.LetterOf(CharsUpperCase, CharsIdx));
        }
        CharsIdx += 1;
    }
    Looks.SwitchCostumeTo(_ABCDEFGHIJKLMNOPQRSTUVWXYZ);
    Looks.SwitchCostumeTo(Chars);
    If (Costume.GetNumberName(number) == 1)
    {
        IsLowerCaseRes = 0;
    }
    Else
    {
        IsLowerCaseRes = 1;
    }
}

Define IsQuiescentCheck(string Piece)(string SourceIdx)(string Depth) (warp=true)
{
    IsQuiescentCheckRes = 0;
    If (((IsModeJunior == 0) And (Level > 1)) And (((IsScratch3 == 0) Or (IsEndgame == 1)) Or (((IsWhiteCastlingPossible == 0) And (Piece > 0)) Or ((IsBlackCastlingPossible == 0) And (Piece < 0)))))
    {
        If (Piece > 0)
        {
            If (Not ((MovePosLookupBlack[((PieceIdxLookup[Piece] * 10000) + ((SourceIdx * 100) + WhiteKingIdx))] == "")))
            {
                IsQuiescentCheckRes = 1;
            }
        }
        Else
        {
            If (Not ((MovePosLookupWhite[((PieceIdxLookup[(0 - Piece)] * 10000) + ((SourceIdx * 100) + BlackKingIdx))] == "")))
            {
                IsQuiescentCheckRes = 1;
            }
        }
        If (IsQuiescentCheckRes == 1)
        {
            If ((Quiescence[2] == 1) And ((CheckedState[(Depth - 1)] == 1) And (Depth < 6)))
            {
                Stop(this script);
            }
            If (Quiescence[(Depth - 1)] == 0)
            {
                If ((((IsScratch3 == 0) And (IsEndgame == 1)) Or (IsEndgame2 == 1)) Or (CheckedState[(Depth - 1)] == 1))
                {
                    Stop(this script);
                }
            }
            Else
            {
                If (Quiescence[(Depth - 2)] == 0)
                {
                    If ((((IsScratch3 == 0) And (IsEndgame == 1)) Or (IsEndgame2 == 1)) And (CheckedState[(Depth - 1)] == 1))
                    {
                        Stop(this script);
                    }
                }
                Else
                {
                    If (Quiescence[(Depth - 3)] == 0)
                    {
                        If ((((IsScratch3 == 0) And (IsEndgame == 1)) Or (IsEndgame2 == 1)) And (CheckedState[(Depth - 1)] == 1))
                        {
                            Stop(this script);
                        }
                    }
                    Else
                    {
                        If (Quiescence[(Depth - 4)] == 0)
                        {
                            If ((((IsScratch3 == 0) And (IsEndgame == 1)) Or (IsEndgame2 == 1)) And (CheckedState[(Depth - 1)] == 1))
                            {
                                Stop(this script);
                            }
                        }
                        Else
                        {
                            If (Quiescence[(Depth - 5)] == 0)
                            {
                                If ((((IsScratch3 == 0) And (IsEndgame == 1)) Or (IsEndgame2 == 1)) And (CheckedState[(Depth - 1)] == 1))
                                {
                                    Stop(this script);
                                }
                            }
                        }
                    }
                }
            }
            IsQuiescentCheckRes = 0;
        }
    }
}

Define IsValidMove(num Move) (warp=true)
{
    ValidMoveRes = 1;
    If (((Move < 0) Or (Move > 9999)) Or (((floor((Move / 100)) == 0) Or (floor((Move % 100)) == 0)) And (Not ((((Move == BlackQueensideCastling) Or (Move == BlackKingsideCastling)) Or ((Move == WhiteQueensideCastling) Or (Move == WhiteKingsideCastling)))))))
    {
        ValidMoveRes = 0;
    }
}

Define IsWhiteKingCheckMate (warp=true)
{
    IsWhiteKingCheckMateRes = 0;
    Call CalcBoardAttackedByMove(1);
    If (IsWhiteChecked == 1)
    {
        IsWhiteKingCheckMateRes = 1;
        Call CalculateMoves(2);
        List.ReplaceItem(MovesIdx, 2, 1);
        Repeat (MovesCount[2])
        {
            If (IsWhiteKingCheckMateRes == 1)
            {
                Call ApplyMove(2);
                Call CalcBoardAttackedByMove(1);
                If (IsWhiteChecked == 0)
                {
                    IsWhiteKingCheckMateRes = 0;
                }
                Call RevertMove(2);
            }
            List.ReplaceItem(MovesIdx, 2, (MovesIdx[2] + 1));
        }
    }
}

Define LoadList(string Data)(string ListName) (warp=true)
{
    IdxString = 1;
    CurrentValue = "";
    Repeat Until (IdxString > Variable.Length(Data))
    {
        If ((Not ((Operator.LetterOf(Data, IdxString) == " "))) And (Not ((Operator.LetterOf(Data, IdxString) == ","))))
        {
            CurrentValue = Operator.Join(CurrentValue, Operator.LetterOf(Data, IdxString));
        }
        If ((Operator.LetterOf(Data, IdxString) == ",") Or (IdxString == Variable.Length(Data)))
        {
            If (ListName == "PawnPieceSquare")
            {
                List.Add(PawnPieceSquare, (Operator.Round((CurrentValue * 0.75)) - 15));
            }
            If (ListName == "PawnPieceSquareEndgame")
            {
                List.Add(PawnPieceSquareEndgame, (Operator.Round((CurrentValue * 0.5)) - 15));
            }
            If (ListName == "PawnPieceSquarePreCastling")
            {
                List.Add(PawnPieceSquarePreCastling, (Operator.Round((CurrentValue * 0.75)) - 15));
            }
            If (ListName == "KingPieceSquare")
            {
                List.Add(KingPieceSquare, CurrentValue);
            }
            If (ListName == "KingPieceSquareEndgame")
            {
                List.Add(KingPieceSquareEndgame, CurrentValue);
            }
            If (ListName == "QueenPieceSquare")
            {
                List.Add(QueenPieceSquare, CurrentValue);
            }
            If (ListName == "RookPieceSquare")
            {
                List.Add(RookPieceSquare, CurrentValue);
            }
            If (ListName == "BishopPieceSquare")
            {
                List.Add(BishopPieceSquare, CurrentValue);
            }
            If (ListName == "KnightPieceSquare")
            {
                List.Add(KnightPieceSquare, CurrentValue);
            }
            If (ListName == "KnightMobilityBonus")
            {
                List.Add(KnightMobilityBonus, (CurrentValue * 3));
            }
            If (ListName == "BishopMobilityBonus")
            {
                List.Add(BishopMobilityBonus, (CurrentValue * 3));
            }
            If (ListName == "RookMobilityBonus")
            {
                List.Add(RookMobilityBonus, (CurrentValue * 3));
            }
            If (ListName == "QueenMobilityBonus")
            {
                List.Add(QueenMobilityBonus, (CurrentValue * 3));
            }
            If (ListName == "PawnStorm")
            {
                List.Add(PawnStorm, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "PawnShelter")
            {
                List.Add(PawnShelter, Operator.Round((CurrentValue * 1)));
            }
            CurrentValue = "";
        }
        IdxString += 1;
    }
}

Define Log(string Txt1)(string Txt2)(string Txt3)(string Txt4)(string Txt5)(string Txt6)(string Txt7)(string Txt8) (warp=true)
{
    List.Add(Logfile, Operator.Join(Txt1, Operator.Join(Txt2, Operator.Join(Txt3, Operator.Join(Txt4, Operator.Join(Txt5, Operator.Join(Txt6, Operator.Join(Txt7, Txt8))))))));
}

Define OnEvaluationChanged(string Eval) (warp=true)
{
    If (IsModeJunior == 0)
    {
        If (Eval > 1000)
        {
            EvaluationValue = 100;
        }
        Else
        {
            If (Eval < -1000)
            {
                EvaluationValue = -100;
            }
            Else
            {
                EvaluationValue = (Eval / 10);
            }
        }
    }
    Else
    {
        EvaluationValue = 0;
    }
    Event.Broadcast("evaluationvaluechanged");
    Control.Wait(0);
}

Define OnProgressChanged(num Progress) (warp=true)
{
    If (Progress < 100)
    {
        ProgressValue = Progress;
    }
    Else
    {
        ProgressValue = 100;
    }
    Event.Broadcast("progressvaluechangedinternal");
    Control.Wait(0);
}

Define OnScoreCalc(string Depth)(string MinDepth)(string MaxDepth)(bool Quiescence) (warp=true)
{
    If (Depth == 0)
    {
        Call EvaluateBoard;
        EvalResultBase = EvalResult;
        Stop(this script);
    }
    If (IsProfilerEnabled > 0)
    {
        Call Profile_MethodEnter(Depth);
    }
    ScoreCalcRes = "";
    If (Depth == 1)
    {
        List.ReplaceItem(PosScoreDeltaSum, Depth, PosScoreDelta[Depth]);
        List.ReplaceItem(CapturesDeltaSum, Depth, (TargetPieces[Depth] - PromotionPieces[Depth]));
        Call EvaluateBoardExtended1(Depth);
        List.ReplaceItem(EvalExtended1, Depth, EvalExtendedResult1);
        Call EvaluateBoardExtended2(Depth);
        List.ReplaceItem(EvalExtended2, Depth, EvalExtendedResult2);
        Call EvaluateBoardExtended3(Depth);
        List.ReplaceItem(EvalExtended3, Depth, EvalExtendedResult3);
    }
    Else
    {
        SourcePiece = abs(SourcePieces[Depth]);
        List.ReplaceItem(PosScoreDeltaSum, Depth, (PosScoreDeltaSum[(Depth - 1)] + PosScoreDelta[Depth]));
        List.ReplaceItem(CapturesDeltaSum, Depth, (CapturesDeltaSum[(Depth - 1)] + (TargetPieces[Depth] - PromotionPieces[Depth])));
        If (((SourcePiece == BlackPawn) Or (SourcePiece == BlackKing)) Or (abs(TargetPieces[Depth]) == BlackPawn))
        {
            Call EvaluateBoardExtended1(Depth);
            List.ReplaceItem(EvalExtended1, Depth, EvalExtendedResult1);
        }
        Else
        {
            List.ReplaceItem(EvalExtended1, Depth, EvalExtended1[(Depth - 1)]);
        }
        If (((Not (Quiescence)) And (SourcePiece == BlackRook)) Or (SourcePiece == BlackKing))
        {
            Call EvaluateBoardExtended2(Depth);
            List.ReplaceItem(EvalExtended2, Depth, EvalExtendedResult2);
        }
        Else
        {
            List.ReplaceItem(EvalExtended2, Depth, EvalExtended2[(Depth - 1)]);
        }
        If (BoardAttackedCalculated[Depth] == 1)
        {
            Call EvaluateBoardExtended3(Depth);
            List.ReplaceItem(EvalExtended3, Depth, EvalExtendedResult3);
        }
        Else
        {
            List.ReplaceItem(EvalExtended3, Depth, EvalExtended3[(Depth - 1)]);
        }
    }
    If (IsEndgame == 1)
    {
        If (abs(TargetPieces[Depth]) == BlackPawn)
        {
            List.ReplaceItem(CapturesDeltaSum, Depth, (CapturesDeltaSum[Depth] + (TargetPieces[Depth] * ((IsEndgame + IsEndgame2) * 0.1))));
        }
        Else
        {
            If (Not ((PromotionPieces[Depth] == 0)))
            {
                List.ReplaceItem(CapturesDeltaSum, Depth, (CapturesDeltaSum[Depth] + (SourcePieces[Depth] * ((IsEndgame + IsEndgame2) * 0.1))));
            }
        }
    }
    If (Depth == MaxDepth)
    {
        ScoreCalcRes = ((EvalResultBase + ((EvalExtended1[Depth] + EvalExtended2[Depth]) + EvalExtended3[Depth])) + ((PosScoreDeltaSum[Depth] - CapturesDeltaSum[Depth]) + (BlackMobBonus[Depth] - WhiteMobBonus[Depth])));
    }
    If List.ContainsItem(SourcePieces, BlackKing)
    {
        If (CapturesDeltaSum[Depth] == ((BlackPawn + BlackRook) + (WhiteBishop + WhiteKnight)))
        {
            ScoreCalcRes += 75;
        }
    }
    If List.ContainsItem(SourcePieces, WhiteKing)
    {
        If (CapturesDeltaSum[Depth] == ((WhitePawn + WhiteRook) + (BlackBishop + BlackKnight)))
        {
            ScoreCalcRes += -75;
        }
    }
    If ((Not (List.ContainsItem(TargetPieces, BlackBishop))) And (BlackBishopCount == 2))
    {
        ScoreCalcRes += (10 * ((IsEndgame * 4) + 1));
    }
    If ((Not (List.ContainsItem(TargetPieces, WhiteBishop))) And (WhiteBishopCount == 2))
    {
        ScoreCalcRes += (-10 * ((IsEndgame * 4) + 1));
    }
    If (CapturesDeltaSum[Depth] == 0)
    {
        CurrentValue = ((((BlackQueenCount * 9) + (BlackRookCount * 5)) + (((BlackMinorCount - BlackRookCount) * 3) + BlackPawnCount)) - (((WhiteQueenCount * 9) + (WhiteRookCount * 5)) + (((WhiteMinorCount - WhiteRookCount) * 3) + WhitePawnCount)));
        If (Not ((CurrentValue == 0)))
        {
            HasCaptures = 0;
            Idx = Depth;
            Repeat Until ((HasCaptures == 1) Or (Idx < 1))
            {
                If (Not ((TargetPieces[Depth] == 0)))
                {
                    HasCaptures = 1;
                }
                Idx += -1;
            }
            If (HasCaptures == 1)
            {
                If (CurrentValue > 0)
                {
                    ScoreCalcRes += 50;
                }
                Else
                {
                    If (CurrentValue < 0)
                    {
                        ScoreCalcRes += -50;
                    }
                }
            }
        }
    }
    If (IsProfilerEnabled > 0)
    {
        Call Profile_MethodExit(Depth);
    }
}

Define PickMove(string Depth)(string MaxDepth)(bool InitialDeepening)(bool Quiescence)(bool PrevQuiescence) (warp=true)
{
    If (PickPhase[Depth] == 1)
    {
        List.ReplaceItem(PickedMove, Depth, "");
        Call ClearMoveList(Depth);
        If (Depth > 1)
        {
            Call TTProbeNode(CurrentBoardHash)(Depth);
            If (TTProbeRes == 1)
            {
                If (IsProfilerEnabled > 0)
                {
                    Call Profile_IncCounter((210 + Depth));
                }
                If (Not ((TTProbeCheckedRes == "")))
                {
                    List.ReplaceItem(CheckedState, Depth, TTProbeCheckedRes);
                    If (((Not ((TTProbeBoardAttackedByOpp == ""))) And (Not ((TTProbeBoardAttackedByOppPiece == "")))) And (Not ((TTProbeCheckedAttackLinesRes == ""))))
                    {
                        List.ReplaceItem(CheckedStateAttackLines, Depth, TTProbeCheckedAttackLinesRes);
                        If ((Depth % 2) == 1)
                        {
                            List.ReplaceItem(BoardAttackedByWhiteSnapshot, Depth, TTProbeBoardAttackedByOpp);
                            List.ReplaceItem(BoardAttackedByWhitePieceSnapshot, Depth, TTProbeBoardAttackedByOppPiece);
                        }
                        Else
                        {
                            List.ReplaceItem(BoardAttackedByBlackSnapshot, Depth, TTProbeBoardAttackedByOpp);
                            List.ReplaceItem(BoardAttackedByBlackPieceSnapshot, Depth, TTProbeBoardAttackedByOppPiece);
                        }
                        List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
                    }
                }
                If (Variable.Length(TTProbeBestMoveRes) == 6)
                {
                    List.ReplaceItem(PawnPromotionFile, Depth, IdxToFile[(floor(TTProbeBestMoveRes) % 100)]);
                }
                If (Not ((TTProbeBlackMobRes == "")))
                {
                    List.ReplaceItem(BlackMobBonus, Depth, TTProbeBlackMobRes);
                }
                If (Not ((TTProbeWhiteMobRes == "")))
                {
                    List.ReplaceItem(WhiteMobBonus, Depth, TTProbeWhiteMobRes);
                }
                If (Not ((TTProbeBestMoveRes == "")))
                {
                    TargetIdx = floor((TTProbeBestMoveRes % 100));
                    If ((Not (Quiescence)) Or (Quiescence And ((TTProbeHorizonRes == -1) Or (Not ((Board[TargetIdx] == 0))))))
                    {
                        List.ReplaceItem(PickedMove, Depth, TTProbeBestMoveRes);
                        Call AddMoveToList(TTProbeBestMoveRes)(0)(Depth);
                        List.ReplaceItem(MovesIdx, Depth, 1);
                        Call ApplyMove(Depth);
                        List.ReplaceItem(PickPhase, Depth, 2);
                        List.ReplaceItem(PickMoveRes, Depth, 1);
                        Stop(this script);
                    }
                }
            }
        }
        List.ReplaceItem(PickPhase, Depth, 2);
    }
    If (PickPhase[Depth] == 2)
    {
        If (Depth == 1)
        {
            Call CalcBoardAttackedByMove((Depth + 2));
            Call StoreAttackInfo((Depth + 2))(Depth);
        }
        If ((Not (Quiescence)) Or (Quiescence And (CheckedState[Depth] == 1)))
        {
            If (BoardAttackedCalculated[Depth] == 0)
            {
                Call CalcBoardAttackedByMove((Depth + 1));
                Call StoreAttackInfo((Depth + 1))(Depth);
                List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
            }
        }
        If InitialDeepening
        {
            If (Depth == 1)
            {
                List.DeleteItem(DeepeningScore, all);
                List.DeleteItem(DeepeningScoreOrderMap, all);
            }
        }
        CalculateMovesRequiresAttackRecalc = 0;
        Call CalculateMovesImplWrapper(Depth)((1 == 0))(Quiescence);
        If (Quiescence And (CalculateMovesRequiresAttackRecalc == 1))
        {
            Call CalcBoardAttackedByMove((Depth + 1));
            Call StoreAttackInfo((Depth + 1))(Depth);
            List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
            Call CalculateMovesImplWrapper(Depth)((1 == 0))(Quiescence);
        }
        List.DeleteAll(KingAttackLines);
        List.ReplaceItem(MovesIdx, Depth, 1);
        Call GetCurrentMove(Depth);
        BoardAttackedString = "";
        BoardAttackedString2 = "";
        CurrentValue = "";
        CurrentValue2 = "";
        If (BoardAttackedCalculated[Depth] == 1)
        {
            If ((Depth % 2) == 1)
            {
                BoardAttackedString = BoardAttackedByWhiteSnapshot[Depth];
                BoardAttackedString2 = BoardAttackedByWhitePieceSnapshot[Depth];
            }
            Else
            {
                BoardAttackedString = BoardAttackedByBlackSnapshot[Depth];
                BoardAttackedString2 = BoardAttackedByBlackPieceSnapshot[Depth];
            }
            CurrentValue = CheckedState[Depth];
            CurrentValue2 = CheckedStateAttackLines[Depth];
        }
        If Quiescence
        {
            Call TTStoreNode(CurrentBoardHash)(Depth)("")(CurrentMove)("")(CurrentValue)(-1)("")("")(BoardAttackedString)(BoardAttackedString2)(CurrentValue2);
        }
        Else
        {
            Call TTStoreNode(CurrentBoardHash)(Depth)("")(CurrentMove)("")(CurrentValue)(0)(BlackMobBonus[Depth])(WhiteMobBonus[Depth])(BoardAttackedString)(BoardAttackedString2)(CurrentValue2);
        }
        List.ReplaceItem(MovesIdx, Depth, 0);
        List.ReplaceItem(PickPhase, Depth, 3);
    }
    If (PickPhase[Depth] == 3)
    {
        List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
        If (Not ((MovesIdx[Depth] > MovesCount[Depth])))
        {
            Call GetCurrentMove(Depth);
            If (CurrentMove == PickedMove[Depth])
            {
                List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
            }
            If (Not ((MovesIdx[Depth] > MovesCount[Depth])))
            {
                Call ApplyMove(Depth);
                List.ReplaceItem(PickMoveRes, Depth, 1);
                Stop(this script);
            }
        }
        List.ReplaceItem(PickPhase, Depth, 4);
        List.ReplaceItem(PickMoveRes, Depth, 0);
    }
    List.ReplaceItem(PickMoveRes, Depth, 0);
}

Define Profile_IncCounter(num Id) (warp=true)
{
    If (IsProfilerEnabled > 0)
    {
        Repeat Until (Not ((List.Length(Profile_Data) < Id)))
        {
            List.Add(Profile_Data, 0);
        }
        List.ReplaceItem(Profile_Data, Id, (Profile_Data[Id] + 1));
    }
}

Define Profile_MethodEnter(num Id) (warp=true)
{
    If (IsProfilerEnabled > 0)
    {
        Repeat Until (Not ((List.Length(Profile_Data) < Id)))
        {
            List.Add(Profile_Data, 0);
        }
        List.ReplaceItem(Profile_Data, Id, (Profile_Data[Id] - ((Sensing.DaysSince2000() * 24) * 3600)));
    }
}

Define Profile_MethodExit(num Id) (warp=false)
{
    If (IsProfilerEnabled > 0)
    {
        List.ReplaceItem(Profile_Data, Id, (Profile_Data[Id] + ((Sensing.DaysSince2000() * 24) * 3600)));
    }
}

Define Profile_Reset (warp=true)
{
    List.DeleteItem(Profile_Data, all);
}

Define QuickSort (warp=true)
{
    List.DeleteAll(QSPartStack);
    Call QuickSortImpl(1)(List.Length(CalcMovesScoreList));
}

Define QuickSortImpl(string Lo)(string Hi) (warp=true)
{
    QSPivot = CalcMovesScoreList[floor(((Lo + Hi) / 2))];
    QSLower = Lo;
    QSUpper = Hi;
    Repeat Until (QSLower > QSUpper)
    {
        Repeat Until (Not ((CalcMovesScoreList[QSLower] < QSPivot)))
        {
            QSLower += 1;
        }
        Repeat Until (Not ((CalcMovesScoreList[QSUpper] > QSPivot)))
        {
            QSUpper += -1;
        }
        If (Not ((QSLower > QSUpper)))
        {
            QSSwap = CalcMovesScoreList[QSLower];
            List.ReplaceItem(CalcMovesScoreList, QSLower, CalcMovesScoreList[QSUpper]);
            List.ReplaceItem(CalcMovesScoreList, QSUpper, QSSwap);
            QSSwap = CalcMovesMoveList[QSLower];
            List.ReplaceItem(CalcMovesMoveList, QSLower, CalcMovesMoveList[QSUpper]);
            List.ReplaceItem(CalcMovesMoveList, QSUpper, QSSwap);
            QSLower += 1;
            QSUpper += -1;
        }
    }
    If (Lo < QSUpper)
    {
        List.Add(QSPartStack, QSLower);
        Call QuickSortImpl(Lo)(QSUpper);
        QSLower = QSPartStack[List.Length(QSPartStack)];
        List.DeleteItem(QSPartStack, List.Length(QSPartStack));
    }
    If (QSLower < Hi)
    {
        Call QuickSortImpl(QSLower)(Hi);
    }
}

Define RevertMove(num Depth) (warp=true)
{
    CurrentMove = AppliedMove[Depth];
    SourceIdx = floor((CurrentMove / 100));
    If (SourceIdx > 0)
    {
        TargetIdx = floor((CurrentMove % 100));
        List.ReplaceItem(Board, SourceIdx, Board[TargetIdx]);
        List.ReplaceItem(Board, TargetIdx, 0);
        List.ReplaceItem(Board, TargetPiecesIdx[Depth], TargetPieces[Depth]);
        If (PromotionPieces[Depth] > 0)
        {
            List.ReplaceItem(Board, SourceIdx, BlackPawn);
        }
        Else
        {
            If (PromotionPieces[Depth] < 0)
            {
                List.ReplaceItem(Board, SourceIdx, WhitePawn);
            }
        }
        If (Board[SourceIdx] > 0)
        {
            If (Board[SourceIdx] == BlackPawn)
            {
                List.ReplaceItem(BlackPawnCount, IdxToFile[SourceIdx], (BlackPawnCount[IdxToFile[SourceIdx]] + 1));
                List.ReplaceItem(BlackPawnCount, IdxToFile[TargetIdx], (BlackPawnCount[IdxToFile[TargetIdx]] - 1));
            }
            Else
            {
                If (Board[SourceIdx] == BlackKing)
                {
                    BlackKingIdx = SourceIdx;
                }
            }
        }
        Else
        {
            If (Board[SourceIdx] == WhitePawn)
            {
                List.ReplaceItem(WhitePawnCount, IdxToFile[SourceIdx], (WhitePawnCount[IdxToFile[SourceIdx]] + 1));
                List.ReplaceItem(WhitePawnCount, IdxToFile[TargetIdx], (WhitePawnCount[IdxToFile[TargetIdx]] - 1));
            }
            Else
            {
                If (Board[SourceIdx] == WhiteKing)
                {
                    WhiteKingIdx = SourceIdx;
                }
            }
        }
        If (TargetPieces[Depth] == BlackPawn)
        {
            List.ReplaceItem(BlackPawnCount, IdxToFile[TargetPiecesIdx[Depth]], (BlackPawnCount[IdxToFile[TargetPiecesIdx[Depth]]] + 1));
        }
        Else
        {
            If (TargetPieces[Depth] == WhitePawn)
            {
                List.ReplaceItem(WhitePawnCount, IdxToFile[TargetPiecesIdx[Depth]], (WhitePawnCount[IdxToFile[TargetPiecesIdx[Depth]]] + 1));
            }
        }
    }
    Else
    {
        If (CurrentMove == WhiteKingsideCastling)
        {
            List.ReplaceItem(Board, VirtualBoard[61], WhiteKing);
            List.ReplaceItem(Board, VirtualBoard[62], Empty);
            List.ReplaceItem(Board, VirtualBoard[63], Empty);
            List.ReplaceItem(Board, VirtualBoard[64], WhiteRook);
            WhiteKingIdx = VirtualBoard[61];
        }
        Else
        {
            If (CurrentMove == WhiteQueensideCastling)
            {
                List.ReplaceItem(Board, VirtualBoard[57], WhiteRook);
                List.ReplaceItem(Board, VirtualBoard[59], Empty);
                List.ReplaceItem(Board, VirtualBoard[60], Empty);
                List.ReplaceItem(Board, VirtualBoard[61], WhiteKing);
                WhiteKingIdx = VirtualBoard[61];
            }
            Else
            {
                If (CurrentMove == BlackKingsideCastling)
                {
                    List.ReplaceItem(Board, VirtualBoard[5], BlackKing);
                    List.ReplaceItem(Board, VirtualBoard[6], Empty);
                    List.ReplaceItem(Board, VirtualBoard[7], Empty);
                    List.ReplaceItem(Board, VirtualBoard[8], BlackRook);
                    BlackKingIdx = VirtualBoard[5];
                }
                Else
                {
                    If (CurrentMove == BlackQueensideCastling)
                    {
                        List.ReplaceItem(Board, VirtualBoard[1], BlackRook);
                        List.ReplaceItem(Board, VirtualBoard[4], Empty);
                        List.ReplaceItem(Board, VirtualBoard[3], Empty);
                        List.ReplaceItem(Board, VirtualBoard[5], BlackKing);
                        BlackKingIdx = VirtualBoard[5];
                    }
                }
            }
        }
    }
    CurrentBoardHash = PreviousBoardHash[Depth];
    List.ReplaceItem(AppliedMove, Depth, "");
    List.ReplaceItem(SourcePieces, Depth, "");
    List.ReplaceItem(TargetPieces, Depth, "");
}

Define RUN_BEFORE_SAVING (warp=true)
{
    List.DeleteItem(MovePosLookupBlack, all);
    List.DeleteItem(MovePosLookupWhite, all);
    List.DeleteItem(MoveHashLookupBlack, all);
    List.DeleteItem(MoveHashLookupWhite, all);
    List.DeleteItem(TTBoardScore1, all);
    List.DeleteItem(TTBoardScore2, all);
    List.DeleteItem(TTBoardScore3, all);
    List.DeleteItem(TTBoardHash, all);
    List.DeleteItem(TTBoardAge, all);
    List.DeleteItem(TTNodeChecked, all);
    List.DeleteItem(TTNodeHash, all);
    List.DeleteItem(TTNodeBestMove, all);
    List.DeleteItem(TTNodeScore, all);
    List.DeleteItem(TTNodeDepth, all);
    List.DeleteItem(TTNodeAge, all);
    List.DeleteItem(TTNodeType, all);
    List.DeleteItem(TTNodeHorizon, all);
    List.DeleteItem(KillerMoves1, all);
    List.DeleteItem(KillerMoves2, all);
    List.DeleteItem(KillerMoves3, all);
    List.DeleteItem(KillerMoves4, all);
    List.DeleteItem(KillerMoves5, all);
    List.DeleteItem(KillerMoves6, all);
    List.DeleteItem(KillerMoves7, all);
    List.DeleteItem(KillerMoves8, all);
    List.DeleteItem(TTNodeHorizon, all);
    List.DeleteItem(TTNodeBlackMobility, all);
    List.DeleteItem(TTNodeWhiteMobility, all);
    List.DeleteItem(PieceIdxLookup, all);
    List.DeleteItem(TTNodeBoardAttackedByOpp, all);
    List.DeleteItem(TTNodeBoardAttackedByOppPiece, all);
    If (1 == 1)
    {
        List.DeleteItem(MoveLookupStraight, all);
        List.DeleteItem(MoveLookupCross, all);
        List.DeleteItem(MoveLookupOffsetsStraight, all);
        List.DeleteItem(MoveLookupOffsetsCross, all);
        List.DeleteItem(OpeningMoves, all);
        List.DeleteItem(KnightPieceSquare, all);
        List.DeleteItem(PawnPieceSquare, all);
        List.DeleteItem(BishopPieceSquare, all);
        List.DeleteItem(RookPieceSquare, all);
        List.DeleteItem(QueenPieceSquare, all);
        List.DeleteItem(KingPieceSquare, all);
        List.DeleteItem(KingPieceSquareEndgame, all);
        List.DeleteItem(OpeningMoves, all);
        List.DeleteItem(PawnPieceSquareEndgame, all);
        List.DeleteItem(PosPieceHashLookup, all);
        List.DeleteItem(BoardHistory, all);
        List.DeleteItem(MoveLookupKing, all);
        List.DeleteItem(MoveLookupKnight, all);
    }
}

Define SayAsync(string Text)(num Duration) (warp=false)
{
    SayAsyncText = Text;
    SayAsyncDuration = Duration;
    Event.Broadcast("sayasyncmsg");
}

Define SortList (warp=true)
{
    If (List.Length(CalcMovesScoreList) > 1)
    {
        Call QuickSort;
    }
}

Define SortMoveList(string Depth) (warp=true)
{
    If (IsProfilerEnabled > 0)
    {
        Call Profile_MethodEnter((300 + Depth));
    }
    If (Depth < 6)
    {
        If (Depth == 5)
        {
            Call SortList;
            List.DeleteAll(Moves5);
            Idx = List.Length(CalcMovesMoveList);
            Repeat (List.Length(CalcMovesMoveList))
            {
                List.Add(Moves5, CalcMovesMoveList[Idx]);
                Idx += -1;
            }
        }
        Else
        {
            If (Depth == 4)
            {
                Call SortList;
                List.DeleteAll(Moves4);
                Idx = 1;
                Repeat (List.Length(CalcMovesMoveList))
                {
                    List.Add(Moves4, CalcMovesMoveList[Idx]);
                    Idx += 1;
                }
            }
            Else
            {
                If (Depth == 3)
                {
                    Call SortList;
                    List.DeleteAll(Moves3);
                    Idx = List.Length(CalcMovesMoveList);
                    Repeat (List.Length(CalcMovesMoveList))
                    {
                        List.Add(Moves3, CalcMovesMoveList[Idx]);
                        Idx += -1;
                    }
                }
                Else
                {
                    If (Depth == 2)
                    {
                        Call SortList;
                        List.DeleteAll(Moves2);
                        Idx = 1;
                        Repeat (List.Length(CalcMovesMoveList))
                        {
                            List.Add(Moves2, CalcMovesMoveList[Idx]);
                            Idx += 1;
                        }
                    }
                    Else
                    {
                        If (Depth == 1)
                        {
                            List.DeleteAll(Moves1);
                            List.DeleteAll(Moves1Score);
                            Idx = 1;
                            Repeat (List.Length(CalcMovesMoveList))
                            {
                                List.Add(Moves1, CalcMovesMoveList[Idx]);
                                List.Add(Moves1Score, CalcMovesScoreList[Idx]);
                                Idx += 1;
                            }
                            Call SortList;
                            Idx = 1;
                            IdxSub = List.Length(CalcMovesMoveList);
                            Repeat (List.Length(CalcMovesMoveList))
                            {
                                List.ReplaceItem(DeepeningScoreOrderMap, Idx, List.IndexOf(Moves1, CalcMovesMoveList[IdxSub]));
                                Idx += 1;
                                IdxSub += -1;
                            }
                            Idx = 1;
                            IdxSub = List.Length(CalcMovesMoveList);
                            Repeat (List.Length(CalcMovesMoveList))
                            {
                                List.ReplaceItem(Moves1, Idx, CalcMovesMoveList[IdxSub]);
                                Idx += 1;
                                IdxSub += -1;
                            }
                        }
                    }
                }
            }
        }
    }
    Else
    {
        If (Depth < 11)
        {
            If (Depth == 6)
            {
                Call SortList;
                List.DeleteAll(Moves6);
                Idx = 1;
                Repeat (List.Length(CalcMovesMoveList))
                {
                    List.Add(Moves6, CalcMovesMoveList[Idx]);
                    Idx += 1;
                }
            }
            Else
            {
                If (Depth == 7)
                {
                    Call SortList;
                    List.DeleteAll(Moves7);
                    Idx = List.Length(CalcMovesMoveList);
                    Repeat (List.Length(CalcMovesMoveList))
                    {
                        List.Add(Moves7, CalcMovesMoveList[Idx]);
                        Idx += -1;
                    }
                }
                Else
                {
                    If (Depth == 8)
                    {
                        Call SortList;
                        List.DeleteAll(Moves8);
                        Idx = 1;
                        Repeat (List.Length(CalcMovesMoveList))
                        {
                            List.Add(Moves8, CalcMovesMoveList[Idx]);
                            Idx += 1;
                        }
                    }
                    Else
                    {
                        If (Depth == 9)
                        {
                            Call SortList;
                            List.DeleteAll(Moves9);
                            Idx = List.Length(CalcMovesMoveList);
                            Repeat (List.Length(CalcMovesMoveList))
                            {
                                List.Add(Moves9, CalcMovesMoveList[Idx]);
                                Idx += -1;
                            }
                        }
                        Else
                        {
                            If (Depth == 10)
                            {
                                Call SortList;
                                List.DeleteAll(Moves10);
                                Idx = 1;
                                Repeat (List.Length(CalcMovesMoveList))
                                {
                                    List.Add(Moves10, CalcMovesMoveList[Idx]);
                                    Idx += 1;
                                }
                            }
                        }
                    }
                }
            }
        }
        Else
        {
            If (Depth == 11)
            {
                Call SortList;
                List.DeleteAll(Moves11);
                Idx = List.Length(CalcMovesMoveList);
                Repeat (List.Length(CalcMovesMoveList))
                {
                    List.Add(Moves11, CalcMovesMoveList[Idx]);
                    Idx += -1;
                }
            }
            Else
            {
                If (Depth == 12)
                {
                    Call SortList;
                    List.DeleteAll(Moves12);
                    Idx = 1;
                    Repeat (List.Length(CalcMovesMoveList))
                    {
                        List.Add(Moves12, CalcMovesMoveList[Idx]);
                        Idx += 1;
                    }
                }
                Else
                {
                    If (Depth == 13)
                    {
                        Call SortList;
                        List.DeleteAll(Moves13);
                        Idx = List.Length(CalcMovesMoveList);
                        Repeat (List.Length(CalcMovesMoveList))
                        {
                            List.Add(Moves13, CalcMovesMoveList[Idx]);
                            Idx += -1;
                        }
                    }
                    Else
                    {
                        If (Depth == 14)
                        {
                            Call SortList;
                            List.DeleteAll(Moves14);
                            Idx = 1;
                            Repeat (List.Length(CalcMovesMoveList))
                            {
                                List.Add(Moves14, CalcMovesMoveList[Idx]);
                                Idx += 1;
                            }
                        }
                        Else
                        {
                            If (Depth == 15)
                            {
                                Call SortList;
                                List.DeleteAll(Moves15);
                                Idx = List.Length(CalcMovesMoveList);
                                Repeat (List.Length(CalcMovesMoveList))
                                {
                                    List.Add(Moves15, CalcMovesMoveList[Idx]);
                                    Idx += -1;
                                }
                            }
                            Else
                            {
                                If (Depth == 16)
                                {
                                    Call SortList;
                                    List.DeleteAll(Moves16);
                                    Idx = 1;
                                    Repeat (List.Length(CalcMovesMoveList))
                                    {
                                        List.Add(Moves16, CalcMovesMoveList[Idx]);
                                        Idx += 1;
                                    }
                                }
                                Else
                                {
                                    If (Depth == 17)
                                    {
                                        Call SortList;
                                        List.DeleteAll(Moves17);
                                        Idx = List.Length(CalcMovesMoveList);
                                        Repeat (List.Length(CalcMovesMoveList))
                                        {
                                            List.Add(Moves17, CalcMovesMoveList[Idx]);
                                            Idx += -1;
                                        }
                                    }
                                    Else
                                    {
                                        If (Depth == 18)
                                        {
                                            Call SortList;
                                            List.DeleteAll(Moves18);
                                            Idx = 1;
                                            Repeat (List.Length(CalcMovesMoveList))
                                            {
                                                List.Add(Moves18, CalcMovesMoveList[Idx]);
                                                Idx += 1;
                                            }
                                        }
                                        Else
                                        {
                                            If (Depth == 19)
                                            {
                                                Call SortList;
                                                List.DeleteAll(Moves19);
                                                Idx = List.Length(CalcMovesMoveList);
                                                Repeat (List.Length(CalcMovesMoveList))
                                                {
                                                    List.Add(Moves19, CalcMovesMoveList[Idx]);
                                                    Idx += -1;
                                                }
                                            }
                                            Else
                                            {
                                                If (Depth == 20)
                                                {
                                                    Call SortList;
                                                    List.DeleteAll(Moves20);
                                                    Idx = 1;
                                                    Repeat (List.Length(CalcMovesMoveList))
                                                    {
                                                        List.Add(Moves20, CalcMovesMoveList[Idx]);
                                                        Idx += 1;
                                                    }
                                                }
                                                Else
                                                {
                                                    If (Depth == 21)
                                                    {
                                                        Call SortList;
                                                        List.DeleteAll(Moves21);
                                                        Idx = List.Length(CalcMovesMoveList);
                                                        Repeat (List.Length(CalcMovesMoveList))
                                                        {
                                                            List.Add(Moves21, CalcMovesMoveList[Idx]);
                                                            Idx += -1;
                                                        }
                                                    }
                                                    Else
                                                    {
                                                        If (Depth == 22)
                                                        {
                                                            Call SortList;
                                                            List.DeleteAll(Moves22);
                                                            Idx = 1;
                                                            Repeat (List.Length(CalcMovesMoveList))
                                                            {
                                                                List.Add(Moves22, CalcMovesMoveList[Idx]);
                                                                Idx += 1;
                                                            }
                                                        }
                                                        Else
                                                        {
                                                            If (Depth == 23)
                                                            {
                                                                Call SortList;
                                                                List.DeleteAll(Moves23);
                                                                Idx = List.Length(CalcMovesMoveList);
                                                                Repeat (List.Length(CalcMovesMoveList))
                                                                {
                                                                    List.Add(Moves23, CalcMovesMoveList[Idx]);
                                                                    Idx += -1;
                                                                }
                                                            }
                                                            Else
                                                            {
                                                                If (Depth == 24)
                                                                {
                                                                    Call SortList;
                                                                    List.DeleteAll(Moves24);
                                                                    Idx = 1;
                                                                    Repeat (List.Length(CalcMovesMoveList))
                                                                    {
                                                                        List.Add(Moves24, CalcMovesMoveList[Idx]);
                                                                        Idx += 1;
                                                                    }
                                                                }
                                                                Else
                                                                {
                                                                    If (Depth == 25)
                                                                    {
                                                                        Call SortList;
                                                                        List.DeleteAll(Moves25);
                                                                        Idx = List.Length(CalcMovesMoveList);
                                                                        Repeat (List.Length(CalcMovesMoveList))
                                                                        {
                                                                            List.Add(Moves25, CalcMovesMoveList[Idx]);
                                                                            Idx += -1;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    If (IsProfilerEnabled > 0)
    {
        Call Profile_MethodExit((300 + Depth));
    }
}

Define StoreAttackInfo(string Depth)(string StoreDepth) (warp=true)
{
    If ((Depth % 2) == 1)
    {
        CurrentValue = "";
        CurrentValue2 = "";
        Idx = 1;
        Repeat (64)
        {
            CurrentValue = Operator.Join(CurrentValue, BoardAttackedByBlack[Idx]);
            If (Not ((BoardAttackedByBlackPiece[Idx] == 0)))
            {
                CurrentValue2 = Operator.Join(CurrentValue2, PieceIdxLookup[BoardAttackedByBlackPiece[Idx]]);
            }
            Else
            {
                CurrentValue2 = Operator.Join(CurrentValue2, 0);
            }
            Idx += 1;
        }
        List.ReplaceItem(BoardAttackedByBlackSnapshot, StoreDepth, CurrentValue);
        List.ReplaceItem(BoardAttackedByBlackPieceSnapshot, StoreDepth, CurrentValue2);
        If ((StoreDepth % 2) == 0)
        {
            List.ReplaceItem(CheckedStateAttackLines, StoreDepth, 0000000000000000000000000000000000000000000000000000000000000000);
            List.ReplaceItem(CheckedState, StoreDepth, IsWhiteChecked);
            If (IsWhiteChecked == 1)
            {
                CurrentValue = "";
                Idx = 1;
                Repeat (64)
                {
                    If List.ContainsItem(KingAttackLines, Idx)
                    {
                        CurrentValue = Operator.Join(CurrentValue, 1);
                    }
                    Else
                    {
                        CurrentValue = Operator.Join(CurrentValue, 0);
                    }
                    Idx += 1;
                }
                List.ReplaceItem(CheckedStateAttackLines, StoreDepth, CurrentValue);
            }
        }
    }
    Else
    {
        CurrentValue = "";
        CurrentValue2 = "";
        Idx = 1;
        Repeat (64)
        {
            CurrentValue = Operator.Join(CurrentValue, BoardAttackedByWhite[Idx]);
            If (Not ((BoardAttackedByWhitePiece[Idx] == 0)))
            {
                CurrentValue2 = Operator.Join(CurrentValue2, PieceIdxLookup[abs(BoardAttackedByWhitePiece[Idx])]);
            }
            Else
            {
                CurrentValue2 = Operator.Join(CurrentValue2, 0);
            }
            Idx += 1;
        }
        List.ReplaceItem(BoardAttackedByWhiteSnapshot, StoreDepth, CurrentValue);
        List.ReplaceItem(BoardAttackedByWhitePieceSnapshot, StoreDepth, CurrentValue2);
        If ((StoreDepth % 2) == 1)
        {
            List.ReplaceItem(CheckedStateAttackLines, StoreDepth, 0000000000000000000000000000000000000000000000000000000000000000);
            List.ReplaceItem(CheckedState, StoreDepth, IsBlackChecked);
            If (IsBlackChecked == 1)
            {
                CurrentValue = "";
                Idx = 1;
                Repeat (64)
                {
                    If List.ContainsItem(KingAttackLines, Idx)
                    {
                        CurrentValue = Operator.Join(CurrentValue, 1);
                    }
                    Else
                    {
                        CurrentValue = Operator.Join(CurrentValue, 0);
                    }
                    Idx += 1;
                }
                List.ReplaceItem(CheckedStateAttackLines, StoreDepth, CurrentValue);
            }
        }
    }
}

Define StoreKillerMove(string Depth)(string Move) (warp=true)
{
    If (Depth == 8)
    {
        List.DeleteItem(KillerMoves8, List.IndexOf(KillerMoves8, Move));
        List.Add(KillerMoves8, Move);
        If (List.Length(KillerMoves8) > 4)
        {
            List.DeleteItem(KillerMoves8, 1);
        }
    }
    Else
    {
        If (Depth == 7)
        {
            List.DeleteItem(KillerMoves7, List.IndexOf(KillerMoves7, Move));
            List.Add(KillerMoves7, Move);
            If (List.Length(KillerMoves7) > 4)
            {
                List.DeleteItem(KillerMoves7, 1);
            }
        }
        Else
        {
            If (Depth == 6)
            {
                List.DeleteItem(KillerMoves6, List.IndexOf(KillerMoves6, Move));
                List.Add(KillerMoves6, Move);
                If (List.Length(KillerMoves6) > 4)
                {
                    List.DeleteItem(KillerMoves6, 1);
                }
            }
            Else
            {
                If (Depth == 5)
                {
                    List.DeleteItem(KillerMoves5, List.IndexOf(KillerMoves5, Move));
                    List.Add(KillerMoves5, Move);
                    If (List.Length(KillerMoves5) > 4)
                    {
                        List.DeleteItem(KillerMoves5, 1);
                    }
                }
                Else
                {
                    If (Depth == 4)
                    {
                        List.DeleteItem(KillerMoves4, List.IndexOf(KillerMoves4, Move));
                        List.Add(KillerMoves4, Move);
                        If (List.Length(KillerMoves4) > 4)
                        {
                            List.DeleteItem(KillerMoves4, 1);
                        }
                    }
                    Else
                    {
                        If (Depth == 3)
                        {
                            List.DeleteItem(KillerMoves3, List.IndexOf(KillerMoves3, Move));
                            List.Add(KillerMoves3, Move);
                            If (List.Length(KillerMoves3) > 4)
                            {
                                List.DeleteItem(KillerMoves3, 1);
                            }
                        }
                        Else
                        {
                            If (Depth == 2)
                            {
                                List.DeleteItem(KillerMoves2, List.IndexOf(KillerMoves2, Move));
                                List.Add(KillerMoves2, Move);
                                If (List.Length(KillerMoves2) > 4)
                                {
                                    List.DeleteItem(KillerMoves2, 1);
                                }
                            }
                            Else
                            {
                                If (Depth == 1)
                                {
                                    List.DeleteItem(KillerMoves1, List.IndexOf(KillerMoves1, Depth));
                                    List.Add(KillerMoves1, Depth);
                                    If (List.Length(KillerMoves1) > 4)
                                    {
                                        List.DeleteItem(KillerMoves1, 1);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

Define SwitchMode (warp=false)
{
    If (IsModeJunior == 0)
    {
        IsModeJunior = 1;
        Call SayAsync("Junior mode enabled. Low playing strength. Easy and Medium play semi-random moves, Difficult searches one ply. Valid move advice activated.")(5);
        Event.Broadcast("JuniorModeEnabled");
    }
    Else
    {
        IsModeJunior = 0;
        Call SayAsync("Standard mode enabled. Normal playing strength. Valid move advice deactivated.")(5);
        Event.Broadcast("JuniorModeDisabled");
    }
}

Define TTProbeBoard(string BoardHash) (warp=true)
{
    TTProbeBoardScore1Res = "";
    CurrentIdx = 1;
    HashBucket = ((BoardHash % List.Length(TTBoardHash)) + 1);
    Repeat Until (TTBoardHash[HashBucket] == BoardHash)
    {
        HashBucket += 1;
        If (HashBucket > List.Length(TTBoardHash))
        {
            HashBucket = 1;
        }
        CurrentIdx += 1;
        If (CurrentIdx > 5)
        {
            TTProbeRes = 0;
            Stop(this script);
        }
    }
    List.ReplaceItem(TTBoardAge, HashBucket, TTProbeCurrentAge);
    TTProbeRes = 1;
    TTProbeBoardScore1Res = TTBoardScore1[HashBucket];
    TTProbeBoardScore3Res = TTBoardScore3[HashBucket];
}

Define TTProbeNode(string BoardHash)(string Depth) (warp=true)
{
    CurrentIdx = 1;
    HashBucket = ((BoardHash % List.Length(TTNodeHash)) + 1);
    Repeat Until ((TTNodeHash[HashBucket] == BoardHash) And ((TTNodeDepth[HashBucket] % 2) == (Depth % 2)))
    {
        HashBucket += 1;
        If (HashBucket > List.Length(TTNodeHash))
        {
            HashBucket = 1;
        }
        CurrentIdx += 1;
        If (CurrentIdx > 5)
        {
            TTProbeRes = 0;
            Stop(this script);
        }
    }
    List.ReplaceItem(TTNodeAge, HashBucket, TTProbeCurrentAge);
    TTProbeRes = 1;
    TTProbeBestMoveRes = TTNodeBestMove[HashBucket];
    TTProbeNodeScoreRes = TTNodeScore[HashBucket];
    TTProbeNodeTypeRes = TTNodeType[HashBucket];
    TTProbeCheckedRes = TTNodeChecked[HashBucket];
    TTProbeCheckedAttackLinesRes = TTNodeCheckedAttackLines[HashBucket];
    TTProbeHorizonRes = TTNodeHorizon[HashBucket];
    TTProbeBlackMobRes = TTNodeBlackMobility[HashBucket];
    TTProbeWhiteMobRes = TTNodeWhiteMobility[HashBucket];
    TTProbeBoardAttackedByOpp = TTNodeBoardAttackedByOpp[HashBucket];
    TTProbeBoardAttackedByOppPiece = TTNodeBoardAttackedByOppPiece[HashBucket];
}

Define TTStoreBoard(string BoardHash)(string BoardScore1)(string BoardScore2)(string BoardScore3) (warp=true)
{
    HashBucket = ((BoardHash % List.Length(TTBoardHash)) + 1);
    CurrentIdx = 1;
    Repeat Until ((TTBoardHash[HashBucket] == BoardHash) Or (CurrentIdx > 5))
    {
        HashBucket += 1;
        If (HashBucket > List.Length(TTBoardHash))
        {
            HashBucket = 1;
        }
        CurrentIdx += 1;
    }
    If (Not ((TTBoardHash[HashBucket] == BoardHash)))
    {
        HashBucket = ((BoardHash % List.Length(TTBoardHash)) + 1);
        CurrentIdx = 1;
        Repeat Until ((TTBoardHash[HashBucket] == "") Or (TTBoardAge[HashBucket] < (TTProbeCurrentAge - 1)))
        {
            HashBucket += 1;
            If (HashBucket > List.Length(TTBoardHash))
            {
                HashBucket = 1;
            }
            CurrentIdx += 1;
            If (CurrentIdx > 5)
            {
                Stop(this script);
            }
        }
    }
    List.ReplaceItem(TTBoardAge, HashBucket, TTProbeCurrentAge);
    If (Not ((TTBoardHash[HashBucket] == BoardHash)))
    {
        List.ReplaceItem(TTBoardHash, HashBucket, BoardHash);
        List.ReplaceItem(TTBoardScore1, HashBucket, BoardScore1);
        List.ReplaceItem(TTBoardScore2, HashBucket, BoardScore2);
        List.ReplaceItem(TTBoardScore3, HashBucket, BoardScore3);
    }
    Else
    {
        If (Not ((BoardScore1 == "")))
        {
            List.ReplaceItem(TTBoardScore1, HashBucket, BoardScore1);
        }
        If (Not ((BoardScore2 == "")))
        {
            List.ReplaceItem(TTBoardScore2, HashBucket, BoardScore2);
        }
        If (Not ((BoardScore3 == "")))
        {
            List.ReplaceItem(TTBoardScore3, HashBucket, BoardScore3);
        }
    }
}

Define TTStoreNode(string BoardHash)(string Depth)(string Score)(string BestMove)(string Type)(string Checked)(string Horizon)(string BlackMob)(string WhiteMob)(string BoardAttackedByOpp)(string BoardAttackedByOppPiece)(string CheckedAttackLines) (warp=true)
{
    HashBucket = ((BoardHash % List.Length(TTNodeHash)) + 1);
    CurrentIdx = 1;
    Repeat Until (((TTNodeHash[HashBucket] == BoardHash) And ((TTNodeDepth[HashBucket] % 2) == (Depth % 2))) Or (CurrentIdx > 5))
    {
        HashBucket += 1;
        If (HashBucket > List.Length(TTNodeHash))
        {
            HashBucket = 1;
        }
        CurrentIdx += 1;
    }
    If (Not (((TTNodeHash[HashBucket] == BoardHash) And ((TTNodeDepth[HashBucket] % 2) == (Depth % 2)))))
    {
        HashBucket = ((BoardHash % List.Length(TTNodeHash)) + 1);
        CurrentIdx = 1;
        Repeat Until ((TTNodeHash[HashBucket] == "") Or (TTNodeAge[HashBucket] < (TTProbeCurrentAge - 1)))
        {
            HashBucket += 1;
            If (HashBucket > List.Length(TTNodeHash))
            {
                HashBucket = 1;
            }
            CurrentIdx += 1;
            If (CurrentIdx > 5)
            {
                Stop(this script);
            }
        }
    }
    List.ReplaceItem(TTNodeAge, HashBucket, TTProbeCurrentAge);
    If ((BoardHash == TTNodeHash[HashBucket]) And ((Depth % 2) == (TTNodeDepth[HashBucket] % 2)))
    {
        If (Horizon < TTNodeHorizon[HashBucket])
        {
            If ((Not ((BestMove == ""))) And (TTNodeBestMove[HashBucket] == ""))
            {
                List.ReplaceItem(TTNodeBestMove, HashBucket, BestMove);
                List.ReplaceItem(TTNodeHorizon, HashBucket, Horizon);
                List.ReplaceItem(TTNodeType, HashBucket, "");
                List.ReplaceItem(TTNodeScore, HashBucket, "");
            }
            If ((Not ((BoardAttackedByOpp == ""))) And (TTNodeBoardAttackedByOpp[HashBucket] == ""))
            {
                List.ReplaceItem(TTNodeBoardAttackedByOpp, HashBucket, BoardAttackedByOpp);
                List.ReplaceItem(TTNodeBoardAttackedByOppPiece, HashBucket, BoardAttackedByOppPiece);
                List.ReplaceItem(TTNodeCheckedAttackLines, HashBucket, CheckedAttackLines);
            }
            If ((Not ((Checked == ""))) And (TTNodeChecked[HashBucket] == ""))
            {
                List.ReplaceItem(TTNodeChecked, HashBucket, Checked);
            }
            Stop(this script);
        }
        If (Not ((BoardAttackedByOpp == "")))
        {
            List.ReplaceItem(TTNodeBoardAttackedByOpp, HashBucket, BoardAttackedByOpp);
            List.ReplaceItem(TTNodeBoardAttackedByOppPiece, HashBucket, BoardAttackedByOppPiece);
            List.ReplaceItem(TTNodeCheckedAttackLines, HashBucket, CheckedAttackLines);
        }
        If (Not ((Checked == "")))
        {
            List.ReplaceItem(TTNodeChecked, HashBucket, Checked);
        }
        List.ReplaceItem(TTNodeDepth, HashBucket, Depth);
        If (Not ((Score == "")))
        {
            If (Not ((BestMove == "")))
            {
                List.ReplaceItem(TTNodeBestMove, HashBucket, BestMove);
            }
            Else
            {
                If (Not ((Horizon == TTNodeHorizon[HashBucket])))
                {
                    List.ReplaceItem(TTNodeBestMove, HashBucket, "");
                }
            }
            List.ReplaceItem(TTNodeType, HashBucket, Type);
            List.ReplaceItem(TTNodeScore, HashBucket, Score);
            List.ReplaceItem(TTNodeHorizon, HashBucket, Horizon);
        }
        Else
        {
            If (Not ((BestMove == "")))
            {
                If (Not ((Horizon == TTNodeHorizon[HashBucket])))
                {
                    List.ReplaceItem(TTNodeType, HashBucket, "");
                    List.ReplaceItem(TTNodeScore, HashBucket, "");
                }
                List.ReplaceItem(TTNodeBestMove, HashBucket, BestMove);
                List.ReplaceItem(TTNodeHorizon, HashBucket, Horizon);
            }
        }
        If ((Not ((BlackMob == ""))) And (Not ((WhiteMob == ""))))
        {
            List.ReplaceItem(TTNodeBlackMobility, HashBucket, BlackMob);
            List.ReplaceItem(TTNodeWhiteMobility, HashBucket, WhiteMob);
        }
    }
    Else
    {
        List.ReplaceItem(TTNodeBestMove, HashBucket, BestMove);
        List.ReplaceItem(TTNodeBoardAttackedByOpp, HashBucket, BoardAttackedByOpp);
        List.ReplaceItem(TTNodeBoardAttackedByOppPiece, HashBucket, BoardAttackedByOppPiece);
        List.ReplaceItem(TTNodeChecked, HashBucket, Checked);
        List.ReplaceItem(TTNodeCheckedAttackLines, HashBucket, CheckedAttackLines);
        List.ReplaceItem(TTNodeHash, HashBucket, BoardHash);
        List.ReplaceItem(TTNodeDepth, HashBucket, Depth);
        List.ReplaceItem(TTNodeType, HashBucket, Type);
        List.ReplaceItem(TTNodeBlackMobility, HashBucket, BlackMob);
        List.ReplaceItem(TTNodeWhiteMobility, HashBucket, WhiteMob);
        List.ReplaceItem(TTNodeScore, HashBucket, Score);
        List.ReplaceItem(TTNodeHorizon, HashBucket, Horizon);
    }
}

Define UndoMove (warp=false)
{
    If ((IsInUndo == 0) And (List.Length(GameMovesAN) > 1))
    {
        IsInUndo = 1;
        If (IsGameSuspended == 0)
        {
            Call UndoPrevMove;
            Call UndoPrevMove;
        }
        Else
        {
            Call UndoPrevMove;
            Call GetSubstringRight(GameMoves)(4);
            If ((Board[floor((SubstringRes % 100))] < 0) Or ((SubstringRes == WhiteQueensideCastling) Or (SubstringRes == WhiteKingsideCastling)))
            {
                Call UndoPrevMove;
            }
        }
        Call DrawBoard;
        IsGameSuspended = 0;
        IsInUndo = 0;
    }
}

Define UndoPrevMove (warp=false)
{
    If (List.Length(GameMovesAN) > 0)
    {
        Call GetSubstringRight(GameMoves)(4);
        If ((Board[(SubstringRes % 100)] > 0) Or ((SubstringRes == BlackQueensideCastling) Or (SubstringRes == BlackKingsideCastling)))
        {
            IsBlackMove = 1;
        }
        Else
        {
            IsBlackMove = 0;
        }
        Call ImportBoardImpl(BoardHistory[(List.Length(BoardHistory) - 1)]);
        List.DeleteItem(BoardHistory, List.Length(BoardHistory));
        List.DeleteItem(BoardHistoryHash, List.Length(BoardHistoryHash));
        If ((GameMovesAN[List.Length(GameMovesAN)] == "O-O") Or (GameMovesAN[List.Length(GameMovesAN)] == "O-O-O"))
        {
            If (IsBlackMove == 1)
            {
                HasBlackCastled = 0;
                HasBlackKingMoved = 0;
            }
            Else
            {
                HasWhiteCastled = 0;
                HasWhiteKingMoved = 0;
            }
        }
        If (Operator.LetterOf(GameMovesAN[List.Length(GameMovesAN)], 1) == "K")
        {
            If (IsBlackMove == 1)
            {
                HasBlackKingMoved = 0;
            }
            Else
            {
                HasWhiteKingMoved = 0;
            }
            Idx = (List.Length(GameMovesAN) - 2);
            Repeat Until (Idx < 1)
            {
                If (Operator.LetterOf(GameMovesAN[Idx], 1) == "K")
                {
                    If (IsBlackMove == 1)
                    {
                        HasBlackKingMoved = 1;
                    }
                    Else
                    {
                        HasWhiteKingMoved = 0;
                    }
                }
                Idx += -1;
            }
        }
        List.DeleteItem(GameMovesAN, List.Length(GameMovesAN));
        Call GetSubstringLeft(GameMoves)((Variable.Length(GameMoves) - 4));
        GameMoves = SubstringRes;
    }
}

Define UpdateMoveHashPosScore(num Piece)(num SourceIdx)(num TargetIdx)(bool PosScoreUpdate) (warp=true)
{
    Call GetPiecePosHash(Piece)(SourceIdx);
    CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
    Call GetPiecePosHash(Piece)(TargetIdx);
    CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
    Call GetPiecePosScore(Piece)(SourceIdx);
    If PosScoreUpdate
    {
        List.ReplaceItem(PosScoreDelta, Depth, (PosScoreDelta[Depth] - PosScoreRes));
    }
    Else
    {
        List.ReplaceItem(PosScoreDelta, Depth, (0 - PosScoreRes));
    }
    Call GetPiecePosScore(Piece)(TargetIdx);
    List.ReplaceItem(PosScoreDelta, Depth, (PosScoreDelta[Depth] + PosScoreRes));
}
