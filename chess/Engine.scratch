define QuickSortImpl %s %s
set [QSPivot v] to (item ([floor v] of (((argument_reporter_string_number) + (argument_reporter_string_number)) / (2)) ::operators) of [SortedList v])
set [QSLower v] to (argument_reporter_string_number)
set [QSUpper v] to (argument_reporter_string_number)
repeat until <(QSLower) > (QSUpper)> 
repeat until <not <(item (QSLower) of [SortedList v]) < (QSPivot)>> 
change [QSLower v] by (1)
end
repeat until <not <(item (QSUpper) of [SortedList v]) > (QSPivot)>> 
change [QSUpper v] by (-1)
end
if <not <(QSLower) > (QSUpper)>> then 
set [QSSwap v] to (item (QSLower) of [SortedList v])
replace item (QSLower) of [SortedList v] with (item (QSUpper) of [SortedList v])
replace item (QSUpper) of [SortedList v] with [QSSwap]
change [QSLower v] by (1)
change [QSUpper v] by (-1)
end
end
add [QSLower] to [QSPartStack v]
if <(argument_reporter_string_number) < (QSUpper)> then 
QuickSortImpl %s %s
end
if <(item (length of [QSPartStack v]) of [QSPartStack v]) < (argument_reporter_string_number)> then 
QuickSortImpl %s %s
end
delete (length of [QSPartStack v]) of [QSPartStack v]

define InitMovePosLookup
set [MetaState v] to (((((IsBlackCastlingPossible) * (1000000)) + ((IsWhiteCastlingPossible) * (10000))) + ((([ceiling v] of (((BlackQueenCount) + (BlackMinorCount)) / (10)) ::operators) * (1000)) + (([ceiling v] of (((WhiteQueenCount) + (WhiteMinorCount)) / (10)) ::operators) * (100)))) + (((IsEndgame2) * (10)) + (IsEndgame)))
if <not <(MetaState) = (PrevMetaState)>> then 
set [PrevMetaState v] to [MetaState]
if <<<not <(length of [MovePosLookupBlack v]) = (100000)>> or <not <(length of [MovePosLookupWhite v]) = (100000)>>> or <<not <(length of [MoveHashLookupBlack v]) = (100000)>> or <not <(length of [MoveHashLookupWhite v]) = (100000)>>>> then 
delete all of [MovePosLookupBlack v]
delete all of [MovePosLookupWhite v]
delete all of [MoveHashLookupBlack v]
delete all of [MoveHashLookupWhite v]
repeat (100000) 
add [0] to [MovePosLookupBlack v]
add [0] to [MovePosLookupWhite v]
add [0] to [MoveHashLookupBlack v]
add [0] to [MoveHashLookupWhite v]
end
end
delete all of [Pieces v]
add [BlackKing] to [Pieces v]
add [BlackQueen] to [Pieces v]
add [BlackRook] to [Pieces v]
add [BlackBishop] to [Pieces v]
add [BlackKnight] to [Pieces v]
add [BlackPawn] to [Pieces v]
add [WhiteKing] to [Pieces v]
add [WhiteQueen] to [Pieces v]
add [WhiteRook] to [Pieces v]
add [WhiteBishop] to [Pieces v]
add [WhiteKnight] to [Pieces v]
add [WhitePawn] to [Pieces v]
set [IdxOuter v] to [1]
repeat (length of [Pieces v]) 
set [SourcePiece v] to (item (IdxOuter) of [Pieces v])
set [SourceIdx v] to [0]
repeat (65) 
GetPosScore %n %n
set [PosScoreRes2 v] to [PosScoreRes]
GetPosPieceHash %n %n
set [PosPieceHash2 v] to [PosPieceHash]
set [TargetIdx v] to [0]
repeat (65) 
set [IsLegalMove v] to [0]
if <(SourcePiece) = (WhitePawn)> then 
if <<<([abs v] of ((item (TargetIdx) of [IdxToFile v]) - (item (SourceIdx) of [IdxToFile v])) ::operators) < (2)> and <((item (TargetIdx) of [IdxToRank v]) - (item (SourceIdx) of [IdxToRank v])) > (-3)>> and <((item (TargetIdx) of [IdxToRank v]) - (item (SourceIdx) of [IdxToRank v])) < (0)>> then 
set [IsLegalMove v] to [1]
end
 else 
if <(SourcePiece) = (BlackPawn)> then 
if <<<([abs v] of ((item (TargetIdx) of [IdxToFile v]) - (item (SourceIdx) of [IdxToFile v])) ::operators) < (2)> and <((item (TargetIdx) of [IdxToRank v]) - (item (SourceIdx) of [IdxToRank v])) < (3)>> and <((item (TargetIdx) of [IdxToRank v]) - (item (SourceIdx) of [IdxToRank v])) > (0)>> then 
set [IsLegalMove v] to [1]
end
 else 
if <([abs v] of (SourcePiece) ::operators) = (BlackKing)> then 
if <<([abs v] of ((item (TargetIdx) of [IdxToRank v]) - (item (SourceIdx) of [IdxToRank v])) ::operators) < (2)> and <([abs v] of ((item (TargetIdx) of [IdxToFile v]) - (item (SourceIdx) of [IdxToFile v])) ::operators) < (2)>> then 
set [IsLegalMove v] to [1]
end
 else 
if <([abs v] of (SourcePiece) ::operators) = (BlackKnight)> then 
if <<([abs v] of ((item (TargetIdx) of [IdxToRank v]) - (item (SourceIdx) of [IdxToRank v])) ::operators) < (3)> and <([abs v] of ((item (TargetIdx) of [IdxToFile v]) - (item (SourceIdx) of [IdxToFile v])) ::operators) < (3)>> then 
set [IsLegalMove v] to [1]
end
 else 
if <<([abs v] of (SourcePiece) ::operators) = (BlackQueen)> or <([abs v] of (SourcePiece) ::operators) = (BlackRook)>> then 
if <<((item (TargetIdx) of [IdxToRank v]) - (item (SourceIdx) of [IdxToRank v])) = (0)> or <((item (TargetIdx) of [IdxToFile v]) - (item (SourceIdx) of [IdxToFile v])) = (0)>> then 
set [IsLegalMove v] to [1]
end
end
if <<([abs v] of (SourcePiece) ::operators) = (BlackQueen)> or <([abs v] of (SourcePiece) ::operators) = (BlackBishop)>> then 
if <([abs v] of ((item (TargetIdx) of [IdxToRank v]) - (item (SourceIdx) of [IdxToRank v])) ::operators) = ([abs v] of ((item (TargetIdx) of [IdxToFile v]) - (item (SourceIdx) of [IdxToFile v])) ::operators)> then 
set [IsLegalMove v] to [1]
end
end
end
end
end
end
if <<(IsLegalMove) = (1)> or <<(SourceIdx) = (0)> or <(TargetIdx) = (0)>>> then 
GetPosScore %n %n
GetPosPieceHash %n %n
if <(SourcePiece) > (0)> then 
set [IdxOuter2 v] to ((([ceiling v] of (((SourcePiece) mod (1000)) / (100)) ::operators) * (10000)) + (((SourceIdx) * (100)) + (TargetIdx)))
replace item (IdxOuter2) of [MovePosLookupBlack v] with ((PosScoreRes) - (PosScoreRes2))
replace item (IdxOuter2) of [MoveHashLookupBlack v] with ((PosPieceHash) - (PosPieceHash2))
 else 
set [IdxOuter2 v] to ((([ceiling v] of ((([abs v] of (SourcePiece) ::operators) mod (1000)) / (100)) ::operators) * (10000)) + (((SourceIdx) * (100)) + (TargetIdx)))
replace item (IdxOuter2) of [MovePosLookupWhite v] with ((PosScoreRes) - (PosScoreRes2))
replace item (IdxOuter2) of [MoveHashLookupWhite v] with ((PosPieceHash) - (PosPieceHash2))
end
end
change [TargetIdx v] by (1)
end
change [SourceIdx v] by (1)
end
change [IdxOuter v] by (1)
end
end

define InvalidateMovePosLookup
set [PrevMetaState v] to [-1]

when [k v] key pressed
hide list [Logfile v]

when [l v] key pressed
show list [Logfile v]

when [m v] key pressed
delete all of [Logfile v]

when gf clicked
delete all of [Logfile v]
hide list [Logfile v]

define TTStoreBoard %s %s %s %s
set [HashBucket v] to (((argument_reporter_string_number) mod (length of [TTBoardHash v])) + (1))
set [CurrentIdx v] to [1]
repeat until <<<(length of (item (HashBucket) of [TTBoardHash v])) = (0)> or <(item (HashBucket) of [TTBoardHash v]) = (argument_reporter_string_number)>> or <(item (HashBucket) of [TTBoardAge v]) < ((TTProbeCurrentAge) - (2))>> 
change [HashBucket v] by (1)
if <(HashBucket) > (length of [TTBoardHash v])> then 
set [HashBucket v] to [1]
end
change [CurrentIdx v] by (1)
if <(CurrentIdx) > (10)> then 
stop [this script v]
end
end
replace item (HashBucket) of [TTBoardHash v] with (argument_reporter_string_number)
replace item (HashBucket) of [TTBoardAge v] with [TTProbeCurrentAge]
if <<not <(argument_reporter_string_number) = ()>> or <not <(item (HashBucket) of [TTBoardHash v]) = (argument_reporter_string_number)>>> then 
replace item (HashBucket) of [TTBoardScore1 v] with (argument_reporter_string_number)
end
if <<not <(argument_reporter_string_number) = ()>> or <not <(item (HashBucket) of [TTBoardHash v]) = (argument_reporter_string_number)>>> then 
replace item (HashBucket) of [TTBoardScore2 v] with (argument_reporter_string_number)
end
if <<not <(argument_reporter_string_number) = ()>> or <not <(item (HashBucket) of [TTBoardHash v]) = (argument_reporter_string_number)>>> then 
replace item (HashBucket) of [TTBoardScore3 v] with (argument_reporter_string_number)
end

define TTProbeBoard %s
set [TTProbeRes v] to [0]
set [TTProbeBoardScore1Res v] to []
set [CurrentIdx v] to [1]
set [HashBucket v] to (((argument_reporter_string_number) mod (length of [TTBoardHash v])) + (1))
repeat until <(item (HashBucket) of [TTBoardHash v]) = (argument_reporter_string_number)> 
change [HashBucket v] by (1)
if <(HashBucket) > (length of [TTBoardHash v])> then 
set [HashBucket v] to [1]
end
change [CurrentIdx v] by (1)
if <(CurrentIdx) > (10)> then 
stop [this script v]
end
end
replace item (HashBucket) of [TTBoardAge v] with [TTProbeCurrentAge]
set [TTProbeRes v] to [1]
set [TTProbeBoardScore1Res v] to (item (HashBucket) of [TTBoardScore1 v])
set [TTProbeBoardScore2Res v] to (item (HashBucket) of [TTBoardScore2 v])
set [TTProbeBoardScore3Res v] to (item (HashBucket) of [TTBoardScore3 v])

define InitBoard
set [IsInUndo v] to [0]
set [ExecutionDepth v] to [0]
set [IsExecutionRunning v] to [0]
set [IsProfilerEnabled v] to [0]
set [IsDebugMode v] to [0]
set [IsEndgame v] to [0]
set [IsEndgame2 v] to [0]
set [IsImportedBoard v] to [0]
set [BlackKingsideCastling v] to [0090]
set [WhiteKingsideCastling v] to [0092]
set [BlackQueensideCastling v] to [0091]
set [WhiteQueensideCastling v] to [0093]
set [HasBlackCastled v] to [0]
set [HasWhiteKingMoved v] to [0]
set [HasWhiteCastled v] to [0]
set [HasBlackKingMoved v] to [0]
set [HasWhiteRookKSMoved v] to [0]
set [HasWhiteRookQSMoved v] to [0]
set [HasBlackRookKSMoved v] to [0]
set [HasBlackRookQSMoved v] to [0]
set [GameMoves v] to []
set [LineMoveTypeStraight v] to [1]
set [LineMoveTypeCross v] to [2]
set [LookupMoveTypeKnight v] to [1]
set [LookupMoveTypeKing v] to [2]
set [IsGameSuspended v] to [0]
set [PrevProgressUpdate v] to [0]
set [Empty v] to [0]
set [WhiteKing v] to [-20000]
set [WhiteQueen v] to [-900]
set [WhiteRook v] to [-500]
set [WhiteBishop v] to [-320]
set [WhiteKnight v] to [-300]
set [WhitePawn v] to [-100]
set [BlackKing v] to [20000]
set [BlackQueen v] to [900]
set [BlackRook v] to [500]
set [BlackBishop v] to [320]
set [BlackKnight v] to [300]
set [BlackPawn v] to [100]
DetectFlash30Bug
InitKingSafety
InitMobilityBonusLookup
InitCoordLookup
InitHashLookup
InitMoveLookup
InitKnightSquare
InitPawnSquare
InitPawnSquareEndgame
InitBishopSquare
InitRookSquare
InitQueenSquare
InitKingSquare
InitKingSquareEndgame
InitPawnSquarePreCastling
FillBoard
InitOpeningBook
hide list [BoardHistory v]
hide list [GameMovesAN v]
hide list [ExportData v]
hide list [ExportMoves v]
set [CharsUpperCase v] to [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
delete (all) of [CharsUpperCaseList v]
set [Idx v] to [1]
repeat (length of [CharsUpperCaseList v]) 
add (letter (Idx) of [CharsUpperCase]) to [CharsUpperCaseList v]
change [Idx v] by (1)
end
delete (all) of [BoardHistory v]
delete (all) of [BoardHistoryHash v]
delete (all) of [GameMovesAN v]
delete (all) of [BoardAttackedByWhite v]
delete (all) of [BoardAttackedByBlack v]
delete (all) of [PieceMobility v]
delete (all) of [BoardAttackedByWhitePiece v]
delete (all) of [BoardAttackedByBlackPiece v]
repeat (64) 
add [0] to [BoardAttackedByWhite v]
add [0] to [BoardAttackedByBlack v]
add [0] to [PieceMobility v]
add [0] to [BoardAttackedByWhitePiece v]
add [0] to [BoardAttackedByBlackPiece v]
end
delete (all) of [Alphas v]
delete (all) of [Betas v]
delete (all) of [MinMaxResults v]
delete (all) of [MovesCount v]
delete (all) of [MovesIdx v]
delete (all) of [TargetPieces v]
delete (all) of [PreviousMoveHash v]
delete (all) of [BestHashMoveMaxDepth v]
delete (all) of [BaseHashMove v]
delete (all) of [BestHashMoveType v]
delete (all) of [PickMoveRes v]
delete (all) of [PickPhase v]
delete (all) of [PickedMove v]
delete (all) of [ChildNodeCutoffMove v]
delete (all) of [CheckedState v]
delete (all) of [PromotionPieces v]
delete (all) of [TargetPiecesIdx v]
delete (all) of [PosScoreDelta v]
delete (all) of [BoardAttackedCalculated v]
delete (all) of [PutsInCheck v]
delete (all) of [PawnPromotionFile v]
delete (all) of [EvalExtended1 v]
delete (all) of [PlyExtension v]
delete (all) of [SourcePieces v]
delete (all) of [EvalExtended2 v]
delete (all) of [BlackKingIdxs v]
delete (all) of [WhiteKingIdxs v]
delete (all) of [EvalExtended3 v]
delete (all) of [BlackMobBonus v]
delete (all) of [WhiteMobBonus v]
repeat (25) 
add [] to [Alphas v]
add [] to [Betas v]
add [] to [MinMaxResults v]
add [] to [MovesCount v]
add [] to [MovesIdx v]
add [] to [TargetPieces v]
add [] to [PreviousMoveHash v]
add [] to [BaseHashMove v]
add [] to [BestHashMoveType v]
add [] to [PickMoveRes v]
add [] to [PickPhase v]
add [] to [PickedMove v]
add [] to [ChildNodeCutoffMove v]
add [] to [BestHashMoveMaxDepth v]
add [] to [CheckedState v]
add [] to [PromotionPieces v]
add [] to [TargetPiecesIdx v]
add [] to [PosScoreDelta v]
add [] to [BoardAttackedCalculated v]
add [] to [PutsInCheck v]
add [] to [PawnPromotionFile v]
add [] to [EvalExtended1 v]
add [] to [PlyExtension v]
add [] to [SourcePieces v]
add [] to [EvalExtended2 v]
add [] to [BlackKingIdxs v]
add [] to [WhiteKingIdxs v]
add [] to [EvalExtended3 v]
add [] to [BlackMobBonus v]
add [] to [WhiteMobBonus v]
end
delete (all) of [BlackPawnCount v]
delete (all) of [WhitePawnCount v]
repeat (8) 
add [0] to [BlackPawnCount v]
add [0] to [WhitePawnCount v]
end
InvalidateMovePosLookup
AddBoardToHistory

define InitBishopSquare
delete (all) of [BishopPieceSquare v]
LoadList %s %s

define InitKingSquare
delete (all) of [KingPieceSquare v]
LoadList %s %s

define InitRookSquare
delete (all) of [RookPieceSquare v]
LoadList %s %s

when i receive [squareclicked v]
if <<(IsExecutionRunning) = (0)> and <(IsGameSuspended) = (0)>> then 
if <(MoveFromIdx) = (-1)> then 
if <(item (SquareClickedIdx) of [Board v]) < (0)> then 
set [MoveFromIdx v] to [SquareClickedIdx]
set [FromSquareIdx v] to [SquareClickedIdx]
broadcast (1 v) and wait
end
 else 
if <(MoveToIdx) = (-1)> then 
set [MoveToIdx v] to [SquareClickedIdx]
set [ToSquareIdx v] to [SquareClickedIdx]
broadcast (1 v) and wait
broadcast (1 v)
 else 
set [MoveFromIdx v] to [-1]
set [MoveToIdx v] to [-1]
end
end
end

define InitPawnSquare
delete (all) of [PawnPieceSquare v]
LoadList %s %s

define AddBoardToHistory
GetBoardString
add [GetBoardStringRes] to [BoardHistory v]
GetCurrentMoveHash
add [CurrentMoveHash] to [BoardHistoryHash v]

define RevertMove %n
GetCurrentMove %n
set [SourceIdx v] to ([floor v] of ((CurrentMove) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((CurrentMove) mod (100)) ::operators)
if <<(SourceIdx) > (0)> and <(TargetIdx) > (0)>> then 
replace item (SourceIdx) of [Board v] with (item (TargetIdx) of [Board v])
replace item (TargetIdx) of [Board v] with [Empty]
replace item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [Board v] with (item (argument_reporter_string_number) of [TargetPieces v])
if <(item (argument_reporter_string_number) of [PromotionPieces v]) > (0)> then 
replace item (SourceIdx) of [Board v] with [BlackPawn]
end
if <(item (argument_reporter_string_number) of [PromotionPieces v]) < (0)> then 
replace item (SourceIdx) of [Board v] with [WhitePawn]
end
if <(item (SourceIdx) of [Board v]) = (BlackPawn)> then 
replace item (item (SourceIdx) of [IdxToFile v]) of [BlackPawnCount v] with ((item (item (SourceIdx) of [IdxToFile v]) of [BlackPawnCount v]) + (1))
replace item (item (TargetIdx) of [IdxToFile v]) of [BlackPawnCount v] with ((item (item (TargetIdx) of [IdxToFile v]) of [BlackPawnCount v]) - (1))
 else 
if <(item (SourceIdx) of [Board v]) = (WhitePawn)> then 
replace item (item (SourceIdx) of [IdxToFile v]) of [WhitePawnCount v] with ((item (item (SourceIdx) of [IdxToFile v]) of [WhitePawnCount v]) + (1))
replace item (item (TargetIdx) of [IdxToFile v]) of [WhitePawnCount v] with ((item (item (TargetIdx) of [IdxToFile v]) of [WhitePawnCount v]) - (1))
 else 
if <(item (SourceIdx) of [Board v]) = (BlackQueen)> then 
delete (item # of [TargetIdx] in [BlackQueenIdxs v]) of [BlackQueenIdxs v]
add [SourceIdx] to [BlackQueenIdxs v]
 else 
if <(item (SourceIdx) of [Board v]) = (WhiteQueen)> then 
delete (item # of [TargetIdx] in [WhiteQueenIdxs v]) of [WhiteQueenIdxs v]
add [SourceIdx] to [WhiteQueenIdxs v]
 else 
if <(item (SourceIdx) of [Board v]) = (BlackRook)> then 
delete (item # of [TargetIdx] in [BlackRookIdxs v]) of [BlackRookIdxs v]
add [SourceIdx] to [BlackRookIdxs v]
 else 
if <(item (SourceIdx) of [Board v]) = (WhiteRook)> then 
delete (item # of [TargetIdx] in [WhiteRookIdxs v]) of [WhiteRookIdxs v]
add [SourceIdx] to [WhiteRookIdxs v]
 else 
if <(item (SourceIdx) of [Board v]) = (BlackKing)> then 
replace item (1) of [BlackKingIdxs v] with [SourceIdx]
 else 
if <(item (SourceIdx) of [Board v]) = (WhiteKing)> then 
replace item (1) of [WhiteKingIdxs v] with [SourceIdx]
end
end
end
end
end
end
end
end
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (BlackPawn)> then 
replace item (item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [IdxToFile v]) of [BlackPawnCount v] with ((item (item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [IdxToFile v]) of [BlackPawnCount v]) + (1))
 else 
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (WhitePawn)> then 
replace item (item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [IdxToFile v]) of [WhitePawnCount v] with ((item (item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [IdxToFile v]) of [WhitePawnCount v]) + (1))
end
end
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (BlackQueen)> then 
add (item (argument_reporter_string_number) of [TargetPiecesIdx v]) to [BlackQueenIdxs v]
 else 
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (WhiteQueen)> then 
add (item (argument_reporter_string_number) of [TargetPiecesIdx v]) to [WhiteQueenIdxs v]
 else 
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (BlackRook)> then 
add (item (argument_reporter_string_number) of [TargetPiecesIdx v]) to [BlackRookIdxs v]
 else 
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (WhiteRook)> then 
add (item (argument_reporter_string_number) of [TargetPiecesIdx v]) to [WhiteRookIdxs v]
end
end
end
end
 else 
if <(CurrentMove) = (WhiteKingsideCastling)> then 
replace item (item (61) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (62) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (63) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (64) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (1) of [WhiteKingIdxs v] with (item (61) of [VirtualBoard v])
delete (item # of (item (62) of [VirtualBoard v]) in [WhiteRookIdxs v]) of [WhiteRookIdxs v]
add (item (64) of [VirtualBoard v]) to [WhiteRookIdxs v]
 else 
if <(CurrentMove) = (WhiteQueensideCastling)> then 
replace item (item (57) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (59) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (60) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (61) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (1) of [WhiteKingIdxs v] with (item (61) of [VirtualBoard v])
delete (item # of (item (60) of [VirtualBoard v]) in [WhiteRookIdxs v]) of [WhiteRookIdxs v]
add (item (57) of [VirtualBoard v]) to [WhiteRookIdxs v]
 else 
if <(CurrentMove) = (BlackKingsideCastling)> then 
replace item (item (5) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (6) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (7) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (8) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (1) of [BlackKingIdxs v] with (item (5) of [VirtualBoard v])
delete (item # of (item (6) of [VirtualBoard v]) in [BlackRookIdxs v]) of [BlackRookIdxs v]
add (item (8) of [VirtualBoard v]) to [BlackRookIdxs v]
 else 
if <(CurrentMove) = (BlackQueensideCastling)> then 
replace item (item (1) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (4) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (3) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (5) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (1) of [BlackKingIdxs v] with (item (5) of [VirtualBoard v])
delete (item # of (item (4) of [VirtualBoard v]) in [BlackRookIdxs v]) of [BlackRookIdxs v]
add (item (1) of [VirtualBoard v]) to [BlackRookIdxs v]
end
end
end
end
end
replace item (argument_reporter_string_number) of [PosScoreDelta v] with [0]
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with []
replace item (argument_reporter_string_number) of [SourcePieces v] with [Empty]
replace item (argument_reporter_string_number) of [TargetPieces v] with [Empty]
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
set [CurrentMoveHash v] to (item (argument_reporter_string_number) of [PreviousMoveHash v])

define GetSubstringRight %s %n
GetSubstring %s %n %n

define InitQueenSquare
delete (all) of [QueenPieceSquare v]
LoadList %s %s

define InitOpeningBook
delete (all) of [OpeningMoves v]
add [533711276346122052362736463607225843021962531321] to [OpeningMoves v]
add [533711276346122062260312] to [OpeningMoves v]
add [5337112763460219523627364636072258431220] to [OpeningMoves v]
add [5337112751430722372922285236273643361220] to [OpeningMoves v]
add [5337112758430219554715236255061552441220] to [OpeningMoves v]
add [5337112758430219634612206226031200920722] to [OpeningMoves v]
add [533711276235132163460917] to [OpeningMoves v]
add [533711276235132158430917] to [OpeningMoves v]
add [533711275236273660360219] to [OpeningMoves v]
add [533711195236122837290330] to [OpeningMoves v]
add [53371119523612285843283743370330] to [OpeningMoves v]
add [533713296032021962351523] to [OpeningMoves v]
add [5337132960460722] to [OpeningMoves v]
add [5337132962350722] to [OpeningMoves v]
add [533713296346021962260917263307220092061362610090] to [OpeningMoves v]
add [533713296346021962260917263307226053102633420613] to [OpeningMoves v]
add [533713296346021962260917263307225236293600920613] to [OpeningMoves v]
add [533713296346021962260917263307225843061300921026] to [OpeningMoves v]
add [5337132963460219622609172619121946290436] to [OpeningMoves v]
add [533713296346021962260917261912190092033956481632] to [OpeningMoves v]
add [533713296346021962260917261912195843142252362936] to [OpeningMoves v]
add [533713296346021962260917261912195236293660360436] to [OpeningMoves v]
add [5337132963460219523629364636062759450422] to [OpeningMoves v]
add [533713296346021962350722] to [OpeningMoves v]
add [5337132963460219584307226226063400920090] to [OpeningMoves v]
add [5337132954382938634615316235313946290440] to [OpeningMoves v]
add [533713295438293863461531564031394629072252361220] to [OpeningMoves v]
add [5337132954382938623504406162062752362718] to [OpeningMoves v]
add [53371329543829386346061362350722] to [OpeningMoves v]
add [53371329543829386235072258431119] to [OpeningMoves v]
add [53371329543829385236044061531220634603395648394653464032] to [OpeningMoves v]
add [53371329543806276346122062350722] to [OpeningMoves v]
add [53371329543802196346122062350339] to [OpeningMoves v]
add [533702195236122837280428] to [OpeningMoves v]
add [533715235236061562351220] to [OpeningMoves v]
add [53371523523606156346122062350722] to [OpeningMoves v]
add [53371523523606155843072263460090] to [OpeningMoves v]
add [533713215236122837291127514302195438273643360418] to [OpeningMoves v]
add [5337132152361228372911275143021963460418] to [OpeningMoves v]
add [53371321523612285843063460442837] to [OpeningMoves v]
add [53371321523612285843063437291127] to [OpeningMoves v]
add [5337132152361228584306343728212859520722] to [OpeningMoves v]
add [5337132163461228372821285236072258431119] to [OpeningMoves v]
add [533712205236072258430212634613296253061300921119] to [OpeningMoves v]
add [533712205236072258430212634613296235162400921119] to [OpeningMoves v]
add [533712205236072258430212634613296235061300920090] to [OpeningMoves v]
add [5337122052360722584315235945061554460090] to [OpeningMoves v]
add [5337122052360722584315236235061563460219] to [OpeningMoves v]
add [523612286346072259312237] to [OpeningMoves v]
add [523612286346072253451127] to [OpeningMoves v]
add [523612286346021958431321533707223729221259310613] to [OpeningMoves v]
add [523612286346021959380339] to [OpeningMoves v]
add [523612286346072251351119] to [OpeningMoves v]
add [52361228634613215843072253450219] to [OpeningMoves v]
add [52361228634613215843072253372837] to [OpeningMoves v]
add [523612285135132158430722534509176244283544350634] to [OpeningMoves v]
add [5236122851351321584307225931021253450634] to [OpeningMoves v]
add [523612285345072262441321] to [OpeningMoves v]
add [523612285135111958430722] to [OpeningMoves v]
add [5236122851351119634607225843132159312835] to [OpeningMoves v]
add [523612285938072253451321] to [OpeningMoves v]
add [52360722513515235843061563460090] to [OpeningMoves v]
add [52360722513515236346061555470090] to [OpeningMoves v]
add [52360722513515236346061558430090] to [OpeningMoves v]
add [52360722513513215843063453450090] to [OpeningMoves v]
add [523607225135122063460339] to [OpeningMoves v]
add [523607225135152358430615533712206346009062531329] to [OpeningMoves v]
add [52360722634613215135101858430310] to [OpeningMoves v]
add [52361430513507225843132153450634] to [OpeningMoves v]
add [5236143055470722625515236346061500920090] to [OpeningMoves v]
add [523614306346072255471321] to [OpeningMoves v]
add [5236132151350722634610185547031062550613] to [OpeningMoves v]
add [52361321513507225843063460510090] to [OpeningMoves v]
add [523613215135122858430722] to [OpeningMoves v]
add [494113295345122851350722] to [OpeningMoves v]
add [4933132953370722] to [OpeningMoves v]
add [493313293325122856401127] to [OpeningMoves v]
add [504213295950021951350722] to [OpeningMoves v]
add [503413295950122051350722] to [OpeningMoves v]
add [514313295337072252440219] to [OpeningMoves v]
add [513513295843072255471228] to [OpeningMoves v]
add [513513296346021958430722] to [OpeningMoves v]
add [5446132955390440] to [OpeningMoves v]
add [5438132155390440] to [OpeningMoves v]
add [543812286346152355470615] to [OpeningMoves v]
add [5539132954380440] to [OpeningMoves v]
add [554712286255132951352836] to [OpeningMoves v]
add [5648132953370722] to [OpeningMoves v]
add [5648132949411228] to [OpeningMoves v]
add [564013295337072252440627] to [OpeningMoves v]
add [5640072251351127] to [OpeningMoves v]
add [5640072263460219] to [OpeningMoves v]
add [6346072251351523554706156255009000921220] to [OpeningMoves v]
add [634612285236072251351321] to [OpeningMoves v]
add [6346122858431321] to [OpeningMoves v]
set [Count v] to (length of [OpeningMoves v])
set [Idx v] to [1]
repeat (Count) 
add [] to [OpeningMoves v]
if <((length of (item (Idx) of [OpeningMoves v])) / (4)) > (4)> then 
set [IdxSub v] to [1]
repeat ((length of (item (Idx) of [OpeningMoves v])) / (4)) 
GetVirtualMove %n
replace item (last) of [OpeningMoves v] with (join (item (last) of [OpeningMoves v]) [VirtualMove])
change [IdxSub v] by (4)
end
end
change [Idx v] by (1)
end

define AddSimpleMove %n %n %n %n %b %b %b %b %b
set [Y v] to ((item (argument_reporter_string_number) of [IdxToRank v]) + (argument_reporter_string_number))
if <<(Y) > (0)> and <(Y) < (9)>> then 
set [X v] to ((item (argument_reporter_string_number) of [IdxToFile v]) + (argument_reporter_string_number))
if <<(X) > (0)> and <(X) < (9)>> then 
set [TargetIdx v] to ((X) + (((Y) - (1)) * (8)))
if <<not <argument_reporter_boolean>> or <<<(item (argument_reporter_string_number) of [Board v]) > (0)> and <(item (TargetIdx) of [Board v]) < (0)>> or <<(item (argument_reporter_string_number) of [Board v]) < (0)> and <(item (TargetIdx) of [Board v]) > (0)>>>> then 
AddMoveImpl %n %n %n %b %b %b %b %b
end
end
end

define InitKnightSquare
delete (all) of [KnightPieceSquare v]
LoadList %s %s

define EvaluateBoardExtended1 %s
TTProbeBoard %s
if <<(TTProbeRes) = (1)> and <not <(TTProbeBoardScore1Res) = ()>>> then 
set [EvalExtendedResult1 v] to [TTProbeBoardScore1Res]
stop [this script v]
end
set [BlackKingEndgameTargetIdx v] to [0]
set [WhiteKingEndgameTargetIdx v] to [0]
set [BlackKingIdx v] to (item (1) of [BlackKingIdxs v])
set [WhiteKingIdx v] to (item (1) of [WhiteKingIdxs v])
set [EvalExtendedResult1 v] to [0]
delete (all) of [PawnAdvancePerFile v]
repeat (32) 
add [0] to [PawnAdvancePerFile v]
end
set [Idx v] to [1]
repeat (64) 
set [CurrentPiece v] to (item (Idx) of [Board v])
if <(CurrentPiece) = (BlackPawn)> then 
set [File v] to (item (Idx) of [IdxToFile v])
set [Rank v] to (item (Idx) of [IdxToRank v])
if <(Idx) > (16)> then 
if <<<(File) > (1)> and <<(item ((Idx) - (9)) of [Board v]) = (BlackPawn)> or <(item ((Idx) - (1)) of [Board v]) = (BlackPawn)>>> or <<(File) < (8)> and <<(item ((Idx) - (7)) of [Board v]) = (BlackPawn)> or <(item ((Idx) + (1)) of [Board v]) = (BlackPawn)>>>> then 
if <(item ((Idx) + (8)) of [Board v]) = (WhitePawn)> then 
change [EvalExtendedResult1 v] by ((5) * (((Rank) - (2)) * ((IsEndgame) + (1))))
 else 
change [EvalExtendedResult1 v] by ((10) * (((Rank) - (2)) * ((IsEndgame) + (1))))
end
end
end
if <<(item ((File) + (16)) of [PawnAdvancePerFile v]) = (0)> or <(Rank) < (item ((File) + (16)) of [PawnAdvancePerFile v])>> then 
replace item ((File) + (16)) of [PawnAdvancePerFile v] with [Rank]
end
if <<(item ((File) + (24)) of [PawnAdvancePerFile v]) = (0)> or <(Rank) > (item ((File) + (24)) of [PawnAdvancePerFile v])>> then 
replace item ((File) + (24)) of [PawnAdvancePerFile v] with [Rank]
end
 else 
if <(CurrentPiece) = (WhitePawn)> then 
set [File v] to (item (Idx) of [IdxToFile v])
set [Rank v] to (item (Idx) of [IdxToRank v])
if <(Idx) < (49)> then 
if <<<(File) > (1)> and <<(item ((Idx) + (7)) of [Board v]) = (WhitePawn)> or <(item ((Idx) - (1)) of [Board v]) = (WhitePawn)>>> or <<(File) < (8)> and <<(item ((Idx) + (9)) of [Board v]) = (WhitePawn)> or <(item ((Idx) + (1)) of [Board v]) = (WhitePawn)>>>> then 
if <(item ((Idx) - (8)) of [Board v]) = (BlackPawn)> then 
change [EvalExtendedResult1 v] by ((-5) * (((7) - (Rank)) * ((IsEndgame) + (1))))
 else 
change [EvalExtendedResult1 v] by ((-10) * (((7) - (Rank)) * ((IsEndgame) + (1))))
end
end
end
if <<(item (File) of [PawnAdvancePerFile v]) = (0)> or <(Rank) > (item (File) of [PawnAdvancePerFile v])>> then 
replace item (File) of [PawnAdvancePerFile v] with [Rank]
end
if <<(item ((File) + (8)) of [PawnAdvancePerFile v]) = (0)> or <(Rank) < (item ((File) + (8)) of [PawnAdvancePerFile v])>> then 
replace item ((File) + (8)) of [PawnAdvancePerFile v] with [Rank]
end
end
end
change [Idx v] by (1)
end
if <<(IsImportedBoard) = (0)> and <(length of [BoardHistory v]) < (13)>> then 
if <not <(item (item (4) of [VirtualBoard v]) of [Board v]) = (BlackQueen)>> then 
change [EvalExtendedResult1 v] by (-10)
end
if <not <(item (item (60) of [VirtualBoard v]) of [Board v]) = (WhiteQueen)>> then 
change [EvalExtendedResult1 v] by (10)
end
end
set [HasBlackCastledStateLocal v] to [0]
if <(IsBlackCastlingPossible) = (1)> then 
if <<(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackKingsideCastling)> or <(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (BlackQueensideCastling)>> then 
set [HasBlackCastledStateLocal v] to [1]
end
if <(argument_reporter_string_number) > (2)> then 
if <<(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackKingsideCastling)> or <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (BlackQueensideCastling)>> then 
set [HasBlackCastledStateLocal v] to [2]
end
if <(argument_reporter_string_number) > (4)> then 
if <<(item (item (5) of [MovesIdx v]) of [Moves5 v]) = (BlackKingsideCastling)> or <(item (item (5) of [MovesIdx v]) of [Moves5 v]) = (BlackQueensideCastling)>> then 
set [HasBlackCastledStateLocal v] to [3]
end
end
end
end
set [HasWhiteCastledStateLocal v] to [0]
if <(IsWhiteCastlingPossible) = (1)> then 
if <(argument_reporter_string_number) > (1)> then 
if <<(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (WhiteKingsideCastling)> or <(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (WhiteQueensideCastling)>> then 
set [HasWhiteCastledStateLocal v] to [1]
end
if <(argument_reporter_string_number) > (3)> then 
if <<(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (WhiteKingsideCastling)> or <(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (WhiteQueensideCastling)>> then 
set [HasWhiteCastledStateLocal v] to [2]
end
if <(argument_reporter_string_number) > (5)> then 
if <<(item (item (6) of [MovesIdx v]) of [Moves6 v]) = (WhiteKingsideCastling)> or <(item (item (6) of [MovesIdx v]) of [Moves6 v]) = (WhiteQueensideCastling)>> then 
set [HasWhiteCastledStateLocal v] to [3]
end
end
end
end
end
set [Idx v] to [1]
repeat (8) 
if <(IsEndgame) = (1)> then 
if <<not <(item ((Idx) + (8)) of [PawnAdvancePerFile v]) = (0)>> and <<(item ((Idx) + (8)) of [PawnAdvancePerFile v]) < (item ((Idx) + (16)) of [PawnAdvancePerFile v])> or <(item ((Idx) + (16)) of [PawnAdvancePerFile v]) = (0)>>> then 
if <<(item ((Idx) + (8)) of [PawnAdvancePerFile v]) < (5)> and <<<<(Idx) = (1)> or <(item (((Idx) - (1)) + (16)) of [PawnAdvancePerFile v]) = (0)>> or <(item ((Idx) + (1)) of [PawnAdvancePerFile v]) < (item (((Idx) - (1)) + (16)) of [PawnAdvancePerFile v])>> and <<<(Idx) = (8)> or <(item (((Idx) + (1)) + (16)) of [PawnAdvancePerFile v]) = (0)>> or <(item ((Idx) + (8)) of [PawnAdvancePerFile v]) < (item (((Idx) + (1)) + (16)) of [PawnAdvancePerFile v])>>>> then 
if <not <(item (2) of [PawnPromotionFile v]) = (Idx)>> then 
change [EvalExtendedResult1 v] by ((-30) * ((5) - (item ((Idx) + (8)) of [PawnAdvancePerFile v])))
end
if <<(BlackKingEndgameTargetIdx) = (0)> or <(BlackKingEndgameTargetIdx) < ((0) + (Idx))>> then 
set [BlackKingEndgameTargetIdx v] to ((0) + (Idx))
end
 else 
change [EvalExtendedResult1 v] by ((-10) * ((5) - (item ((Idx) + (8)) of [PawnAdvancePerFile v])))
end
end
if <<not <(item ((Idx) + (24)) of [PawnAdvancePerFile v]) = (0)>> and <<(item ((Idx) + (24)) of [PawnAdvancePerFile v]) > (item ((Idx) + (0)) of [PawnAdvancePerFile v])> or <(item ((Idx) + (0)) of [PawnAdvancePerFile v]) = (0)>>> then 
if <<(item ((Idx) + (24)) of [PawnAdvancePerFile v]) > (4)> and <<<<(Idx) = (1)> or <(item (((Idx) - (1)) + (0)) of [PawnAdvancePerFile v]) = (0)>> or <(item ((Idx) + (24)) of [PawnAdvancePerFile v]) > (item (((Idx) - (1)) + (0)) of [PawnAdvancePerFile v])>> and <<<(Idx) = (8)> or <(item (((Idx) + (1)) + (0)) of [PawnAdvancePerFile v]) = (0)>> or <(item ((Idx) + (24)) of [PawnAdvancePerFile v]) > (item (((Idx) + (1)) + (0)) of [PawnAdvancePerFile v])>>>> then 
if <not <(item (1) of [PawnPromotionFile v]) = (Idx)>> then 
change [EvalExtendedResult1 v] by ((30) * ((item ((Idx) + (24)) of [PawnAdvancePerFile v]) - (4)))
end
if <<(WhiteKingEndgameTargetIdx) = (0)> or <(WhiteKingEndgameTargetIdx) > ((50) + (Idx))>> then 
set [WhiteKingEndgameTargetIdx v] to ((56) + (Idx))
end
 else 
change [EvalExtendedResult1 v] by ((10) * ((item ((Idx) + (24)) of [PawnAdvancePerFile v]) - (4)))
end
end
end
if <(item (Idx) of [BlackPawnCount v]) > (0)> then 
if <not <<<(Idx) > (1)> and <(item ((Idx) - (1)) of [BlackPawnCount v]) > (0)>> or <<(Idx) < (8)> and <(item ((Idx) + (1)) of [BlackPawnCount v]) > (0)>>>> then 
change [EvalExtendedResult1 v] by (20)
end
if <(item (Idx) of [BlackPawnCount v]) > (1)> then 
change [EvalExtendedResult1 v] by ((-30) * ((item (Idx) of [BlackPawnCount v]) - (1)))
end
end
if <(item (Idx) of [WhitePawnCount v]) > (0)> then 
if <not <<<(Idx) > (1)> and <(item ((Idx) - (1)) of [WhitePawnCount v]) > (0)>> or <<(Idx) < (8)> and <(item ((Idx) + (1)) of [WhitePawnCount v]) > (0)>>>> then 
change [EvalExtendedResult1 v] by (-20)
end
if <(item (Idx) of [WhitePawnCount v]) > (1)> then 
change [EvalExtendedResult1 v] by ((30) * ((item (Idx) of [WhitePawnCount v]) - (1)))
end
end
change [Idx v] by (1)
end
if <<<(WhiteQueenCount) > (0)> or <(WhiteMinorCount) > (2)>> or <(IsEndgame) = (0)>> then 
if <<(HasBlackCastled) = (1)> or <(HasBlackCastledStateLocal) > (0)>> then 
set [KingProtection v] to ((150) - (((4) - (HasBlackCastledStateLocal)) * (15)))
 else 
if <<(IsBlackCastlingPossible) = (1)> and <<not <[SourcePieces v] contains [BlackKing] ? ::lists>> and <not <[SourcePieces v] contains [BlackRook] ? ::lists>>>> then 
set [KingProtection v] to [90]
 else 
set [KingProtection v] to [40]
end
end
set [File v] to ((item (BlackKingIdx) of [IdxToFile v]) - (1))
repeat (3) 
if <<(File) > (0)> and <(File) < (9)>> then 
if <(item ((File) + (16)) of [PawnAdvancePerFile v]) > (0)> then 
if <(File) = (item (BlackKingIdx) of [IdxToFile v])> then 
change [KingProtection v] by (item ((((item ((File) + (16)) of [PawnAdvancePerFile v]) - (item (BlackKingIdx) of [IdxToRank v])) * (8)) + (File)) of [PawnShelterKingFile v])
 else 
change [KingProtection v] by (item ((((item ((File) + (16)) of [PawnAdvancePerFile v]) - (item (BlackKingIdx) of [IdxToRank v])) * (8)) + (File)) of [PawnShelterNeighborFile v])
end
 else 
if <(File) = (item (BlackKingIdx) of [IdxToFile v])> then 
change [KingProtection v] by (item (File) of [PawnShelterKingFile v])
if <<(item ((File) + (0)) of [PawnAdvancePerFile v]) = (0)> or <(1) = (0)>> then 
change [KingProtection v] by (-30)
end
 else 
change [KingProtection v] by (item (File) of [PawnShelterNeighborFile v])
if <<(item ((File) + (0)) of [PawnAdvancePerFile v]) = (0)> or <(1) = (0)>> then 
change [KingProtection v] by (-20)
end
end
end
if <(item (File) of [PawnAdvancePerFile v]) > (0)> then 
if <(item ((File) + (16)) of [PawnAdvancePerFile v]) < (item ((File) + (8)) of [PawnAdvancePerFile v])> then 
change [KingProtection v] by ((0) - (item ((((item ((File) + (8)) of [PawnAdvancePerFile v]) - (item (BlackKingIdx) of [IdxToRank v])) * (8)) + (File)) of [PawnStormBlockedByPawn v]))
 else 
if <((BlackKingIdx) + (8)) = ((((item ((File) + (8)) of [PawnAdvancePerFile v]) - (1)) * (8)) + (File))> then 
change [KingProtection v] by ((0) - (item ((((item ((File) + (8)) of [PawnAdvancePerFile v]) - (item (BlackKingIdx) of [IdxToRank v])) * (8)) + (File)) of [PawnStormBlockedByKing v]))
 else 
change [KingProtection v] by ((0) - (item ((((item ((File) + (8)) of [PawnAdvancePerFile v]) - (item (BlackKingIdx) of [IdxToRank v])) * (8)) + (File)) of [PawnStormBlockedByNone v]))
end
if <(item ((File) + (16)) of [PawnAdvancePerFile v]) = (0)> then 
if <(File) = (item (BlackKingIdx) of [IdxToFile v])> then 
change [KingProtection v] by (-30)
 else 
change [KingProtection v] by (-20)
end
end
end
end
end
change [File v] by (1)
end
change [EvalExtendedResult1 v] by ([floor v] of ((KingProtection) * (1)) ::operators)
end
if <<<(BlackMinorCount) > (2)> or <(BlackQueenCount) > (0)>> or <(IsEndgame) = (0)>> then 
if <<(HasWhiteCastled) = (1)> or <(HasWhiteCastledStateLocal) > (0)>> then 
set [KingProtection v] to ((150) - (((4) - (HasWhiteCastledStateLocal)) * (15)))
 else 
if <<(IsWhiteCastlingPossible) = (1)> and <<not <[SourcePieces v] contains [WhiteKing] ? ::lists>> and <not <[SourcePieces v] contains [WhiteRook] ? ::lists>>>> then 
set [KingProtection v] to [90]
 else 
set [KingProtection v] to [40]
end
end
set [File v] to ((item (WhiteKingIdx) of [IdxToFile v]) - (1))
repeat (3) 
if <<(File) > (0)> and <(File) < (9)>> then 
if <(item ((File) + (0)) of [PawnAdvancePerFile v]) > (0)> then 
if <(File) = (item (WhiteKingIdx) of [IdxToFile v])> then 
change [KingProtection v] by (item ((((item (WhiteKingIdx) of [IdxToRank v]) - (item ((File) + (0)) of [PawnAdvancePerFile v])) * (8)) + (File)) of [PawnShelterKingFile v])
 else 
change [KingProtection v] by (item ((((item (WhiteKingIdx) of [IdxToRank v]) - (item ((File) + (0)) of [PawnAdvancePerFile v])) * (8)) + (File)) of [PawnShelterNeighborFile v])
end
 else 
if <(File) = (item (WhiteKingIdx) of [IdxToFile v])> then 
change [KingProtection v] by (item (File) of [PawnShelterKingFile v])
if <<(item ((File) + (16)) of [PawnAdvancePerFile v]) = (0)> or <(1) = (0)>> then 
change [KingProtection v] by (-30)
end
 else 
change [KingProtection v] by (item (File) of [PawnShelterNeighborFile v])
if <<(item ((File) + (16)) of [PawnAdvancePerFile v]) = (0)> or <(1) = (0)>> then 
change [KingProtection v] by (-20)
end
end
end
if <(item (File) of [PawnAdvancePerFile v]) > (0)> then 
if <(item ((File) + (0)) of [PawnAdvancePerFile v]) > (item ((File) + (24)) of [PawnAdvancePerFile v])> then 
change [KingProtection v] by ((0) - (item ((((item (WhiteKingIdx) of [IdxToRank v]) - (item ((File) + (24)) of [PawnAdvancePerFile v])) * (8)) + (File)) of [PawnStormBlockedByPawn v]))
 else 
if <((WhiteKingIdx) - (8)) = ((((item ((File) + (24)) of [PawnAdvancePerFile v]) - (1)) * (8)) + (File))> then 
change [KingProtection v] by ((0) - (item ((((item (WhiteKingIdx) of [IdxToRank v]) - (item ((File) + (24)) of [PawnAdvancePerFile v])) * (8)) + (File)) of [PawnStormBlockedByKing v]))
 else 
change [KingProtection v] by ((0) - (item ((((item (WhiteKingIdx) of [IdxToRank v]) - (item ((File) + (24)) of [PawnAdvancePerFile v])) * (8)) + (File)) of [PawnStormBlockedByNone v]))
end
if <(item ((File) + (0)) of [PawnAdvancePerFile v]) = (0)> then 
if <(File) = (item (WhiteKingIdx) of [IdxToFile v])> then 
change [KingProtection v] by (-30)
 else 
change [KingProtection v] by (-20)
end
end
end
end
end
change [File v] by (1)
end
change [EvalExtendedResult1 v] by ([floor v] of (((0) - (KingProtection)) * (1)) ::operators)
end
if <<(IsEndgame) = (1)> and <<(item (1) of [PawnPromotionFile v]) = ()> and <(item (2) of [PawnPromotionFile v]) = ()>>> then 
if <<(BlackKingEndgameTargetIdx) = (0)> or <(((BlackQueenCount) * (3)) + (BlackMinorCount)) > (((WhiteQueenCount) * (3)) + (WhiteMinorCount))>> then 
set [BlackKingEndgameTargetIdx v] to [WhiteKingEndgameTargetIdx]
end
if <<(WhiteKingEndgameTargetIdx) = (0)> or <(((WhiteQueenCount) * (3)) + (WhiteMinorCount)) > (((BlackQueenCount) * (3)) + (BlackMinorCount))>> then 
set [WhiteKingEndgameTargetIdx v] to [BlackKingEndgameTargetIdx]
end
if <not <(BlackKingEndgameTargetIdx) = (0)>> then 
set [Delta v] to ([abs v] of ((item (BlackKingEndgameTargetIdx) of [IdxToRank v]) - (item (BlackKingIdx) of [IdxToRank v])) ::operators)
if <(Delta) < ([abs v] of ((item (BlackKingEndgameTargetIdx) of [IdxToFile v]) - (item (BlackKingIdx) of [IdxToFile v])) ::operators)> then 
set [Delta v] to ([abs v] of ((item (BlackKingEndgameTargetIdx) of [IdxToFile v]) - (item (BlackKingIdx) of [IdxToFile v])) ::operators)
end
change [EvalExtendedResult1 v] by ((-25) * (Delta))
end
if <not <(WhiteKingEndgameTargetIdx) = (0)>> then 
set [Delta v] to ([abs v] of ((item (WhiteKingEndgameTargetIdx) of [IdxToRank v]) - (item (WhiteKingIdx) of [IdxToRank v])) ::operators)
if <(Delta) < ([abs v] of ((item (WhiteKingEndgameTargetIdx) of [IdxToFile v]) - (item (WhiteKingIdx) of [IdxToFile v])) ::operators)> then 
set [Delta v] to ([abs v] of ((item (WhiteKingEndgameTargetIdx) of [IdxToFile v]) - (item (WhiteKingIdx) of [IdxToFile v])) ::operators)
end
change [EvalExtendedResult1 v] by ((25) * (Delta))
end
if <(IsEndgame2) = (1)> then 
set [Delta v] to ([abs v] of ((item (WhiteKingIdx) of [IdxToRank v]) - (item (BlackKingIdx) of [IdxToRank v])) ::operators)
if <(Delta) < ([abs v] of ((item (WhiteKingIdx) of [IdxToFile v]) - (item (BlackKingIdx) of [IdxToFile v])) ::operators)> then 
set [Delta v] to ([abs v] of ((item (WhiteKingIdx) of [IdxToFile v]) - (item (BlackKingIdx) of [IdxToFile v])) ::operators)
end
if <<((WhiteQueenCount) + (WhiteMinorCount)) = (0)> and <(BlackKingEndgameTargetIdx) = (0)>> then 
change [EvalExtendedResult1 v] by ((-35) * (Delta))
end
if <<((BlackQueenCount) + (BlackMinorCount)) = (0)> and <(WhiteKingEndgameTargetIdx) = (0)>> then 
change [EvalExtendedResult1 v] by ((35) * (Delta))
end
end
end
TTStoreBoard %s %s %s %s

define GetTargetIdx %n %n %n
set [GetTargetIdxRes v] to [-1]
set [X v] to ((item (argument_reporter_string_number) of [IdxToFile v]) + (argument_reporter_string_number))
if <<(X) > (0)> and <(X) < (9)>> then 
set [Y v] to ((item (argument_reporter_string_number) of [IdxToRank v]) + (argument_reporter_string_number))
if <<(Y) > (0)> and <(Y) < (9)>> then 
set [GetTargetIdxRes v] to ((X) + (((Y) - (1)) * (8)))
end
end

define AlphaBetaMinMax %n %n %n %n %b %b %n %b
OnScoreCalc %n %n %n %b %b %b
replace item (argument_reporter_string_number) of [Alphas v] with (argument_reporter_string_number)
replace item (argument_reporter_string_number) of [Betas v] with (argument_reporter_string_number)
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b

define IsStringEqual %s %n %s %n
set [IsStringEqualRes v] to [1]
set [Offset v] to [0]
repeat until <<(Offset) = (length of (argument_reporter_string_number))> or <(Offset) = (length of (argument_reporter_string_number))>> 
if <not <(letter ((argument_reporter_string_number) + (Offset)) of (argument_reporter_string_number)) = (letter ((argument_reporter_string_number) + (Offset)) of (argument_reporter_string_number))>> then 
set [IsStringEqualRes v] to [0]
stop [this script v]
end
change [Offset v] by (1)
end

define PickMove %n %n %b %b %b %b
if <(item (argument_reporter_string_number) of [PickPhase v]) = (1)> then 
ClearMoveList %n
replace item (argument_reporter_string_number) of [PickedMove v] with []
replace item (argument_reporter_string_number) of [PawnPromotionFile v] with []
if <<(argument_reporter_string_number) > (1)> or <argument_reporter_boolean>> then 
TTProbeNode %s %s
if <<(TTProbeRes) = (1)> and <<not <(TTProbeBestMoveRes) = ()>> and <((argument_reporter_string_number) mod (2)) = ((TTProbeDepthRes) mod (2))>>> then 
set [SourceIdx v] to ([floor v] of ((TTProbeBestMoveRes) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((TTProbeBestMoveRes) mod (100)) ::operators)
GetMoveScore %n %n %n %n %n %n
if <<<not <argument_reporter_boolean>> and <<not <(TTProbeHorizonRes) = (-1)>> or <<<((argument_reporter_string_number) mod (2)) = (1)> and <(MoveScoreRes) > (0)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(MoveScoreRes) < (0)>>>>> or <<argument_reporter_boolean> and <not <(item (TargetIdx) of [Board v]) = (Empty)>>>> then 
replace item (argument_reporter_string_number) of [ChildNodeCutoffMove v] with [TTProbeBestMoveRes]
if <not <(TTProbeBestMoveRes) = ([floor v] of (TTProbeBestMoveRes) ::operators)>> then 
replace item (argument_reporter_string_number) of [PawnPromotionFile v] with (item (([floor v] of (TTProbeBestMoveRes) ::operators) mod (100)) of [IdxToFile v])
end
replace item (argument_reporter_string_number) of [CheckedState v] with [TTProbeCheckedRes]
if <not <(TTProbeBlackMobRes) = ()>> then 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with [TTProbeBlackMobRes]
 else 
if <(argument_reporter_string_number) = (1)> then 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with [0]
 else 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with (item ((argument_reporter_string_number) - (1)) of [BlackMobBonus v])
end
end
if <not <(TTProbeWhiteMobRes) = ()>> then 
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with [TTProbeWhiteMobRes]
 else 
if <(argument_reporter_string_number) = (1)> then 
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with [0]
 else 
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with (item ((argument_reporter_string_number) - (1)) of [WhiteMobBonus v])
end
end
replace item (argument_reporter_string_number) of [PickedMove v] with [TTProbeBestMoveRes]
AddToMoveList %n %n
replace item (argument_reporter_string_number) of [MovesIdx v] with [1]
ApplyMove %n
replace item (argument_reporter_string_number) of [PickPhase v] with [2]
replace item (argument_reporter_string_number) of [PickMoveRes v] with [1]
Profile_IncCounter %n
stop [this script v]
end
end
end
replace item (argument_reporter_string_number) of [PickPhase v] with [2]
end
if <(item (argument_reporter_string_number) of [PickPhase v]) = (2)> then 
ClearBoardAttackedByMove %n
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [0]
replace item (argument_reporter_string_number) of [CheckedState v] with [-1]
if <not <argument_reporter_boolean>> then 
CalcBoardAttackedByMove %n
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [1]
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (1)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (1)>>> then 
replace item (argument_reporter_string_number) of [CheckedState v] with [1]
 else 
replace item (argument_reporter_string_number) of [CheckedState v] with [0]
end
end
set [CalculateMovesRequiresAttackRecalc v] to [0]
CalculateMovesImpl %n %b %b
if <<argument_reporter_boolean> and <(CalculateMovesRequiresAttackRecalc) = (1)>> then 
CalcBoardAttackedByMove %n
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [1]
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (1)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (1)>>> then 
replace item (argument_reporter_string_number) of [CheckedState v] with [1]
 else 
replace item (argument_reporter_string_number) of [CheckedState v] with [0]
end
CalculateMovesImpl %n %b %b
end
if <argument_reporter_boolean> then 
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [DeepeningScore v]
repeat (length of [Moves1Score v]) 
add [] to [DeepeningScore v]
end
delete (all) of [DeepeningScoreOrderMap v]
repeat (length of [Moves1Score v]) 
add [] to [DeepeningScoreOrderMap v]
end
end
end
if <argument_reporter_boolean> then 
if <(argument_reporter_string_number) = (1)> then 
EvaluateBoard
set [Idx v] to [1]
repeat (length of [Moves1Score v]) 
if <<(item (Idx) of [DeepeningScore v]) = ()> or <([floor v] of ((item (Idx) of [DeepeningScore v]) / (100000)) ::operators) < ((argument_reporter_string_number) - (1))>> then 
replace item (Idx) of [Moves1Score v] with ((EvalResult) + (item (Idx) of [Moves1Score v]))
 else 
replace item (Idx) of [Moves1Score v] with (item (Idx) of [DeepeningScore v])
end
change [Idx v] by (1)
end
end
end
CutoffReorder %n %b
if <(item (argument_reporter_string_number) of [ChildNodeCutoffMove v]) = ()> then 
replace item (argument_reporter_string_number) of [MovesIdx v] with [1]
GetCurrentMove %n
replace item (argument_reporter_string_number) of [ChildNodeCutoffMove v] with [CurrentMove]
end
replace item (argument_reporter_string_number) of [MovesIdx v] with [0]
replace item (argument_reporter_string_number) of [PickPhase v] with [3]
end
if <(item (argument_reporter_string_number) of [PickPhase v]) = (3)> then 
replace item (argument_reporter_string_number) of [MovesIdx v] with ((item (argument_reporter_string_number) of [MovesIdx v]) + (1))
if <not <(item (argument_reporter_string_number) of [MovesIdx v]) > (item (argument_reporter_string_number) of [MovesCount v])>> then 
GetCurrentMove %n
if <(CurrentMove) = (item (argument_reporter_string_number) of [PickedMove v])> then 
replace item (argument_reporter_string_number) of [MovesIdx v] with ((item (argument_reporter_string_number) of [MovesIdx v]) + (1))
end
if <not <(item (argument_reporter_string_number) of [MovesIdx v]) > (item (argument_reporter_string_number) of [MovesCount v])>> then 
ApplyMove %n
replace item (argument_reporter_string_number) of [PickMoveRes v] with [1]
stop [this script v]
end
end
replace item (argument_reporter_string_number) of [PickPhase v] with [4]
replace item (argument_reporter_string_number) of [PickMoveRes v] with [0]
end
replace item (argument_reporter_string_number) of [PickMoveRes v] with [0]

define CutoffReorder %n %b
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves1Score v]) 
if <(item (Idx) of [Moves1Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves1Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves1Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [DeepeningScoreOrderMap v] with (([abs v] of (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v]) ::operators) mod (10000))
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves1 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves1 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (2)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves2Score v]) 
if <(item (Idx) of [Moves2Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves2Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves2Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves2 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves2 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (3)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves3Score v]) 
if <(item (Idx) of [Moves3Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves3Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves3Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves3 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves3 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (4)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves4Score v]) 
if <(item (Idx) of [Moves4Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves4Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves4Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves4 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves4 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (5)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves5Score v]) 
if <(item (Idx) of [Moves5Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves5Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves5Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves5 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves5 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (6)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves6Score v]) 
if <(item (Idx) of [Moves6Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves6Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves6Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves6 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves6 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (7)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves7Score v]) 
if <(item (Idx) of [Moves7Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves7Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves7Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves7 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves7 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (8)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves8Score v]) 
if <(item (Idx) of [Moves8Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves8Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves8Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves8 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves8 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (9)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves9Score v]) 
if <(item (Idx) of [Moves9Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves9Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves9Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves9 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves9 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (10)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves10Score v]) 
if <(item (Idx) of [Moves10Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves10Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves10Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves10 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves10 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (11)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves9Score v]) 
if <(item (Idx) of [Moves11Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves11Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves11Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves11 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves11 v] with (item (((length of [SortedList v]) - (Idx)) + (1)) of [SortedList v])
change [Idx v] by (1)
end
end
if <(argument_reporter_string_number) = (12)> then 
delete (all) of [SortedList v]
set [Idx v] to [1]
repeat (length of [Moves12Score v]) 
if <(item (Idx) of [Moves12Score v]) < (0)> then 
add ((0) - ((([abs v] of (item (Idx) of [Moves12Score v]) ::operators) * (10000)) + (Idx))) to [SortedList v]
 else 
add (((item (Idx) of [Moves12Score v]) * (10000)) + (Idx)) to [SortedList v]
end
change [Idx v] by (1)
end
QuickSort
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [SortedList v] with (item (([abs v] of (item (Idx) of [SortedList v]) ::operators) mod (10000)) of [Moves12 v])
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (length of [SortedList v]) 
replace item (Idx) of [Moves12 v] with (item (Idx) of [SortedList v])
change [Idx v] by (1)
end
end

define AddMoveImpl %n %n %n %b %b %b %b %b
set [TargetPiece v] to (item ([floor v] of (argument_reporter_string_number) ::operators) of [Board v])
if <<<argument_reporter_boolean> and <(TargetPiece) = (Empty)>> or <<<argument_reporter_boolean> and <(TargetPiece) > (0)>> or <<argument_reporter_boolean> and <(TargetPiece) < (0)>>>> then 
set [SourcePiece v] to (item (argument_reporter_string_number) of [Board v])
if <argument_reporter_boolean> then 
if <(SourcePiece) > (0)> then 
replace item (argument_reporter_string_number) of [BoardAttackedByBlack v] with ((item (argument_reporter_string_number) of [BoardAttackedByBlack v]) + (1))
if <(TargetPiece) = (WhiteKing)> then 
set [IsWhiteChecked v] to [1]
end
 else 
replace item (argument_reporter_string_number) of [BoardAttackedByWhite v] with ((item (argument_reporter_string_number) of [BoardAttackedByWhite v]) + (1))
if <(TargetPiece) = (BlackKing)> then 
set [IsBlackChecked v] to [1]
end
end
 else 
if <<argument_reporter_boolean> and <<(TargetPiece) = (Empty)> and <not <<<(SourcePiece) = (WhitePawn)> and <(item (argument_reporter_string_number) of [IdxToRank v]) = (1)>> or <<(SourcePiece) = (BlackPawn)> and <(item (argument_reporter_string_number) of [IdxToRank v]) = (8)>>>>>> then 
stop [this script v]
end
if <<(SourcePiece) = (WhiteKing)> or <(SourcePiece) = (BlackKing)>> then 
if <not <(item (argument_reporter_string_number) of [BoardAttackedCalculated v]) = (1)>> then 
set [CalculateMovesRequiresAttackRecalc v] to [1]
stop [this script v]
end
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(item (argument_reporter_string_number) of [BoardAttackedByWhite v]) > (0)> then 
stop [this script v]
end
 else 
if <(item (argument_reporter_string_number) of [BoardAttackedByBlack v]) > (0)> then 
stop [this script v]
end
end
end
if <not <argument_reporter_boolean>> then 
if <<<(SourcePiece) > (0)> and <(item (argument_reporter_string_number) of [BoardAttackedByWhite v]) = (0)>> or <<(SourcePiece) < (0)> and <(item (argument_reporter_string_number) of [BoardAttackedByBlack v]) = (0)>>> then 
replace item (argument_reporter_string_number) of [PieceMobility v] with ((item (argument_reporter_string_number) of [PieceMobility v]) + (1))
end
end
if <(argument_reporter_string_number) < (10)> then 
set [CurrentMove v] to (((argument_reporter_string_number) * (100)) + (argument_reporter_string_number))
 else 
set [CurrentMove v] to (join [0] (((argument_reporter_string_number) * (100)) + (argument_reporter_string_number)))
end
if <<<(SourcePiece) = (WhitePawn)> and <(item (argument_reporter_string_number) of [IdxToRank v]) = (1)>> or <<(SourcePiece) = (BlackPawn)> and <(item (argument_reporter_string_number) of [IdxToRank v]) = (8)>>> then 
replace item (argument_reporter_string_number) of [PawnPromotionFile v] with (item (argument_reporter_string_number) of [IdxToFile v])
AddSpecialMove %s %n
AddSpecialMove %s %n
AddSpecialMove %s %n
AddSpecialMove %s %n
stop [this script v]
end
GetMoveScore %n %n %n %n %n %n
if <(argument_reporter_string_number) < (6)> then 
if <(argument_reporter_string_number) = (5)> then 
add [CurrentMove] to [Moves5 v]
add [MoveScoreRes] to [Moves5Score v]
 else 
if <(argument_reporter_string_number) = (4)> then 
add [CurrentMove] to [Moves4 v]
add [MoveScoreRes] to [Moves4Score v]
 else 
if <(argument_reporter_string_number) = (3)> then 
add [CurrentMove] to [Moves3 v]
add [MoveScoreRes] to [Moves3Score v]
 else 
if <(argument_reporter_string_number) = (2)> then 
add [CurrentMove] to [Moves2 v]
add [MoveScoreRes] to [Moves2Score v]
 else 
if <(argument_reporter_string_number) = (1)> then 
add [CurrentMove] to [Moves1 v]
add [MoveScoreRes] to [Moves1Score v]
end
end
end
end
end
 else 
if <(argument_reporter_string_number) = (6)> then 
add [CurrentMove] to [Moves6 v]
add [MoveScoreRes] to [Moves6Score v]
 else 
if <(argument_reporter_string_number) = (7)> then 
add [CurrentMove] to [Moves7 v]
add [MoveScoreRes] to [Moves7Score v]
 else 
if <(argument_reporter_string_number) = (8)> then 
add [CurrentMove] to [Moves8 v]
add [MoveScoreRes] to [Moves8Score v]
 else 
if <(argument_reporter_string_number) = (9)> then 
add [CurrentMove] to [Moves9 v]
add [MoveScoreRes] to [Moves9Score v]
 else 
if <(argument_reporter_string_number) = (10)> then 
add [CurrentMove] to [Moves10 v]
add [MoveScoreRes] to [Moves10Score v]
 else 
if <(argument_reporter_string_number) = (20)> then 
add [CurrentMove] to [Moves20 v]
add [MoveScoreRes] to [Moves20Score v]
 else 
if <(argument_reporter_string_number) = (19)> then 
add [CurrentMove] to [Moves19 v]
add [MoveScoreRes] to [Moves19Score v]
 else 
if <(argument_reporter_string_number) = (18)> then 
add [CurrentMove] to [Moves18 v]
add [MoveScoreRes] to [Moves18Score v]
 else 
if <(argument_reporter_string_number) = (17)> then 
add [CurrentMove] to [Moves17 v]
add [MoveScoreRes] to [Moves17Score v]
 else 
if <(argument_reporter_string_number) = (16)> then 
add [CurrentMove] to [Moves16 v]
add [MoveScoreRes] to [Moves16Score v]
 else 
if <(argument_reporter_string_number) = (15)> then 
add [CurrentMove] to [Moves15 v]
add [MoveScoreRes] to [Moves15Score v]
 else 
if <(argument_reporter_string_number) = (14)> then 
add [CurrentMove] to [Moves14 v]
add [MoveScoreRes] to [Moves14Score v]
 else 
if <(argument_reporter_string_number) = (13)> then 
add [CurrentMove] to [Moves13 v]
add [MoveScoreRes] to [Moves13Score v]
 else 
if <(argument_reporter_string_number) = (12)> then 
add [CurrentMove] to [Moves12 v]
add [MoveScoreRes] to [Moves12Score v]
 else 
if <(argument_reporter_string_number) = (11)> then 
add [CurrentMove] to [Moves11 v]
add [MoveScoreRes] to [Moves11Score v]
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end

define AddPossibleEnPassant %n %n %b
AddPossibleEnPassantImpl %n %n %n %b
AddPossibleEnPassantImpl %n %n %n %b

define AddLineMove %n %n %n %b %b %b %b %b
set [SourcePieceOuter v] to (item (argument_reporter_string_number) of [Board v])
set [Count v] to [1]
set [IdxOuter v] to (item (argument_reporter_string_number) of [MoveLookupLineIndexOffset v])
set [InvIdxOuter v] to [8]
repeat until <(Count) > (32)> 
set [TargetIdxOuter v] to [-1]
if <(argument_reporter_string_number) = (LineMoveTypeStraight)> then 
set [TargetIdxOuter v] to (item ((IdxOuter) + (Count)) of [MoveLookupStraight v])
 else 
if <(argument_reporter_string_number) = (LineMoveTypeCross)> then 
set [TargetIdxOuter v] to (item ((IdxOuter) + (Count)) of [MoveLookupCross v])
end
end
set [TargetPieceOuter v] to [Empty]
if <not <(TargetIdxOuter) = (-1)>> then 
set [TargetPieceOuter v] to (item (TargetIdxOuter) of [Board v])
if <<not <argument_reporter_boolean>> or <<<(SourcePieceOuter) > (0)> and <(item (TargetIdxOuter) of [Board v]) < (0)>> or <<(SourcePieceOuter) < (0)> and <(item (TargetIdxOuter) of [Board v]) > (0)>>>> then 
AddMoveImpl %n %n %n %b %b %b %b %b
end
end
if <<(TargetIdxOuter) = (-1)> or <not <(TargetPieceOuter) = (Empty)>>> then 
change [Count v] by (InvIdxOuter)
set [InvIdxOuter v] to [8]
 else 
change [Count v] by (1)
change [InvIdxOuter v] by (-1)
end
end

define GetBoardString
set [GetBoardStringRes v] to []
set [Idx v] to [1]
repeat (64) 
set [GetBoardStringRes v] to (join [GetBoardStringRes] (join (item (Idx) of [Board v]) [,]))
change [Idx v] by (1)
end

when i receive [progressvaluechangedinternal v]
broadcast (1 v) and wait

when i receive [stageclicked v]
hide list [ExportData v]
hide list [ExportMoves v]
if <(IsExecutionRunning) = (0)> then 
say []
end

define GetSubstringLeft %s %n
GetSubstring %s %n %n

define QuickSort
delete all of [QSPartStack v]
QuickSortImpl %s %s

define DrawBoard
set [ProgressValue v] to [0]
broadcast (1 v)
broadcast (1 v)

define GetSubstring %s %n %n
set [SubstringRes v] to []
set [IdxString v] to (argument_reporter_string_number)
repeat (((argument_reporter_string_number) - (argument_reporter_string_number)) + (1)) 
set [SubstringRes v] to (join [SubstringRes] (letter (IdxString) of (argument_reporter_string_number)))
change [IdxString v] by (1)
end

define GetRepetitionCount
set [Idx v] to ((length of [BoardHistory v]) - (1))
set [RepetitionCountRes v] to [1]
repeat ((length of [BoardHistory v]) - (1)) 
if <(item (Idx) of [BoardHistory v]) = (item (last) of [BoardHistory v])> then 
change [RepetitionCountRes v] by (1)
end
change [Idx v] by (-1)
end

define CalculateOpeningMoves
delete (all) of [BestMoves v]
if <(IsImportedBoard) = (0)> then 
if <(IsPlayerBlack) = (0)> then 
set [Idx v] to [1]
 else 
set [Idx v] to (((length of [OpeningMoves v]) / (2)) + (1))
end
repeat ((length of [OpeningMoves v]) / (2)) 
if <(length of [GameMoves]) < (length of (item (Idx) of [OpeningMoves v]))> then 
set [IdxString v] to [1]
set [IsEqual v] to [1]
repeat (length of [GameMoves]) 
if <not <(letter (IdxString) of [GameMoves]) = (letter (IdxString) of (item (Idx) of [OpeningMoves v]))>> then 
set [IsEqual v] to [0]
end
change [IdxString v] by (1)
end
if <(IsEqual) = (1)> then 
set [BestMove v] to (letter ((length of [GameMoves]) + (1)) of (item (Idx) of [OpeningMoves v]))
set [BestMove v] to (join [BestMove] (letter ((length of [GameMoves]) + (2)) of (item (Idx) of [OpeningMoves v])))
set [BestMove v] to (join [BestMove] (letter ((length of [GameMoves]) + (3)) of (item (Idx) of [OpeningMoves v])))
set [BestMove v] to (join [BestMove] (letter ((length of [GameMoves]) + (4)) of (item (Idx) of [OpeningMoves v])))
add [BestMove] to [BestMoves v]
end
end
change [Idx v] by (1)
end
end

define GetXOR %n %n
set [XORA v] to (argument_reporter_string_number)
set [XORB v] to (argument_reporter_string_number)
set [XORVal v] to [1]
set [XORResult v] to [0]
repeat until <<(XORA) = (0)> and <(XORB) = (0)>> 
if <not <((XORA) mod (2)) = ((XORB) mod (2))>> then 
change [XORResult v] by (XORVal)
end
set [XORA v] to ([floor v] of ((XORA) / (2)) ::operators)
set [XORB v] to ([floor v] of ((XORB) / (2)) ::operators)
set [XORVal v] to ((XORVal) * (2))
end

define InitCoordLookup
delete (all) of [IdxToFile v]
delete (all) of [IdxToRank v]
set [Idx v] to [1]
repeat (64) 
add ((((Idx) - (1)) mod (8)) + (1)) to [IdxToFile v]
add ([ceiling v] of ((Idx) / (8)) ::operators) to [IdxToRank v]
change [Idx v] by (1)
end

define ImportBoard %s
set [IsImportedBoard v] to [1]
set [HasWhiteKingMoved v] to [0]
set [HasBlackKingMoved v] to [0]
set [HasWhiteCastled v] to [0]
set [HasBlackCastled v] to [0]
set [HasWhiteRookKSMoved v] to [0]
set [HasWhiteRookQSMoved v] to [0]
set [HasBlackRookKSMoved v] to [0]
set [HasBlackRookQSMoved v] to [0]
set [GameMoves v] to []
delete (all) of [BoardHistory v]
delete (all) of [BoardHistoryHash v]
delete (all) of [GameMovesAN v]
set [IsFEN v] to [1]
set [IdxString v] to [1]
repeat (length of (argument_reporter_string_number)) 
if <(letter (IdxString) of (argument_reporter_string_number)) = (,)> then 
set [IsFEN v] to [0]
end
change [IdxString v] by (1)
end
if <(IsFEN) = (1)> then 
ImportBoardFEN %s
 else 
ImportBoardInternal %s
end
if <not <(item (item (1) of [VirtualBoard v]) of [Board v]) = (BlackRook)>> then 
set [HasBlackRookQSMoved v] to [1]
end
if <not <(item (item (5) of [VirtualBoard v]) of [Board v]) = (BlackKing)>> then 
set [HasBlackKingMoved v] to [1]
end
if <not <(item (item (8) of [VirtualBoard v]) of [Board v]) = (BlackRook)>> then 
set [HasBlackRookQSMoved v] to [1]
end
if <not <(item (item (57) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> then 
set [HasWhiteRookQSMoved v] to [1]
end
if <not <(item (item (61) of [VirtualBoard v]) of [Board v]) = (WhiteKing)>> then 
set [HasWhiteKingMoved v] to [1]
end
if <not <(item (item (64) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> then 
set [HasWhiteRookKSMoved v] to [1]
end

define CalculateMovesForSource %n %n %b %b
if <<(item (argument_reporter_string_number) of [Board v]) > (0)> or <argument_reporter_boolean>> then 
set [DoMoveOnWhite v] to [1]
 else 
set [DoMoveOnWhite v] to [0]
end
if <<(item (argument_reporter_string_number) of [Board v]) < (0)> or <argument_reporter_boolean>> then 
set [DoMoveOnBlack v] to [1]
 else 
set [DoMoveOnBlack v] to [0]
end
if <(item (argument_reporter_string_number) of [Board v]) = (BlackPawn)> then 
if <(item (argument_reporter_string_number) of [IdxToRank v]) < (8)> then 
if <(item (argument_reporter_string_number) of [IdxToFile v]) > (1)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <(item (argument_reporter_string_number) of [IdxToFile v]) < (8)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <<not <argument_reporter_boolean>> and <<not <argument_reporter_boolean>> or <(item (argument_reporter_string_number) of [IdxToRank v]) = (7)>>> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
if <(item (argument_reporter_string_number) of [IdxToRank v]) = (2)> then 
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <(item ((argument_reporter_string_number) + (8)) of [Board v]) = (Empty)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
 else 
if <(item (argument_reporter_string_number) of [IdxToRank v]) = (5)> then 
AddPossibleEnPassant %n %n %b
end
end
 else 
if <(item (argument_reporter_string_number) of [Board v]) = (WhitePawn)> then 
if <(item (argument_reporter_string_number) of [IdxToRank v]) > (1)> then 
if <(item (argument_reporter_string_number) of [IdxToFile v]) > (1)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <(item (argument_reporter_string_number) of [IdxToFile v]) < (8)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
if <<not <argument_reporter_boolean>> and <<not <argument_reporter_boolean>> or <(item (argument_reporter_string_number) of [IdxToRank v]) = (2)>>> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
if <(item (argument_reporter_string_number) of [IdxToRank v]) = (7)> then 
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <(item ((argument_reporter_string_number) - (8)) of [Board v]) = (Empty)> then 
AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
end
end
 else 
if <(item (argument_reporter_string_number) of [IdxToRank v]) = (4)> then 
AddPossibleEnPassant %n %n %b
end
end
 else 
set [SourcePieceOuter2 v] to ([abs v] of (item (argument_reporter_string_number) of [Board v]) ::operators)
if <(SourcePieceOuter2) = (BlackRook)> then 
AddLineMove %n %n %n %b %b %b %b %b
 else 
if <(SourcePieceOuter2) = (BlackBishop)> then 
AddLineMove %n %n %n %b %b %b %b %b
 else 
if <(SourcePieceOuter2) = (BlackKnight)> then 
AddLookupMove %n %n %n %b %b %b %b %b
 else 
if <(SourcePieceOuter2) = (BlackKing)> then 
AddLookupMove %n %n %n %b %b %b %b %b
 else 
if <(SourcePieceOuter2) = (BlackQueen)> then 
AddLineMove %n %n %n %b %b %b %b %b
AddLineMove %n %n %n %b %b %b %b %b
end
end
end
end
end
end
end

define ClearMoveList %n
if <(argument_reporter_string_number) = (20)> then 
delete (all) of [Moves20 v]
delete (all) of [Moves20Score v]
replace item (20) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (19)> then 
delete (all) of [Moves19 v]
delete (all) of [Moves19Score v]
replace item (19) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (18)> then 
delete (all) of [Moves18 v]
delete (all) of [Moves18Score v]
replace item (18) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (17)> then 
delete (all) of [Moves17 v]
delete (all) of [Moves17Score v]
replace item (17) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (16)> then 
delete (all) of [Moves16 v]
delete (all) of [Moves16Score v]
replace item (16) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (15)> then 
delete (all) of [Moves15 v]
delete (all) of [Moves15Score v]
replace item (15) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (14)> then 
delete (all) of [Moves14 v]
delete (all) of [Moves14Score v]
replace item (14) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (13)> then 
delete (all) of [Moves13 v]
delete (all) of [Moves13Score v]
replace item (13) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (12)> then 
delete (all) of [Moves12 v]
delete (all) of [Moves12Score v]
replace item (12) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (11)> then 
delete (all) of [Moves11 v]
delete (all) of [Moves11Score v]
replace item (11) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (10)> then 
delete (all) of [Moves10 v]
delete (all) of [Moves10Score v]
replace item (10) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (9)> then 
delete (all) of [Moves9 v]
delete (all) of [Moves9Score v]
replace item (9) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (8)> then 
delete (all) of [Moves8 v]
delete (all) of [Moves8Score v]
replace item (8) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (7)> then 
delete (all) of [Moves7 v]
delete (all) of [Moves7Score v]
replace item (7) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (6)> then 
delete (all) of [Moves6 v]
delete (all) of [Moves6Score v]
replace item (6) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (5)> then 
delete (all) of [Moves5 v]
delete (all) of [Moves5Score v]
replace item (5) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (4)> then 
delete (all) of [Moves4 v]
delete (all) of [Moves4Score v]
replace item (4) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (3)> then 
delete (all) of [Moves3 v]
delete (all) of [Moves3Score v]
replace item (3) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (2)> then 
delete (all) of [Moves2 v]
delete (all) of [Moves2Score v]
replace item (2) of [MovesCount v] with [0]
 else 
if <(argument_reporter_string_number) = (1)> then 
delete (all) of [Moves1 v]
delete (all) of [Moves1Score v]
replace item (1) of [MovesCount v] with [0]
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end

define RUN_BEFORE_SAVING
delete (all) of [MovePosLookupBlack v]
delete (all) of [MovePosLookupWhite v]
delete (all) of [MoveHashLookupBlack v]
delete (all) of [MoveHashLookupWhite v]
delete (all) of [TTBoardScore1 v]
delete (all) of [TTBoardScore2 v]
delete (all) of [TTBoardScore3 v]
delete (all) of [TTBoardHash v]
delete (all) of [TTBoardAge v]
delete (all) of [TTNodeChecked v]
delete (all) of [TTNodeHash v]
delete (all) of [TTNodeBestMove v]
delete (all) of [TTNodeScore v]
delete (all) of [TTNodeDepth v]
delete (all) of [TTNodeAge v]
delete (all) of [TTNodeType v]
delete (all) of [TTNodeHorizon v]
delete (all) of [KillerMoves1 v]
delete (all) of [KillerMoves2 v]
delete (all) of [KillerMoves3 v]
delete (all) of [KillerMoves4 v]
delete (all) of [KillerMoves5 v]
delete (all) of [KillerMoves6 v]
delete (all) of [TTNodeHorizon v]
delete (all) of [TTNodeBlackMobility v]
delete (all) of [TTNodeWhiteMobility v]
if <(1) = (0)> then 
delete (all) of [MoveLookupStraight v]
delete (all) of [MoveLookupCross v]
delete (all) of [MoveLookupOffsetsStraight v]
delete (all) of [MoveLookupOffsetsCross v]
delete (all) of [OpeningMoves v]
delete (all) of [KnightPieceSquare v]
delete (all) of [PawnPieceSquare v]
delete (all) of [BishopPieceSquare v]
delete (all) of [RookPieceSquare v]
delete (all) of [QueenPieceSquare v]
delete (all) of [KingPieceSquare v]
delete (all) of [KingPieceSquareEndgame v]
delete (all) of [OpeningMoves v]
delete (all) of [PawnPieceSquareEndgame v]
delete (all) of [PosPieceHashLookup v]
delete (all) of [BoardHistory v]
end

define GetMoveNotation %n
GetVirtualMove %n
set [MoveNotationRes v] to []
if <<(VirtualMove) = (BlackKingsideCastling)> or <(VirtualMove) = (WhiteKingsideCastling)>> then 
set [MoveNotationRes v] to [O-O]
stop [this script v]
end
if <<(VirtualMove) = (BlackQueensideCastling)> or <(VirtualMove) = (WhiteQueensideCastling)>> then 
set [MoveNotationRes v] to [O-O-O]
stop [this script v]
end
set [SourceIdx v] to ([floor v] of ((VirtualMove) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((VirtualMove) mod (100)) ::operators)
set [CurrentPiece v] to (item ([floor v] of ((argument_reporter_string_number) / (100)) ::operators) of [Board v])
if <<(CurrentPiece) = (BlackBishop)> or <(CurrentPiece) = (WhiteBishop)>> then 
set [MoveNotationRes v] to [B]
end
if <<(CurrentPiece) = (BlackKing)> or <(CurrentPiece) = (WhiteKing)>> then 
set [MoveNotationRes v] to [K]
end
if <<(CurrentPiece) = (BlackRook)> or <(CurrentPiece) = (WhiteRook)>> then 
set [MoveNotationRes v] to [R]
end
if <<(CurrentPiece) = (BlackKnight)> or <(CurrentPiece) = (WhiteKnight)>> then 
set [MoveNotationRes v] to [N]
end
if <<(CurrentPiece) = (WhiteQueen)> or <(CurrentPiece) = (BlackQueen)>> then 
set [MoveNotationRes v] to [Q]
end
set [X v] to (item (SourceIdx) of [IdxToFile v])
set [Y v] to ((9) - (item (SourceIdx) of [IdxToRank v]))
set [MoveNotationRes v] to (join [MoveNotationRes] (join (letter (X) of [abcdefgh]) [Y]))
if <not <(item ([floor v] of ((argument_reporter_string_number) mod (100)) ::operators) of [Board v]) = (Empty)>> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [x])
end
set [X v] to (item (TargetIdx) of [IdxToFile v])
set [Y v] to ((9) - (item (TargetIdx) of [IdxToRank v]))
if <((letter (5) of [VirtualMove]) = (.)) = (.1)> then 
if <(letter (6) of [VirtualMove]) = (1)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [Q])
end
if <(letter (6) of [VirtualMove]) = (2)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [R])
end
if <(letter (6) of [VirtualMove]) = (3)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [B])
end
if <(letter (6) of [VirtualMove]) = (4)> then 
set [MoveNotationRes v] to (join [MoveNotationRes] [N])
end
 else 
set [MoveNotationRes v] to (join [MoveNotationRes] (join (letter (X) of [abcdefgh]) [Y]))
end

define LoadList %s %s
set [IdxString v] to [1]
set [CurrentValue v] to []
repeat until <(IdxString) > (length of (argument_reporter_string_number))> 
if <<not <(letter (IdxString) of (argument_reporter_string_number)) = ( )>> and <not <(letter (IdxString) of (argument_reporter_string_number)) = (,)>>> then 
set [CurrentValue v] to (join [CurrentValue] (letter (IdxString) of (argument_reporter_string_number)))
end
if <<(letter (IdxString) of (argument_reporter_string_number)) = (,)> or <(IdxString) = (length of (argument_reporter_string_number))>> then 
if <(argument_reporter_string_number) = (PawnPieceSquare)> then 
add [CurrentValue] to [PawnPieceSquare v]
end
if <(argument_reporter_string_number) = (PawnPieceSquareEndgame)> then 
add [CurrentValue] to [PawnPieceSquareEndgame v]
end
if <(argument_reporter_string_number) = (PawnPieceSquareKingside)> then 
end
if <(argument_reporter_string_number) = (PawnPieceSquareQueenside)> then 
end
if <(argument_reporter_string_number) = (KingPieceSquare)> then 
add [CurrentValue] to [KingPieceSquare v]
end
if <(argument_reporter_string_number) = (KingPieceSquareEndgame)> then 
add [CurrentValue] to [KingPieceSquareEndgame v]
end
if <(argument_reporter_string_number) = (QueenPieceSquare)> then 
add [CurrentValue] to [QueenPieceSquare v]
end
if <(argument_reporter_string_number) = (RookPieceSquare)> then 
add [CurrentValue] to [RookPieceSquare v]
end
if <(argument_reporter_string_number) = (BishopPieceSquare)> then 
add [CurrentValue] to [BishopPieceSquare v]
end
if <(argument_reporter_string_number) = (KnightPieceSquare)> then 
add [CurrentValue] to [KnightPieceSquare v]
end
if <(argument_reporter_string_number) = (KnightMobilityBonus)> then 
add ((CurrentValue) * (3)) to [KnightMobilityBonus v]
end
if <(argument_reporter_string_number) = (BishopMobilityBonus)> then 
add ((CurrentValue) * (3)) to [BishopMobilityBonus v]
end
if <(argument_reporter_string_number) = (RookMobilityBonus)> then 
add ((CurrentValue) * (3)) to [RookMobilityBonus v]
end
if <(argument_reporter_string_number) = (QueenMobilityBonus)> then 
add ((CurrentValue) * (3)) to [QueenMobilityBonus v]
end
if <(argument_reporter_string_number) = (PawnStormBlockedByKing)> then 
add [CurrentValue] to [PawnStormBlockedByKing v]
end
if <(argument_reporter_string_number) = (PawnStormBlockedByPawn)> then 
add [CurrentValue] to [PawnStormBlockedByPawn v]
end
if <(argument_reporter_string_number) = (PawnStormBlockedByNone)> then 
add [CurrentValue] to [PawnStormBlockedByNone v]
end
if <(argument_reporter_string_number) = (PawnShelterKingCol)> then 
add [CurrentValue] to [PawnShelterKingFile v]
end
if <(argument_reporter_string_number) = (PawnShelterNeighborCol)> then 
add [CurrentValue] to [PawnShelterNeighborFile v]
end
set [CurrentValue v] to []
end
change [IdxString v] by (1)
end

define AddPossibleEnPassantImpl %n %n %n %b
GetTargetIdx %n %n %n
if <not <(GetTargetIdxRes) = (-1)>> then 
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(item (GetTargetIdxRes) of [Board v]) = (WhitePawn)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(item (GetTargetIdxRes) of [Board v]) = (BlackPawn)>>> then 
set [IsEnPassantAllowed v] to [0]
if <((argument_reporter_string_number) mod (2)) = (1)> then 
set [EnPassantPrevMove v] to (join ((GetTargetIdxRes) + (16)) [GetTargetIdxRes])
 else 
set [EnPassantPrevMove v] to (join ((GetTargetIdxRes) - (16)) [GetTargetIdxRes])
end
if <(argument_reporter_string_number) < (6)> then 
if <(argument_reporter_string_number) = (5)> then 
if <(item (item (4) of [MovesIdx v]) of [Moves4 v]) = (EnPassantPrevMove)> then 
set [IsEnPassantAllowed v] to [1]
end
 else 
if <(argument_reporter_string_number) = (4)> then 
if <(item (item (3) of [MovesIdx v]) of [Moves3 v]) = (EnPassantPrevMove)> then 
set [IsEnPassantAllowed v] to [1]
end
 else 
if <(argument_reporter_string_number) = (3)> then 
if <(item (item (2) of [MovesIdx v]) of [Moves2 v]) = (EnPassantPrevMove)> then 
set [IsEnPassantAllowed v] to [1]
end
 else 
GetSubstringRight %s %n
if <(argument_reporter_string_number) = (2)> then 
if <<(SubstringRes) = (EnPassantPrevMove)> or <(item (item (1) of [MovesIdx v]) of [Moves1 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
 else 
if <(argument_reporter_string_number) = (1)> then 
if <(SubstringRes) = (EnPassantPrevMove)> then 
set [IsEnPassantAllowed v] to [1]
end
end
end
end
end
end
 else 
if <(argument_reporter_string_number) = (6)> then 
if <(item (item (5) of [MovesIdx v]) of [Moves5 v]) = (EnPassantPrevMove)> then 
set [IsEnPassantAllowed v] to [1]
end
 else 
if <(argument_reporter_string_number) = (7)> then 
if <(item (item (6) of [MovesIdx v]) of [Moves6 v]) = (EnPassantPrevMove)> then 
set [IsEnPassantAllowed v] to [1]
end
 else 
if <(argument_reporter_string_number) = (8)> then 
if <(item (item (7) of [MovesIdx v]) of [Moves7 v]) = (EnPassantPrevMove)> then 
set [IsEnPassantAllowed v] to [1]
end
 else 
if <(argument_reporter_string_number) = (9)> then 
if <(item (item (8) of [MovesIdx v]) of [Moves8 v]) = (EnPassantPrevMove)> then 
set [IsEnPassantAllowed v] to [1]
end
 else 
if <(argument_reporter_string_number) = (10)> then 
if <(item (item (9) of [MovesIdx v]) of [Moves9 v]) = (EnPassantPrevMove)> then 
set [IsEnPassantAllowed v] to [1]
end
 else 
if <<(argument_reporter_string_number) = (11)> and <(item (item (10) of [MovesIdx v]) of [Moves10 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (12)> and <(item (item (11) of [MovesIdx v]) of [Moves11 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (13)> and <(item (item (12) of [MovesIdx v]) of [Moves12 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (14)> and <(item (item (13) of [MovesIdx v]) of [Moves13 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (15)> and <(item (item (14) of [MovesIdx v]) of [Moves14 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (16)> and <(item (item (15) of [MovesIdx v]) of [Moves15 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (17)> and <(item (item (16) of [MovesIdx v]) of [Moves16 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (18)> and <(item (item (17) of [MovesIdx v]) of [Moves17 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (19)> and <(item (item (18) of [MovesIdx v]) of [Moves18 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
if <<(argument_reporter_string_number) = (20)> and <(item (item (19) of [MovesIdx v]) of [Moves19 v]) = (EnPassantPrevMove)>> then 
set [IsEnPassantAllowed v] to [1]
end
end
end
end
end
end
end
if <(IsEnPassantAllowed) = (1)> then 
if <argument_reporter_boolean> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
replace item (GetTargetIdxRes) of [BoardAttackedByBlack v] with ((item (GetTargetIdxRes) of [BoardAttackedByBlack v]) + (1))
 else 
replace item (GetTargetIdxRes) of [BoardAttackedByWhite v] with ((item (GetTargetIdxRes) of [BoardAttackedByWhite v]) + (1))
end
 else 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
AddSpecialMove %s %n
 else 
AddSpecialMove %s %n
end
end
end
end
end

define GetCurrentMove %n
if <(argument_reporter_string_number) < (6)> then 
if <(argument_reporter_string_number) = (5)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves5 v])
 else 
if <(argument_reporter_string_number) = (4)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves4 v])
 else 
if <(argument_reporter_string_number) = (3)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves3 v])
 else 
if <(argument_reporter_string_number) = (2)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves2 v])
 else 
if <(argument_reporter_string_number) = (1)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves1 v])
end
end
end
end
end
 else 
if <(argument_reporter_string_number) = (6)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves6 v])
 else 
if <(argument_reporter_string_number) = (7)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves7 v])
 else 
if <(argument_reporter_string_number) = (8)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves8 v])
 else 
if <(argument_reporter_string_number) = (9)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves9 v])
 else 
if <(argument_reporter_string_number) = (10)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves10 v])
 else 
if <(argument_reporter_string_number) = (20)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves20 v])
 else 
if <(argument_reporter_string_number) = (19)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves19 v])
 else 
if <(argument_reporter_string_number) = (18)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves18 v])
 else 
if <(argument_reporter_string_number) = (17)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves17 v])
 else 
if <(argument_reporter_string_number) = (16)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves16 v])
 else 
if <(argument_reporter_string_number) = (15)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves15 v])
 else 
if <(argument_reporter_string_number) = (14)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves14 v])
 else 
if <(argument_reporter_string_number) = (13)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves13 v])
 else 
if <(argument_reporter_string_number) = (12)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves12 v])
 else 
if <(argument_reporter_string_number) = (11)> then 
set [CurrentMove v] to (item (item (argument_reporter_string_number) of [MovesIdx v]) of [Moves11 v])
 else 
set [CurrentMove v] to []
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end

define AddLookupMove %n %n %n %b %b %b %b %b
set [SourcePieceOuter v] to (item (argument_reporter_string_number) of [Board v])
set [IdxOuter v] to (item (argument_reporter_string_number) of [MoveLookupIndexOffset v])
set [Count v] to [1]
repeat until <(Count) > (8)> 
if <(argument_reporter_string_number) = (LookupMoveTypeKnight)> then 
set [TargetIdxOuter v] to (item ((IdxOuter) + (Count)) of [MoveLookupKnight v])
 else 
if <(argument_reporter_string_number) = (LookupMoveTypeKing)> then 
set [TargetIdxOuter v] to (item ((IdxOuter) + (Count)) of [MoveLookupKing v])
 else 
set [TargetIdxOuter v] to [-1]
end
end
if <not <(TargetIdxOuter) = (-1)>> then 
if <<not <argument_reporter_boolean>> or <<<(SourcePieceOuter) > (0)> and <(item (TargetIdxOuter) of [Board v]) < (0)>> or <<(SourcePieceOuter) < (0)> and <(item (TargetIdxOuter) of [Board v]) > (0)>>>> then 
AddMoveImpl %n %n %n %b %b %b %b %b
end
change [Count v] by (1)
 else 
stop [this script v]
end
end

define IsTwoKingDraw
set [TwoKingDrawRes v] to [1]
set [Idx v] to [1]
repeat (64) 
if <<not <(item (Idx) of [Board v]) = (Empty)>> and <<not <(item (Idx) of [Board v]) = (BlackKing)>> and <not <(item (Idx) of [Board v]) = (WhiteKing)>>>> then 
set [TwoKingDrawRes v] to [0]
end
change [Idx v] by (1)
end

define CalculateMoves %n
CalcBoardAttackedByMove %n
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [1]
CalculateMovesImpl %n %b %b
replace item (argument_reporter_string_number) of [BoardAttackedCalculated v] with [0]

define AddToMoveList %n %n
if <(argument_reporter_string_number) < (6)> then 
if <(argument_reporter_string_number) = (5)> then 
add (argument_reporter_string_number) to [Moves5 v]
add [0] to [Moves5Score v]
replace item (5) of [MovesCount v] with (length of [Moves5 v])
 else 
if <(argument_reporter_string_number) = (4)> then 
add (argument_reporter_string_number) to [Moves4 v]
add [0] to [Moves4Score v]
replace item (4) of [MovesCount v] with (length of [Moves4 v])
 else 
if <(argument_reporter_string_number) = (3)> then 
add (argument_reporter_string_number) to [Moves3 v]
add [0] to [Moves3Score v]
replace item (3) of [MovesCount v] with (length of [Moves3 v])
 else 
if <(argument_reporter_string_number) = (2)> then 
add (argument_reporter_string_number) to [Moves2 v]
add [0] to [Moves2Score v]
replace item (2) of [MovesCount v] with (length of [Moves2 v])
 else 
if <(argument_reporter_string_number) = (1)> then 
add (argument_reporter_string_number) to [Moves1 v]
add [0] to [Moves1Score v]
replace item (1) of [MovesCount v] with (length of [Moves1 v])
end
end
end
end
end
 else 
if <(argument_reporter_string_number) = (6)> then 
add (argument_reporter_string_number) to [Moves6 v]
add [0] to [Moves6Score v]
replace item (6) of [MovesCount v] with (length of [Moves6 v])
 else 
if <(argument_reporter_string_number) = (7)> then 
add (argument_reporter_string_number) to [Moves7 v]
add [0] to [Moves7Score v]
replace item (7) of [MovesCount v] with (length of [Moves7 v])
 else 
if <(argument_reporter_string_number) = (8)> then 
add (argument_reporter_string_number) to [Moves8 v]
add [0] to [Moves8Score v]
replace item (8) of [MovesCount v] with (length of [Moves8 v])
 else 
if <(argument_reporter_string_number) = (9)> then 
add (argument_reporter_string_number) to [Moves9 v]
add [0] to [Moves9Score v]
replace item (9) of [MovesCount v] with (length of [Moves9 v])
 else 
if <(argument_reporter_string_number) = (10)> then 
add (argument_reporter_string_number) to [Moves10 v]
add [0] to [Moves10Score v]
replace item (10) of [MovesCount v] with (length of [Moves10 v])
 else 
if <(argument_reporter_string_number) = (20)> then 
add (argument_reporter_string_number) to [Moves20 v]
add [0] to [Moves20Score v]
replace item (20) of [MovesCount v] with (length of [Moves20 v])
 else 
if <(argument_reporter_string_number) = (19)> then 
add (argument_reporter_string_number) to [Moves19 v]
add [0] to [Moves19Score v]
replace item (19) of [MovesCount v] with (length of [Moves19 v])
 else 
if <(argument_reporter_string_number) = (18)> then 
add (argument_reporter_string_number) to [Moves18 v]
add [0] to [Moves18Score v]
replace item (18) of [MovesCount v] with (length of [Moves18 v])
 else 
if <(argument_reporter_string_number) = (17)> then 
add (argument_reporter_string_number) to [Moves17 v]
add [] to [Moves17Score v]
replace item (17) of [MovesCount v] with (length of [Moves17 v])
 else 
if <(argument_reporter_string_number) = (16)> then 
add (argument_reporter_string_number) to [Moves16 v]
add [0] to [Moves16Score v]
replace item (16) of [MovesCount v] with (length of [Moves16 v])
 else 
if <(argument_reporter_string_number) = (15)> then 
add (argument_reporter_string_number) to [Moves15 v]
add [0] to [Moves15Score v]
replace item (15) of [MovesCount v] with (length of [Moves15 v])
 else 
if <(argument_reporter_string_number) = (14)> then 
add (argument_reporter_string_number) to [Moves14 v]
add [0] to [Moves14Score v]
replace item (14) of [MovesCount v] with (length of [Moves14 v])
 else 
if <(argument_reporter_string_number) = (13)> then 
add (argument_reporter_string_number) to [Moves13 v]
add [0] to [Moves13Score v]
replace item (13) of [MovesCount v] with (length of [Moves13 v])
 else 
if <(argument_reporter_string_number) = (12)> then 
add (argument_reporter_string_number) to [Moves12 v]
add [] to [Moves12Score v]
replace item (12) of [MovesCount v] with (length of [Moves12 v])
 else 
if <(argument_reporter_string_number) = (11)> then 
add (argument_reporter_string_number) to [Moves11 v]
add [0] to [Moves11Score v]
replace item (11) of [MovesCount v] with (length of [Moves11 v])
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end
end

define GetPosScore %n %n
set [PosScoreRes v] to [0]
if <<(argument_reporter_string_number) > (0)> and <not <(argument_reporter_string_number) = (0)>>> then 
if <(argument_reporter_string_number) = (BlackPawn)> then 
if <(IsEndgame) = (0)> then 
if <(IsBlackCastlingPossible) = (1)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [PawnPieceSquarePreCastling v])
 else 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [PawnPieceSquare v])
end
 else 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [PawnPieceSquareEndgame v])
end
 else 
if <(argument_reporter_string_number) = (WhitePawn)> then 
if <(IsEndgame) = (0)> then 
if <(IsWhiteCastlingPossible) = (1)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [PawnPieceSquarePreCastling v]))
 else 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [PawnPieceSquare v]))
end
 else 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [PawnPieceSquareEndgame v]))
end
 else 
if <(IsEndgame) = (0)> then 
if <(argument_reporter_string_number) = (BlackBishop)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [BishopPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteBishop)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [BishopPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackKnight)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [KnightPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteKnight)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [KnightPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackQueen)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [QueenPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteQueen)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [QueenPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackRook)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [RookPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteRook)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [RookPieceSquare v]))
 else 
if <(argument_reporter_string_number) = (BlackKing)> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [KingPieceSquare v])
 else 
if <(argument_reporter_string_number) = (WhiteKing)> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [KingPieceSquare v]))
end
end
end
end
end
end
end
end
end
end
 else 
if <(argument_reporter_string_number) = (BlackKing)> then 
if <<(IsEndgame2) = (0)> or <<(BlackQueenCount) = (0)> and <(BlackMinorCount) = (0)>>> then 
set [PosScoreRes v] to (item ((65) - (argument_reporter_string_number)) of [KingPieceSquareEndgame v])
if <(IsEndgame2) = (1)> then 
set [PosScoreRes v] to ((PosScoreRes) * (4))
end
end
 else 
if <(argument_reporter_string_number) = (WhiteKing)> then 
if <<(IsEndgame2) = (0)> or <<(WhiteQueenCount) = (0)> and <(WhiteMinorCount) = (0)>>> then 
set [PosScoreRes v] to ((0) - (item (argument_reporter_string_number) of [KingPieceSquareEndgame v]))
if <(IsEndgame2) = (1)> then 
set [PosScoreRes v] to ((PosScoreRes) * (4))
end
end
end
end
end
end
end
end

define ClearBoardAttackedByMove %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
delete all of [BoardAttackedByBlack v]
delete all of [BoardAttackedByBlackPiece v]
repeat (64) 
add [0] to [BoardAttackedByBlack v]
add [0] to [BoardAttackedByBlackPiece v]
end
set [IsWhiteChecked v] to [0]
 else 
delete all of [BoardAttackedByWhite v]
delete all of [BoardAttackedByWhitePiece v]
repeat (64) 
add [0] to [BoardAttackedByWhite v]
add [0] to [BoardAttackedByWhitePiece v]
end
set [IsBlackChecked v] to [0]
end

define GetPosPieceHash %n %n
set [PosPieceHash v] to [0]
if <<(argument_reporter_string_number) > (0)> and <not <(argument_reporter_string_number) = (0)>>> then 
if <(argument_reporter_string_number) = (BlackPawn)> then 
set [PosPieceHash v] to (item ((64) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (WhitePawn)> then 
set [PosPieceHash v] to (item ((576) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (BlackBishop)> then 
set [PosPieceHash v] to (item (argument_reporter_string_number) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (WhiteBishop)> then 
set [PosPieceHash v] to (item ((384) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (BlackKnight)> then 
set [PosPieceHash v] to (item ((256) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (WhiteKnight)> then 
set [PosPieceHash v] to (item ((640) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (BlackQueen)> then 
set [PosPieceHash v] to (item ((128) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (WhiteQueen)> then 
set [PosPieceHash v] to (item ((448) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (BlackRook)> then 
set [PosPieceHash v] to (item ((320) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (WhiteRook)> then 
set [PosPieceHash v] to (item ((704) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (BlackKing)> then 
set [PosPieceHash v] to (item ((192) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
 else 
if <(argument_reporter_string_number) = (WhiteKing)> then 
set [PosPieceHash v] to (item ((512) + (argument_reporter_string_number)) of [PosPieceHashLookup v])
end
end
end
end
end
end
end
end
end
end
end
end
end

define TTProbeNode %s %s
set [TTProbeRes v] to [0]
set [TTProbeBestMoveRes v] to []
set [TTProbeNodeScoreRes v] to []
set [TTProbeDepthRes v] to []
set [TTProbeNodeTypeRes v] to []
set [TTProbeCheckedRes v] to []
set [TTProbeHorizonRes v] to []
set [CurrentIdx v] to [1]
set [HashBucket v] to (((argument_reporter_string_number) mod (length of [TTNodeHash v])) + (1))
repeat until <<(item (HashBucket) of [TTNodeHash v]) = (argument_reporter_string_number)> and <((item (HashBucket) of [TTNodeDepth v]) mod (2)) = ((argument_reporter_string_number) mod (2))>> 
change [HashBucket v] by (1)
if <(HashBucket) > (length of [TTNodeHash v])> then 
set [HashBucket v] to [1]
end
change [CurrentIdx v] by (1)
if <(CurrentIdx) > (10)> then 
stop [this script v]
end
end
set [TTProbeRes v] to [1]
set [TTProbeBestMoveRes v] to (item (HashBucket) of [TTNodeBestMove v])
set [TTProbeNodeScoreRes v] to (item (HashBucket) of [TTNodeScore v])
set [TTProbeDepthRes v] to (item (HashBucket) of [TTNodeDepth v])
set [TTProbeNodeTypeRes v] to (item (HashBucket) of [TTNodeType v])
set [TTProbeCheckedRes v] to (item (HashBucket) of [TTNodeChecked v])
set [TTProbeAgeRes v] to (item (HashBucket) of [TTNodeAge v])
set [TTProbeHorizonRes v] to (item (HashBucket) of [TTNodeHorizon v])
set [TTProbeBlackMobRes v] to (item (HashBucket) of [TTNodeBlackMobility v])
set [TTProbeWhiteMobRes v] to (item (HashBucket) of [TTNodeWhiteMobility v])
if <(1) = (1)> then 
replace item (HashBucket) of [TTNodeAge v] with [TTProbeCurrentAge]
end

define InitMobilityBonusLookup
delete (all) of [QueenMobilityBonus v]
delete (all) of [BishopMobilityBonus v]
delete (all) of [RookMobilityBonus v]
delete (all) of [KnightMobilityBonus v]
LoadList %s %s
LoadList %s %s
LoadList %s %s
LoadList %s %s

define ClearLog
delete (all) of [Logfile v]

define Log %s %s %s %s %s %s %s %s
add (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (join (argument_reporter_string_number) (argument_reporter_string_number)))))))) to [Logfile v]

define InitAlphaBeta %n %n %b
if <(argument_reporter_string_number) = (1)> then 
set [IsInNullMove v] to [0]
set [IsInReduction v] to [0]
set [IsMinMaxTimeout v] to [0]
if <not <argument_reporter_boolean>> then 
Profile_Reset
end
set [Idx v] to [1]
repeat (8) 
replace item (Idx) of [BlackPawnCount v] with [0]
replace item (Idx) of [WhitePawnCount v] with [0]
change [Idx v] by (1)
end
change [TTProbeCurrentAge v] by (1)
delete all of [BlackKingIdxs v]
delete all of [BlackRookIdxs v]
delete all of [BlackQueenIdxs v]
delete all of [WhiteKingIdxs v]
delete all of [WhiteRookIdxs v]
delete all of [WhiteQueenIdxs v]
set [CurrentMoveHash v] to [0]
set [Idx v] to [1]
repeat (64) 
if <(item (Idx) of [Board v]) = (WhitePawn)> then 
replace item (item (Idx) of [IdxToFile v]) of [WhitePawnCount v] with ((item (item (Idx) of [IdxToFile v]) of [WhitePawnCount v]) + (1))
 else 
if <(item (Idx) of [Board v]) = (BlackPawn)> then 
replace item (item (Idx) of [IdxToFile v]) of [BlackPawnCount v] with ((item (item (Idx) of [IdxToFile v]) of [BlackPawnCount v]) + (1))
 else 
if <(item (Idx) of [Board v]) = (WhiteKing)> then 
add [Idx] to [WhiteKingIdxs v]
 else 
if <(item (Idx) of [Board v]) = (BlackKing)> then 
add [Idx] to [BlackKingIdxs v]
 else 
if <(item (Idx) of [Board v]) = (WhiteQueen)> then 
add [Idx] to [WhiteQueenIdxs v]
 else 
if <(item (Idx) of [Board v]) = (BlackQueen)> then 
add [Idx] to [BlackQueenIdxs v]
 else 
if <(item (Idx) of [Board v]) = (WhiteRook)> then 
add [Idx] to [WhiteRookIdxs v]
 else 
if <(item (Idx) of [Board v]) = (BlackRook)> then 
add [Idx] to [BlackRookIdxs v]
end
end
end
end
end
end
end
end
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
change [Idx v] by (1)
end
delete (all) of [MinMaxPly1EvalMoves v]
set [BlackMinorCount v] to [0]
set [BlackQueenCount v] to [0]
set [WhiteQueenCount v] to [0]
set [WhiteMinorCount v] to [0]
set [Idx v] to [1]
repeat (64) 
if <(item (Idx) of [Board v]) = (WhiteQueen)> then 
change [WhiteQueenCount v] by (1)
end
if <(item (Idx) of [Board v]) = (BlackQueen)> then 
change [BlackQueenCount v] by (1)
end
if <<(item (Idx) of [Board v]) = (WhiteKnight)> or <<(item (Idx) of [Board v]) = (WhiteBishop)> or <(item (Idx) of [Board v]) = (WhiteRook)>>> then 
change [WhiteMinorCount v] by (1)
end
if <<(item (Idx) of [Board v]) = (BlackKnight)> or <<(item (Idx) of [Board v]) = (BlackBishop)> or <(item (Idx) of [Board v]) = (BlackRook)>>> then 
change [BlackMinorCount v] by (1)
end
change [Idx v] by (1)
end
set [IsEndgame v] to [0]
if <<(((WhiteQueenCount) * (9)) + ((WhiteMinorCount) * (4))) < (10)> or <(((BlackQueenCount) * (9)) + ((BlackMinorCount) * (4))) < (10)>> then 
set [IsEndgame v] to [1]
end
set [IsEndgame2 v] to [0]
if <<((WhiteQueenCount) + (WhiteMinorCount)) < (2)> or <((BlackQueenCount) + (BlackMinorCount)) < (2)>> then 
set [IsEndgame2 v] to [1]
end
if <<(HasBlackCastled) = (0)> and <<(HasBlackKingMoved) = (0)> and <<(HasBlackRookKSMoved) = (0)> or <(HasBlackRookQSMoved) = (0)>>>> then 
set [IsBlackCastlingPossible v] to [1]
 else 
set [IsBlackCastlingPossible v] to [0]
end
if <<(HasWhiteCastled) = (0)> and <<(HasWhiteKingMoved) = (0)> and <<(HasWhiteRookKSMoved) = (0)> or <(HasWhiteRookQSMoved) = (0)>>>> then 
set [IsWhiteCastlingPossible v] to [1]
 else 
set [IsWhiteCastlingPossible v] to [0]
end
Log %s %s %s %s %s %s %s %s
InitMovePosLookup
if <not <argument_reporter_boolean>> then 
Log %s %s %s %s %s %s %s %s
end
end

define InitKingSquareEndgame
delete (all) of [KingPieceSquareEndgame v]
LoadList %s %s

define IsLowerCase %s
set [Chars v] to []
set [CharsIdx v] to [1]
repeat (length of [CharsUpperCase]) 
if <(letter (CharsIdx) of [CharsUpperCase]) = (argument_reporter_string_number)> then 
set [Chars v] to (join [Chars] (argument_reporter_string_number))
 else 
set [Chars v] to (join [Chars] (letter (CharsIdx) of [CharsUpperCase]))
end
change [CharsIdx v] by (1)
end
switch costume to (1 v)
switch costume to (3 v)
if <(costume [number v] ::looks) = (1)> then 
set [IsLowerCaseRes v] to [0]
 else 
set [IsLowerCaseRes v] to [1]
end

define ImportBoardInternal %s
ImportBoardImpl %s
AddBoardToHistory
DrawBoardAndWait
set [IsGameSuspended v] to [0]

when i receive [import v]
ask [Please paste FEN data or GoK data into the text field for import from your clipboard via Ctrl-V] and wait
if <(length of (answer)) > (0)> then 
ImportBoard %s
end

when i receive [export v]
ExportBoardFEN
delete (all) of [ExportData v]
add [ExportDataFEN] to [ExportData v]
add [ExportDataFENLichess] to [ExportData v]
add (item (last) of [BoardHistory v]) to [ExportData v]
show list [ExportData v]
SayAsync %s %n

define InitPawnSquareEndgame
delete (all) of [PawnPieceSquareEndgame v]
LoadList %s %s

define ExportMovesPGN
set [ExportMovesPGN v] to []
set [Idx v] to [1]
repeat (length of [GameMovesAN v]) 
if <((Idx) mod (2)) = (1)> then 
set [ExportMovesPGN v] to (join [ExportMovesPGN] (join ((((Idx) - (1)) / (2)) + (1)) [. ]))
end
set [ExportMovesPGN v] to (join [ExportMovesPGN] (join (item (Idx) of [GameMovesAN v]) [ ]))
change [Idx v] by (1)
end

define UndoMove
if <<(length of [GameMovesAN v]) > (1)> and <(IsInUndo) = (0)>> then 
set [IsInUndo v] to [1]
UndoPrevMove
UndoPrevMove
DrawBoardAndWait
set [IsGameSuspended v] to [0]
set [IsInUndo v] to [0]
end

when i receive [showmoves v]
ExportMovesPGN
delete (all) of [ExportMoves v]
add [ExportMovesPGN] to [ExportMoves v]
show list [ExportMoves v]
SayAsync %s %n

define FillBoard
delete (all) of [VirtualBoard v]
set [Idx v] to [1]
repeat (64) 
if <(IsPlayerBlack) = (0)> then 
add [Idx] to [VirtualBoard v]
 else 
add ((((item (Idx) of [IdxToRank v]) - (1)) * (8)) + ((9) - (item (Idx) of [IdxToFile v]))) to [VirtualBoard v]
end
change [Idx v] by (1)
end
delete (all) of [Board v]
repeat (64) 
add [Empty] to [Board v]
end
replace item (item (1) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (2) of [VirtualBoard v]) of [Board v] with [BlackKnight]
replace item (item (3) of [VirtualBoard v]) of [Board v] with [BlackBishop]
replace item (item (4) of [VirtualBoard v]) of [Board v] with [BlackQueen]
replace item (item (5) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (6) of [VirtualBoard v]) of [Board v] with [BlackBishop]
replace item (item (7) of [VirtualBoard v]) of [Board v] with [BlackKnight]
replace item (item (8) of [VirtualBoard v]) of [Board v] with [BlackRook]
set [Idx v] to [9]
repeat (8) 
replace item (item (Idx) of [VirtualBoard v]) of [Board v] with [BlackPawn]
change [Idx v] by (1)
end
set [Idx v] to [49]
repeat (8) 
replace item (item (Idx) of [VirtualBoard v]) of [Board v] with [WhitePawn]
change [Idx v] by (1)
end
replace item (item (57) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (58) of [VirtualBoard v]) of [Board v] with [WhiteKnight]
replace item (item (59) of [VirtualBoard v]) of [Board v] with [WhiteBishop]
replace item (item (60) of [VirtualBoard v]) of [Board v] with [WhiteQueen]
replace item (item (61) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (62) of [VirtualBoard v]) of [Board v] with [WhiteBishop]
replace item (item (63) of [VirtualBoard v]) of [Board v] with [WhiteKnight]
replace item (item (64) of [VirtualBoard v]) of [Board v] with [WhiteRook]

when i receive [undo v]
UndoMove
say []

define GetVirtualMove %n
if <(IsPlayerBlack) = (0)> then 
set [VirtualMove v] to (argument_reporter_string_number)
 else 
if <<not <(argument_reporter_string_number) < (0100)>> and <not <(argument_reporter_string_number) > (6499)>>> then 
set [VirtualMove v] to ((65) - ([floor v] of ((argument_reporter_string_number) mod (100)) ::operators))
repeat until <(length of [VirtualMove]) > (1)> 
set [VirtualMove v] to (join [0] [VirtualMove])
end
set [VirtualMove v] to (join ((65) - ([floor v] of ((argument_reporter_string_number) / (100)) ::operators)) [VirtualMove])
repeat until <(length of [VirtualMove]) > (3)> 
set [VirtualMove v] to (join [0] [VirtualMove])
end
if <(letter (5) of (argument_reporter_string_number)) = (.)> then 
set [VirtualMove v] to (join [VirtualMove] (join (letter (5) of (argument_reporter_string_number)) (letter (6) of (argument_reporter_string_number))))
end
 else 
if <(argument_reporter_string_number) = (BlackKingsideCastling)> then 
set [VirtualMove v] to [WhiteKingsideCastling]
 else 
if <(argument_reporter_string_number) = (BlackQueensideCastling)> then 
set [VirtualMove v] to [WhiteQueensideCastling]
 else 
if <(argument_reporter_string_number) = (WhiteKingsideCastling)> then 
set [VirtualMove v] to [BlackKingsideCastling]
 else 
if <(argument_reporter_string_number) = (WhiteQueensideCastling)> then 
set [VirtualMove v] to [BlackQueensideCastling]
end
end
end
end
end
end

define TTStoreNode %s %s %s %s %s %s %s %s %s
if <(argument_reporter_string_number) = (0)> then 
stop [this script v]
end
set [HashBucket v] to (((argument_reporter_string_number) mod (length of [TTNodeHash v])) + (1))
set [CurrentIdx v] to [1]
repeat until <<<(length of (item (HashBucket) of [TTNodeHash v])) = (0)> or <<(item (HashBucket) of [TTNodeHash v]) = (argument_reporter_string_number)> and <((item (HashBucket) of [TTNodeDepth v]) mod (2)) = ((argument_reporter_string_number) mod (2))>>> or <(item (HashBucket) of [TTNodeAge v]) < ((TTProbeCurrentAge) - (2))>> 
change [HashBucket v] by (1)
if <(HashBucket) > (length of [TTNodeHash v])> then 
set [HashBucket v] to [1]
end
change [CurrentIdx v] by (1)
if <(CurrentIdx) > (10)> then 
stop [this script v]
end
end
replace item (HashBucket) of [TTNodeAge v] with [TTProbeCurrentAge]
if <<(argument_reporter_string_number) = (item (HashBucket) of [TTNodeHash v])> and <((argument_reporter_string_number) mod (2)) = ((item (HashBucket) of [TTNodeDepth v]) mod (2))>> then 
if <not <(argument_reporter_string_number) = (1)>> then 
if <(argument_reporter_string_number) < (item (HashBucket) of [TTNodeHorizon v])> then 
stop [this script v]
end
if <(argument_reporter_string_number) = (item (HashBucket) of [TTNodeHorizon v])> then 
if <<not <(argument_reporter_string_number) = (E)>> and <(item (HashBucket) of [TTNodeType v]) = (E)>> then 
stop [this script v]
end
end
if <<(argument_reporter_string_number) = ()> and <not <(item (HashBucket) of [TTNodeBestMove v]) = ()>>> then 
stop [this script v]
end
end
end
replace item (HashBucket) of [TTNodeHash v] with (argument_reporter_string_number)
replace item (HashBucket) of [TTNodeDepth v] with (argument_reporter_string_number)
replace item (HashBucket) of [TTNodeScore v] with (argument_reporter_string_number)
replace item (HashBucket) of [TTNodeType v] with (argument_reporter_string_number)
replace item (HashBucket) of [TTNodeChecked v] with (argument_reporter_string_number)
replace item (HashBucket) of [TTNodeHorizon v] with (argument_reporter_string_number)
replace item (HashBucket) of [TTNodeBestMove v] with (argument_reporter_string_number)
replace item (HashBucket) of [TTNodeBlackMobility v] with (argument_reporter_string_number)
replace item (HashBucket) of [TTNodeWhiteMobility v] with (argument_reporter_string_number)

define ExecuteInit
set [ExecutionDepth v] to [0]
set [IsExecutionRunning v] to [0]
EnterExecution
if <(IsPlayerBlack) = (1)> then 
ExecuteEngineMove
end
ExecuteMovePostProcess
ExitExecution

define ExecuteEngineMove
EnterExecution
if <(IsGameSuspended) = (0)> then 
delete (all) of [BestMoves v]
CalculateOpeningMoves
set [BestMove v] to (item (pick random (1) to (length of [BestMoves v])) of [BestMoves v])
IsValidMove %n
if <(ValidMoveRes) = (0)> then 
think [Thinking...]
wait (0) seconds
InitAlphaBeta %n %n %b
if <(IsModeJunior) = (0)> then 
if <(Level) = (1)> then 
set [ThinkTimeLimit v] to [5]
 else 
if <(Level) = (2)> then 
set [ThinkTimeLimit v] to [15]
 else 
if <(IsModeCompetition) = (0)> then 
if <(IsEndgame) = (0)> then 
set [ThinkTimeLimit v] to [30]
 else 
set [ThinkTimeLimit v] to [20]
end
 else 
set [ThinkTimeLimit v] to [60]
end
end
end
set [ThinkTimeStart v] to (timer)
set [IsDeepeningDone v] to [0]
set [IdxDeepening v] to [2]
set [BestMove v] to []
set [BestMinMaxRes v] to []
repeat until <(IsDeepeningDone) = (1)> 
set [IsDone v] to [0]
set [QuiescenceDepth v] to ((20) - (IdxDeepening))
if <(IdxDeepening) > (2)> then 
set [ThinkTimeLimitMinMax v] to [ThinkTimeLimit]
 else 
set [ThinkTimeLimitMinMax v] to [60]
end
if <<<(IsScratch3) = (1)> and <(IdxDeepening) > (99)>> or <<(IsScratch3) = (0)> and <(IdxDeepening) > (99)>>> then 
if <(IsScratch3) = (1)> then 
if <((IdxDeepening) mod (2)) = (0)> then 
set [PruningAlphaWindow v] to [75]
set [PruningBetaWindow v] to [25]
 else 
set [PruningAlphaWindow v] to [25]
set [PruningBetaWindow v] to [75]
end
 else 
if <((IdxDeepening) mod (2)) = (0)> then 
set [PruningAlphaWindow v] to [60]
set [PruningBetaWindow v] to [20]
 else 
set [PruningAlphaWindow v] to [20]
set [PruningBetaWindow v] to [60]
end
end
repeat until <<(IsDone) = (1)> or <(IsMinMaxTimeout) = (1)>> 
set [PruningAlpha v] to ((BestMinMaxRes) - (PruningAlphaWindow))
set [PruningBeta v] to ((BestMinMaxRes) + (PruningBetaWindow))
delete (all) of [BestMoves v]
AlphaBetaMinMax %n %n %n %n %b %b %n %b
if <not <(item (1) of [MinMaxResults v]) > (PruningAlpha)>> then 
change [TTProbeCurrentAge v] by (-1)
set [PruningAlphaWindow v] to [100000]
 else 
if <not <(item (1) of [MinMaxResults v]) < (PruningBeta)>> then 
change [TTProbeCurrentAge v] by (-1)
set [PruningBetaWindow v] to [100000]
 else 
set [IsDone v] to [1]
end
end
end
 else 
delete (all) of [BestMoves v]
AlphaBetaMinMax %n %n %n %n %b %b %n %b
set [IsDone v] to [1]
end
if <(IsDone) = (1)> then 
if <<(length of [BestMoves v]) > (0)> and <(length of (item (1) of [BestMoves v])) > (0)>> then 
if <<(BestMove) = ()> or <[MinMaxPly1EvalMoves v] contains [BestMove] ? ::lists>> then 
set [BestMove v] to (item (1) of [BestMoves v])
set [BestMinMaxRes v] to (item (1) of [BestMinMaxResults v])
end
end
if <not <(BestMove) = ()>> then 
if <(1) = (0)> then 
GetCurrentMoveHash
TTStoreNode %s %s %s %s %s %s %s %s %s
end
end
end
if <<(IsMinMaxTimeout) = (1)> or <<<(BestMinMaxRes) > ((BlackKing) / (2))> or <(BestMinMaxRes) < ((WhiteKing) / (2))>> or <(IdxDeepening) = (20)>>> then 
set [IsDeepeningDone v] to [1]
 else 
change [IdxDeepening v] by (1)
end
end
 else 
delete (all) of [BestMoves v]
if <(Level) = (1)> then 
set [JuniorDistQuota v] to [10]
set [JuniorSearchQuota v] to [0]
 else 
if <(Level) = (2)> then 
set [JuniorDistQuota v] to [5]
set [JuniorSearchQuota v] to [50]
 else 
set [JuniorDistQuota v] to [1]
set [JuniorSearchQuota v] to [100]
end
end
set [ThinkTimeStart v] to (timer)
set [ThinkTimeLimitMinMax v] to [2]
if <(Level) < (3)> then 
AlphaBetaMinMax %n %n %n %n %b %b %n %b
 else 
AlphaBetaMinMax %n %n %n %n %b %b %n %b
end
set [BestMove v] to (item (1) of [BestMoves v])
if <<(BestMove) = ()> or <(pick random (1) to (100)) > (JuniorSearchQuota)>> then 
CalculateMoves %n
CutoffReorder %n %b
replace item (1) of [MovesIdx v] with (pick random (1) to ([ceiling v] of ((length of [Moves1 v]) * ((JuniorDistQuota) / (100))) ::operators))
ApplyMove %n
CalcBoardAttackedByMove %n
RevertMove %n
repeat until <(IsBlackChecked) = (0)> 
replace item (1) of [MovesIdx v] with (pick random (1) to (length of [Moves1 v]))
ApplyMove %n
CalcBoardAttackedByMove %n
RevertMove %n
end
set [BestMove v] to (item (item (1) of [MovesIdx v]) of [Moves1 v])
end
end
end
broadcast (1 v) and wait
OnProgressChanged %n
wait (0) seconds
IsValidMove %n
if <(ValidMoveRes) = (0)> then 
say (join [Internal Error: No valid move found. Sorry, this should not happen. Maybe you cleared lookup lists in the editor? If you are running a normal game, please export board data and report bug via project comment] (join [ Move: ] [BestMove])) for (10) seconds
broadcast (1 v)
set [IsGameSuspended v] to [1]
ExecuteMovePostProcess
ExitExecution
stop [this script v]
end
think []
GetMoveNotation %n
set [BestMoveAN v] to [MoveNotationRes]
set [GameMoves v] to (join [GameMoves] [BestMove])
set [MovePieceFromIdx v] to ([floor v] of ((BestMove) / (100)) ::operators)
set [MovePieceToIdx v] to ([floor v] of ((BestMove) mod (100)) ::operators)
if <<<(BestMove) = (BlackQueensideCastling)> or <(BestMove) = (BlackKingsideCastling)>> or <<(BestMove) = (WhiteQueensideCastling)> or <(BestMove) = (WhiteKingsideCastling)>>> then 
set [MovePieceSpecial v] to [BestMove]
 else 
set [MovePieceSpecial v] to []
end
wait (0) seconds
broadcast (1 v) and wait
broadcast (1 v)
delete (all) of [Moves1 v]
add [BestMove] to [Moves1 v]
replace item (1) of [MovesIdx v] with [1]
replace item (1) of [MovesCount v] with [1]
ApplyMove %n
DrawBoardAndWait
AddBoardToHistory
add [BestMoveAN] to [GameMovesAN v]
GetRepetitionCount
if <(RepetitionCountRes) > (2)> then 
say [Draw!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
IsTwoKingDraw
if <(TwoKingDrawRes) = (1)> then 
say [Draw!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
IsWhiteKingCheckMate
if <(IsWhiteKingCheckMateRes) = (1)> then 
say [Checkmate!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
IsDraw %n
if <(IsDrawRes) = (1)> then 
say [Draw!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
SayAsync %s %n
broadcast (1 v)
end
if <(item ((BestMove) mod (100)) of [Board v]) = (BlackKing)> then 
set [HasBlackKingMoved v] to [1]
end
if <(item ((BestMove) mod (100)) of [Board v]) = (BlackRook)> then 
if <([floor v] of ((BestMove) / (100)) ::operators) = (item (1) of [VirtualBoard v])> then 
set [HasBlackRookQSMoved v] to [1]
end
if <([floor v] of ((BestMove) / (100)) ::operators) = (item (8) of [VirtualBoard v])> then 
set [HasBlackRookKSMoved v] to [1]
end
end
if <<(BestMove) = (BlackQueensideCastling)> or <(BestMove) = (BlackKingsideCastling)>> then 
set [HasBlackKingMoved v] to [1]
set [HasBlackCastled v] to [1]
end
end
end
end
end
end
ExecuteMovePostProcess
ExitExecution

define ExecuteMovePostProcess
set [MoveFromIdx v] to [-1]
set [MoveToIdx v] to [-1]
set [FromSquareIdx v] to [-1]
set [ToSquareIdx v] to [-1]
broadcast (1 v) and wait
broadcast (1 v) and wait
broadcast (1 v) and wait

when i receive [usermove v]
ExecuteUserMove

when i receive [startgame v]
set [MoveFromIdx v] to [-1]
set [MoveToIdx v] to [-1]
go to x: (240) y: (80)
InitBoard
DrawBoardAndWait
ExecuteInit
if <(IsFlash30Bug) = (0)> then 
SayAsync %s %n
 else 
SayAsync %s %n
end

define ExecuteUserMove
EnterExecution
if <(IsGameSuspended) = (0)> then 
if <<(item (MoveFromIdx) of [Board v]) < (0)> and <not <(MoveFromIdx) = (MoveToIdx)>>> then 
set [UserMove v] to []
if <<(item (MoveFromIdx) of [Board v]) = (WhiteKing)> and <(MoveFromIdx) = (item (61) of [VirtualBoard v])>> then 
if <<(MoveToIdx) = (item (59) of [VirtualBoard v])> and <(item (item (57) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> then 
CalculateMoves %n
if <[Moves2 v] contains [WhiteQueensideCastling] ? ::lists> then 
set [UserMove v] to [WhiteQueensideCastling]
 else 
set [UserMove v] to [6159]
end
end
if <<(MoveToIdx) = (item (63) of [VirtualBoard v])> and <(item (item (64) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>> then 
CalculateMoves %n
if <[Moves2 v] contains [WhiteKingsideCastling] ? ::lists> then 
set [UserMove v] to [WhiteKingsideCastling]
 else 
set [UserMove v] to [6163]
end
end
end
if <(UserMove) = ()> then 
set [UserMove v] to (((MoveFromIdx) * (100)) + (MoveToIdx))
if <(length of [UserMove]) = (3)> then 
set [UserMove v] to (join [0] [UserMove])
end
if <<(item (MoveFromIdx) of [Board v]) = (WhitePawn)> and <(MoveFromIdx) < (17)>> then 
set [UserMove v] to (join [UserMove] [.1])
end
end
set [MovePieceFromIdx v] to [MoveFromIdx]
set [MovePieceToIdx v] to [MoveToIdx]
if <<<(UserMove) = (BlackQueensideCastling)> or <(UserMove) = (BlackKingsideCastling)>> or <<(UserMove) = (WhiteQueensideCastling)> or <(UserMove) = (WhiteKingsideCastling)>>> then 
set [MovePieceSpecial v] to [UserMove]
 else 
set [MovePieceSpecial v] to []
end
broadcast (1 v) and wait
broadcast (1 v)
set [FromSquareIdx v] to [-1]
set [ToSquareIdx v] to [-1]
broadcast (1 v) and wait
broadcast (1 v) and wait
CalculateMoves %n
if <not <[Moves2 v] contains [UserMove] ? ::lists>> then 
delete (all) of [Moves2 v]
add [UserMove] to [Moves2 v]
replace item (2) of [MovesIdx v] with [1]
replace item (2) of [MovesCount v] with [1]
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
SayAsync %s %n
broadcast (1 v)
 else 
SayAsync %s %n
broadcast (1 v)
end
RevertMove %n
DrawBoardAndWait
 else 
if <not <(UserMove) = ([floor v] of (UserMove) ::operators)>> then 
say [Please select promotion piece]
broadcast (1 v) and wait
broadcast (1 v) and wait
broadcast (1 v) and wait
say []
if <(SelectedPromotionPiece) = (WhiteQueen)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.1])
 else 
if <(SelectedPromotionPiece) = (WhiteRook)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.2])
 else 
if <(SelectedPromotionPiece) = (WhiteBishop)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.3])
 else 
if <(SelectedPromotionPiece) = (WhiteKnight)> then 
set [UserMove v] to (join ([floor v] of (UserMove) ::operators) [.4])
end
end
end
end
repeat until <(length of [UserMove]) > (5)> 
set [UserMove v] to (join [0] [UserMove])
end
end
GetMoveNotation %n
delete (all) of [Moves2 v]
add [UserMove] to [Moves2 v]
replace item (2) of [MovesIdx v] with [1]
replace item (2) of [MovesCount v] with [1]
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
RevertMove %n
DrawBoardAndWait
SayAsync %s %n
broadcast (1 v)
 else 
think [Thinking...]
DrawBoardAndWait
wait (0) seconds
broadcast (1 v) and wait
set [UserMoveAN v] to [MoveNotationRes]
add [UserMoveAN] to [GameMovesAN v]
set [GameMoves v] to (join [GameMoves] [UserMove])
AddBoardToHistory
IsBlackKingCheckMate
if <(IsBlackKingCheckMateRes) = (1)> then 
say [Checkmate!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
IsDraw %n
if <(IsDrawRes) = (1)> then 
say [Draw!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
GetRepetitionCount
if <(RepetitionCountRes) > (2)> then 
say [Draw!]
broadcast (1 v)
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
IsTwoKingDraw
if <(TwoKingDrawRes) = (1)> then 
say [Draw!]
broadcast (1 v)
set [IsGameSuspended v] to [1]
 else 
if <(item ((UserMove) mod (100)) of [Board v]) = (WhiteKing)> then 
set [HasWhiteKingMoved v] to [1]
end
if <(item ((UserMove) mod (100)) of [Board v]) = (WhiteRook)> then 
if <([floor v] of ((UserMove) / (100)) ::operators) = (item (57) of [VirtualBoard v])> then 
set [HasWhiteRookQSMoved v] to [1]
end
if <([floor v] of ((UserMove) / (100)) ::operators) = (item (64) of [VirtualBoard v])> then 
set [HasWhiteRookKSMoved v] to [1]
end
end
if <<(UserMove) = (WhiteQueensideCastling)> or <(UserMove) = (WhiteKingsideCastling)>> then 
set [HasWhiteCastled v] to [1]
set [HasWhiteKingMoved v] to [1]
end
ExecuteEngineMove
end
end
end
end
end
end
end
end
ExecuteMovePostProcess
ExitExecution

when i receive [sayasyncmsg v]
say [SayAsyncText] for (SayAsyncDuration) seconds

define SayAsync %s %n
set [SayAsyncText v] to (argument_reporter_string_number)
set [SayAsyncDuration v] to (argument_reporter_string_number)
broadcast (1 v)

define EnterExecution
change [ExecutionDepth v] by (1)
if <(ExecutionDepth) > (0)> then 
set [IsExecutionRunning v] to [1]
end

define ExitExecution
change [ExecutionDepth v] by (-1)
if <not <(ExecutionDepth) > (0)>> then 
set [IsExecutionRunning v] to [0]
end

when i receive [levelchanged v]
if <<(Level) = (3)> and <(IsModeJunior) = (0)>> then 
SayAsync %s %n
 else 
say []
end

define ExportBoardFEN
set [ExportDataFEN v] to []
set [ExportDataFENLichess v] to [https://lichess.org/analysis/]
set [Idx v] to [1]
repeat until <(Idx) > (64)> 
if <(IsPlayerBlack) = (0)> then 
set [CurrentPiece v] to (item (Idx) of [Board v])
 else 
set [CurrentPiece v] to ((0) - (item ((65) - (Idx)) of [Board v]))
end
if <(CurrentPiece) = (BlackPawn)> then 
set [CurrentValue v] to [p]
end
if <(CurrentPiece) = (BlackKnight)> then 
set [CurrentValue v] to [n]
end
if <(CurrentPiece) = (BlackBishop)> then 
set [CurrentValue v] to [b]
end
if <(CurrentPiece) = (BlackRook)> then 
set [CurrentValue v] to [r]
end
if <(CurrentPiece) = (BlackQueen)> then 
set [CurrentValue v] to [q]
end
if <(CurrentPiece) = (BlackKing)> then 
set [CurrentValue v] to [k]
end
if <(CurrentPiece) = (WhitePawn)> then 
set [CurrentValue v] to [P]
end
if <(CurrentPiece) = (WhiteKnight)> then 
set [CurrentValue v] to [N]
end
if <(CurrentPiece) = (WhiteBishop)> then 
set [CurrentValue v] to [B]
end
if <(CurrentPiece) = (WhiteRook)> then 
set [CurrentValue v] to [R]
end
if <(CurrentPiece) = (WhiteQueen)> then 
set [CurrentValue v] to [Q]
end
if <(CurrentPiece) = (WhiteKing)> then 
set [CurrentValue v] to [K]
end
if <(CurrentPiece) = (Empty)> then 
set [IdxSub v] to [Idx]
repeat until <<((IdxSub) mod (8)) = (0)> or <<<(IsPlayerBlack) = (0)> and <not <(item ((IdxSub) + (1)) of [Board v]) = (Empty)>>> or <<(IsPlayerBlack) = (1)> and <not <(item ((65) - ((IdxSub) + (1))) of [Board v]) = (Empty)>>>>> 
change [IdxSub v] by (1)
end
set [CurrentValue v] to (((IdxSub) - (Idx)) + (1))
change [Idx v] by ((IdxSub) - (Idx))
end
set [ExportDataFEN v] to (join [ExportDataFEN] [CurrentValue])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [CurrentValue])
if <<((Idx) mod (8)) = (0)> and <(Idx) < (64)>> then 
set [ExportDataFEN v] to (join [ExportDataFEN] [/])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [/])
end
change [Idx v] by (1)
end
if <(IsPlayerBlack) = (0)> then 
set [ExportDataFEN v] to (join [ExportDataFEN] [ w])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [_w])
 else 
set [ExportDataFEN v] to (join [ExportDataFEN] [ b])
set [ExportDataFENLichess v] to (join [ExportDataFENLichess] [_b])
end

define IsValidMove %n
set [ValidMoveRes v] to [1]
if <<<(argument_reporter_string_number) < (0)> or <(argument_reporter_string_number) > (9999)>> or <<<([floor v] of ((argument_reporter_string_number) / (100)) ::operators) = (0)> or <([floor v] of ((argument_reporter_string_number) mod (100)) ::operators) = (0)>> and <not <<<(argument_reporter_string_number) = (BlackQueensideCastling)> or <(argument_reporter_string_number) = (BlackKingsideCastling)>> or <<(argument_reporter_string_number) = (WhiteQueensideCastling)> or <(argument_reporter_string_number) = (WhiteKingsideCastling)>>>>>> then 
set [ValidMoveRes v] to [0]
end

define IsBlackKingCheckMate
set [IsBlackKingCheckMateRes v] to [0]
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (1)> then 
set [IsBlackKingCheckMateRes v] to [1]
CalculateMoves %n
replace item (1) of [MovesIdx v] with [1]
repeat (item (1) of [MovesCount v]) 
if <(IsBlackKingCheckMateRes) = (1)> then 
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (0)> then 
set [IsBlackKingCheckMateRes v] to [0]
end
RevertMove %n
end
replace item (1) of [MovesIdx v] with ((item (1) of [MovesIdx v]) + (1))
end
end

define IsWhiteKingCheckMate
set [IsWhiteKingCheckMateRes v] to [0]
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
set [IsWhiteKingCheckMateRes v] to [1]
CalculateMoves %n
replace item (2) of [MovesIdx v] with [1]
repeat (item (2) of [MovesCount v]) 
if <(IsWhiteKingCheckMateRes) = (1)> then 
ApplyMove %n
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (0)> then 
set [IsWhiteKingCheckMateRes v] to [0]
end
RevertMove %n
end
replace item (2) of [MovesIdx v] with ((item (2) of [MovesIdx v]) + (1))
end
end

define CalculateMovesImpl %n %b %b
if <argument_reporter_boolean> then 
Profile_MethodEnter %n
 else 
if <argument_reporter_boolean> then 
Profile_MethodEnter %n
 else 
Profile_MethodEnter %n
end
end
ClearMoveList %n
set [SourceIdxOuter v] to [1]
if <(argument_reporter_string_number) = (1)> then 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with [0]
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with [0]
 else 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with (item ((argument_reporter_string_number) - (1)) of [BlackMobBonus v])
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with (item ((argument_reporter_string_number) - (1)) of [WhiteMobBonus v])
end
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with [0]
 else 
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with [0]
end
end
repeat (64) 
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
replace item (SourceIdxOuter) of [PieceMobility v] with [0]
end
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(item (SourceIdxOuter) of [Board v]) > (0)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(item (SourceIdxOuter) of [Board v]) < (0)>>> then 
CalculateMovesForSource %n %n %b %b
end
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
set [CurrentPiece v] to (item (SourceIdxOuter) of [Board v])
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(CurrentPiece) = (BlackRook)> then 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with ((item (argument_reporter_string_number) of [BlackMobBonus v]) + (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [RookMobilityBonus v]))
 else 
if <(CurrentPiece) = (BlackQueen)> then 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with ((item (argument_reporter_string_number) of [BlackMobBonus v]) + (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [QueenMobilityBonus v]))
 else 
if <(CurrentPiece) = (BlackBishop)> then 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with ((item (argument_reporter_string_number) of [BlackMobBonus v]) + (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [BishopMobilityBonus v]))
 else 
if <(CurrentPiece) = (BlackKnight)> then 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with ((item (argument_reporter_string_number) of [BlackMobBonus v]) + (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [KnightMobilityBonus v]))
 else 
if <(CurrentPiece) = (BlackKing)> then 
if <<(IsEndgame2) = (1)> and <<(BlackQueenCount) = (0)> and <(BlackMinorCount) = (0)>>> then 
replace item (argument_reporter_string_number) of [BlackMobBonus v] with ((item (argument_reporter_string_number) of [BlackMobBonus v]) + ((item (SourceIdxOuter) of [PieceMobility v]) * (10)))
end
end
end
end
end
end
end
if <((argument_reporter_string_number) mod (2)) = (0)> then 
if <(CurrentPiece) = (WhiteRook)> then 
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with ((item (argument_reporter_string_number) of [WhiteMobBonus v]) + (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [RookMobilityBonus v]))
 else 
if <(CurrentPiece) = (WhiteQueen)> then 
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with ((item (argument_reporter_string_number) of [WhiteMobBonus v]) + (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [QueenMobilityBonus v]))
 else 
if <(CurrentPiece) = (WhiteBishop)> then 
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with ((item (argument_reporter_string_number) of [WhiteMobBonus v]) + (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [BishopMobilityBonus v]))
 else 
if <(CurrentPiece) = (WhiteKnight)> then 
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with ((item (argument_reporter_string_number) of [WhiteMobBonus v]) + (item ((item (SourceIdxOuter) of [PieceMobility v]) + (1)) of [KnightMobilityBonus v]))
 else 
if <(CurrentPiece) = (WhiteKing)> then 
if <<(IsEndgame2) = (1)> and <<(WhiteQueenCount) = (0)> and <(WhiteMinorCount) = (0)>>> then 
replace item (argument_reporter_string_number) of [WhiteMobBonus v] with ((item (argument_reporter_string_number) of [WhiteMobBonus v]) + ((item (SourceIdxOuter) of [PieceMobility v]) * (10)))
end
end
end
end
end
end
end
end
change [SourceIdxOuter v] by (1)
end
if <<not <argument_reporter_boolean>> and <not <argument_reporter_boolean>>> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <<(HasBlackKingMoved) = (0)> and <(HasBlackCastled) = (0)>> then 
if <<<<(item (item (1) of [VirtualBoard v]) of [Board v]) = (BlackRook)> and <(item (item (2) of [VirtualBoard v]) of [Board v]) = (Empty)>> and <<(item (item (3) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (4) of [VirtualBoard v]) of [Board v]) = (Empty)>>> and <(item (item (5) of [VirtualBoard v]) of [Board v]) = (BlackKing)>> then 
if <<(item (item (3) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <<(item (item (4) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <(item (item (5) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)>>> then 
if <(HasBlackRookQSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
if <<<(item (item (5) of [VirtualBoard v]) of [Board v]) = (BlackKing)> and <(item (item (6) of [VirtualBoard v]) of [Board v]) = (Empty)>> and <<(item (item (7) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (8) of [VirtualBoard v]) of [Board v]) = (BlackRook)>>> then 
if <<(item (item (5) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <<(item (item (6) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)> and <(item (item (7) of [VirtualBoard v]) of [BoardAttackedByWhite v]) = (0)>>> then 
if <(HasBlackRookKSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
end
 else 
if <<(HasWhiteKingMoved) = (0)> and <(HasWhiteCastled) = (0)>> then 
if <<<(item (item (57) of [VirtualBoard v]) of [Board v]) = (WhiteRook)> and <(item (item (58) of [VirtualBoard v]) of [Board v]) = (Empty)>> and <<(item (item (59) of [VirtualBoard v]) of [Board v]) = (Empty)> and <<(item (item (60) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (61) of [VirtualBoard v]) of [Board v]) = (WhiteKing)>>>> then 
if <<(item (item (59) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <<(item (item (60) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <(item (item (61) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)>>> then 
if <(HasWhiteRookQSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
if <<<(item (item (62) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (61) of [VirtualBoard v]) of [Board v]) = (WhiteKing)>> and <<(item (item (63) of [VirtualBoard v]) of [Board v]) = (Empty)> and <(item (item (64) of [VirtualBoard v]) of [Board v]) = (WhiteRook)>>> then 
if <<(item (item (61) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <<(item (item (62) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)> and <(item (item (63) of [VirtualBoard v]) of [BoardAttackedByBlack v]) = (0)>>> then 
if <(HasWhiteRookKSMoved) = (0)> then 
AddSpecialMove %s %n
end
end
end
end
end
end
if <not <argument_reporter_boolean>> then 
if <(argument_reporter_string_number) < (6)> then 
if <(argument_reporter_string_number) = (5)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves5 v])
 else 
if <(argument_reporter_string_number) = (4)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves4 v])
 else 
if <(argument_reporter_string_number) = (3)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves3 v])
 else 
if <(argument_reporter_string_number) = (2)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves2 v])
 else 
if <(argument_reporter_string_number) = (1)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves1 v])
end
end
end
end
end
 else 
if <(argument_reporter_string_number) = (6)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves6 v])
 else 
if <(argument_reporter_string_number) = (7)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves7 v])
 else 
if <(argument_reporter_string_number) = (8)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves8 v])
 else 
if <(argument_reporter_string_number) = (9)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves9 v])
 else 
if <(argument_reporter_string_number) = (10)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves10 v])
 else 
if <(argument_reporter_string_number) = (11)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves11 v])
end
if <(argument_reporter_string_number) = (12)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves12 v])
end
if <(argument_reporter_string_number) = (13)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves13 v])
end
if <(argument_reporter_string_number) = (14)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves14 v])
end
if <(argument_reporter_string_number) = (15)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves15 v])
end
if <(argument_reporter_string_number) = (16)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves16 v])
end
if <(argument_reporter_string_number) = (17)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves17 v])
end
if <(argument_reporter_string_number) = (18)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves18 v])
end
if <(argument_reporter_string_number) = (19)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves19 v])
end
if <(argument_reporter_string_number) = (20)> then 
replace item (argument_reporter_string_number) of [MovesCount v] with (length of [Moves20 v])
end
end
end
end
end
end
end
end
if <argument_reporter_boolean> then 
Profile_MethodExit %n
 else 
if <argument_reporter_boolean> then 
Profile_MethodExit %n
 else 
Profile_MethodExit %n
end
end

define GetMoveScore %n %n %n %n %n %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
set [OrderFac v] to [1]
 else 
set [OrderFac v] to [-1]
end
if <(argument_reporter_string_number) = (0)> then 
if <<<(argument_reporter_string_number) = (BlackQueensideCastling)> or <(argument_reporter_string_number) = (BlackKingsideCastling)>> or <<(argument_reporter_string_number) = (WhiteQueensideCastling)> or <(argument_reporter_string_number) = (WhiteKingsideCastling)>>> then 
set [MoveScoreRes v] to ((50) * (OrderFac))
stop [this script v]
end
end
if <(letter (5) of (argument_reporter_string_number)) = (.)> then 
if <(letter (6) of (argument_reporter_string_number)) = (1)> then 
set [MoveScoreRes v] to ((800) * (OrderFac))
end
if <(letter (6) of (argument_reporter_string_number)) = (2)> then 
set [MoveScoreRes v] to ((400) * (OrderFac))
end
if <(letter (6) of (argument_reporter_string_number)) = (3)> then 
set [MoveScoreRes v] to ((230) * (OrderFac))
end
if <(letter (6) of (argument_reporter_string_number)) = (4)> then 
set [MoveScoreRes v] to ((210) * (OrderFac))
end
stop [this script v]
end
if <((argument_reporter_string_number) mod (2)) = (0)> then 
if <<(item (argument_reporter_string_number) of [BoardAttackedByBlack v]) > (0)> and <<not <(item (argument_reporter_string_number) of [BoardAttackedByWhite v]) = (0)>> or <(item (argument_reporter_string_number) of [BoardAttackedByBlackPiece v]) < ([abs v] of (argument_reporter_string_number) ::operators)>>> then 
set [WasAttacked v] to [1]
 else 
set [WasAttacked v] to [0]
end
if <(item (argument_reporter_string_number) of [BoardAttackedByBlack v]) > (0)> then 
set [IsAttacked v] to [1]
 else 
set [IsAttacked v] to [0]
end
 else 
if <<(item (argument_reporter_string_number) of [BoardAttackedByWhite v]) > (0)> and <<not <(item (argument_reporter_string_number) of [BoardAttackedByBlack v]) = (0)>> or <([abs v] of (item (argument_reporter_string_number) of [BoardAttackedByWhitePiece v]) ::operators) < (argument_reporter_string_number)>>> then 
set [WasAttacked v] to [1]
 else 
set [WasAttacked v] to [0]
end
if <(item (argument_reporter_string_number) of [BoardAttackedByWhite v]) > (0)> then 
set [IsAttacked v] to [1]
 else 
set [IsAttacked v] to [0]
end
end
if <<(argument_reporter_string_number) = (Empty)> and <<(IsAttacked) = (0)> and <(WasAttacked) = (0)>>> then 
if <(argument_reporter_string_number) = (8)> then 
if <[KillerMoves8 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves8 v])) * (OrderFac))
stop [this script v]
end
 else 
if <(argument_reporter_string_number) = (7)> then 
if <[KillerMoves7 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves7 v])) * (OrderFac))
stop [this script v]
end
 else 
if <(argument_reporter_string_number) = (6)> then 
if <[KillerMoves6 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves6 v])) * (OrderFac))
stop [this script v]
end
 else 
if <(argument_reporter_string_number) = (5)> then 
if <[KillerMoves5 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves5 v])) * (OrderFac))
stop [this script v]
end
 else 
if <(argument_reporter_string_number) = (4)> then 
if <[KillerMoves4 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves4 v])) * (OrderFac))
stop [this script v]
end
 else 
if <(argument_reporter_string_number) = (3)> then 
if <[KillerMoves3 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves3 v])) * (OrderFac))
stop [this script v]
end
 else 
if <(argument_reporter_string_number) = (2)> then 
if <[KillerMoves2 v] contains (argument_reporter_string_number) ? ::lists> then 
set [MoveScoreRes v] to (((80) + (item # of (argument_reporter_string_number) in [KillerMoves2 v])) * (OrderFac))
stop [this script v]
end
end
end
end
end
end
end
end
end
set [MoveScoreRes v] to [0]
if <(argument_reporter_string_number) > (0)> then 
change [MoveScoreRes v] by (item ((([ceiling v] of (((argument_reporter_string_number) mod (1000)) / (100)) ::operators) * (10000)) + (((argument_reporter_string_number) * (100)) + (argument_reporter_string_number))) of [MovePosLookupBlack v])
 else 
change [MoveScoreRes v] by (item ((([ceiling v] of ((([abs v] of (argument_reporter_string_number) ::operators) mod (1000)) / (100)) ::operators) * (10000)) + (((argument_reporter_string_number) * (100)) + (argument_reporter_string_number))) of [MovePosLookupWhite v])
end
if <not <(argument_reporter_string_number) = (Empty)>> then 
if <<(IsEndgame) = (1)> and <([abs v] of (argument_reporter_string_number) ::operators) = (BlackPawn)>> then 
change [MoveScoreRes v] by ((0) - ((argument_reporter_string_number) * (1.2)))
 else 
change [MoveScoreRes v] by ((0) - (argument_reporter_string_number))
end
if <(argument_reporter_string_number) > (0)> then 
change [MoveScoreRes v] by (item ((([ceiling v] of (((argument_reporter_string_number) mod (1000)) / (100)) ::operators) * (10000)) + ((argument_reporter_string_number) * (100))) of [MovePosLookupBlack v])
 else 
change [MoveScoreRes v] by (item ((([ceiling v] of ((([abs v] of (argument_reporter_string_number) ::operators) mod (1000)) / (100)) ::operators) * (10000)) + ((argument_reporter_string_number) * (100))) of [MovePosLookupWhite v])
end
end
if <<(IsEndgame) = (1)> and <([abs v] of (argument_reporter_string_number) ::operators) = (BlackPawn)>> then 
if <(IsAttacked) = (1)> then 
change [MoveScoreRes v] by ((0) - ((argument_reporter_string_number) * (1.2)))
end
if <(WasAttacked) = (1)> then 
change [MoveScoreRes v] by ((argument_reporter_string_number) * (1.2))
end
 else 
if <(IsAttacked) = (1)> then 
change [MoveScoreRes v] by ((0) - (argument_reporter_string_number))
end
if <(WasAttacked) = (1)> then 
change [MoveScoreRes v] by (argument_reporter_string_number)
end
end

when gf clicked
hide list [ExportData v]
hide list [ExportMoves v]

define InitKingSafety
delete (all) of [PawnStormBlockedByKing v]
LoadList %s %s
delete (all) of [PawnStormBlockedByPawn v]
LoadList %s %s
delete (all) of [PawnStormBlockedByNone v]
LoadList %s %s
delete (all) of [PawnShelterKingFile v]
LoadList %s %s
delete (all) of [PawnShelterNeighborFile v]
LoadList %s %s

define ImportBoardFEN %s
if <(IsPlayerBlack) = (0)> then 
set [Idx v] to [1]
set [IdxInc v] to [1]
 else 
set [Idx v] to [64]
set [IdxInc v] to [-1]
end
set [IdxString v] to [1]
repeat until <<(Idx) > (64)> or <(Idx) < (1)>> 
set [CurrentValue v] to (letter (IdxString) of (argument_reporter_string_number))
if <<not <(CurrentValue) < (A)>> and <not <(CurrentValue) > (Z)>>> then 
set [CurrentPiece v] to [Empty]
if <(CurrentValue) = (P)> then 
set [CurrentPiece v] to [BlackPawn]
end
if <(CurrentValue) = (N)> then 
set [CurrentPiece v] to [BlackKnight]
end
if <(CurrentValue) = (B)> then 
set [CurrentPiece v] to [BlackBishop]
end
if <(CurrentValue) = (R)> then 
set [CurrentPiece v] to [BlackRook]
end
if <(CurrentValue) = (Q)> then 
set [CurrentPiece v] to [BlackQueen]
end
if <(CurrentValue) = (K)> then 
set [CurrentPiece v] to [BlackKing]
end
IsLowerCase %s
if <(IsLowerCaseRes) = (0)> then 
set [CurrentPiece v] to ((CurrentPiece) * (-1))
end
if <(IsPlayerBlack) = (1)> then 
set [CurrentPiece v] to ((CurrentPiece) * (-1))
end
replace item (Idx) of [Board v] with [CurrentPiece]
change [Idx v] by (IdxInc)
 else 
if <<not <(CurrentValue) < (0)>> and <not <(CurrentValue) > (9)>>> then 
repeat (CurrentValue) 
replace item (Idx) of [Board v] with [Empty]
change [Idx v] by (IdxInc)
end
 else 
if <(CurrentValue) = (/)> then 
repeat until <<<((Idx) mod (8)) = (1)> and <(IsPlayerBlack) = (0)>> or <<((Idx) mod (8)) = (0)> and <(IsPlayerBlack) = (1)>>> 
replace item (Idx) of [Board v] with [Empty]
change [Idx v] by (IdxInc)
end
end
end
end
change [IdxString v] by (1)
end
AddBoardToHistory
DrawBoardAndWait
change [IdxString v] by (1)
set [CurrentValue v] to (letter (IdxString) of (argument_reporter_string_number))
if <<<(CurrentValue) = (B)> and <(IsPlayerBlack) = (0)>> or <<(CurrentValue) = (W)> and <(IsPlayerBlack) = (1)>>> then 
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
say [Checkmate!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
CalculateMoves %n
if <(length of [Moves1 v]) = (0)> then 
say [Draw!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
set [IsGameSuspended v] to [0]
ExecuteEngineMove
end
end
end
if <<<(CurrentValue) = (W)> and <(IsPlayerBlack) = (0)>> or <<(CurrentValue) = (B)> and <(IsPlayerBlack) = (1)>>> then 
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (1)> then 
say [Checkmate!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
CalculateMoves %n
if <(length of [Moves2 v]) = (0)> then 
say [Draw!] for (5) seconds
set [IsGameSuspended v] to [1]
 else 
set [IsGameSuspended v] to [0]
end
end
end

define OnProgressChanged %n
if <(argument_reporter_string_number) < (100)> then 
set [ProgressValue v] to (argument_reporter_string_number)
 else 
set [ProgressValue v] to [100]
end
broadcast (1 v)
wait (0) seconds

define Profile_MethodExit %n
if <(IsProfilerEnabled) > (0)> then 
replace item (argument_reporter_string_number) of [Profile_Data v] with ((item (argument_reporter_string_number) of [Profile_Data v]) + (((days since 2000) * (24)) * (3600)))
end

define CalcBoardAttackedByMove %n
ClearBoardAttackedByMove %n
CalculateMovesImpl %n %b %b

define Profile_Reset
delete (all) of [Profile_Data v]

define Profile_MethodEnter %n
if <(IsProfilerEnabled) > (0)> then 
repeat until <not <(length of [Profile_Data v]) < (argument_reporter_string_number)>> 
add [0] to [Profile_Data v]
end
replace item (argument_reporter_string_number) of [Profile_Data v] with ((item (argument_reporter_string_number) of [Profile_Data v]) - (((days since 2000) * (24)) * (3600)))
end

define AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
InitAlphaBeta %n %n %b
if <(IsMinMaxTimeout) = (1)> then 
stop [this script v]
end
replace item (argument_reporter_string_number) of [BestHashMoveType v] with []
replace item (argument_reporter_string_number) of [ChildNodeCutoffMove v] with []
replace item (argument_reporter_string_number) of [BestHashMoveMaxDepth v] with (argument_reporter_string_number)
if <argument_reporter_boolean> then 
OnScoreCalc %n %n %n %b %b %b
 else 
OnScoreCalc %n %n %n %b %b %b
end
if <(argument_reporter_string_number) = (argument_reporter_string_number)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [ScoreCalcRes]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
stop [this script v]
end
if <argument_reporter_boolean> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <not <(ScoreCalcRes) < (item (argument_reporter_string_number) of [Betas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [X]
stop [this script v]
end
if <(ScoreCalcRes) > (item (argument_reporter_string_number) of [Alphas v])> then 
replace item (argument_reporter_string_number) of [Alphas v] with [ScoreCalcRes]
end
 else 
if <not <(ScoreCalcRes) > (item (argument_reporter_string_number) of [Alphas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [X]
stop [this script v]
end
if <(ScoreCalcRes) < (item (argument_reporter_string_number) of [Betas v])> then 
replace item (argument_reporter_string_number) of [Betas v] with [ScoreCalcRes]
end
end
end
if <(item ((argument_reporter_string_number) - (1)) of [TargetPieces v]) = (WhiteKing)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((100000) - ((argument_reporter_string_number) * (1000)))
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
stop [this script v]
end
if <(item ((argument_reporter_string_number) - (1)) of [TargetPieces v]) = (BlackKing)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((-100000) + ((argument_reporter_string_number) * (1000)))
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
stop [this script v]
end
if <<(argument_reporter_string_number) = (1)> and <<<(argument_reporter_string_number) = (2)> or <(argument_reporter_string_number) = (3)>> or <<not <argument_reporter_boolean>> and <(item ((argument_reporter_string_number) - (1)) of [CheckedState v]) = (1)>>>> then 
CalcBoardAttackedByMove %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(IsWhiteChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((100000) - ((argument_reporter_string_number) * (1000)))
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
ClearBoardAttackedByMove %n
stop [this script v]
end
 else 
if <(IsBlackChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((-100000) + ((argument_reporter_string_number) * (1000)))
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
ClearBoardAttackedByMove %n
stop [this script v]
end
end
ClearBoardAttackedByMove %n
end
if <<(argument_reporter_string_number) = (1)> and <(argument_reporter_string_number) = (2)>> then 
IsDraw %n
if <<(WhiteQueenCount) = (0)> and <(WhiteMinorCount) = (0)>> then 
if <(IsDrawRes) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
stop [this script v]
end
end
end
if <<<(argument_reporter_string_number) = (1)> and <<(argument_reporter_string_number) > (1)> and <(argument_reporter_string_number) < (7)>>> and <not <argument_reporter_boolean>>> then 
set [Idx v] to ((length of [BoardHistoryHash v]) - (1))
repeat until <(Idx) < (1)> 
if <(CurrentMoveHash) = (item (Idx) of [BoardHistoryHash v])> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [X]
stop [this script v]
end
change [Idx v] by (-2)
end
set [Idx v] to ((length of [BoardHistoryHash v]) - (1))
repeat until <(Idx) < (1)> 
if <(CurrentMoveHash) = (item (Idx) of [BoardHistoryHash v])> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [X]
stop [this script v]
end
change [Idx v] by (-2)
end
end
if <(argument_reporter_string_number) > (1)> then 
TTProbeNode %s %s
if <<(TTProbeRes) = (1)> and <<<<not <argument_reporter_boolean>> and <not <(TTProbeHorizonRes) = (-1)>>> and <<not <(TTProbeHorizonRes) < ((argument_reporter_string_number) - (argument_reporter_string_number))>> or <([abs v] of (TTProbeNodeScoreRes) ::operators) > ((BlackKing) / (2))>>> or <<<argument_reporter_boolean> and <(TTProbeHorizonRes) = (-1)>> and <(1) = (1)>>>> then 
if <<(TTProbeNodeTypeRes) = (E)> and <<not <((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)>> or <<not <(TTProbeNodeScoreRes) > (item (argument_reporter_string_number) of [Alphas v])>> or <not <(TTProbeNodeScoreRes) < (item (argument_reporter_string_number) of [Betas v])>>>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [TTProbeNodeScoreRes]
replace item (argument_reporter_string_number) of [ChildNodeCutoffMove v] with [TTProbeBestMoveRes]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [X]
Profile_IncCounter %n
stop [this script v]
 else 
if <<(TTProbeNodeTypeRes) = (A)> and <not <(TTProbeNodeScoreRes) > (item (argument_reporter_string_number) of [Alphas v])>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [TTProbeNodeScoreRes]
replace item (argument_reporter_string_number) of [ChildNodeCutoffMove v] with [TTProbeBestMoveRes]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [X]
Profile_IncCounter %n
stop [this script v]
 else 
if <<(TTProbeNodeTypeRes) = (B)> and <not <(TTProbeNodeScoreRes) < (item (argument_reporter_string_number) of [Betas v])>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [TTProbeNodeScoreRes]
replace item (argument_reporter_string_number) of [ChildNodeCutoffMove v] with [TTProbeBestMoveRes]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [X]
Profile_IncCounter %n
stop [this script v]
end
end
end
end
end
if <<<(IsInNullMove) = (0)> and <(IsEndgame) = (0)>> and <<<<not <argument_reporter_boolean>> and <(argument_reporter_string_number) > (1)>> and <((argument_reporter_string_number) - (argument_reporter_string_number)) > (1)>> and <<((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)> and <<(item ((argument_reporter_string_number) - (1)) of [PutsInCheck v]) = (0)> and <(item ((argument_reporter_string_number) - (1)) of [CheckedState v]) = (0)>>>>> then 
change [IsInNullMove v] by (1)
if <<<((argument_reporter_string_number) mod (2)) = (0)> and <<(WhiteMinorCount) > (0)> or <(WhiteQueenCount) > (0)>>> or <<((argument_reporter_string_number) mod (2)) = (1)> and <<(BlackMinorCount) > (0)> or <(BlackQueenCount) > (0)>>>> then 
OnScoreCalc %n %n %n %b %b %b
if <<((argument_reporter_string_number) mod (2)) = (1)> and <not <(ScoreCalcRes) < (item (argument_reporter_string_number) of [Betas v])>>> then 
ClearMoveList %n
AddToMoveList %n %n
replace item ((argument_reporter_string_number) + (0)) of [MovesIdx v] with [1]
ApplyMove %n
OnScoreCalc %n %n %n %b %b %b
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with ((item (argument_reporter_string_number) of [Betas v]) - (1))
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with (item (argument_reporter_string_number) of [Betas v])
if <((argument_reporter_string_number) - (argument_reporter_string_number)) > (2)> then 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
 else 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
end
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
RevertMove %n
if <<not <(Score) < (item (argument_reporter_string_number) of [Betas v])>> and <not <([abs v] of (Score) ::operators) > ((BlackKing) / (2))>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
replace item (argument_reporter_string_number) of [ChildNodeCutoffMove v] with []
change [IsInNullMove v] by (-1)
stop [this script v]
end
end
if <<((argument_reporter_string_number) mod (2)) = (0)> and <not <(ScoreCalcRes) > (item (argument_reporter_string_number) of [Alphas v])>>> then 
ClearMoveList %n
AddToMoveList %n %n
replace item ((argument_reporter_string_number) + (0)) of [MovesIdx v] with [1]
OnScoreCalc %n %n %n %b %b %b
ApplyMove %n
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with (item (argument_reporter_string_number) of [Alphas v])
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with ((item (argument_reporter_string_number) of [Alphas v]) + (1))
if <((argument_reporter_string_number) - (argument_reporter_string_number)) > (2)> then 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
 else 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
end
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
RevertMove %n
if <<not <(Score) > (item (argument_reporter_string_number) of [Alphas v])>> and <not <([abs v] of (Score) ::operators) > ((BlackKing) / (2))>>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
replace item (argument_reporter_string_number) of [ChildNodeCutoffMove v] with []
change [IsInNullMove v] by (-1)
stop [this script v]
end
end
end
change [IsInNullMove v] by (-1)
end
replace item (argument_reporter_string_number) of [PickPhase v] with [1]
replace item (argument_reporter_string_number) of [PickMoveRes v] with [1]
replace item (argument_reporter_string_number) of [CheckedState v] with [0]
repeat until <(item (argument_reporter_string_number) of [PickMoveRes v]) = (0)> 
if <(IsMinMaxTimeout) = (0)> then 
if <(argument_reporter_string_number) < (4)> then 
if <((timer) - (ThinkTimeStart)) > (ThinkTimeLimitMinMax)> then 
set [IsMinMaxTimeout v] to [1]
end
end
end
if <(IsMinMaxTimeout) = (1)> then 
stop [this script v]
end
Profile_MethodEnter %n
PickMove %n %n %b %b %b %b
Profile_MethodExit %n
if <(item (argument_reporter_string_number) of [PickMoveRes v]) = (1)> then 
if <<argument_reporter_boolean> and <(argument_reporter_string_number) = (1)>> then 
if <(timer) > ((PrevProgressUpdate) + (1))> then 
OnProgressChanged %n
set [PrevProgressUpdate v] to (timer)
end
end
replace item (argument_reporter_string_number) of [PutsInCheck v] with [0]
replace item (argument_reporter_string_number) of [PlyExtension v] with [0]
if <not <argument_reporter_boolean>> then 
TTProbeNode %s %s
if <<(TTProbeRes) = (1)> and <not <(TTProbeCheckedRes) = ()>>> then 
replace item (argument_reporter_string_number) of [PutsInCheck v] with [TTProbeCheckedRes]
 else 
if <<<(argument_reporter_string_number) < (3)> and <(IsScratch3) = (1)>> or <<(argument_reporter_string_number) < (4)> and <(IsScratch3) = (0)>>> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
set [IsWhiteChecked v] to [0]
CalcBoardAttackedByMove %n
if <(IsWhiteChecked) = (1)> then 
replace item (argument_reporter_string_number) of [PutsInCheck v] with [1]
end
 else 
set [IsBlackChecked v] to [0]
CalcBoardAttackedByMove %n
if <(IsBlackChecked) = (1)> then 
replace item (argument_reporter_string_number) of [PutsInCheck v] with [1]
end
end
 else 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
GetCurrentMove %n
replace item ([floor v] of ((CurrentMove) mod (100)) ::operators) of [BoardAttackedByBlack v] with ((item ([floor v] of ((CurrentMove) mod (100)) ::operators) of [BoardAttackedByBlack v]) - (1))
set [IsWhiteChecked v] to [0]
CalculateMovesForSource %n %n %b %b
if <(IsWhiteChecked) = (1)> then 
replace item (argument_reporter_string_number) of [PutsInCheck v] with [1]
end
 else 
GetCurrentMove %n
replace item ([floor v] of ((CurrentMove) mod (100)) ::operators) of [BoardAttackedByWhite v] with ((item ([floor v] of ((CurrentMove) mod (100)) ::operators) of [BoardAttackedByWhite v]) - (1))
set [IsBlackChecked v] to [0]
CalculateMovesForSource %n %n %b %b
if <(IsBlackChecked) = (1)> then 
replace item (argument_reporter_string_number) of [PutsInCheck v] with [1]
end
end
end
end
if <<<((argument_reporter_string_number) - (argument_reporter_string_number)) = (1)> and <not <argument_reporter_boolean>>> and <<(item (argument_reporter_string_number) of [PutsInCheck v]) = (1)> and <(item ((argument_reporter_string_number) - (1)) of [PlyExtension v]) = (0)>>> then 
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <not <(item ([floor v] of ((CurrentMove) mod (100)) ::operators) of [BoardAttackedByWhite v]) > (item ([floor v] of ((CurrentMove) mod (100)) ::operators) of [BoardAttackedByBlack v])>> then 
replace item (argument_reporter_string_number) of [PlyExtension v] with [1]
end
 else 
if <not <(item ([floor v] of ((CurrentMove) mod (100)) ::operators) of [BoardAttackedByBlack v]) > (item ([floor v] of ((CurrentMove) mod (100)) ::operators) of [BoardAttackedByWhite v])>> then 
replace item (argument_reporter_string_number) of [PlyExtension v] with [1]
end
end
end
end
set [IsFutile v] to [0]
if <<argument_reporter_boolean> or <<<<<not <argument_reporter_boolean>> and <<(argument_reporter_string_number) > (2)> and <((argument_reporter_string_number) - (argument_reporter_string_number)) < (3)>>> and <<(item (argument_reporter_string_number) of [MovesIdx v]) > (1)> and <((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)>>> and <<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>>> and <<(item (argument_reporter_string_number) of [CheckedState v]) = (0)> and <(item (argument_reporter_string_number) of [PutsInCheck v]) = (0)>>>> then 
if <argument_reporter_boolean> then 
set [FutilityMargin v] to [125]
 else 
set [FutilityMargin v] to (((argument_reporter_string_number) - (argument_reporter_string_number)) * (75))
end
OnScoreCalc %n %n %n %b %b %b
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <not <((ScoreCalcRes) + (FutilityMargin)) > (item (argument_reporter_string_number) of [Alphas v])>> then 
set [IsFutile v] to [1]
end
 else 
if <not <((ScoreCalcRes) - (FutilityMargin)) < (item (argument_reporter_string_number) of [Betas v])>> then 
set [IsFutile v] to [1]
end
end
end
if <(IsFutile) = (1)> then 
Profile_IncCounter %n
RevertMove %n
 else 
Profile_IncCounter %n
set [IsReductionAndDone v] to [0]
if <<<not <argument_reporter_boolean>> and <<(argument_reporter_string_number) > (2)> and <<((argument_reporter_string_number) - (argument_reporter_string_number)) > (1)> or <(item (argument_reporter_string_number) of [PlyExtension v]) = (1)>>>> and <(item (argument_reporter_string_number) of [MovesIdx v]) > (1)>> then 
Profile_IncCounter %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
set [Score v] to ((item (argument_reporter_string_number) of [Alphas v]) + (1))
if <<<((argument_reporter_string_number) - (argument_reporter_string_number)) > (2)> and <(item (argument_reporter_string_number) of [CheckedState v]) = (0)>> and <<<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>> and <<(item (argument_reporter_string_number) of [PutsInCheck v]) = (0)> and <<((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)> and <((item (argument_reporter_string_number) of [MovesIdx v]) / (item (argument_reporter_string_number) of [MovesCount v])) > (0.2)>>>>> then 
Profile_IncCounter %n
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with (item (argument_reporter_string_number) of [Alphas v])
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with ((item (argument_reporter_string_number) of [Alphas v]) + (1))
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
set [IsReductionAndDone v] to [1]
end
if <(Score) > (item (argument_reporter_string_number) of [Alphas v])> then 
Profile_IncCounter %n
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with (item (argument_reporter_string_number) of [Alphas v])
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with ((item (argument_reporter_string_number) of [Alphas v]) + (1))
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
set [IsReductionAndDone v] to [1]
if <<(Score) > (item (argument_reporter_string_number) of [Alphas v])> and <(Score) < (item (argument_reporter_string_number) of [Betas v])>> then 
Profile_IncCounter %n
set [IsReductionAndDone v] to [0]
end
end
 else 
set [Score v] to ((item (argument_reporter_string_number) of [Betas v]) - (1))
if <<<((argument_reporter_string_number) - (argument_reporter_string_number)) > (2)> and <(item (argument_reporter_string_number) of [CheckedState v]) = (0)>> and <<<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>> and <<(item (argument_reporter_string_number) of [PutsInCheck v]) = (0)> and <<((item (argument_reporter_string_number) of [Betas v]) - (item (argument_reporter_string_number) of [Alphas v])) = (1)> and <((item (argument_reporter_string_number) of [MovesIdx v]) / (item (argument_reporter_string_number) of [MovesCount v])) > (0.2)>>>>> then 
Profile_IncCounter %n
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with ((item (argument_reporter_string_number) of [Betas v]) - (1))
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with (item (argument_reporter_string_number) of [Betas v])
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
set [IsReductionAndDone v] to [1]
end
if <(Score) < (item (argument_reporter_string_number) of [Betas v])> then 
Profile_IncCounter %n
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with ((item (argument_reporter_string_number) of [Betas v]) - (1))
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with (item (argument_reporter_string_number) of [Betas v])
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
set [IsReductionAndDone v] to [1]
if <<(Score) > (item (argument_reporter_string_number) of [Alphas v])> and <(Score) < (item (argument_reporter_string_number) of [Betas v])>> then 
Profile_IncCounter %n
set [IsReductionAndDone v] to [0]
end
end
end
end
if <(IsReductionAndDone) = (0)> then 
replace item ((argument_reporter_string_number) + (1)) of [Alphas v] with (item (argument_reporter_string_number) of [Alphas v])
replace item ((argument_reporter_string_number) + (1)) of [Betas v] with (item (argument_reporter_string_number) of [Betas v])
if <<(argument_reporter_string_number) > (0)> and <(argument_reporter_string_number) = ((argument_reporter_string_number) - (1))>> then 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
 else 
AlphaBetaMinMaxImpl %n %n %n %b %b %n %b %b %b
end
set [Score v] to (item ((argument_reporter_string_number) + (1)) of [MinMaxResults v])
set [IsReductionAndDone v] to [0]
end
if <(IsMinMaxTimeout) = (1)> then 
RevertMove %n
stop [this script v]
end
if <not <(item ((argument_reporter_string_number) + (1)) of [BestHashMoveType v]) = (X)>> then 
if <<argument_reporter_boolean> or <<(argument_reporter_string_number) = ((argument_reporter_string_number) - (1))> and <(item (argument_reporter_string_number) of [PlyExtension v]) = (0)>>> then 
TTStoreNode %s %s %s %s %s %s %s %s %s
 else 
TTStoreNode %s %s %s %s %s %s %s %s %s
end
end
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> then 
set [IsPotentialKillerMove v] to [1]
 else 
set [IsPotentialKillerMove v] to [0]
end
RevertMove %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(argument_reporter_string_number) = (1)> then 
add (item (item (1) of [MovesIdx v]) of [Moves1 v]) to [MinMaxPly1EvalMoves v]
end
if <(argument_reporter_string_number) > (1)> then 
if <not <(Score) < (item (argument_reporter_string_number) of [Betas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
StoreMove %n %b
stop [this script v]
end
end
if <(Score) > (item (argument_reporter_string_number) of [Alphas v])> then 
replace item (argument_reporter_string_number) of [Alphas v] with [Score]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
if <<(argument_reporter_string_number) = (1)> and <(IsMinMaxTimeout) = (0)>> then 
if <(Score) < (item (argument_reporter_string_number) of [Betas v])> then 
delete (all) of [BestMinMaxResults v]
add [Score] to [BestMinMaxResults v]
if <(Score) > (-98000)> then 
if <(1) = (1)> then 
Log %s %s %s %s %s %s %s %s
end
delete (all) of [BestMoves v]
add (item (item (1) of [MovesIdx v]) of [Moves1 v]) to [BestMoves v]
replace item (item (item (1) of [MovesIdx v]) of [DeepeningScoreOrderMap v]) of [DeepeningScore v] with (((argument_reporter_string_number) * (100000)) + ((10000) + (Score)))
if <(item (1) of [BestMoves v]) = (BlackKingsideCastling)> then 
set [BestMoveFromIdx v] to (item (5) of [VirtualBoard v])
set [BestMoveToIdx v] to (item (7) of [VirtualBoard v])
 else 
if <(item (1) of [BestMoves v]) = (BlackQueensideCastling)> then 
set [BestMoveFromIdx v] to (item (5) of [VirtualBoard v])
set [BestMoveToIdx v] to (item (3) of [VirtualBoard v])
 else 
set [BestMoveFromIdx v] to ([floor v] of ((item (1) of [BestMoves v]) / (100)) ::operators)
set [BestMoveToIdx v] to ([floor v] of ((item (1) of [BestMoves v]) mod (100)) ::operators)
end
end
broadcast (1 v)
end
end
end
StoreMove %n %b
end
 else 
if <not <(Score) > (item (argument_reporter_string_number) of [Alphas v])>> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
StoreMove %n %b
stop [this script v]
end
if <(Score) < (item (argument_reporter_string_number) of [Betas v])> then 
replace item (argument_reporter_string_number) of [Betas v] with [Score]
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
StoreMove %n %b
end
end
end
end
end
if <((argument_reporter_string_number) mod (2)) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Alphas v])
if <not <(item (argument_reporter_string_number) of [BestHashMoveType v]) = (E)>> then 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [A]
end
 else 
replace item (argument_reporter_string_number) of [MinMaxResults v] with (item (argument_reporter_string_number) of [Betas v])
if <not <(item (argument_reporter_string_number) of [BestHashMoveType v]) = (E)>> then 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [B]
end
end
if <(item (argument_reporter_string_number) of [MovesCount v]) = (0)> then 
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [E]
if <argument_reporter_boolean> then 
OnScoreCalc %n %n %n %b %b %b
replace item (argument_reporter_string_number) of [MinMaxResults v] with [ScoreCalcRes]
stop [this script v]
 else 
CalcBoardAttackedByMove %n
if <((argument_reporter_string_number) mod (2)) = (1)> then 
if <(IsBlackChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((-100000) + ((argument_reporter_string_number) * (1000)))
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [X]
stop [this script v]
 else 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
stop [this script v]
end
 else 
if <(IsWhiteChecked) = (1)> then 
replace item (argument_reporter_string_number) of [MinMaxResults v] with ((100000) - ((argument_reporter_string_number) * (1000)))
replace item (argument_reporter_string_number) of [BestHashMoveType v] with [X]
stop [this script v]
 else 
replace item (argument_reporter_string_number) of [MinMaxResults v] with [0]
stop [this script v]
end
end
end
end

define OnScoreCalc %n %n %n %b %b %b
Profile_MethodEnter %n
set [ScoreCalcRes v] to []
if <(argument_reporter_string_number) = (0)> then 
EvaluateBoard
set [EvalResultBase v] to [EvalResult]
Profile_MethodExit %n
stop [this script v]
end
if <(argument_reporter_string_number) = (1)> then 
replace item (argument_reporter_string_number) of [EvalExtended1 v] with [0]
replace item (argument_reporter_string_number) of [EvalExtended2 v] with [0]
replace item (argument_reporter_string_number) of [EvalExtended3 v] with [0]
 else 
replace item (argument_reporter_string_number) of [EvalExtended1 v] with (item ((argument_reporter_string_number) - (1)) of [EvalExtended1 v])
replace item (argument_reporter_string_number) of [EvalExtended2 v] with (item ((argument_reporter_string_number) - (1)) of [EvalExtended2 v])
replace item (argument_reporter_string_number) of [EvalExtended3 v] with (item ((argument_reporter_string_number) - (1)) of [EvalExtended3 v])
end
GetCurrentMove %n
if <<(argument_reporter_string_number) = (1)> or <<<<([abs v] of (item (argument_reporter_string_number) of [SourcePieces v]) ::operators) = (BlackPawn)> or <([abs v] of (item (argument_reporter_string_number) of [TargetPieces v]) ::operators) = (BlackPawn)>> or <<([abs v] of (item (argument_reporter_string_number) of [SourcePieces v]) ::operators) = (BlackKing)> or <not <(item (Idx) of [PromotionPieces v]) = (Empty)>>>> or <<<(CurrentMove) = (BlackQueensideCastling)> or <(CurrentMove) = (BlackKingsideCastling)>> or <<(CurrentMove) = (WhiteKingsideCastling)> or <(CurrentMove) = (WhiteQueensideCastling)>>>>> then 
EvaluateBoardExtended1 %s
replace item (argument_reporter_string_number) of [EvalExtended1 v] with [EvalExtendedResult1]
end
if <(1) = (0)> then 
if <(IsEndgame) = (0)> then 
set [IsInvalidated v] to [0]
if <<<(CurrentMove) = (BlackQueensideCastling)> or <(CurrentMove) = (BlackKingsideCastling)>> or <<(CurrentMove) = (WhiteKingsideCastling)> or <(CurrentMove) = (WhiteQueensideCastling)>>> then 
set [IsInvalidated v] to [1]
 else 
set [SourceIdx v] to ([floor v] of ((CurrentMove) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((CurrentMove) mod (100)) ::operators)
if <<<<([abs v] of (item (argument_reporter_string_number) of [SourcePieces v]) ::operators) = (BlackRook)> or <<([abs v] of (item (argument_reporter_string_number) of [SourcePieces v]) ::operators) = (BlackQueen)> and <(1) = (0)>>> or <<([abs v] of (item (argument_reporter_string_number) of [SourcePieces v]) ::operators) = (BlackKing)> or <([abs v] of (item (argument_reporter_string_number) of [SourcePieces v]) ::operators) = (BlackPawn)>>> and <<<(item (item (SourceIdx) of [IdxToFile v]) of [BlackPawnCount v]) = (0)> and <(item (item (SourceIdx) of [IdxToFile v]) of [WhitePawnCount v]) = (0)>> or <<(item (item (TargetIdx) of [IdxToFile v]) of [BlackPawnCount v]) = (0)> and <(item (item (TargetIdx) of [IdxToFile v]) of [WhitePawnCount v]) = (0)>>>> then 
set [IsInvalidated v] to [1]
 else 
if <<<<([abs v] of (item (argument_reporter_string_number) of [TargetPieces v]) ::operators) = (BlackRook)> or <<([abs v] of (item (argument_reporter_string_number) of [TargetPieces v]) ::operators) = (BlackQueen)> and <(1) = (0)>>> or <([abs v] of (item (argument_reporter_string_number) of [TargetPieces v]) ::operators) = (BlackPawn)>> and <<(item (item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [IdxToFile v]) of [BlackPawnCount v]) = (0)> and <(item (item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [IdxToFile v]) of [WhitePawnCount v]) = (0)>>> then 
set [IsInvalidated v] to [1]
end
end
end
if <<(argument_reporter_string_number) = (1)> or <(IsInvalidated) = (1)>> then 
EvaluateBoardExtended2 %s
replace item (argument_reporter_string_number) of [EvalExtended2 v] with [EvalExtendedResult2]
end
end
end
if <(IsEndgame) = (0)> then 
if <<not <argument_reporter_boolean>> and <(argument_reporter_string_number) = (argument_reporter_string_number)>> then 
EvaluateBoardExtended3 %s
replace item (argument_reporter_string_number) of [EvalExtended3 v] with [EvalExtendedResult3]
end
end
if <(argument_reporter_string_number) = (argument_reporter_string_number)> then 
set [ScoreCalcRes v] to ((EvalResultBase) + ((item (argument_reporter_string_number) of [EvalExtended1 v]) + ((item (argument_reporter_string_number) of [EvalExtended2 v]) + (item (argument_reporter_string_number) of [EvalExtended3 v]))))
change [ScoreCalcRes v] by ((item (argument_reporter_string_number) of [BlackMobBonus v]) - (item (argument_reporter_string_number) of [WhiteMobBonus v]))
set [Idx v] to [1]
repeat until <(Idx) > (argument_reporter_string_number)> 
change [ScoreCalcRes v] by (item (Idx) of [PosScoreDelta v])
if <<([abs v] of (item (Idx) of [TargetPieces v]) ::operators) = (BlackPawn)> and <(IsEndgame) = (1)>> then 
change [ScoreCalcRes v] by ((0) - ((1.2) * (item (Idx) of [TargetPieces v])))
 else 
change [ScoreCalcRes v] by ((0) - (item (Idx) of [TargetPieces v]))
end
if <not <(item (Idx) of [PromotionPieces v]) = (Empty)>> then 
if <(IsEndgame) = (1)> then 
change [ScoreCalcRes v] by ((item (Idx) of [PromotionPieces v]) - ((1.2) * (item (Idx) of [SourcePieces v])))
 else 
change [ScoreCalcRes v] by ((item (Idx) of [PromotionPieces v]) - (item (Idx) of [SourcePieces v]))
end
end
change [Idx v] by (1)
end
end
Profile_MethodExit %n

define AddSpecialMove %s %n
GetMoveScore %n %n %n %n %n %n
if <(argument_reporter_string_number) < (6)> then 
if <(argument_reporter_string_number) = (5)> then 
add (argument_reporter_string_number) to [Moves5 v]
add [MoveScoreRes] to [Moves5Score v]
 else 
if <(argument_reporter_string_number) = (4)> then 
add (argument_reporter_string_number) to [Moves4 v]
add [MoveScoreRes] to [Moves4Score v]
 else 
if <(argument_reporter_string_number) = (3)> then 
add (argument_reporter_string_number) to [Moves3 v]
add [MoveScoreRes] to [Moves3Score v]
 else 
if <(argument_reporter_string_number) = (2)> then 
add (argument_reporter_string_number) to [Moves2 v]
add [MoveScoreRes] to [Moves2Score v]
 else 
if <(argument_reporter_string_number) = (1)> then 
add (argument_reporter_string_number) to [Moves1 v]
add [MoveScoreRes] to [Moves1Score v]
end
end
end
end
end
 else 
if <(argument_reporter_string_number) = (6)> then 
add (argument_reporter_string_number) to [Moves6 v]
add [MoveScoreRes] to [Moves6Score v]
 else 
if <(argument_reporter_string_number) = (7)> then 
add (argument_reporter_string_number) to [Moves7 v]
add [MoveScoreRes] to [Moves7Score v]
 else 
if <(argument_reporter_string_number) = (8)> then 
add (argument_reporter_string_number) to [Moves8 v]
add [MoveScoreRes] to [Moves8Score v]
 else 
if <(argument_reporter_string_number) = (9)> then 
add (argument_reporter_string_number) to [Moves9 v]
add [MoveScoreRes] to [Moves9Score v]
 else 
if <(argument_reporter_string_number) = (10)> then 
add (argument_reporter_string_number) to [Moves10 v]
add [MoveScoreRes] to [Moves10Score v]
 else 
if <(argument_reporter_string_number) = (11)> then 
delete (argument_reporter_string_number) of [Moves11 v]
delete (MoveScoreRes) of [Moves11Score v]
end
if <(argument_reporter_string_number) = (12)> then 
delete (argument_reporter_string_number) of [Moves12 v]
delete (MoveScoreRes) of [Moves12Score v]
end
if <(argument_reporter_string_number) = (13)> then 
delete (argument_reporter_string_number) of [Moves13 v]
delete (MoveScoreRes) of [Moves13Score v]
end
if <(argument_reporter_string_number) = (14)> then 
delete (argument_reporter_string_number) of [Moves14 v]
delete (MoveScoreRes) of [Moves14Score v]
end
if <(argument_reporter_string_number) = (15)> then 
delete (argument_reporter_string_number) of [Moves15 v]
delete (MoveScoreRes) of [Moves15Score v]
end
if <(argument_reporter_string_number) = (16)> then 
delete (argument_reporter_string_number) of [Moves16 v]
delete (MoveScoreRes) of [Moves16Score v]
end
if <(argument_reporter_string_number) = (17)> then 
delete (argument_reporter_string_number) of [Moves17 v]
delete (MoveScoreRes) of [Moves17Score v]
end
if <(argument_reporter_string_number) = (18)> then 
delete (argument_reporter_string_number) of [Moves18 v]
delete (MoveScoreRes) of [Moves18Score v]
end
if <(argument_reporter_string_number) = (19)> then 
delete (argument_reporter_string_number) of [Moves19 v]
delete (MoveScoreRes) of [Moves19Score v]
end
if <(argument_reporter_string_number) = (20)> then 
delete (argument_reporter_string_number) of [Moves20 v]
delete (MoveScoreRes) of [Moves20Score v]
end
end
end
end
end
end
end

define DetectFlash30Bug
set [IsFlash30Bug v] to [0]
set [ThinkTimeStart v] to (timer)
repeat (10000) 
end
if <(timer) > ((ThinkTimeStart) + (0.1))> then 
if <(1) = (0)> then 
set [IsFlash30Bug v] to [1]
end
end

define ApplyMove %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with [0]
replace item (argument_reporter_string_number) of [SourcePieces v] with [Empty]
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with []
replace item (argument_reporter_string_number) of [TargetPieces v] with [Empty]
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
replace item (argument_reporter_string_number) of [PreviousMoveHash v] with [CurrentMoveHash]
GetCurrentMove %n
set [SourceIdx v] to ([floor v] of ((CurrentMove) / (100)) ::operators)
set [TargetIdx v] to ([floor v] of ((CurrentMove) mod (100)) ::operators)
if <<(SourceIdx) > (0)> and <(TargetIdx) > (0)>> then 
set [SourcePiece v] to (item (SourceIdx) of [Board v])
set [TargetPiece v] to (item (TargetIdx) of [Board v])
if <(SourcePiece) > (0)> then 
set [IdxSub v] to ((([ceiling v] of (((SourcePiece) mod (1000)) / (100)) ::operators) * (10000)) + (((SourceIdx) * (100)) + (TargetIdx)))
replace item (argument_reporter_string_number) of [PosScoreDelta v] with (item (IdxSub) of [MovePosLookupBlack v])
change [CurrentMoveHash v] by (item (IdxSub) of [MoveHashLookupBlack v])
 else 
set [IdxSub v] to ((([ceiling v] of ((([abs v] of (SourcePiece) ::operators) mod (1000)) / (100)) ::operators) * (10000)) + (((SourceIdx) * (100)) + (TargetIdx)))
replace item (argument_reporter_string_number) of [PosScoreDelta v] with (item (IdxSub) of [MovePosLookupWhite v])
change [CurrentMoveHash v] by (item (IdxSub) of [MoveHashLookupWhite v])
end
if <(TargetPiece) > (0)> then 
set [IdxSub v] to ((([ceiling v] of (((TargetPiece) mod (1000)) / (100)) ::operators) * (10000)) + ((TargetIdx) * (100)))
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((item (argument_reporter_string_number) of [PosScoreDelta v]) + (item (IdxSub) of [MovePosLookupBlack v]))
change [CurrentMoveHash v] by (item (IdxSub) of [MoveHashLookupBlack v])
 else 
if <(TargetPiece) < (0)> then 
set [IdxSub v] to ((([ceiling v] of ((([abs v] of (TargetPiece) ::operators) mod (1000)) / (100)) ::operators) * (10000)) + ((TargetIdx) * (100)))
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((item (argument_reporter_string_number) of [PosScoreDelta v]) + (item (IdxSub) of [BoardAttackedByWhite v]))
change [CurrentMoveHash v] by (item (IdxSub) of [MoveHashLookupWhite v])
end
end
replace item (argument_reporter_string_number) of [SourcePieces v] with [SourcePiece]
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with [TargetIdx]
replace item (argument_reporter_string_number) of [TargetPieces v] with [TargetPiece]
replace item (TargetIdx) of [Board v] with [SourcePiece]
replace item (SourceIdx) of [Board v] with [Empty]
if <(SourcePiece) = (BlackPawn)> then 
replace item (item (SourceIdx) of [IdxToFile v]) of [BlackPawnCount v] with ((item (item (SourceIdx) of [IdxToFile v]) of [BlackPawnCount v]) - (1))
replace item (item (TargetIdx) of [IdxToFile v]) of [BlackPawnCount v] with ((item (item (TargetIdx) of [IdxToFile v]) of [BlackPawnCount v]) + (1))
if <<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <not <(item (SourceIdx) of [IdxToFile v]) = (item (TargetIdx) of [IdxToFile v])>>> then 
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with ((TargetIdx) - (8))
replace item (argument_reporter_string_number) of [TargetPieces v] with (item ((TargetIdx) - (8)) of [Board v])
replace item ((TargetIdx) - (8)) of [Board v] with [Empty]
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
end
if <(TargetIdx) > (56)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
set [PromotionVal v] to (letter (6) of [CurrentMove])
if <(PromotionVal) = (1)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackQueen]
end
if <(PromotionVal) = (2)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackRook]
end
if <(PromotionVal) = (3)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackBishop]
end
if <(PromotionVal) = (4)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [BlackKnight]
end
if <not <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>> then 
replace item (TargetIdx) of [Board v] with (item (argument_reporter_string_number) of [PromotionPieces v])
end
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
end
 else 
if <(SourcePiece) = (WhitePawn)> then 
replace item (item (SourceIdx) of [IdxToFile v]) of [WhitePawnCount v] with ((item (item (SourceIdx) of [IdxToFile v]) of [WhitePawnCount v]) - (1))
replace item (item (TargetIdx) of [IdxToFile v]) of [WhitePawnCount v] with ((item (item (TargetIdx) of [IdxToFile v]) of [WhitePawnCount v]) + (1))
if <<(item (argument_reporter_string_number) of [TargetPieces v]) = (Empty)> and <not <(item (SourceIdx) of [IdxToFile v]) = (item (TargetIdx) of [IdxToFile v])>>> then 
replace item (argument_reporter_string_number) of [TargetPiecesIdx v] with ((TargetIdx) + (8))
replace item (argument_reporter_string_number) of [TargetPieces v] with (item ((TargetIdx) + (8)) of [Board v])
replace item ((TargetIdx) + (8)) of [Board v] with [Empty]
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
end
if <(TargetIdx) < (9)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [Empty]
set [PromotionVal v] to (letter (6) of [CurrentMove])
if <(PromotionVal) = (1)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteQueen]
end
if <(PromotionVal) = (2)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteRook]
end
if <(PromotionVal) = (3)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteBishop]
end
if <(PromotionVal) = (4)> then 
replace item (argument_reporter_string_number) of [PromotionPieces v] with [WhiteKnight]
end
if <not <(item (argument_reporter_string_number) of [PromotionPieces v]) = (Empty)>> then 
replace item (TargetIdx) of [Board v] with (item (argument_reporter_string_number) of [PromotionPieces v])
end
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
end
 else 
if <(SourcePiece) = (BlackRook)> then 
delete (item # of [SourceIdx] in [BlackRookIdxs v]) of [BlackRookIdxs v]
add [TargetIdx] to [BlackRookIdxs v]
 else 
if <(SourcePiece) = (WhiteRook)> then 
delete (item # of [SourceIdx] in [WhiteRookIdxs v]) of [WhiteRookIdxs v]
add [TargetIdx] to [WhiteRookIdxs v]
 else 
if <(SourcePiece) = (BlackQueen)> then 
delete (item # of [SourceIdx] in [BlackQueenIdxs v]) of [BlackQueenIdxs v]
add [TargetIdx] to [BlackQueenIdxs v]
 else 
if <(SourcePiece) = (WhiteQueen)> then 
delete (item # of [SourceIdx] in [WhiteQueenIdxs v]) of [WhiteQueenIdxs v]
add [TargetIdx] to [WhiteQueenIdxs v]
 else 
if <(SourcePiece) = (BlackKing)> then 
replace item (1) of [BlackKingIdxs v] with [TargetIdx]
 else 
if <(SourcePiece) = (WhiteKingIdx)> then 
replace item (1) of [WhiteKingIdxs v] with [TargetIdx]
end
end
end
end
end
end
end
end
if <(TargetPiece) = (BlackQueen)> then 
delete (item # of [TargetIdx] in [BlackQueenIdxs v]) of [BlackQueenIdxs v]
 else 
if <(TargetPiece) = (WhiteQueen)> then 
delete (item # of [TargetIdx] in [WhiteQueenIdxs v]) of [WhiteQueenIdxs v]
 else 
if <(TargetPiece) = (BlackRook)> then 
delete (item # of [TargetIdx] in [BlackRookIdxs v]) of [BlackRookIdxs v]
 else 
if <(TargetPiece) = (WhiteRook)> then 
delete (item # of [TargetIdx] in [WhiteRookIdxs v]) of [WhiteRookIdxs v]
end
end
end
end
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (BlackPawn)> then 
replace item (item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [IdxToFile v]) of [BlackPawnCount v] with ((item (item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [IdxToFile v]) of [BlackPawnCount v]) - (1))
 else 
if <(item (argument_reporter_string_number) of [TargetPieces v]) = (WhitePawn)> then 
replace item (item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [IdxToFile v]) of [WhitePawnCount v] with ((item (item (item (argument_reporter_string_number) of [TargetPiecesIdx v]) of [IdxToFile v]) of [WhitePawnCount v]) - (1))
end
end
 else 
if <(CurrentMove) = (WhiteKingsideCastling)> then 
replace item (argument_reporter_string_number) of [SourcePieces v] with [WhiteKing]
replace item (item (61) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (62) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (63) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (64) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (1) of [WhiteKingIdxs v] with (item (63) of [VirtualBoard v])
delete (item # of (item (64) of [VirtualBoard v]) in [WhiteRookIdxs v]) of [WhiteRookIdxs v]
add (item (62) of [VirtualBoard v]) to [WhiteRookIdxs v]
UpdateMoveHashPosScore %n %n %n %b
UpdateMoveHashPosScore %n %n %n %b
 else 
if <(CurrentMove) = (WhiteQueensideCastling)> then 
replace item (argument_reporter_string_number) of [SourcePieces v] with [WhiteKing]
replace item (item (57) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (59) of [VirtualBoard v]) of [Board v] with [WhiteKing]
replace item (item (60) of [VirtualBoard v]) of [Board v] with [WhiteRook]
replace item (item (61) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (1) of [WhiteKingIdxs v] with (item (59) of [VirtualBoard v])
delete (item # of (item (57) of [VirtualBoard v]) in [WhiteRookIdxs v]) of [WhiteRookIdxs v]
add (item (60) of [VirtualBoard v]) to [WhiteRookIdxs v]
UpdateMoveHashPosScore %n %n %n %b
UpdateMoveHashPosScore %n %n %n %b
 else 
if <(CurrentMove) = (BlackKingsideCastling)> then 
replace item (argument_reporter_string_number) of [SourcePieces v] with [BlackKing]
replace item (item (5) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (6) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (7) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (8) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (1) of [BlackKingIdxs v] with (item (3) of [VirtualBoard v])
delete (item # of (item (8) of [VirtualBoard v]) in [BlackRookIdxs v]) of [BlackRookIdxs v]
add (item (6) of [VirtualBoard v]) to [BlackRookIdxs v]
UpdateMoveHashPosScore %n %n %n %b
UpdateMoveHashPosScore %n %n %n %b
 else 
if <(CurrentMove) = (BlackQueensideCastling)> then 
replace item (argument_reporter_string_number) of [SourcePieces v] with [BlackKing]
replace item (item (1) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (item (3) of [VirtualBoard v]) of [Board v] with [BlackKing]
replace item (item (4) of [VirtualBoard v]) of [Board v] with [BlackRook]
replace item (item (5) of [VirtualBoard v]) of [Board v] with [Empty]
replace item (1) of [BlackKingIdxs v] with (item (5) of [VirtualBoard v])
delete (item # of (item (1) of [VirtualBoard v]) in [BlackRookIdxs v]) of [BlackRookIdxs v]
add (item (4) of [VirtualBoard v]) to [BlackRookIdxs v]
UpdateMoveHashPosScore %n %n %n %b
UpdateMoveHashPosScore %n %n %n %b
end
end
end
end
end

define AddSimpleMoveNoCheck %n %n %n %n %b %b %b %b %b
set [TargetIdx v] to (((item (argument_reporter_string_number) of [IdxToFile v]) + (argument_reporter_string_number)) + ((((item (argument_reporter_string_number) of [IdxToRank v]) + (argument_reporter_string_number)) - (1)) * (8)))
AddMoveImpl %n %n %n %b %b %b %b %b

define DrawBoardAndWait
set [ProgressValue v] to [0]
broadcast (1 v) and wait
broadcast (1 v) and wait

define Profile_IncCounter %n
if <(IsProfilerEnabled) > (0)> then 
repeat until <not <(length of [Profile_Data v]) < (argument_reporter_string_number)>> 
add [0] to [Profile_Data v]
end
replace item (argument_reporter_string_number) of [Profile_Data v] with ((item (argument_reporter_string_number) of [Profile_Data v]) + (1))
end

when [p v] key pressed
if <(IsModeProfiler) = (0)> then 
set [IsModeProfiler v] to [1]
show list [Profile_Data v]
show variable [IsProfilerEnabled v]
 else 
set [IsModeProfiler v] to [0]
hide list [Profile_Data v]
hide variable [IsProfilerEnabled v]
end

when [d v] key pressed
if <(IsModeDeepeningDebug) = (0)> then 
set [IsModeDeepeningDebug v] to [1]
show variable [IdxDeepening v]
show variable [BestMinMaxRes v]
show variable [BestMove v]
show variable [PruningAlphaWindow v]
show variable [PruningBetaWindow v]
 else 
set [IsModeDeepeningDebug v] to [0]
hide variable [IdxDeepening v]
hide variable [BestMinMaxRes v]
hide variable [BestMove v]
hide variable [PruningAlphaWindow v]
hide variable [PruningBetaWindow v]
end

when [c v] key pressed
if <(IsModeCompetition) = (0)> then 
set [IsModeCompetition v] to [1]
SayAsync %s %n
 else 
set [IsModeCompetition v] to [0]
SayAsync %s %n
end

define UpdateMoveHashPosScore %n %n %n %b
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) - (PosPieceHash))
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
GetPosScore %n %n
if <argument_reporter_boolean> then 
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((item (argument_reporter_string_number) of [PosScoreDelta v]) - (PosScoreRes))
 else 
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((0) - (PosScoreRes))
end
GetPosScore %n %n
replace item (argument_reporter_string_number) of [PosScoreDelta v] with ((item (argument_reporter_string_number) of [PosScoreDelta v]) + (PosScoreRes))

define StoreMove %n %b
GetCurrentMove %n
replace item (argument_reporter_string_number) of [ChildNodeCutoffMove v] with [CurrentMove]
if <argument_reporter_boolean> then 
if <(argument_reporter_string_number) = (8)> then 
delete (item # of [CurrentMove] in [KillerMoves8 v]) of [KillerMoves8 v]
add [CurrentMove] to [KillerMoves8 v]
if <(length of [KillerMoves8 v]) > (4)> then 
delete (1) of [KillerMoves8 v]
end
 else 
if <(argument_reporter_string_number) = (7)> then 
delete (item # of [CurrentMove] in [KillerMoves7 v]) of [KillerMoves7 v]
add [CurrentMove] to [KillerMoves7 v]
if <(length of [KillerMoves7 v]) > (4)> then 
delete (1) of [KillerMoves7 v]
end
 else 
if <(argument_reporter_string_number) = (6)> then 
delete (item # of [CurrentMove] in [KillerMoves6 v]) of [KillerMoves6 v]
add [CurrentMove] to [KillerMoves6 v]
if <(length of [KillerMoves6 v]) > (4)> then 
delete (1) of [KillerMoves6 v]
end
 else 
if <(argument_reporter_string_number) = (5)> then 
delete (item # of [CurrentMove] in [KillerMoves5 v]) of [KillerMoves5 v]
add [CurrentMove] to [KillerMoves5 v]
if <(length of [KillerMoves5 v]) > (4)> then 
delete (1) of [KillerMoves5 v]
end
 else 
if <(argument_reporter_string_number) = (4)> then 
delete (item # of [CurrentMove] in [KillerMoves4 v]) of [KillerMoves4 v]
add [CurrentMove] to [KillerMoves4 v]
if <(length of [KillerMoves4 v]) > (4)> then 
delete (1) of [KillerMoves4 v]
end
 else 
if <(argument_reporter_string_number) = (3)> then 
delete (item # of [CurrentMove] in [KillerMoves3 v]) of [KillerMoves3 v]
add [CurrentMove] to [KillerMoves3 v]
if <(length of [KillerMoves3 v]) > (4)> then 
delete (1) of [KillerMoves3 v]
end
 else 
if <(argument_reporter_string_number) = (2)> then 
delete (item # of [CurrentMove] in [KillerMoves2 v]) of [KillerMoves2 v]
add [CurrentMove] to [KillerMoves2 v]
if <(length of [KillerMoves2 v]) > (4)> then 
delete (1) of [KillerMoves2 v]
end
 else 
if <(argument_reporter_string_number) = (1)> then 
delete (item # of [CurrentMove] in [KillerMoves1 v]) of [KillerMoves1 v]
add [CurrentMove] to [KillerMoves1 v]
if <(length of [KillerMoves1 v]) > (4)> then 
delete (1) of [KillerMoves1 v]
end
end
end
end
end
end
end
end
end
end

define EvaluateBoard
set [EvalResult v] to [0]
set [Idx v] to [1]
repeat (64) 
set [CurrentPiece v] to (item (Idx) of [Board v])
if <not <(CurrentPiece) = (Empty)>> then 
if <<([abs v] of (CurrentPiece) ::operators) = (BlackPawn)> and <(IsEndgame) = (1)>> then 
change [EvalResult v] by ((1.2) * (CurrentPiece))
 else 
change [EvalResult v] by (CurrentPiece)
end
GetPosScore %n %n
change [EvalResult v] by (PosScoreRes)
end
change [Idx v] by (1)
end

define IsDraw %n
CalcBoardAttackedByMove %n
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (1)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (1)>>> then 
set [IsDrawRes v] to [0]
stop [this script v]
end
set [IsDrawRes v] to [1]
CalculateMoves %n
replace item (argument_reporter_string_number) of [MovesIdx v] with [1]
repeat (item (argument_reporter_string_number) of [MovesCount v]) 
if <(IsDrawRes) = (1)> then 
ApplyMove %n
CalcBoardAttackedByMove %n
if <<<((argument_reporter_string_number) mod (2)) = (1)> and <(IsBlackChecked) = (0)>> or <<((argument_reporter_string_number) mod (2)) = (0)> and <(IsWhiteChecked) = (0)>>> then 
set [IsDrawRes v] to [0]
end
RevertMove %n
end
replace item (argument_reporter_string_number) of [MovesIdx v] with ((item (argument_reporter_string_number) of [MovesIdx v]) + (1))
end

define InitHashLookup
set [TTProbeCurrentAge v] to [0]
delete (all) of [PosPieceHashLookup v]
repeat (1024) 
add (pick random ((1) - (((65536) * (65536)) * ((65536) * (1)))) to (((65536) * (65536)) * ((65536) * (1)))) to [PosPieceHashLookup v]
end
ClearHashCache

when gf clicked
set [IsScratch3 v] to [0]
set [Scratch3TestVal v] to [1]
repeat (1000) 
set [Scratch3TestVal v] to ((2) * (Scratch3TestVal))
end
if <(join [x] [Scratch3TestVal]) = (x1.0715086071862673e+301)> then 
set [Scratch3TestVal v] to (timer)
wait (0) seconds
set [Scratch3TestVal v] to ((timer) - (Scratch3TestVal))
if <(Scratch3TestVal) > (0)> then 
set [IsScratch3 v] to [1]
end
end

define UndoPrevMove
if <(length of [GameMovesAN v]) > (0)> then 
GetSubstringRight %s %n
if <<(item ([floor v] of ((SubstringRes) mod (100)) ::operators) of [Board v]) > (0)> or <<([floor v] of (SubstringRes) ::operators) = (BlackQueensideCastling)> or <(SubstringRes) = (BlackKingsideCastling)>>> then 
set [IsBlackMove v] to [1]
 else 
set [IsBlackMove v] to [0]
end
ImportBoardImpl %s
delete (length of [BoardHistory v]) of [BoardHistory v]
delete (length of [BoardHistoryHash v]) of [BoardHistoryHash v]
if <<(item (length of [GameMovesAN v]) of [GameMovesAN v]) = (O-O)> or <(item (length of [GameMovesAN v]) of [GameMovesAN v]) = (O-O-O)>> then 
if <(IsBlackMove) = (1)> then 
set [HasBlackCastled v] to [0]
set [HasBlackKingMoved v] to [0]
 else 
set [HasWhiteCastled v] to [0]
set [HasWhiteKingMoved v] to [0]
end
end
if <(letter (1) of (item (length of [GameMovesAN v]) of [GameMovesAN v])) = (K)> then 
if <(IsBlackMove) = (1)> then 
set [HasBlackKingMoved v] to [0]
 else 
set [HasWhiteKingMoved v] to [0]
end
set [Idx v] to ((length of [GameMovesAN v]) - (2))
repeat until <(Idx) < (1)> 
if <(letter (1) of (item (Idx) of [GameMovesAN v])) = (K)> then 
if <(IsBlackMove) = (1)> then 
set [HasBlackKingMoved v] to [1]
 else 
set [HasWhiteKingMoved v] to [0]
end
end
change [Idx v] by (-1)
end
end
delete (length of [GameMovesAN v]) of [GameMovesAN v]
GetSubstringLeft %s %n
set [GameMoves v] to [SubstringRes]
end

define ClearHashCache
if <(IsFlash30Bug) = (1)> then 
stop [this script v]
end
if <(IsScratch3) = (1)> then 
set [HashCacheSize v] to [80000]
 else 
set [HashCacheSize v] to [400000]
end
delete (all) of [TTNodeHash v]
repeat (HashCacheSize) 
add [] to [TTNodeHash v]
end
delete (all) of [TTNodeBestMove v]
repeat (HashCacheSize) 
add [] to [TTNodeBestMove v]
end
delete (all) of [TTNodeScore v]
repeat (HashCacheSize) 
add [] to [TTNodeScore v]
end
delete (all) of [TTNodeDepth v]
repeat (HashCacheSize) 
add [] to [TTNodeDepth v]
end
delete (all) of [TTNodeAge v]
repeat (HashCacheSize) 
add [] to [TTNodeAge v]
end
delete (all) of [TTNodeType v]
repeat (HashCacheSize) 
add [] to [TTNodeType v]
end
delete (all) of [TTNodeChecked v]
repeat (HashCacheSize) 
add [] to [TTNodeChecked v]
end
delete (all) of [TTNodeHorizon v]
repeat (HashCacheSize) 
add [] to [TTNodeHorizon v]
end
delete (all) of [TTBoardAge v]
repeat (HashCacheSize) 
add [] to [TTBoardAge v]
end
delete (all) of [TTBoardHash v]
repeat (HashCacheSize) 
add [] to [TTBoardHash v]
end
delete (all) of [TTBoardScore1 v]
repeat (HashCacheSize) 
add [] to [TTBoardScore1 v]
end
delete (all) of [TTBoardScore2 v]
repeat (HashCacheSize) 
add [] to [TTBoardScore2 v]
end
delete (all) of [TTBoardScore3 v]
repeat (HashCacheSize) 
add [] to [TTBoardScore3 v]
end
delete (all) of [TTNodeBlackMobility v]
repeat (HashCacheSize) 
add [] to [TTNodeBlackMobility v]
end
delete (all) of [TTNodeWhiteMobility v]
repeat (HashCacheSize) 
add [] to [TTNodeWhiteMobility v]
end

when [j v] key pressed
if <not <(backdrop [name v] ::looks) = (Intro)>> then 
if <(IsModeJunior) = (0)> then 
set [IsModeJunior v] to [1]
SayAsync %s %n
broadcast (1 v)
 else 
set [IsModeJunior v] to [0]
SayAsync %s %n
broadcast (1 v)
end
end

when gf clicked
set [IsModeJunior v] to [0]
set [IsModeProfiler v] to [0]
set [IsModeDeepeningDebug v] to [0]
set [IsModeCompetition v] to [0]

define InitPawnSquarePreCastling
delete (all) of [PawnPieceSquarePreCastling v]
LoadList %s %s

define GetCurrentMoveHash
set [CurrentMoveHash v] to [0]
set [Idx v] to [1]
repeat (64) 
GetPosPieceHash %n %n
set [CurrentMoveHash v] to ((CurrentMoveHash) + (PosPieceHash))
change [Idx v] by (1)
end

define InitMoveLookup
delete (all) of [KnightMoveOffsets v]
delete (all) of [KingMoveOffsets v]
add [-2] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [-2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [-2] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [-2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [-1] to [KnightMoveOffsets v]
add [2] to [KnightMoveOffsets v]
add [1] to [KnightMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [-1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [0] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
add [1] to [KingMoveOffsets v]
delete (all) of [MoveLookupStraight v]
delete (all) of [MoveLookupCross v]
delete (all) of [MoveLookupOffsetsStraight v]
delete (all) of [MoveLookupOffsetsCross v]
delete (all) of [MoveLookupKnight v]
delete (all) of [MoveLookupKing v]
delete (all) of [MoveLookupIndexOffset v]
delete (all) of [MoveLookupLineIndexOffset v]
add [1] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [1] to [MoveLookupOffsetsStraight v]
add [-1] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [0] to [MoveLookupOffsetsStraight v]
add [-1] to [MoveLookupOffsetsStraight v]
add [1] to [MoveLookupOffsetsCross v]
add [1] to [MoveLookupOffsetsCross v]
add [1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
add [1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
add [-1] to [MoveLookupOffsetsCross v]
set [Idx v] to [1]
repeat (64) 
set [IdxSub v] to [1]
repeat (4) 
set [X v] to (item (Idx) of [IdxToFile v])
set [Y v] to (item (Idx) of [IdxToRank v])
repeat (8) 
change [X v] by (item (IdxSub) of [MoveLookupOffsetsStraight v])
change [Y v] by (item ((IdxSub) + (1)) of [MoveLookupOffsetsStraight v])
add [-1] to [MoveLookupStraight v]
if <<(Y) > (0)> and <(Y) < (9)>> then 
if <<(X) > (0)> and <(X) < (9)>> then 
set [TargetIdx v] to ((X) + (((Y) - (1)) * (8)))
replace item (last) of [MoveLookupStraight v] with [TargetIdx]
end
end
end
change [IdxSub v] by (2)
end
set [IdxSub v] to [1]
repeat (4) 
set [X v] to (item (Idx) of [IdxToFile v])
set [Y v] to (item (Idx) of [IdxToRank v])
repeat (8) 
change [X v] by (item (IdxSub) of [MoveLookupOffsetsCross v])
change [Y v] by (item ((IdxSub) + (1)) of [MoveLookupOffsetsCross v])
add [-1] to [MoveLookupCross v]
if <<(Y) > (0)> and <(Y) < (9)>> then 
if <<(X) > (0)> and <(X) < (9)>> then 
set [TargetIdx v] to ((X) + (((Y) - (1)) * (8)))
replace item (last) of [MoveLookupCross v] with [TargetIdx]
end
end
end
change [IdxSub v] by (2)
end
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (64) 
insert (((Idx) - (1)) * (8)) at (Idx) of [MoveLookupIndexOffset v]
insert (((Idx) - (1)) * (32)) at (Idx) of [MoveLookupLineIndexOffset v]
change [Idx v] by (1)
end
set [Idx v] to [1]
repeat (64) 
set [IdxSub v] to [1]
repeat (8) 
GetTargetIdx %n %n %n
if <not <(GetTargetIdxRes) = (-1)>> then 
add [GetTargetIdxRes] to [MoveLookupKing v]
end
change [IdxSub v] by (2)
end
repeat until <(length of [MoveLookupKing v]) = ((Idx) * (8))> 
add [-1] to [MoveLookupKing v]
end
set [IdxSub v] to [1]
repeat (8) 
GetTargetIdx %n %n %n
if <not <(GetTargetIdxRes) = (-1)>> then 
add [GetTargetIdxRes] to [MoveLookupKnight v]
end
change [IdxSub v] by (2)
end
repeat until <(length of [MoveLookupKnight v]) = ((Idx) * (8))> 
add [-1] to [MoveLookupKnight v]
end
change [Idx v] by (1)
end

define EvaluateBoardExtended2 %s
set [EvalExtendedResult2 v] to [0]
if <(IsEndgame) = (0)> then 
TTProbeBoard %s
if <<(TTProbeRes) = (1)> and <not <(TTProbeBoardScore2Res) = ()>>> then 
set [EvalExtendedResult2 v] to [TTProbeBoardScore2Res]
stop [this script v]
end
set [BlackKingIdx v] to (item (argument_reporter_string_number) of [BlackKingIdxs v])
set [WhiteKingIdx v] to (item (argument_reporter_string_number) of [WhiteKingIdxs v])
set [File v] to [1]
repeat (8) 
if <<(item (File) of [BlackPawnCount v]) = (0)> and <(item (File) of [WhitePawnCount v]) = (0)>> then 
if <([abs v] of ((File) - (item (BlackKingIdx) of [IdxToFile v])) ::operators) < (2)> then 
set [Factor v] to [3]
 else 
set [Factor v] to [2]
end
if <<(length of [WhiteRookIdxs v]) > (0)> and <(item (item (1) of [WhiteRookIdxs v]) of [IdxToFile v]) = (File)>> then 
change [EvalExtendedResult2 v] by ((5) * (Factor))
end
if <<(length of [WhiteRookIdxs v]) > (1)> and <(item (item (2) of [WhiteRookIdxs v]) of [IdxToFile v]) = (File)>> then 
change [EvalExtendedResult2 v] by ((5) * (Factor))
end
if <<(length of [WhiteQueenIdxs v]) > (0)> and <(item (item (1) of [WhiteQueenIdxs v]) of [IdxToFile v]) = (File)>> then 
change [EvalExtendedResult2 v] by ((0) * (Factor))
end
if <([abs v] of ((File) - (item (WhiteKingIdx) of [IdxToFile v])) ::operators) < (2)> then 
set [Factor v] to [3]
 else 
set [Factor v] to [2]
end
if <<(length of [BlackRookIdxs v]) > (0)> and <(item (item (1) of [BlackRookIdxs v]) of [IdxToFile v]) = (File)>> then 
change [EvalExtendedResult2 v] by ((-5) * (Factor))
end
if <<(length of [BlackRookIdxs v]) > (1)> and <(item (item (2) of [BlackRookIdxs v]) of [IdxToFile v]) = (File)>> then 
change [EvalExtendedResult2 v] by ((-5) * (Factor))
end
if <<(length of [BlackQueenIdxs v]) > (0)> and <(item (item (1) of [BlackQueenIdxs v]) of [IdxToFile v]) = (File)>> then 
change [EvalExtendedResult2 v] by ((0) * (Factor))
end
end
change [File v] by (1)
end
TTStoreBoard %s %s %s %s
end

define EvaluateBoardExtended3 %s
set [EvalExtendedResult3 v] to [0]
TTProbeBoard %s
if <<(TTProbeRes) = (1)> and <not <(TTProbeBoardScore3Res) = ()>>> then 
set [EvalExtendedResult3 v] to [TTProbeBoardScore3Res]
stop [this script v]
end
set [BlackKingIdx v] to (item (argument_reporter_string_number) of [BlackKingIdxs v])
set [WhiteKingIdx v] to (item (argument_reporter_string_number) of [WhiteKingIdxs v])
set [Idx v] to [1]
repeat (64) 
if <([abs v] of ((item (Idx) of [IdxToRank v]) - (item (BlackKingIdx) of [IdxToRank v])) ::operators) < (2)> then 
if <([abs v] of ((item (Idx) of [IdxToFile v]) - (item (BlackKingIdx) of [IdxToFile v])) ::operators) < (2)> then 
if <<(item (Idx) of [BoardAttackedByWhite v]) > (0)> and <not <<(item (Idx) of [BoardAttackedByBlack v]) > (1)> and <(item (Idx) of [BoardAttackedByBlackPiece v]) < (BlackQueen)>>>> then 
change [EvalExtendedResult3 v] by (-15)
end
end
end
if <([abs v] of ((item (Idx) of [IdxToRank v]) - (item (WhiteKingIdx) of [IdxToRank v])) ::operators) < (2)> then 
if <([abs v] of ((item (Idx) of [IdxToFile v]) - (item (WhiteKingIdx) of [IdxToFile v])) ::operators) < (2)> then 
if <<(item (Idx) of [BoardAttackedByBlack v]) > (0)> and <not <<(item (Idx) of [BoardAttackedByWhite v]) > (1)> and <(item (Idx) of [BoardAttackedByWhitePiece v]) > (WhiteQueen)>>>> then 
change [EvalExtendedResult3 v] by (15)
end
end
end
change [Idx v] by (1)
end
TTStoreBoard %s %s %s %s

define ImportBoardImpl %s
set [Idx v] to [1]
set [IdxString v] to [1]
set [CurrentPiece v] to []
repeat until <(IdxString) > (length of (argument_reporter_string_number))> 
if <(letter (IdxString) of (argument_reporter_string_number)) = (,)> then 
replace item (Idx) of [Board v] with [CurrentPiece]
change [Idx v] by (1)
set [CurrentPiece v] to []
 else 
set [CurrentPiece v] to (join [CurrentPiece] (letter (IdxString) of (argument_reporter_string_number)))
end
change [IdxString v] by (1)
end
