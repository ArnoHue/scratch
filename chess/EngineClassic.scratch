//----- Green flag events ---------------------------------------------------------------------------------------------

WhenGreenFlagClicked()
{
    Level = 4;
    GoK_Level = 4;
    If is compiled?
    {
        IsScratch3 = 0;
    }
    Else
    {
        IsScratch3 = 1;
    }
    Call OnRestart;
}


//----- Key pressed events --------------------------------------------------------------------------------------------

WhenKeyPressed(l)
{
    If (DebugMode == -1)
    {
        Stop(this script);
    }
    List.Show(Logfile);
}

WhenKeyPressed(p)
{
    If (ProfilerMode == -1)
    {
        Stop(this script);
    }
    If ((ProfilerMode % 10) == 0)
    {
        ProfilerMode += 1;
        IsBlockProfilerEnabled = 0;
        Call SayAsync("Statistical profiling enabled. Press 'l' to view data.")(2);
    }
    Else
    {
        If ((ProfilerMode % 10) == 1)
        {
            ProfilerMode += 1;
            IsBlockProfilerEnabled = 1;
            Call SayAsync("Full profiling enabled. Press 'l' / 'r' to view data.")(2);
        }
        Else
        {
            If ((ProfilerMode % 10) == 2)
            {
                ProfilerMode += -2;
                IsBlockProfilerEnabled = 0;
                Call SayAsync("Profiling disabled.")(2);
            }
        }
    }
}

WhenKeyPressed(d)
{
    If (DebugMode == -1)
    {
        Stop(this script);
    }
    If (DebugMode == 0)
    {
        DebugMode = 1;
        Variable.Show(IdxDeepening);
        Variable.Show(BestMinMaxRes);
        Variable.Show(BestMove);
        Variable.Show(NPS);
        Variable.Show(MPS);
        Variable.Show(PV);
    }
    Else
    {
        DebugMode = 0;
        Variable.Hide(IdxDeepening);
        Variable.Hide(BestMinMaxRes);
        Variable.Hide(BestMove);
        Variable.Hide(NPS);
        Variable.Hide(MPS);
        Variable.Hide(PV);
    }
}

WhenKeyPressed(v)
{
    Call SayAsync("Game of Kings Chess Version 6.9248a (06.01.2026) by ArnoHu")(5);
}

WhenKeyPressed(r)
{
    If (ProfilerMode == -1)
    {
        Stop(this script);
    }
    If (ProfilerMode < 10)
    {
        ProfilerMode += 10;
        List.Show(Profile_Data);
    }
    Else
    {
        ProfilerMode += -10;
        List.Hide(Profile_Data);
    }
}

WhenKeyPressed(t)
{
    If (TimeControl == -1)
    {
        Stop(this script);
    }
    If (TimeControl == 0)
    {
        TimeControl = 1;
        Variable.Show(CustomThinkTime);
    }
    Else
    {
        TimeControl = 0;
        Variable.Hide(CustomThinkTime);
    }
}

WhenKeyPressed(e)
{
    Call LogEval;
    List.Show(Logfile);
}


//----- Broadcast received events -------------------------------------------------------------------------------------

WhenBroadcastReceived(advisor)
{
    If (IsExecutionRunning == 0)
    {
        If (IsAdvisorEnabled == 1)
        {
            IsAdvisorEnabled = 0;
            Call DrawBoardAndWait;
        }
        Else
        {
            IsAdvisorEnabled = 1;
            If (Not ((Stg_FromSquareIdx == -1)))
            {
                Event.BroadcastAndWait("fromsquareselected");
            }
        }
    }
}

WhenBroadcastReceived(export)
{
    If (IsExecutionRunning == 0)
    {
        Call ExportBoardFEN((IsPlayerBlack == 1))((1 == 1));
        List.DeleteItem(ExportData, all);
        List.Add(ExportData, "DATA EXPORT");
        List.Add(ExportData, "Select data row by triple-clicking. You can then copy to");
        List.Add(ExportData, "clipboard by right-click / Copy or by pressing Ctrl-C.");
        List.Add(ExportData, "");
        List.Add(ExportData, "PGN (Game Protocol):");
        Call ExportMovesPGN;
        List.Add(ExportData, ExportMovesPGN);
        List.Add(ExportData, "");
        List.Add(ExportData, "FEN (Current Board):");
        List.Add(ExportData, ExportDataFEN);
        List.Add(ExportData, "");
        List.Add(ExportData, "Board Analysis Link (lichess.org)");
        List.Add(ExportData, ExportDataFENLichess);
        List.Show(ExportData);
        If (1 == 0)
        {
            Call SayAsync("You can copy FEN data, lichess.org URL or PGN data to your clipboard via Ctrl-C. Select data by triple-click.")(5);
        }
    }
}

WhenBroadcastReceived(fromsquareselected)
{
    If ((IsAdvisorEnabled == 1) And (Not ((Stg_FromSquareIdx == -1))))
    {
        Stg_BestMoveFromIdx = Stg_FromSquareIdx;
        List.DeleteAll(Selection_UserMoveTargets);
        Call GenerateMovesPublic(2);
        List.ReplaceItem(MovesIdx, 2, 1);
        Repeat (MovesCount[2])
        {
            Call GetCurrentMove(2);
            FSS.CurrentMove = CurrentMove;
            If (floor((FSS.CurrentMove / 100)) == Stg_FromSquareIdx)
            {
                Call ApplyMove(2);
                Call CalcBoardAttackedByMove(3);
                Call RevertMove(2);
                If (IsOppSideChecked == 0)
                {
                    List.Add(Selection_UserMoveTargets, floor((FSS.CurrentMove % 100)));
                }
            }
            Else
            {
                If (Board[Stg_FromSquareIdx] == GoK_OppKing)
                {
                    If (FSS.CurrentMove == GoK_OppKingsideCastling)
                    {
                        List.Add(Selection_UserMoveTargets, VirtualBoard[63]);
                    }
                    Else
                    {
                        If (FSS.CurrentMove == GoK_OppQueensideCastling)
                        {
                            List.Add(Selection_UserMoveTargets, VirtualBoard[59]);
                        }
                    }
                }
            }
            List.ReplaceItem(MovesIdx, 2, (MovesIdx[2] + 1));
        }
        Call DrawBoardAndWait;
        Event.BroadcastAndWait("StampUserMoveTargets");
    }
}

WhenBroadcastReceived(import)
{
    If (IsExecutionRunning == 0)
    {
        Sensing.Ask("Board data import. Please paste FEN data from your clipboard into the text field by pressing Ctrl-V.");
        If (Variable.Length(Sensing.Answer()) > 0)
        {
            Call ImportBoard(Sensing.Answer());
        }
    }
}

WhenBroadcastReceived(levelchanged)
{
    Level = GoK_Level;
    Call DrawBoardAndWait;
}

WhenBroadcastReceived(sayasyncmsg)
{
    Looks.Say(SayAsyncText, SayAsyncDuration);
}

WhenBroadcastReceived(showmoves)
{
    Call ExportMovesPGN;
    List.DeleteItem(ExportMoves, all);
    List.Add(ExportMoves, ExportMovesPGN);
    List.Show(ExportMoves);
    Call SayAsync("You can copy PGN data to your clipboard via Ctrl-C")(5);
}

WhenBroadcastReceived(squareclicked)
{
    If ((IsExecutionRunning == 0) And (GoK_IsGameSuspended == 0))
    {
        Call EnterExecution;
        If (Board[Stg_SquareClickedIdx] < 0)
        {
            MoveFromIdx = Stg_SquareClickedIdx;
            Stg_FromSquareIdx = Stg_SquareClickedIdx;
            Event.BroadcastAndWait("fromsquareselected");
        }
        Else
        {
            If ((Not ((MoveFromIdx == -1))) And (Not ((Stg_FromSquareIdx == -1))))
            {
                MoveToIdx = Stg_SquareClickedIdx;
                Stg_ToSquareIdx = Stg_SquareClickedIdx;
                Event.BroadcastAndWait("tosquareselected");
                If ((Board[MoveFromIdx] < 0) And (Not ((MoveFromIdx == MoveToIdx))))
                {
                    UserMove = "";
                    If ((Board[MoveFromIdx] == GoK_OppKing) And (MoveFromIdx == VirtualBoard[61]))
                    {
                        If ((MoveToIdx == VirtualBoard[59]) And (Board[VirtualBoard[57]] == GoK_OppRook))
                        {
                            Call GenerateMovesPublic(2);
                            If List.ContainsItem(Moves2, GoK_OppQueensideCastling)
                            {
                                UserMove = GoK_OppQueensideCastling;
                            }
                            Else
                            {
                                UserMove = Operator.Join(VirtualBoard[61], VirtualBoard[59]);
                            }
                        }
                        If ((MoveToIdx == VirtualBoard[63]) And (Board[VirtualBoard[64]] == GoK_OppRook))
                        {
                            Call GenerateMovesPublic(2);
                            If List.ContainsItem(Moves2, GoK_OppKingsideCastling)
                            {
                                UserMove = GoK_OppKingsideCastling;
                            }
                            Else
                            {
                                UserMove = Operator.Join(VirtualBoard[61], VirtualBoard[63]);
                            }
                        }
                    }
                    If (UserMove == "")
                    {
                        UserMove = ((MoveFromIdx * 100) + MoveToIdx);
                        If ((Board[MoveFromIdx] == GoK_OppPawn) And (MoveToIdx < 9))
                        {
                            UserMove = (UserMove + 0.1);
                        }
                    }
                }
                Call ExecuteUserMove(UserMove);
            }
        }
        Call ExitExecution;
    }
}

WhenBroadcastReceived(stageclicked)
{
    List.Hide(ExportData);
    List.Hide(ExportMoves);
    List.Hide(Logfile);
    If (Not ((ProfilerMode < 10)))
    {
        ProfilerMode += -10;
        List.Hide(Profile_Data);
    }
    If (IsExecutionRunning == 0)
    {
        Looks.Say("");
    }
}

WhenBroadcastReceived(startgame)
{
    Motion.GoToXY(240, 80);
    ExecutionDepth = 0;
    IsExecutionRunning = 0;
    IsPlayerBlack = GoK_IsPlayerBlack;
    Call EnterExecution;
    Call InitBoard;
    Call DrawBoardAndWait;
    Looks.Say("Initializing engine, please wait...");
    Control.Wait(0.1);
    Call InitBoardPhase2;
    Call ExitExecution;
    Call ExecuteInit;
    Looks.Say("");
}

WhenBroadcastReceived(triggerrestart)
{
    Call OnRestart;
}

WhenBroadcastReceived(undo)
{
    If (IsExecutionRunning == 0)
    {
        Call UndoMove;
        Call OnEvaluationChanged(0);
        Looks.Say("");
    }
}


//----- Custom blocks -------------------------------------------------------------------------------------------------

Define //(string Comment) (warp=true)
{
}

Define AddBoardToHistory(string WasEngineMove) (warp=true)
{
    Call GetBoardString;
    List.Add(BoardHistory, GetBoardStringRes);
    Call CreateCurrentBoardHash;
    List.Add(BoardHistoryHash, CurrentBoardHash);
    List.Add(BoardHistoryMetaState, Operator.Join(Operator.Join(Operator.Join(HasOwnCastled, HasOwnKingMoved), Operator.Join(HasOwnRookKSMoved, HasOwnRookQSMoved)), Operator.Join(Operator.Join(HasOppCastled, HasOppKingMoved), Operator.Join(HasOppRookKSMoved, HasOppRookQSMoved))));
    List.Add(BoardHistoryWasEngineMove, WasEngineMove);
}

Define AddLookupMove(string SourceIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool LookupMoveTypeKing) (warp=true)
{
    ALM.SourcePiece = Board[(SourceIdx + 0)];
    ALM.Idx = MoveLookupIndexOffset[(SourceIdx + 0)];
    ALM.Count = 1;
    Repeat (8)
    {
        If LookupMoveTypeKing
        {
            ALM.TargetIdx = MoveLookupKing[(ALM.Idx + ALM.Count)];
        }
        Else
        {
            ALM.TargetIdx = MoveLookupKnight[(ALM.Idx + ALM.Count)];
        }
        If (ALM.TargetIdx == -1)
        {
            Stop(this script);
        }
        If CalcAttackState
        {
            Call AddMoveImplLookup(SourceIdx)(ALM.TargetIdx)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
        }
        Else
        {
            If (Board[(ALM.TargetIdx + 0)] == 0)
            {
                If CapturesOnly
                {
                    Call AddPotentialQuiescenceMove(SourceIdx)(ALM.TargetIdx)(ALM.SourcePiece)(Depth);
                }
                Else
                {
                    Call AddMoveImplLookup(SourceIdx)(ALM.TargetIdx)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                }
            }
            Else
            {
                If (ALM.SourcePiece > 0)
                {
                    If (Board[(ALM.TargetIdx + 0)] < 0)
                    {
                        Call AddMoveImplLookup(SourceIdx)(ALM.TargetIdx)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                    }
                }
                Else
                {
                    If (Board[(ALM.TargetIdx + 0)] > 0)
                    {
                        Call AddMoveImplLookup(SourceIdx)(ALM.TargetIdx)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                    }
                }
            }
        }
        ALM.Count += 1;
    }
}

Define AddMoveImpl(string SourceIdx)(string TargetIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    If CalcAttackState
    {
        AMI.SourcePiece = (Board[(SourceIdx + 0)] + 0);
        AMI.TargetPiece = (Board[(TargetIdx + 0)] + 0);
        If (CalcAttackStateWithMobility == 1)
        {
            AMI.Idx = (((SourceIdx - 1) * 32) + 1);
            AMI.Count = (PieceMobilityPrep[(AMI.Idx + 0)] + 1);
            List.ReplaceItem(PieceMobilityPrep, (AMI.Idx + 0), AMI.Count);
            List.ReplaceItem(PieceMobilityPrep, (AMI.Idx + AMI.Count), TargetIdx);
        }
        If (AMI.SourcePiece > 0)
        {
            AMI.Attacked = (BoardAttackedByOwn[(TargetIdx + 0)] + 0);
            If ((AMI.Attacked == 0) Or (Board[BoardAttackedByOwnPiece[(TargetIdx + 0)]] > AMI.SourcePiece))
            {
                List.ReplaceItem(BoardAttackedByOwnPiece, (TargetIdx + 0), SourceIdx);
            }
            If (AMI.Attacked < 9)
            {
                List.ReplaceItem(BoardAttackedByOwn, (TargetIdx + 0), (AMI.Attacked + 1));
            }
            If (AMI.TargetPiece == GoK_OppKing)
            {
                IsOppSideChecked = 1;
                List.Add(KingAttackLines, SourceIdx);
            }
        }
        Else
        {
            If (AMI.SourcePiece < 0)
            {
                AMI.Attacked = (BoardAttackedByOpp[(TargetIdx + 0)] + 0);
                If ((AMI.Attacked == 0) Or (Board[BoardAttackedByOppPiece[(TargetIdx + 0)]] < AMI.SourcePiece))
                {
                    List.ReplaceItem(BoardAttackedByOppPiece, (TargetIdx + 0), SourceIdx);
                }
                If (AMI.Attacked < 9)
                {
                    List.ReplaceItem(BoardAttackedByOpp, (TargetIdx + 0), (AMI.Attacked + 1));
                }
                If (AMI.TargetPiece == GoK_OwnKing)
                {
                    IsOwnSideChecked = 1;
                    List.Add(KingAttackLines, SourceIdx);
                }
            }
        }
        Stop(this script);
    }
    If (CheckedState[(Depth + 0)] == 1)
    {
        If (Not ((Operator.LetterOf(CheckedStateAttackLines[(Depth + 0)], TargetIdx) == 1)))
        {
            If (BoardAttackedCalculated[(Depth + 0)] == 1)
            {
                If (Not ((abs(Board[(SourceIdx + 0)]) == GoK_OwnKing)))
                {
                    If (Not ((abs(Board[(TargetIdx + 0)]) == GoK_OwnKing)))
                    {
                        If ((Depth > 2) And (EnPassantTarget[(Depth + 0)] == ""))
                        {
                            Stop(this script);
                        }
                    }
                }
            }
        }
    }
    AMI.CurrentMove = ((SourceIdx * 100) + TargetIdx);
    If (abs(Board[(SourceIdx + 0)]) == GoK_OwnPawn)
    {
        If ((IdxToRank[(TargetIdx + 0)] == 1) Or (IdxToRank[(TargetIdx + 0)] == 8))
        {
            Call AddSpecialMove((AMI.CurrentMove + 0.1))(Depth);
            Call AddSpecialMove((AMI.CurrentMove + 0.2))(Depth);
            Call AddSpecialMove((AMI.CurrentMove + 0.3))(Depth);
            Call AddSpecialMove((AMI.CurrentMove + 0.4))(Depth);
            Stop(this script);
        }
    }
    List.Add(CalcMovesMoveList, AMI.CurrentMove);
    Call GetNormalizedMove(AMI.CurrentMove);
    If Operator.Contains(PickedMoves[(Depth + 0)], NormalizedMoveRes)
    {
        If ((Depth % 2) == 1)
        {
            List.Add(CalcMovesScoreList, MaxMoveOrderScore);
        }
        Else
        {
            List.Add(CalcMovesScoreList, (0 - MaxMoveOrderScore));
        }
        Stop(this script);
    }
    Call GetMoveScore(Board[(SourceIdx + 0)])(Board[(TargetIdx + 0)])(SourceIdx)(TargetIdx)(AMI.CurrentMove)(Depth);
    List.Add(CalcMovesScoreList, MoveScoreRes);
}

Define AddMoveImplLookup(string SourceIdx)(string TargetIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool IsKing) (warp=true)
{
    If IsKing
    {
        If (Not (CalcAttackState))
        {
            If ((Depth % 2) == 1)
            {
                If (ChebyshevDistance[((TargetIdx * 100) + KingIdxOpp)] < 2)
                {
                    Stop(this script);
                }
            }
            Else
            {
                If (ChebyshevDistance[((TargetIdx * 100) + KingIdxtOwn)] < 2)
                {
                    Stop(this script);
                }
            }
            If (BoardAttackedCalculated[(Depth + 0)] == 0)
            {
                GenerateMovesRequiresAttackRecalc = 1;
                Stop(this script);
            }
            Else
            {
                If (PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + TargetIdx)] > 0)
                {
                    Stop(this script);
                }
            }
        }
    }
    Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)(CalcAttackState)(CapturesOnly);
}

Define AddMoveToList(string Move)(string Depth) (warp=true)
{
    List.ReplaceItem(Moves, (((Depth - 1) * MaxMovesPerGeneration) + (MovesCount[Depth] + 1)), Move);
    List.ReplaceItem(MovesCount, Depth, (MovesCount[Depth] + 1));
    If (Depth == 1)
    {
        List.Add(Moves1, Move);
    }
    Else
    {
        If (Depth == 2)
        {
            List.Add(Moves2, Move);
        }
    }
}

Define AddPotentialQuiescenceMove(string SourceIdx)(string TargetIdx)(string Piece)(string Depth) (warp=true)
{
    Call //("Include move in quiescence search if it's a check or check evasion");
    If (CheckedState[Depth] == 1)
    {
        If (BoardAttackedCalculated[(Depth + 0)] == 0)
        {
            GenerateMovesRequiresAttackRecalc = 1;
            Stop(this script);
        }
        If (abs(Piece) == GoK_OwnKing)
        {
            If (PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + TargetIdx)] > 0)
            {
                Stop(this script);
            }
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
        }
        Else
        {
            If (Operator.LetterOf(CheckedStateAttackLines[Depth], (TargetIdx + 0)) == 1)
            {
                Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            }
        }
        Stop(this script);
    }
    If (Piece == GoK_OwnPawn)
    {
        If (IdxToRank[(TargetIdx + 0)] == 8)
        {
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
    }
    If (Piece == GoK_OppPawn)
    {
        If (IdxToRank[(TargetIdx + 0)] == 1)
        {
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
    }
    If (IsPotentialNonCapQuiescMove == 0)
    {
        Stop(this script);
    }
    APCM.TargetPiece = Board[(TargetIdx + 0)];
    List.ReplaceItem(Board, TargetIdx, Board[(SourceIdx + 0)]);
    List.ReplaceItem(Board, SourceIdx, 0);
    Call IsCheckingPieceDiscovery(SourceIdx)(TargetIdx)(Depth);
    List.ReplaceItem(Board, SourceIdx, Board[(TargetIdx + 0)]);
    List.ReplaceItem(Board, TargetIdx, APCM.TargetPiece);
    If (IsCheckingPieceRes == 1)
    {
        Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
        Stop(this script);
    }
    If (abs(Piece) == GoK_OwnKing)
    {
        Stop(this script);
    }
    CurrentMove = "";
    If (Piece > 0)
    {
        If (MovePosLookupOwnLegal[((PieceIdxLookup[(Piece + 0)] * 10000) + ((TargetIdx * 100) + KingIdxOpp))] == 0)
        {
            Stop(this script);
        }
        If (Piece == GoK_OwnPawn)
        {
            If (IdxToFile[(TargetIdx + 0)] == IdxToFile[(KingIdxOpp + 0)])
            {
                Stop(this script);
            }
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
        If (Piece == GoK_OwnKnight)
        {
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
        APCM.CurrentMove = ((TargetIdx * 100) + KingIdxOpp);
    }
    Else
    {
        If (MovePosLookupOppLegal[((PieceIdxLookup[(0 - Piece)] * 10000) + ((TargetIdx * 100) + KingIdxtOwn))] == 0)
        {
            Stop(this script);
        }
        If (Piece == GoK_OppPawn)
        {
            If (IdxToFile[(TargetIdx + 0)] == IdxToFile[(KingIdxtOwn + 0)])
            {
                Stop(this script);
            }
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
        If (Piece == GoK_OppKnight)
        {
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
        APCM.CurrentMove = ((TargetIdx * 100) + KingIdxtOwn);
    }
    APCM.SourceIdx = TargetIdx;
    IdxInc = MovePathStepInc[(APCM.CurrentMove + 0)];
    Repeat ((MovePathDelta[(APCM.CurrentMove + 0)] - 1))
    {
        APCM.SourceIdx += IdxInc;
        If (Not ((Board[(APCM.SourceIdx + 0)] == 0)))
        {
            Stop(this script);
        }
    }
    Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
}

Define AddSlidingMove(string SourceIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool SlidingMoveTypeStraight) (warp=true)
{
    If CalcAttackState
    {
        Call ASMAttack(SourceIdx)(Depth)(SlidingMoveTypeStraight);
    }
    Else
    {
        Call ASM(SourceIdx)(Depth)(CapturesOnly)(SlidingMoveTypeStraight);
    }
}

Define AddSpecialMove(string Move)(string Depth) (warp=true)
{
    List.Add(CalcMovesMoveList, Move);
    If (Variable.Length(PickedMoves[Depth]) > 0)
    {
        Call GetNormalizedMove(Move);
        If Operator.Contains(PickedMoves[Depth], NormalizedMoveRes)
        {
            If ((Depth % 2) == 1)
            {
                List.Add(CalcMovesScoreList, MaxMoveOrderScore);
            }
            Else
            {
                List.Add(CalcMovesScoreList, (0 - MaxMoveOrderScore));
            }
            Stop(this script);
        }
    }
    SourcePiece = "";
    If (Variable.Length(Move) == 6)
    {
        SourcePiece = GoK_OwnPawn;
    }
    If (floor((Move / 100)) == 0)
    {
        SourcePiece = GoK_OwnKing;
    }
    If ((Depth % 2) == 1)
    {
        Call GetMoveScore(SourcePiece)(0)("")("")(Move)(Depth);
    }
    Else
    {
        Call GetMoveScore((0 - SourcePiece))(0)("")("")(Move)(Depth);
    }
    List.Add(CalcMovesScoreList, MoveScoreRes);
}

Define AddToFiftyMoves(bool IsCaptureOrPawnMove) (warp=true)
{
    If IsCaptureOrPawnMove
    {
        List.Add(BoardHistoryFiftyMoves, 0);
    }
    Else
    {
        If (List.Length(BoardHistoryFiftyMoves) == 0)
        {
            List.Add(BoardHistoryFiftyMoves, 0);
        }
        List.Add(BoardHistoryFiftyMoves, (BoardHistoryFiftyMoves[List.Length(BoardHistoryFiftyMoves)] + 1));
    }
}

Define AlphaBetaMinMax(string Alpha)(string Beta)(string MinDepth)(string MaxDepth)(bool InitialDeepening)(string QuiescenceDepth)(bool ShowProgress) (warp=true)
{
    MinMaxAlpha = Alpha;
    MinMaxBeta = Beta;
    MinMaxEvalRes = "";
    MinMaxMoveRes = "";
    Call InitAlphaBeta((MaxDepth - 1))(InitialDeepening);
    Call Evaluate(0)((1 == 0));
    List.ReplaceItem(Alphas, MinDepth, Alpha);
    List.ReplaceItem(Betas, MinDepth, Beta);
    Eval.DebugLog = 0;
    MoveCount = 0;
    MoveCountQ = 0;
    NodeCount = 0;
    NodeCountQ = 0;
    ProfBestMoveCount = 0;
    ProfBestMoveIdxSum = 0;
    ProfBestMoveCountQ = 0;
    ProfBestMoveIdxSumQ = 0;
    MinMaxTimer = (Sensing.DaysSince2000() * 86400);
    Call AlphaBetaMinMaxImpl(MinDepth)(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)((1 == 0))((1 == 0))(ShowProgress)((MaxDepth - 1))((1 == 0))("");
    MinMaxTimer = ((Sensing.DaysSince2000() * 86400) - MinMaxTimer);
    Call ExportBoardFEN((IsPlayerBlack == 1))((1 == 0));
    Call Log("PV: ")("[FEN "")(ExportDataFEN)(""] ")(PV)("")("")("");
    If ((ProfilerMode % 10) > 0)
    {
        Call Log("========================================")("")("")("")("")("")("")("");
        Call Log("SEARCH STATS")("")("")("")("")("")("")("");
        Call Log("========================================")("")("")("")("")("")("")("");
        Call Log("Depth = ")((MaxDepth - 1))(", Time = ")((Operator.Round((MinMaxTimer * 100)) / 100))("")("")("")("");
        Call Log(MoveCount)(" moves (full), ")((Operator.Round(((MoveCount / MinMaxTimer) / 100)) / 10))("k MPS")("")("")("")("");
        Call Log(NodeCount)(" nodes (full), ")((Operator.Round(((NodeCount / MinMaxTimer) / 100)) / 10))("k NPS")("")("")("")("");
        Call Log(MoveCountQ)(" moves (q), ")((Operator.Round(((MoveCountQ / MinMaxTimer) / 100)) / 10))("k MPS")("")("")("")("");
        Call Log(NodeCountQ)(" nodes (q), ")((Operator.Round(((NodeCountQ / MinMaxTimer) / 100)) / 10))("k NPS")("")("")("")("");
        Call Log((MoveCount + MoveCountQ))(" moves (all), ")((Operator.Round((((MoveCount + MoveCountQ) / MinMaxTimer) / 100)) / 10))("k MPS")("")("")("")("");
        Call Log((NodeCount + NodeCountQ))(" nodes (all), ")((Operator.Round((((NodeCount + NodeCountQ) / MinMaxTimer) / 100)) / 10))("k NPS")("")("")("")("");
        Call Log("Avg. best move idx (full) = ")((Operator.Round(((ProfBestMoveIdxSum / ProfBestMoveCount) * 100)) / 100))("")("")("")("")("")("");
        Call Log("Avg. best move idx (q) = ")((Operator.Round(((ProfBestMoveIdxSumQ / ProfBestMoveCountQ) * 100)) / 100))("")("")("")("")("")("");
        Call Log("========================================")("")("")("")("")("")("")("");
    }
    MPS = Operator.Round(((MoveCount + MoveCountQ) / MinMaxTimer));
    NPS = Operator.Round(((NodeCount + NodeCountQ) / MinMaxTimer));
    If (Not ((MinMaxMoveRes == "")))
    {
        List.DeleteAll(PVStablePrev);
        Idx = 1;
        Repeat (List.Length(PVStable))
        {
            List.Add(PVStablePrev, PVStable[Idx]);
            Idx += 1;
        }
        If ((floor((MinMaxMoveRes / 100)) == 0) Or (Board[floor((MinMaxMoveRes % 100))] == 0))
        {
            Call StoreKillerMove(1)(MinMaxMoveRes)(MaxDepth);
        }
        If ((ProfilerMode % 10) > 0)
        {
            Call LogPVEval;
        }
    }
}

Define AlphaBetaMinMaxImpl(string Depth)(string MinDepth)(string MaxDepth)(bool InitialDeepening)(string QuiescenceDepth)(bool Quiescence)(bool PrevQuiescence)(bool ShowProgress)(string Horizon)(bool Cutnode)(string ExcludeMove) (warp=true)
{
    List.ReplaceItem(MinMaxResults, Depth, "");
    List.ReplaceItem(ScoreTypes, Depth, "");
    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, "");
    List.ReplaceItem(BoardEval, Depth, "");
    If (IsMinMaxTimeout == 1)
    {
        Stop(this script);
    }
    Call //("Required for early TT access and draw detection");
    If (Depth == 1)
    {
        List.ReplaceItem(CastlingState, 1, Operator.Join(Operator.Join(Operator.Join(HasOwnCastled, HasOwnKingMoved), Operator.Join(HasOwnRookKSMoved, HasOwnRookQSMoved)), Operator.Join(Operator.Join(HasOppCastled, HasOppKingMoved), Operator.Join(HasOppRookKSMoved, HasOppRookQSMoved))));
        Call SetInitialEnPassantTarget(1);
        List.ReplaceItem(CheckedState, 1, "");
    }
    Else
    {
        List.ReplaceItem(CastlingState, Depth, CastlingState[(Depth - 1)]);
        List.ReplaceItem(EnPassantTarget, Depth, EnPassantTarget[(Depth - 1)]);
        List.ReplaceItem(CheckedState, Depth, PutsInCheck[(Depth - 1)]);
    }
    If (Depth > 1)
    {
        Call //("Virtual king captures on previous ply => depth-corrected checkmate evaluation");
        If (TargetPieces[(Depth - 1)] == GoK_OppKing)
        {
            List.ReplaceItem(MinMaxResults, Depth, (100000 - ((Depth - 1) * 1000)));
            List.ReplaceItem(ScoreTypes, Depth, "E");
            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
            Stop(this script);
        }
        If (TargetPieces[(Depth - 1)] == GoK_OwnKing)
        {
            List.ReplaceItem(MinMaxResults, Depth, (-100000 + ((Depth - 1) * 1000)));
            List.ReplaceItem(ScoreTypes, Depth, "E");
            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
            Stop(this script);
        }
    }
    If ((Depth > 1) And (IsInNullMove == 0))
    {
        Call //("Rule of 50 moves");
        If (BoardHistoryFiftyMoves[List.Length(BoardHistoryFiftyMoves)] > (99 - 0))
        {
            List.ReplaceItem(MinMaxResults, (Depth + 0), DrawByRepetitionEval);
            List.ReplaceItem(ScoreTypes, (Depth + 0), "E");
            List.ReplaceItem(MinMaxResultsIsDynamic, (Depth + 0), 1);
            Stop(this script);
        }
        Call //("Draw-by-repetition detection. This happens on every ply and could be costly, so we check previous plies for pawn moves and captures, and the history tables for board hash. Only then we count hash occurrences for same side.");
        If (BoardHistoryFiftyMoves[List.Length(BoardHistoryFiftyMoves)] > 5)
        {
            Count1 = 1;
            If List.ContainsItem(PreviousBoardHash, CurrentBoardHash)
            {
                Idx = (Depth - 2);
                Repeat Until ((Idx < 2) Or (Count1 > 2))
                {
                    If (CurrentBoardHash == PreviousBoardHash[Idx])
                    {
                        Count1 += 1;
                    }
                    Idx += -2;
                }
            }
            If List.ContainsItem(BoardHistoryHash, CurrentBoardHash)
            {
                Idx = ((List.Length(BoardHistoryHash) - 1) + (Depth % 2));
                Repeat Until ((Idx < 1) Or (Count1 > 2))
                {
                    If (CurrentBoardHash == BoardHistoryHash[Idx])
                    {
                        Count1 += 1;
                    }
                    Idx += -2;
                }
            }
            If (Count1 > 1)
            {
                List.ReplaceItem(MinMaxResults, (Depth + 0), DrawByRepetitionEval);
                List.ReplaceItem(ScoreTypes, (Depth + 0), "E");
                List.ReplaceItem(MinMaxResultsIsDynamic, (Depth + 0), 1);
                Stop(this script);
            }
        }
    }
    Call //("Search tree leaf reached");
    If (Depth == MaxDepth)
    {
        Call Evaluate((Depth - 1))((1 == 1));
        List.ReplaceItem(MinMaxResults, Depth, EvaluateRes);
        List.ReplaceItem(MinMaxResultsIsDynamic, Depth, EvaluateResIsDynamic);
        Stop(this script);
    }
    If ((Depth > 1) And (ExcludeMove == ""))
    {
        Call //("Probe transposition table for cached node evaluations");
        If ((Betas[(Depth + 0)] - Alphas[(Depth + 0)]) == 1)
        {
            Call TTProbeNode(CurrentBoardHash)(Depth);
            If ((TTProbeRes == 1) And ((Not ((TTProbeNodeScoreRes == ""))) And (Not ((TTProbeHorizonRes == "")))))
            {
                If (((Not (Quiescence)) And (Not ((TTProbeHorizonRes < Horizon)))) Or (Quiescence And (TTProbeHorizonRes == -1)))
                {
                    If ((TTProbeNodeTypeRes == "E") Or (((Betas[(Depth + 0)] - Alphas[(Depth + 0)]) == 1) And (((TTProbeNodeTypeRes == "A") And (Not ((TTProbeNodeScoreRes > Alphas[(Depth + 0)])))) Or ((TTProbeNodeTypeRes == "B") And (Not ((TTProbeNodeScoreRes < Betas[(Depth + 0)])))))))
                    {
                        If (Not ((abs(TTProbeNodeScoreRes) > AbsMinCheckmateEval)))
                        {
                            List.ReplaceItem(MinMaxResults, Depth, TTProbeNodeScoreRes);
                            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                            Stop(this script);
                        }
                    }
                }
            }
        }
    }
    If ((Depth > 1) And (IsInNullMove == 0))
    {
        Call //("Draw-by-stalemate detection. This is expensive, and is only applied at low search depth or during late endgame stage (no minor pieces left)");
        If (Not (Quiescence))
        {
            If (Not ((CheckedState[(Depth + 0)] == 1)))
            {
                If ((((Depth % 2) == 1) And ((QueenCounttOwnLocal == 0) And (RookMinorCounttOwnLocal < 2))) Or (((Depth % 2) == 0) And ((QueenCountOppLocal == 0) And (RookMinorCountLocalOpp < 2))))
                {
                    If ((Depth < 4) Or (Horizon > 2))
                    {
                        Call IsDrawByStalemate((Depth + 2));
                        If (IsDrawRes == 1)
                        {
                            Call StoreMinMaxDrawResult(CurrentBoardHash)(Depth);
                            Stop(this script);
                        }
                    }
                }
            }
        }
        Call //("Fast draw-by-material verification");
        If (((QueenCounttOwnLocal == 0) And (QueenCountOppLocal == 0)) And ((PawnCounttOwnLocal == 0) And (PawnCountOppLocal == 0)))
        {
            If (((RookCounttOwnLocal == 0) And (RookMinorCounttOwnLocal < 2)) And ((RookCountOppLocal == 0) And (RookMinorCountLocalOpp < 2)))
            {
                Call StoreMinMaxDrawResult(CurrentBoardHash)(Depth);
                Stop(this script);
            }
        }
        Call //("Special K-KP endgame draw detection, according to pawn and king position. Finds draws otherwise not visible within search horizon");
        If ((Depth > 1) And (Not (PrevQuiescence)))
        {
            If (((QueenCountOppLocal + RookMinorCountLocalOpp) == 0) And ((QueenCounttOwnLocal + RookMinorCounttOwnLocal) == 0))
            {
                If ((PawnCounttOwnLocal + PawnCountOppLocal) == 1)
                {
                    Idx = 1;
                    Repeat (64)
                    {
                        CurrentPiece = Board[(Idx + 0)];
                        If ((CurrentPiece == GoK_OppPawn) And ((Depth % 2) == 0))
                        {
                            If ((IdxToFile[Idx] == 1) Or (IdxToFile[Idx] == 8))
                            {
                                If ((IdxToFile[Idx] == IdxToFile[KingIdxtOwn]) And (IdxToRank[KingIdxtOwn] < IdxToRank[Idx]))
                                {
                                    Call StoreMinMaxDrawResult(CurrentBoardHash)(Depth);
                                    Stop(this script);
                                }
                            }
                            Else
                            {
                                If (((Idx - 8) == KingIdxtOwn) Or ((Idx - 16) == KingIdxtOwn))
                                {
                                    If (Not ((((Idx - 1) == KingIdxOpp) Or ((Idx + 1) == KingIdxOpp))))
                                    {
                                        Call StoreMinMaxDrawResult(CurrentBoardHash)(Depth);
                                        Stop(this script);
                                    }
                                }
                                If ((Idx - 24) == KingIdxtOwn)
                                {
                                    If ((IdxToRank[Idx] > 4) And ((Idx - 8) == KingIdxOpp))
                                    {
                                        Call StoreMinMaxDrawResult(CurrentBoardHash)(Depth);
                                        Stop(this script);
                                    }
                                }
                            }
                        }
                        Else
                        {
                            If ((CurrentPiece == GoK_OwnPawn) And ((Depth % 2) == 1))
                            {
                                If ((IdxToFile[Idx] == 1) Or (IdxToFile[Idx] == 8))
                                {
                                    If ((IdxToFile[Idx] == IdxToFile[KingIdxOpp]) And (IdxToRank[KingIdxOpp] > IdxToRank[Idx]))
                                    {
                                        Call StoreMinMaxDrawResult(CurrentBoardHash)(Depth);
                                        Stop(this script);
                                    }
                                }
                                Else
                                {
                                    If (((Idx + 8) == KingIdxOpp) Or ((Idx + 16) == KingIdxOpp))
                                    {
                                        If (Not ((((Idx - 1) == KingIdxtOwn) Or ((Idx + 1) == KingIdxtOwn))))
                                        {
                                            Call StoreMinMaxDrawResult(CurrentBoardHash)(Depth);
                                            Stop(this script);
                                        }
                                    }
                                    If ((Idx + 24) == KingIdxOpp)
                                    {
                                        If ((IdxToRank[Idx] < 5) And ((Idx + 8) == KingIdxtOwn))
                                        {
                                            Call StoreMinMaxDrawResult(CurrentBoardHash)(Depth);
                                            Stop(this script);
                                        }
                                    }
                                }
                            }
                        }
                        Idx += 1;
                    }
                }
            }
        }
    }
    Call //("Search function (minimax / alpha-beta pruning)");
    List.ReplaceItem(MinMaxResults, (Depth + 0), "");
    List.ReplaceItem(MinMaxResultsIsDynamic, (Depth + 0), 0);
    List.ReplaceItem(ScoreTypes, (Depth + 0), "E");
    List.ReplaceItem(BestMoves, (Depth + 0), "");
    List.ReplaceItem(PV, (((Depth - 1) * MaxSearchDepthStackFrames) + 1), 0);
    List.ReplaceItem(AlphasOld, Depth, Alphas[Depth]);
    List.ReplaceItem(BetasOld, Depth, Betas[Depth]);
    List.ReplaceItem(PutsInCheck, Depth, 0);
    If Quiescence
    {
        List.ReplaceItem(Quiescence, (Depth + 0), 1);
    }
    Else
    {
        List.ReplaceItem(Quiescence, (Depth + 0), 0);
    }
    Call //("Initialize local variables or forward state from previous ply");
    If (Depth == 1)
    {
        List.ReplaceItem(CheckedState, (Depth + 0), "");
        List.ReplaceItem(CastlingState, 1, Operator.Join(Operator.Join(Operator.Join(HasOwnCastled, HasOwnKingMoved), Operator.Join(HasOwnRookKSMoved, HasOwnRookQSMoved)), Operator.Join(Operator.Join(HasOppCastled, HasOppKingMoved), Operator.Join(HasOppRookKSMoved, HasOppRookQSMoved))));
        Call CalcBoardAttackedByMove(2);
        Call StoreAttackInfo(2)(1);
        List.ReplaceItem(BoardAttackedCalculated, 1, 1);
    }
    Else
    {
        List.ReplaceItem(CheckedState, (Depth + 0), PutsInCheck[(Depth - 1)]);
        List.ReplaceItem(CheckedStateAttackLines, Depth, "");
        List.ReplaceItem(CastlingState, Depth, CastlingState[(Depth - 1)]);
        List.ReplaceItem(BoardAttackedCalculated, Depth, 0);
        If (Depth == 2)
        {
            Call CalcBoardAttackedByMove(3);
            Call StoreAttackInfo(3)(2);
            List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
        }
        Else
        {
            Idx = (((Depth - 1) * 100) + 1);
            IdxSub = (((Depth - 3) * 100) + 1);
            Repeat (64)
            {
                List.ReplaceItem(PersistedBoardAttackedByOppSnapshot, Idx, PersistedBoardAttackedByOppSnapshot[IdxSub]);
                List.ReplaceItem(PersistedBoardAttackedByOppPieceSnapshot, Idx, PersistedBoardAttackedByOppPieceSnapshot[IdxSub]);
                Idx += 1;
                IdxSub += 1;
            }
        }
    }
    Call //("Invoke board evaluation to calculate intermediate results if required");
    Call Evaluate((Depth - 1))((1 == 0));
    Call TTProbeBoard(CurrentBoardHash)(Depth);
    If ((TTProbeRes == 1) And (Not ((TTProbeBoardScoreSumRes == ""))))
    {
        List.ReplaceItem(BoardEval, (Depth + 0), TTProbeBoardScoreSumRes);
    }
    If Quiescence
    {
        If (CheckedState[Depth] == 1)
        {
            If ((Depth % 2) == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, (-100000 + (Depth * 1000)));
            }
            Else
            {
                List.ReplaceItem(MinMaxResults, Depth, (100000 - (Depth * 1000)));
            }
        }
        Else
        {
            Call //("Standing pat");
            If (BoardEval[Depth] == "")
            {
                Call Evaluate((Depth - 1))((1 == 1));
                List.ReplaceItem(BoardEval, Depth, EvaluateRes);
            }
            Else
            {
                EvaluateRes = BoardEval[Depth];
                EvaluateResIsDynamic = 0;
            }
            List.ReplaceItem(MinMaxResults, Depth, EvaluateRes);
            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, EvaluateResIsDynamic);
            If ((Depth % 2) == 1)
            {
                If (Not ((EvaluateRes < Betas[Depth])))
                {
                    List.ReplaceItem(MinMaxResults, Depth, EvaluateRes);
                    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, EvaluateResIsDynamic);
                    If (1 == 0)
                    {
                        Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("B")("")(-1)("")("")("")("")("")(MinMaxResultsIsDynamic[Depth]);
                    }
                    Stop(this script);
                }
                If (EvaluateRes > Alphas[Depth])
                {
                    List.ReplaceItem(Alphas, Depth, EvaluateRes);
                }
            }
            Else
            {
                If (Not ((EvaluateRes > Alphas[Depth])))
                {
                    List.ReplaceItem(MinMaxResults, Depth, EvaluateRes);
                    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, EvaluateResIsDynamic);
                    If (1 == 0)
                    {
                        Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("A")("")(-1)("")("")("")("")("")(MinMaxResultsIsDynamic[Depth]);
                    }
                    Stop(this script);
                }
                If (EvaluateRes < Betas[Depth])
                {
                    List.ReplaceItem(Betas, Depth, EvaluateRes);
                }
            }
        }
    }
    If (((Not (Quiescence)) And (Depth > 1)) And ((ExcludeMove == "") And (CheckedState[Depth] == 0)))
    {
        If ((IsInNullMove == 0) And (1 == 0))
        {
            Call //("Reverse futility pruning");
            If ((((Depth > 1) And (Horizon < 3)) And ((IsEndgame == 0) And ((PawnCounttOwnLocal + PawnCountOppLocal) > 0))) And (((Betas[Depth] - Alphas[Depth]) == 1) And (CheckedState[Depth] == 0)))
            {
                If ((((Depth % 2) == 1) And (abs(Betas[Depth]) < AbsMinCheckmateEval)) Or (((Depth % 2) == 0) And (abs(Alphas[Depth]) < AbsMinCheckmateEval)))
                {
                    Call TTProbeNode(CurrentBoardHash)(Depth);
                    If (((TTProbeRes == 0) Or (TTProbeBestMoveRes == "")) Or (Not ((Board[floor((TTProbeBestMoveRes % 100))] == 0))))
                    {
                        If (BoardEval[Depth] == "")
                        {
                            Call Evaluate((Depth - 1))((1 == 1));
                            List.ReplaceItem(BoardEval, Depth, EvaluateRes);
                        }
                        Margin = (80 + (80 * Horizon));
                        If (Depth > 2)
                        {
                            If (Not ((BoardEval[(Depth - 2)] == "")))
                            {
                                If ((((Depth % 2) == 1) And (BoardEval[Depth] < BoardEval[(Depth - 2)])) Or (((Depth % 2) == 0) And (BoardEval[Depth] > BoardEval[(Depth - 2)])))
                                {
                                    Margin += -40;
                                }
                            }
                        }
                        If ((Depth % 2) == 1)
                        {
                            If (Not (((BoardEval[Depth] - Margin) < Betas[Depth])))
                            {
                                List.ReplaceItem(MinMaxResults, Depth, BoardEval[Depth]);
                                List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                                Stop(this script);
                            }
                        }
                        Else
                        {
                            If (Not (((BoardEval[Depth] + Margin) > Alphas[Depth])))
                            {
                                List.ReplaceItem(MinMaxResults, Depth, BoardEval[Depth]);
                                List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                                Stop(this script);
                            }
                        }
                    }
                }
            }
        }
        Call //("Razoring");
        If (1 == 0)
        {
            If (((Horizon + PlyExtension[Depth]) == 1) And ((Betas[Depth] - Alphas[Depth]) == 1))
            {
                If (BoardEval[Depth] == "")
                {
                    Call Evaluate((Depth - 1))((1 == 1));
                    List.ReplaceItem(BoardEval, Depth, EvaluateRes);
                }
                If ((((Depth % 2) == 1) And ((BoardEval[Depth] + 300) < Alphas[Depth])) Or (((Depth % 2) == 0) And ((BoardEval[Depth] - 300) > Betas[Depth])))
                {
                    If (QuiescenceDepth > 0)
                    {
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth + 1))(InitialDeepening)((QuiescenceDepth - 1))((1 == 1))(Quiescence)(ShowProgress)(1)((1 == 1))(ExcludeNode);
                        List.ReplaceItem(MinMaxResults, Depth, MinMaxResults[(Depth + 1)]);
                        List.ReplaceItem(MinMaxResultsIsDynamic, Depth, MinMaxResultsIsDynamic[(Depth + 1)]);
                        Stop(this script);
                    }
                }
            }
        }
        Call //("Null move pruning");
        If (IsInNullMove == 0)
        {
            If ((Horizon > 2) And (((Betas[Depth] - Alphas[Depth]) == 1) And (CheckedState[Depth] == 0)))
            {
                If (((PawnCounttOwnLocal + PawnCountOppLocal) > 0) And ((((Depth % 2) == 1) And ((QueenCounttOwnLocal + RookMinorCounttOwnLocal) > 1)) Or (((Depth % 2) == 0) And ((QueenCountOppLocal + RookMinorCountLocalOpp) > 1))))
                {
                    IsInNullMove += 1;
                    If (BoardEval[Depth] == "")
                    {
                        Call Evaluate((Depth - 1))((1 == 1));
                        List.ReplaceItem(BoardEval, Depth, EvaluateRes);
                    }
                    If ((Depth % 2) == 1)
                    {
                        CurrentValue = (BoardEval[Depth] - Betas[Depth]);
                    }
                    Else
                    {
                        CurrentValue = (Alphas[Depth] - BoardEval[Depth]);
                    }
                    If (CurrentValue > 512)
                    {
                        CurrentValue = 512;
                    }
                    Reduction = (2 + floor((((32 * Horizon) + CurrentValue) / 128)));
                    If (Reduction < 0)
                    {
                        Reduction = 0;
                    }
                    If (Reduction > 0)
                    {
                        If ((((Depth % 2) == 1) And (Not ((BoardEval[Depth] < (Betas[Depth] + 0))))) Or (((Depth % 2) == 0) And (Not ((BoardEval[Depth] > (Alphas[Depth] - 0))))))
                        {
                            Call ClearMoveList((Depth + 0));
                            Call AddMoveToList(0)((Depth + 0));
                            List.ReplaceItem(MovesIdx, (Depth + 0), 1);
                            Call ApplyMove((Depth + 0));
                            Call Evaluate((Depth + 0))((1 == 0));
                            If ((Depth % 2) == 1)
                            {
                                List.ReplaceItem(Alphas, (Depth + 1), (Betas[Depth] - 1));
                                List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                            }
                            Else
                            {
                                List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                                List.ReplaceItem(Betas, (Depth + 1), (Alphas[Depth] + 1));
                            }
                            Call AlphaBetaMinMaxNextPly(Depth)(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)(Quiescence)(ShowProgress)(Horizon)(Reduction)((Not (Cutnode)))("");
                            Score = MinMaxResults[(Depth + 1)];
                            ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                            Call RevertMove((Depth + 0));
                            If (Not ((abs(Score) > AbsMinCheckmateEval)))
                            {
                                If (((((Depth % 2) == 1) And (Not ((Score < Betas[Depth])))) Or (((Depth % 2) == 0) And (Not ((Score > Alphas[Depth]))))) And (Not ((abs(Score) > AbsMinCheckmateEval))))
                                {
                                    List.ReplaceItem(MinMaxResults, Depth, Score);
                                    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreIsDynamic);
                                    IsInNullMove += -1;
                                    Stop(this script);
                                }
                            }
                        }
                    }
                    IsInNullMove += -1;
                }
            }
        }
    }
    If (1 == 0)
    {
        If (BoardEval[Depth] == "")
        {
            If (CheckedState[Depth] == 0)
            {
                If (((Not (Quiescence)) And (((Depth > 1) And (Horizon < 6)) And ((Betas[Depth] - Alphas[Depth]) == 1))) Or Quiescence)
                {
                    Call Evaluate((Depth - 1))((1 == 1));
                    List.ReplaceItem(BoardEval, Depth, EvaluateRes);
                }
            }
        }
    }
    If ((((Not (Quiescence)) And (Horizon > 5)) And (CheckedState[Depth] == 0)) And (Not (((Betas[Depth] - Alphas[Depth]) == 1))))
    {
        If (1 == 1)
        {
            Call //("Internal iterative deepening");
            Call TTProbeNode(CurrentBoardHash)(Depth);
            If ((TTProbeRes == 0) Or (TTProbeBestMoveRes == ""))
            {
                Call ClearMoveList(Depth);
                Call AddMoveToList(0)(Depth);
                Call ApplyMove(Depth);
                Call Evaluate(Depth)((1 == 0));
                Call ClearMoveList((Depth + 1));
                Call AddMoveToList(0)((Depth + 1));
                Call ApplyMove((Depth + 1));
                Call Evaluate((Depth + 1))((1 == 0));
                List.ReplaceItem(Alphas, (Depth + 2), Alphas[Depth]);
                List.ReplaceItem(Betas, (Depth + 2), Betas[Depth]);
                Call AlphaBetaMinMaxImpl((Depth + 2))(MinDepth)((MaxDepth - 2))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress)((Horizon - 3))((1 == 0))("");
                Call RevertMove((Depth + 1));
                Call RevertMove(Depth);
            }
        }
    }
    List.ReplaceItem(PickPhase, Depth, 1);
    List.ReplaceItem(PickMoveRes, Depth, 1);
    List.ReplaceItem(PickedMoveCount, Depth, 0);
    List.ReplaceItem(PickedMoveCountQuiet, Depth, 0);
    Call //("Move generation and application loop, recursive search invocation");
    Repeat Until (PickMoveRes[Depth] == 0)
    {
        If ((Not (Quiescence)) And ((Depth == 1) Or (Horizon > 2)))
        {
            If ((IsMinMaxTimeout == 0) And ((Not (InitialDeepening)) Or (Not ((MinMaxMoveRes == "")))))
            {
                If (((Sensing.DaysSince2000() * 86400) - ThinkTimeStart) > ThinkTimeLimitMinMax)
                {
                    IsMinMaxTimeout = 1;
                    PrevPly1Move = "";
                }
            }
        }
        If (IsMinMaxTimeout == 1)
        {
            If (Quiescence[Depth] == 0)
            {
                MoveCount += MovesCount[Depth];
            }
            Else
            {
                MoveCountQ += MovesCount[Depth];
            }
            Stop(this script);
        }
        If (IsBlockProfilerEnabled == 1)
        {
            Call Profile_MethodEnter(((5 * MaxSearchDepthStackFrames) + Depth));
        }
        If (BoardEval[Depth] == "")
        {
            If (CheckedState[Depth] == 0)
            {
                If (Quiescence Or ((Not (Quiescence)) And (((Depth > 1) And (Horizon < 6)) And (((Betas[Depth] - Alphas[Depth]) == 1) And (PickedMoveCount[Depth] > 0)))))
                {
                    Call Evaluate((Depth - 1))((1 == 1));
                    List.ReplaceItem(BoardEval, Depth, EvaluateRes);
                }
            }
        }
        If (1 == 1)
        {
            If ((Depth == 1) And (PickedMoveCount[Depth] > 4))
            {
                If (Not ((Alphas[Depth] > MinMaxAlpha)))
                {
                    List.ReplaceItem(MinMaxResults, Depth, MinMaxAlpha);
                    Stop(this script);
                }
            }
        }
        Call //("Invoke move generator and apply next move from list");
        Call PickMove(Depth)(Quiescence);
        If (PickMoveRes[Depth] == 1)
        {
            If (AppliedMove[Depth] == ExcludeMove)
            {
                Call RevertMove(Depth);
                Call PickMove(Depth)(Quiescence);
            }
        }
        If (IsBlockProfilerEnabled == 1)
        {
            Call Profile_MethodExit(((5 * MaxSearchDepthStackFrames) + Depth));
        }
        If (PickMoveRes[Depth] == 1)
        {
            Call //("Show progress and collect statistics");
            If (ShowProgress And ((Not (Quiescence)) And ((Depth == 1) Or (Horizon > 2))))
            {
                CurrentValue = (Sensing.DaysSince2000() * 86400);
                If (CurrentValue > (PrevProgressUpdate + 1))
                {
                    Call OnProgressChanged((((CurrentValue - ThinkTimeStart) / ThinkTimeLimitMinMax) * 100));
                    PrevProgressUpdate = CurrentValue;
                }
            }
            List.ReplaceItem(PutsInCheck, Depth, 0);
            List.ReplaceItem(PlyExtensionTagged, Depth, 0);
            List.ReplaceItem(PlyExtension, Depth, 0);
            SourceIdxOuter2 = floor((AppliedMove[Depth] / 100));
            TargetIdxOuter2 = floor((AppliedMove[Depth] % 100));
            Call //("Fast check detection for current move");
            Call IsCheckingPiece(TargetIdxOuter2);
            If (IsCheckingPieceRes == 1)
            {
                List.ReplaceItem(PutsInCheck, Depth, 1);
                List.ReplaceItem(CastlingState, (Depth + 1), CastlingState[Depth]);
                Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(1)("")("")("")("")("")("")("");
            }
            Call //("Fast discovered check detection for current move");
            Call IsCheckingPieceDiscovery(SourceIdxOuter2)(TargetIdxOuter2)(Depth);
            If (IsCheckingPieceRes == 1)
            {
                List.ReplaceItem(PutsInCheck, Depth, 1);
                List.ReplaceItem(CastlingState, (Depth + 1), CastlingState[Depth]);
                Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(1)("")("")("")("")("")("")("");
            }
            Score = "";
            ScoreIsDynamic = 0;
            IsFutile = 0;
            If (1 == 0)
            {
                Call //("LMP");
                If ((((Not (Quiescence)) And (Horizon < 4)) And ((Betas[Depth] - Alphas[Depth]) == 1)) And (((CheckedState[Depth] == 0) And (PutsInCheck[Depth] == 0)) And (PromotionPieces[Depth] == 0)))
                {
                    If (PickedMoveCountQuiet[Depth] > (4 + (Horizon * Horizon)))
                    {
                        IsFutile = 1;
                    }
                }
            }
            Call //("Futility pruning");
            If (((IsFutile == 0) And (CheckedState[Depth] == 0)) And ((PutsInCheck[Depth] == 0) And (PromotionPieces[Depth] == 0)))
            {
                FP.Eval = "";
                FP.SEE = "";
                If (Not ((BoardEval[Depth] == "")))
                {
                    FutilityMargin = "";
                    If Quiescence
                    {
                        If ((Not ((TargetPieces[Depth] == 0))) And ((((Depth % 2) == 1) And ((QueenCounttOwnLocal + RookMinorCounttOwnLocal) > 0)) Or (((Depth % 2) == 0) And ((QueenCountOppLocal + RookMinorCountLocalOpp) > 0))))
                        {
                            FutilityMargin = 400;
                        }
                    }
                    Else
                    {
                        If ((Depth > 1) And (Horizon < 6))
                        {
                            If (((TargetPieces[Depth] == 0) And (PickedMoveCount[Depth] > 1)) And ((Betas[Depth] - Alphas[Depth]) == 1))
                            {
                                Rank = IdxToRank[floor((AppliedMove[Depth] % 100))];
                                If (((Not ((SourcePieces[Depth] == GoK_OwnPawn))) Or (Rank < 6)) And ((Not ((SourcePieces[Depth] == GoK_OppPawn))) Or (Rank > 3)))
                                {
                                    FutilityMargin = (Horizon * 125);
                                }
                            }
                        }
                    }
                    EvaluateRes = BoardEval[Depth];
                    If ((Not ((FutilityMargin == ""))) And (Not ((EvaluateRes == ""))))
                    {
                        If ((Depth % 2) == 1)
                        {
                            FP.Eval = (((EvaluateRes + PosScoreDelta[Depth]) - TargetPieces[Depth]) + FutilityMargin);
                        }
                        Else
                        {
                            FP.Eval = (((EvaluateRes + PosScoreDelta[Depth]) - TargetPieces[Depth]) - FutilityMargin);
                        }
                        If ((((Depth % 2) == 1) And (Not ((FP.Eval > Alphas[(Depth + 0)])))) Or (((Depth % 2) == 0) And (Not ((FP.Eval < Betas[(Depth + 0)])))))
                        {
                            IsFutile = 1;
                            If Quiescence
                            {
                                If ((((Depth % 2) == 1) And (FP.Eval > MinMaxResults[(Depth + 0)])) Or (((Depth % 2) == 0) And (FP.Eval < MinMaxResults[(Depth + 0)])))
                                {
                                    Score = FP.Eval;
                                    List.ReplaceItem(MinMaxResults, Depth, FP.Eval);
                                }
                            }
                        }
                        Else
                        {
                            If Quiescence
                            {
                                If ((Depth % 2) == 1)
                                {
                                    FP.Eval = (EvaluateRes + FutilityMargin);
                                }
                                Else
                                {
                                    FP.Eval = (EvaluateRes - FutilityMargin);
                                }
                                If ((((Depth % 2) == 1) And (Not ((FP.Eval > Alphas[(Depth + 0)])))) Or (((Depth % 2) == 0) And (Not ((FP.Eval < Betas[(Depth + 0)])))))
                                {
                                    Call SEE(Depth);
                                    FP.SEE = SEE.Result;
                                    If ((((Depth % 2) == 1) And (Not ((FP.SEE > 0)))) Or (((Depth % 2) == 0) And (Not ((FP.SEE < 0)))))
                                    {
                                        IsFutile = 1;
                                        If ((((Depth % 2) == 1) And (FP.Eval > MinMaxResults[(Depth + 0)])) Or (((Depth % 2) == 0) And (FP.Eval < MinMaxResults[(Depth + 0)])))
                                        {
                                            Score = FP.Eval;
                                            List.ReplaceItem(MinMaxResults, Depth, FP.Eval);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                If (1 == 1)
                {
                    If (IsFutile == 0)
                    {
                        If Quiescence
                        {
                            If ((CheckedState[Depth] == 0) And (PutsInCheck[Depth] == 0))
                            {
                                If (FP.SEE == "")
                                {
                                    Call SEE(Depth);
                                    FP.SEE = SEE.Result;
                                }
                                If ((((Depth % 2) == 1) And (FP.SEE < 0)) Or (((Depth % 2) == 0) And (FP.SEE > 0)))
                                {
                                    IsFutile = 1;
                                }
                            }
                        }
                    }
                }
            }
            If (IsFutile == 1)
            {
                If (IsMinMaxTimeout == 0)
                {
                    If (Depth == 1)
                    {
                        List.Add(MinMaxPly1EvalMoves, AppliedMove[Depth]);
                    }
                }
                Call RevertMove(Depth);
            }
            Else
            {
                If (Not (Quiescence))
                {
                    If (PlyExtension[Depth] == 0)
                    {
                        Call IsPassedPawnDanger(SourcePieces[Depth])(AppliedMove[Depth]);
                        If (IsPassedPawnDangerRes == 1)
                        {
                            List.ReplaceItem(PlyExtension, Depth, 1);
                        }
                    }
                    If (PlyExtension[Depth] == 0)
                    {
                        If ((Depth > 1) And (CheckedState[Depth] == 1))
                        {
                            Call SEE(Depth);
                            If ((((Depth % 2) == 1) And (Not ((SEE.Result < 0)))) Or (((Depth % 2) == 0) And (Not ((SEE.Result > 0)))))
                            {
                                List.ReplaceItem(PlyExtension, Depth, 1);
                            }
                        }
                    }
                    If (PlyExtension[Depth] == 0)
                    {
                        If (1 == 0)
                        {
                            If (Horizon > 0)
                            {
                                SourceIdxOuter2 = floor((AppliedMove[Depth] % 100));
                                SourcePieceOuter2 = Board[SourceIdxOuter2];
                                If (abs(SourcePieceOuter2) < GoK_OwnRook)
                                {
                                    Call //("Fork detection, will trigger search extension or prevent reduction");
                                    Factor = (((Depth % 2) * 2) - 1);
                                    IdxOuter2 = ((PieceIdxLookup[abs(SourcePieceOuter2)] * 10000) + (SourceIdxOuter2 * 100));
                                    CountOuter1 = 0;
                                    TargetIdxOuter2 = 1;
                                    Repeat (64)
                                    {
                                        If ((Board[TargetIdxOuter2] * Factor) < 0)
                                        {
                                            If (abs(SourcePieceOuter2) < abs(Board[TargetIdxOuter2]))
                                            {
                                                If ((((Depth % 2) == 1) And (MovePosLookupOwnLegal[(IdxOuter2 + TargetIdxOuter2)] == 1)) Or (((Depth % 2) == 0) And (MovePosLookupOppLegal[(IdxOuter2 + TargetIdxOuter2)] == 1)))
                                                {
                                                    CountOuter1 += 1;
                                                }
                                            }
                                        }
                                        TargetIdxOuter2 += 1;
                                    }
                                    If (CountOuter1 > 1)
                                    {
                                        CountOuter2 = 0;
                                        Call ClearMoveList((Depth + 2));
                                        Call GenerateMovesForSourceEx((Depth + 2))(floor((AppliedMove[Depth] % 100)))((1 == 0))((1 == 1));
                                        List.ReplaceItem(MovesIdx, (Depth + 2), 1);
                                        Repeat Until ((MovesIdx[(Depth + 2)] > MovesCount[(Depth + 2)]) Or (CountOuter2 > 1))
                                        {
                                            Call GetCurrentMove((Depth + 2));
                                            SourceIdxOuter2 = floor((CurrentMove / 100));
                                            TargetIdxOuter2 = floor((CurrentMove % 100));
                                            If (abs(Board[SourceIdxOuter2]) < abs(Board[TargetIdxOuter2]))
                                            {
                                                CountOuter2 += 1;
                                            }
                                            List.ReplaceItem(MovesIdx, (Depth + 2), (MovesIdx[(Depth + 2)] + 1));
                                        }
                                        If (CountOuter2 > 0)
                                        {
                                            List.ReplaceItem(PlyExtension, Depth, 1);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    If (PlyExtension[Depth] == 0)
                    {
                        Call //("Singular extensions");
                        If (1 == 0)
                        {
                            If (((Not (Quiescence)) And ((Depth > 1) And (Horizon > 4))) And ((HashMove[Depth] == AppliedMove[Depth]) And (ExcludeMove == "")))
                            {
                                Call TTProbeNode(PreviousBoardHash[Depth])(Depth);
                                If ((TTProbeRes == 1) And ((Not ((TTProbeNodeScoreRes == ""))) And (Not ((TTProbeHorizonRes == "")))))
                                {
                                    If (Not ((TTProbeHorizonRes < (Horizon - 3))))
                                    {
                                        If ((((Depth % 2) == 1) And (TTProbeNodeTypeRes == "A")) Or (((Depth % 2) == 0) And (TTProbeNodeTypeRes == "B")))
                                        {
                                            SE.BoundEval = TTProbeNodeScoreRes;
                                            Call RevertMove(Depth);
                                            List.ReplaceItem(Moves, (((Depth - 1) * MaxMovesPerGeneration) + MovesIdx[Depth]), 0);
                                            Call ApplyMove(Depth);
                                            Call Evaluate(Depth)((1 == 0));
                                            List.ReplaceItem(MovesIdx, (Depth + 1), 1);
                                            Call ClearMoveList((Depth + 1));
                                            Call AddMoveToList(0)((Depth + 1));
                                            Call ApplyMove((Depth + 1));
                                            Call Evaluate((Depth + 1))((1 == 0));
                                            If ((Depth % 2) == 1)
                                            {
                                                SE.BoundEval += (0 - (Horizon * 2));
                                                List.ReplaceItem(Alphas, (Depth + 2), (SE.BoundEval - 1));
                                                List.ReplaceItem(Betas, (Depth + 2), SE.BoundEval);
                                            }
                                            Else
                                            {
                                                SE.BoundEval += (Horizon * 2);
                                                List.ReplaceItem(Alphas, (Depth + 2), SE.BoundEval);
                                                List.ReplaceItem(Betas, (Depth + 2), (SE.BoundEval + 1));
                                            }
                                            Reduction = floor((Horizon / 2));
                                            Call AlphaBetaMinMaxNextPly((Depth + 2))(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)(Quiescence)(ShowProgress)(Horizon)(Reduction)(Cutnode)(HashMove[Depth]);
                                            Score = MinMaxResults[(Depth + 2)];
                                            Call RevertMove((Depth + 1));
                                            Call RevertMove(Depth);
                                            List.ReplaceItem(Moves, (((Depth - 1) * MaxMovesPerGeneration) + MovesIdx[Depth]), HashMove[Depth]);
                                            Call ApplyMove(Depth);
                                            If ((((Depth % 2) == 1) And (Score < Betas[(Depth + 2)])) Or (((Depth % 2) == 0) And (Score > Alphas[(Depth + 2)])))
                                            {
                                                List.ReplaceItem(PlyExtension, Depth, 1);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    If (PlyExtension[Depth] == 1)
                    {
                        Count1 = 0;
                        Idx = (Depth - 2);
                        Repeat Until (Idx < 1)
                        {
                            If (PlyExtension[Idx] == 1)
                            {
                                Count1 += 1;
                            }
                            Idx += -2;
                        }
                        If (Count1 > 1)
                        {
                            List.ReplaceItem(PlyExtension, Depth, 0);
                        }
                    }
                }
                Score = "";
                ScoreIsDynamic = 0;
                Call //("Late move reduction preparation");
                IsReductionAndDone = 0;
                If ((Not (Quiescence)) And (IsMinMaxTimeout == 0))
                {
                    If (((Horizon > 1) And ((CheckedState[Depth] == 0) And (((TargetPieces[Depth] == 0) Or (1 == 0)) And (PromotionPieces[Depth] == 0)))) And (((QueenCountOppLocal + RookMinorCountLocalOpp) + (QueenCounttOwnLocal + RookMinorCounttOwnLocal)) > 0))
                    {
                        Call IsPassedPawnDanger(SourcePieces[Depth])(AppliedMove[Depth]);
                        If (IsPassedPawnDangerRes == 0)
                        {
                            Reduction = 0;
                            If (PickedMoveCount[Depth] > (1 + (Not (((Betas[Depth] - Alphas[Depth]) == 1)))))
                            {
                                Reduction = floor((1 + ((ln(Horizon) * ln(PickedMoveCount[Depth])) / 2)));
                                If (1 == 0)
                                {
                                    Reduction = floor(((0.38 + ((TargetPieces[Depth] == 0) * 1.63)) + ((ln(Horizon) * ln(PickedMoveCount[Depth])) / (2.32 + ((Not ((TargetPieces[Depth] == 0))) * 1.44)))));
                                }
                                If (1 == 1)
                                {
                                    If (Not (((Betas[Depth] - Alphas[Depth]) == 1)))
                                    {
                                        Reduction += -1;
                                    }
                                }
                                If (1 == 1)
                                {
                                    If (PutsInCheck[Depth] == 1)
                                    {
                                        Reduction += -1;
                                    }
                                }
                                If (1 == 0)
                                {
                                    IdxSub = ((PieceIdxLookup[abs(SourcePieces[Depth])] * 100) + floor((AppliedMove[Depth] % 100)));
                                    CurrentValue = floor((0 - (HistoryMoveScores[(((Depth % 2) * 1000) + IdxSub)] / MaxHistoryMoveScore[((Depth % 2) + 1)])));
                                    If (CurrentValue > 0.25)
                                    {
                                        Reduction += -1;
                                    }
                                }
                                If (1 == 0)
                                {
                                    Call GetEndgameLocal;
                                    If (IsEndgameLocal == 1)
                                    {
                                        Reduction += -1;
                                    }
                                }
                                If (1 == 0)
                                {
                                    If Cutnode
                                    {
                                        Reduction += 1;
                                    }
                                }
                                If (1 == 0)
                                {
                                    If (((QueenCountOppLocal + QueenCounttOwnLocal) + (RookCountOppLocal + RookCounttOwnLocal)) < 5)
                                    {
                                        Reduction += -1;
                                    }
                                }
                                If (1 == 0)
                                {
                                    If (Depth > 1)
                                    {
                                        List.ReplaceItem(CastlingState, (Depth + 1), CastlingState[Depth]);
                                        List.ReplaceItem(EnPassantTarget, (Depth + 1), EnPassantTarget[Depth]);
                                        Call Evaluate(Depth)((1 == 1));
                                        List.ReplaceItem(BoardEval, (Depth + 1), EvaluateRes);
                                        If (Not ((BoardEval[(Depth - 1)] == "")))
                                        {
                                            If ((((Depth % 2) == 1) And (EvaluateRes > BoardEval[(Depth - 1)])) Or (((Depth % 2) == 0) And (EvaluateRes < BoardEval[(Depth - 1)])))
                                            {
                                                Reduction += -1;
                                            }
                                        }
                                    }
                                }
                                If (1 == 0)
                                {
                                    If (Reduction > (Horizon - 2))
                                    {
                                        Reduction = (Horizon - 2);
                                    }
                                }
                                If (Reduction < 0)
                                {
                                    Reduction = 0;
                                }
                                Call //("Late move reduction");
                                If (Reduction > 0)
                                {
                                    If ((Depth % 2) == 1)
                                    {
                                        List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                                        List.ReplaceItem(Betas, (Depth + 1), (Alphas[Depth] + 1));
                                    }
                                    Else
                                    {
                                        List.ReplaceItem(Alphas, (Depth + 1), (Betas[Depth] - 1));
                                        List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                                    }
                                    If (PlyExtension[Depth] == 1)
                                    {
                                        List.ReplaceItem(PlyExtension, (Depth + 0), 0);
                                        Call AlphaBetaMinMaxNextPly(Depth)(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)(Quiescence)(ShowProgress)(Horizon)(Reduction)((1 == 1))("");
                                        List.ReplaceItem(PlyExtension, (Depth + 0), 1);
                                    }
                                    Else
                                    {
                                        Call AlphaBetaMinMaxNextPly(Depth)(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)(Quiescence)(ShowProgress)(Horizon)(Reduction)((1 == 1))("");
                                    }
                                    Score = MinMaxResults[(Depth + 1)];
                                    ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                                    IsReductionAndDone = 1;
                                }
                            }
                        }
                    }
                    Call //("Non-PV search");
                    If ((((IsReductionAndDone == 1) And ((((Depth % 2) == 1) And (Score > Alphas[Depth])) Or (((Depth % 2) == 0) And (Score < Betas[Depth])))) Or ((IsReductionAndDone == 0) And ((PickedMoveCount[Depth] > 1) Or ((Betas[Depth] - Alphas[Depth]) == 1)))) And (IsMinMaxTimeout == 0))
                    {
                        If ((Depth % 2) == 1)
                        {
                            List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                            List.ReplaceItem(Betas, (Depth + 1), (Alphas[Depth] + 1));
                        }
                        Else
                        {
                            List.ReplaceItem(Alphas, (Depth + 1), (Betas[Depth] - 1));
                            List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                        }
                        Call AlphaBetaMinMaxNextPly(Depth)(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)(Quiescence)(ShowProgress)(Horizon)(0)((Not (Cutnode)))("");
                        Score = MinMaxResults[(Depth + 1)];
                        ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                        If ((Score > Alphas[Depth]) And ((Depth == 1) Or (Score < Betas[Depth])))
                        {
                            IsReductionAndDone = 0;
                        }
                        Else
                        {
                            IsReductionAndDone = 1;
                        }
                    }
                }
                Call //("Move was not pruned upfront, enter standard search");
                If ((IsReductionAndDone == 0) And (IsMinMaxTimeout == 0))
                {
                    List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                    List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                    Call AlphaBetaMinMaxNextPly(Depth)(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)(Quiescence)(ShowProgress)(Horizon)(0)((1 == 0))("");
                    Score = MinMaxResults[(Depth + 1)];
                    ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                }
                If (IsMinMaxTimeout == 0)
                {
                    If (Depth == 1)
                    {
                        List.Add(MinMaxPly1EvalMoves, AppliedMove[Depth]);
                    }
                }
                Call //("Revert applied move, restore board to previous state");
                Call RevertMove(Depth);
                If (IsMinMaxTimeout == 1)
                {
                    If (Quiescence[Depth] == 0)
                    {
                        MoveCount += MovesCount[Depth];
                    }
                    Else
                    {
                        MoveCountQ += MovesCount[Depth];
                    }
                    Stop(this script);
                }
                If (Not ((Score == "")))
                {
                    Call //("Compare node evaluation with search window, adapt node evaluation result and alpha/beta funnel accordingly");
                    If ((Depth % 2) == 1)
                    {
                        If ((Score > MinMaxResults[Depth]) Or (MinMaxResults[Depth] == ""))
                        {
                            List.ReplaceItem(MinMaxResults, Depth, Score);
                            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreIsDynamic);
                            If (Score > Alphas[Depth])
                            {
                                Call GetCurrentMove(Depth);
                                List.ReplaceItem(BestMoves, Depth, CurrentMove);
                                List.ReplaceItem(MovesIdxBestMove, Depth, MovesIdx[Depth]);
                                Call UpdatePV(Depth)(CurrentMove);
                                If Quiescence
                                {
                                    If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (Score < Betas[Depth]))
                                    {
                                        List.ReplaceItem(Alphas, Depth, Score);
                                    }
                                    Else
                                    {
                                        Call //("Cutoff");
                                        List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                        List.ReplaceItem(PickPhase, Depth, "*");
                                    }
                                }
                                Else
                                {
                                    List.ReplaceItem(Alphas, Depth, Score);
                                    If ((Depth == 1) And (IsMinMaxTimeout == 0))
                                    {
                                        If (Not ((Score < (0 - AbsMaxCheckmateEval))))
                                        {
                                            Call //("Best move found for depth = 1, special handling (re-use history for iterative deepening order, logging, move preview visualization)");
                                            If (Score > MinMaxAlpha)
                                            {
                                                MinMaxMoveRes = BestMoves[Depth];
                                                MinMaxEvalRes = Score;
                                                If (1 == 1)
                                                {
                                                    Call Log((MaxDepth - 1))(" : ")(MinMaxMoveRes)(" : ")(MinMaxEvalRes)("")("")("");
                                                }
                                                Call OnEvaluationChanged(Score);
                                            }
                                            If (MinMaxMoveRes == GoK_OwnKingsideCastling)
                                            {
                                                Stg_BestMoveFromIdx = VirtualBoard[5];
                                                Stg_BestMoveToIdx = VirtualBoard[7];
                                            }
                                            Else
                                            {
                                                If (MinMaxMoveRes == GoK_OwnQueensideCastling)
                                                {
                                                    Stg_BestMoveFromIdx = VirtualBoard[5];
                                                    Stg_BestMoveToIdx = VirtualBoard[3];
                                                }
                                                Else
                                                {
                                                    Stg_BestMoveFromIdx = floor((MinMaxMoveRes / 100));
                                                    Stg_BestMoveToIdx = floor((MinMaxMoveRes % 100));
                                                }
                                            }
                                            Event.Broadcast("showbestmove");
                                            If (Score > (AbsMaxCheckmateEval - ((MaxDepth - 1) * 1000)))
                                            {
                                                IsMinMaxTimeout = 1;
                                                PrevPly1Move = "";
                                            }
                                            If (Not ((Score < MinMaxBeta)))
                                            {
                                                List.ReplaceItem(MinMaxResults, Depth, Score);
                                                Stop(this script);
                                            }
                                        }
                                    }
                                    If (Not ((Score < Betas[Depth])))
                                    {
                                        If ((floor((BestMoves[Depth] / 100)) == 0) Or (Board[floor((BestMoves[Depth] % 100))] == 0))
                                        {
                                            Call StoreKillerMove(Depth)(BestMoves[Depth])(MaxDepth);
                                        }
                                        If (Depth > 1)
                                        {
                                            Call //("Cutoff");
                                            List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                            List.ReplaceItem(PickPhase, Depth, "*");
                                        }
                                    }
                                }
                            }
                        }
                    }
                    Else
                    {
                        If ((Score < MinMaxResults[Depth]) Or (MinMaxResults[Depth] == ""))
                        {
                            List.ReplaceItem(MinMaxResults, Depth, Score);
                            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreIsDynamic);
                            If (Score < Betas[Depth])
                            {
                                Call GetCurrentMove(Depth);
                                List.ReplaceItem(BestMoves, Depth, CurrentMove);
                                List.ReplaceItem(MovesIdxBestMove, Depth, MovesIdx[Depth]);
                                Call UpdatePV(Depth)(CurrentMove);
                                If Quiescence
                                {
                                    If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (Score > Alphas[Depth]))
                                    {
                                        List.ReplaceItem(Betas, Depth, Score);
                                    }
                                    Else
                                    {
                                        List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                        List.ReplaceItem(PickPhase, Depth, "*");
                                        Call //("Cutoff");
                                    }
                                }
                                Else
                                {
                                    List.ReplaceItem(Betas, Depth, Score);
                                    If (Not ((Score > Alphas[Depth])))
                                    {
                                        If ((floor((BestMoves[Depth] / 100)) == 0) Or (Board[floor((BestMoves[Depth] % 100))] == 0))
                                        {
                                            Call StoreKillerMove(Depth)(BestMoves[Depth])(MaxDepth);
                                        }
                                        List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                        List.ReplaceItem(PickPhase, Depth, "*");
                                        Call //("Cutoff");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    If (Quiescence[Depth] == 0)
    {
        MoveCount += MovesCount[Depth];
    }
    Else
    {
        MoveCountQ += MovesCount[Depth];
    }
    Call //("Evaluation alpha-bound, beta-bound or exact?");
    If ((Depth % 2) == 1)
    {
        If (Not ((MinMaxResults[Depth] < Betas[Depth])))
        {
            List.ReplaceItem(ScoreTypes, Depth, "B");
        }
        Else
        {
            If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (((Not (Quiescence)) Or (MinMaxResults[Depth] > AlphasOld[Depth])) And (Not ((BestMoves[Depth] == "")))))
            {
                List.ReplaceItem(ScoreTypes, Depth, "E");
            }
            Else
            {
                List.ReplaceItem(ScoreTypes, Depth, "A");
            }
        }
    }
    Else
    {
        If (Not ((MinMaxResults[Depth] > Alphas[Depth])))
        {
            List.ReplaceItem(ScoreTypes, Depth, "A");
        }
        Else
        {
            If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (((Not (Quiescence)) Or (MinMaxResults[Depth] < BetasOld[Depth])) And (Not ((BestMoves[Depth] == "")))))
            {
                List.ReplaceItem(ScoreTypes, Depth, "E");
            }
            Else
            {
                List.ReplaceItem(ScoreTypes, Depth, "B");
            }
        }
    }
    Call //("Fast quiescence search checkmate detection (no check evasion found)");
    If (Quiescence And ((MovesCount[Depth] == 0) And (CheckedState[Depth] == 1)))
    {
        List.ReplaceItem(ScoreTypes, Depth, "E");
        If ((Depth % 2) == 1)
        {
            List.ReplaceItem(MinMaxResults, Depth, (-100000 + ((Depth + 1) * 1000)));
        }
        Else
        {
            List.ReplaceItem(MinMaxResults, Depth, (100000 - ((Depth + 1) * 1000)));
        }
        List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
    }
    Call //("Fast full search checkmate and stalemate detection");
    If ((Not (Quiescence)) And ((MovesCount[Depth] == 0) And (ExcludeMove == "")))
    {
        List.ReplaceItem(ScoreTypes, Depth, "E");
        If ((Depth % 2) == 1)
        {
            If (CheckedState[Depth] == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, (-100000 + ((Depth + 1) * 1000)));
            }
            Else
            {
                Call CalcBoardAttackedByMoveChecked((Depth + 1));
                If (IsOwnSideChecked == 1)
                {
                    List.ReplaceItem(MinMaxResults, Depth, (-100000 + ((Depth + 1) * 1000)));
                }
                Else
                {
                    List.ReplaceItem(MinMaxResults, Depth, 0);
                }
            }
        }
        Else
        {
            If (CheckedState[Depth] == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, (100000 - ((Depth + 1) * 1000)));
            }
            Else
            {
                Call CalcBoardAttackedByMoveChecked((Depth + 1));
                If (IsOppSideChecked == 1)
                {
                    List.ReplaceItem(MinMaxResults, Depth, (100000 - ((Depth + 1) * 1000)));
                }
                Else
                {
                    List.ReplaceItem(MinMaxResults, Depth, 0);
                }
            }
        }
        List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
        Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")(ScoreTypes[Depth])("")(99)("")("")("")("")("")(0);
    }
    If (BestMoves[Depth] == "")
    {
        If (MovesCount[Depth] > 0)
        {
            List.ReplaceItem(MovesIdx, Depth, 1);
            Call GetCurrentMove(Depth);
            List.ReplaceItem(BestMoves, Depth, CurrentMove);
        }
    }
    If (((IsMinMaxTimeout == 0) And (Depth > 1)) And (ExcludeMove == ""))
    {
        Call //("Store evaluations, hash moves, attack tables, check state, mobility, ... to transposition table");
        If Quiescence
        {
            Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])(BestMoves[Depth])(ScoreTypes[Depth])("")(-1)("")("")("")("")("")(MinMaxResultsIsDynamic[Depth]);
        }
        Else
        {
            Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])(BestMoves[Depth])(ScoreTypes[Depth])("")(Horizon)("")("")("")("")("")(MinMaxResultsIsDynamic[Depth]);
        }
    }
    Call //("Collect statistics");
    If (MovesIdxBestMove[Depth] > 0)
    {
        If Quiescence
        {
            ProfBestMoveCountQ += 1;
            ProfBestMoveIdxSumQ += MovesIdxBestMove[Depth];
        }
        Else
        {
            ProfBestMoveCount += 1;
            ProfBestMoveIdxSum += MovesIdxBestMove[Depth];
        }
        If (1 == 0)
        {
            If (IsBlockProfilerEnabled == 1)
            {
                If (MovesIdxBestMove[Depth] > (3 - (Quiescence[Depth] * 2)))
                {
                    Call ExportBoardFEN((IsPlayerBlack == 1))(((Depth % 2) == 0));
                    Call Log("Move ordering indication")(Operator.Join(Operator.Join(":", Depth), Operator.Join(":", MovesIdxBestMove[Depth])))(Operator.Join(Operator.Join(":", Board[floor((BestMoves[Depth] / 100))]), Operator.Join(":", BestMoves[Depth])))(Operator.Join(Operator.Join(":", Board[floor((BestMoves[Depth] % 100))]), Operator.Join(":", Quiescence[Depth])))(":")(ExportDataFEN)("")("");
                }
            }
        }
    }
}

Define AlphaBetaMinMaxNextPly(string CurrentDepth)(string MinDepth)(string MaxDepth)(bool CurrentInitialDeepening)(string QuiescenceDepth)(bool CurrentQuiescence)(bool ShowProgress)(string CurrentHorizon)(string Reduction)(bool CurrentCutnode)(string ExcludeNode) (warp=true)
{
    If (CurrentQuiescence Or ((Not (CurrentQuiescence)) And (((CurrentHorizon + PlyExtension[CurrentDepth]) - Reduction) < 2)))
    {
        Call //("If on full search and max depth reached, extend or switch to quiescence. If on quiescence search, continue");
        If (QuiescenceDepth > 0)
        {
            Call AlphaBetaMinMaxImpl((CurrentDepth + 1))(MinDepth)((MaxDepth + 1))(CurrentInitialDeepening)((QuiescenceDepth - 1))((1 == 1))(CurrentQuiescence)(ShowProgress)(1)((1 == 1))(ExcludeNode);
        }
        Else
        {
            Call AlphaBetaMinMaxImpl((CurrentDepth + 1))(MinDepth)((CurrentDepth + 1))(CurrentInitialDeepening)((QuiescenceDepth - 1))((1 == 1))(CurrentQuiescence)(ShowProgress)(0)((1 == 1))(ExcludeNode);
        }
    }
    Else
    {
        Call AlphaBetaMinMaxImpl((CurrentDepth + 1))(MinDepth)(((MaxDepth + PlyExtension[CurrentDepth]) - Reduction))(CurrentInitialDeepening)(QuiescenceDepth)(CurrentQuiescence)(CurrentQuiescence)(ShowProgress)((((CurrentHorizon + PlyExtension[CurrentDepth]) - Reduction) - 1))(CurrentCutnode)(ExcludeNode);
    }
}

Define ApplyMove(num Depth) (warp=true)
{
    Call TaperedEval.Init;
    List.ReplaceItem(PosScoreDelta, (Depth + 0), 0);
    List.ReplaceItem(SourcePieces, (Depth + 0), 0);
    List.ReplaceItem(TargetPiecesIdx, (Depth + 0), "");
    List.ReplaceItem(TargetPieces, (Depth + 0), 0);
    List.ReplaceItem(PromotionPieces, (Depth + 0), 0);
    If (Depth == 1)
    {
        List.ReplaceItem(CastlingState, (Depth + 0), Operator.Join(Operator.Join(Operator.Join(HasOwnCastled, HasOwnKingMoved), Operator.Join(HasOwnRookKSMoved, HasOwnRookQSMoved)), Operator.Join(Operator.Join(HasOppCastled, HasOppKingMoved), Operator.Join(HasOppRookKSMoved, HasOppRookQSMoved))));
    }
    Else
    {
        List.ReplaceItem(CastlingState, (Depth + 0), CastlingState[(Depth - 1)]);
    }
    List.ReplaceItem(EnPassantTarget, (Depth + 0), "");
    List.ReplaceItem(PutsInCheck, (Depth + 0), 0);
    List.ReplaceItem(PreviousBoardHash, (Depth + 0), CurrentBoardHash);
    List.ReplaceItem(PreviousBoardHash2, (Depth + 0), CurrentBoardHash2);
    Call GetCurrentMove(Depth);
    List.ReplaceItem(AppliedMove, (Depth + 0), CurrentMove);
    Call AddToFiftyMoves((((Not ((CurrentMove == 0))) And (Not ((floor((CurrentMove / 100)) == 0)))) And ((abs(Board[floor((CurrentMove / 100))]) == GoK_OwnPawn) Or (Not ((Board[floor((CurrentMove % 100))] == 0))))));
    SourceIdx = floor((CurrentMove / 100));
    If (SourceIdx > 0)
    {
        TargetIdx = floor((CurrentMove % 100));
        SourcePiece = Board[(SourceIdx + 0)];
        TargetPiece = Board[(TargetIdx + 0)];
        List.ReplaceItem(SourcePieces, (Depth + 0), SourcePiece);
        List.ReplaceItem(TargetPiecesIdx, (Depth + 0), TargetIdx);
        List.ReplaceItem(TargetPieces, (Depth + 0), TargetPiece);
        List.ReplaceItem(PromotionPieces, (Depth + 0), 0);
        List.ReplaceItem(Board, (TargetIdx + 0), SourcePiece);
        List.ReplaceItem(Board, (SourceIdx + 0), 0);
        If (SourcePiece > 0)
        {
            IdxSub = ((PieceIdxLookup[(SourcePiece + 0)] * 10000) + ((SourceIdx * 100) + TargetIdx));
            If ((Not (((SourcePiece == GoK_OwnKing) And ((IsEndgame == 1) And (QueenCountOppLocal > 0))))) Or (1 == 1))
            {
                Call TaperedEval.GetScalarResult(MovePosLookupMgOwn[(IdxSub + 0)])(MovePosLookupOwnEg[(IdxSub + 0)])(TaperedEval.ScaleFactor)(TaperedEval.Phase);
                List.ReplaceItem(PosScoreDelta, (Depth + 0), (PosScoreDelta[(Depth + 0)] + TaperedEval.ScalarResult));
            }
            CurrentBoardHash += MoveHashLookupOwn[(IdxSub + 0)];
            If (SourcePiece == GoK_OwnPawn)
            {
                CurrentBoardHash2 += MoveHashLookupOwn[(IdxSub + 0)];
                If (Not ((IdxToFile[(SourceIdx + 0)] == IdxToFile[(TargetIdx + 0)])))
                {
                    If (TargetPieces[(Depth + 0)] == 0)
                    {
                        List.ReplaceItem(TargetPiecesIdx, (Depth + 0), (TargetIdx - 8));
                        List.ReplaceItem(TargetPieces, (Depth + 0), Board[(TargetIdx - 8)]);
                        TargetPiece = Board[(TargetIdx - 8)];
                        List.ReplaceItem(Board, (TargetIdx - 8), 0);
                        If (1 == 0)
                        {
                            Call GetPiecePosHash(Board[(TargetIdx - 8)])((TargetIdx - 8));
                            CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                            CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
                        }
                    }
                }
                If ((TargetIdx - SourceIdx) == 16)
                {
                    List.ReplaceItem(EnPassantTarget, Depth, TargetIdx);
                }
                If (TargetIdx > 56)
                {
                    PromotionVal = Operator.LetterOf(CurrentMove, Variable.Length(CurrentMove));
                    If (PromotionVal == 1)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, GoK_OwnQueen);
                        QueenCounttOwnLocal += 1;
                    }
                    If (PromotionVal == 2)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, GoK_OwnRook);
                        RookCounttOwnLocal += 1;
                        RookMinorCounttOwnLocal += 1;
                    }
                    If (PromotionVal == 3)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, GoK_OwnBishop);
                        BishopCounttOwnLocal += 1;
                        RookMinorCounttOwnLocal += 1;
                    }
                    If (PromotionVal == 4)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, GoK_OwnKnight);
                        RookMinorCounttOwnLocal += 1;
                    }
                    PawnCounttOwnLocal += -1;
                    Call GetPiecePosHash(GoK_OwnPawn)(SourceIdx);
                    CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                    CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
                    List.ReplaceItem(Board, TargetIdx, PromotionPieces[(Depth + 0)]);
                    Call GetPiecePosHash(PromotionPieces[(Depth + 0)])(TargetIdx);
                    CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
                }
            }
            Else
            {
                If (SourcePiece == GoK_OwnKing)
                {
                    KingIdxtOwn = TargetIdx;
                    CurrentBoardHash2 += MoveHashLookupOwn[(IdxSub + 0)];
                    Call SetCastlingStateFlag(Depth)(2)(1);
                }
                If (SourcePiece == GoK_OwnRook)
                {
                    If (Operator.LetterOf(CastlingState[(Depth + 0)], 3) == 0)
                    {
                        If (SourceIdx == VirtualBoard[8])
                        {
                            Call SetCastlingStateFlag(Depth)(3)(1);
                        }
                    }
                    If (Operator.LetterOf(CastlingState[(Depth + 0)], 4) == 0)
                    {
                        If (SourceIdx == VirtualBoard[1])
                        {
                            Call SetCastlingStateFlag(Depth)(4)(1);
                        }
                    }
                }
            }
        }
        Else
        {
            IdxSub = ((PieceIdxLookup[(0 - SourcePiece)] * 10000) + ((SourceIdx * 100) + TargetIdx));
            If ((Not (((SourcePiece == GoK_OppKing) And ((IsEndgame == 1) And (QueenCounttOwnLocal > 0))))) Or (1 == 1))
            {
                Call TaperedEval.GetScalarResult(MovePosLookupOppMg[(IdxSub + 0)])(MovePosLookupOppEg[(IdxSub + 0)])(TaperedEval.ScaleFactor)(TaperedEval.Phase);
                List.ReplaceItem(PosScoreDelta, (Depth + 0), (PosScoreDelta[(Depth + 0)] + TaperedEval.ScalarResult));
            }
            CurrentBoardHash += MoveHashLookupOpp[(IdxSub + 0)];
            If (SourcePiece == GoK_OppPawn)
            {
                CurrentBoardHash2 += MoveHashLookupOpp[(IdxSub + 0)];
                If (Not ((IdxToFile[(SourceIdx + 0)] == IdxToFile[(TargetIdx + 0)])))
                {
                    If (TargetPieces[(Depth + 0)] == 0)
                    {
                        List.ReplaceItem(TargetPiecesIdx, (Depth + 0), (TargetIdx + 8));
                        List.ReplaceItem(TargetPieces, (Depth + 0), Board[(TargetIdx + 8)]);
                        TargetPiece = Board[(TargetIdx + 8)];
                        List.ReplaceItem(Board, (TargetIdx + 8), 0);
                        If (1 == 0)
                        {
                            Call GetPiecePosHash(Board[(TargetIdx + 8)])((TargetIdx + 8));
                            CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                            CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
                        }
                    }
                }
                If ((TargetIdx - SourceIdx) == -16)
                {
                    List.ReplaceItem(EnPassantTarget, Depth, TargetIdx);
                }
                If (TargetIdx < 9)
                {
                    PromotionVal = Operator.LetterOf(CurrentMove, Variable.Length(CurrentMove));
                    If (PromotionVal == 1)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, GoK_OppQueen);
                        QueenCountOppLocal += 1;
                    }
                    If (PromotionVal == 2)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, GoK_OppRook);
                        RookCountOppLocal += 1;
                        RookMinorCountLocalOpp += 1;
                    }
                    If (PromotionVal == 3)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, GoK_OppBishop);
                        BishopCountOppLocal += 1;
                        RookMinorCountLocalOpp += 1;
                    }
                    If (PromotionVal == 4)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, GoK_OppKnight);
                        RookMinorCountLocalOpp += 1;
                    }
                    PawnCountOppLocal += -1;
                    Call GetPiecePosHash(GoK_OppPawn)(SourceIdx);
                    CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                    CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
                    List.ReplaceItem(Board, TargetIdx, PromotionPieces[(Depth + 0)]);
                    Call GetPiecePosHash(PromotionPieces[Depth])(TargetIdx);
                    CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
                }
            }
            Else
            {
                If (SourcePiece == GoK_OppKing)
                {
                    KingIdxOpp = TargetIdx;
                    CurrentBoardHash2 += MoveHashLookupOpp[(IdxSub + 0)];
                    Call SetCastlingStateFlag(Depth)(6)(1);
                }
                If (SourcePiece == GoK_OppRook)
                {
                    If (Operator.LetterOf(CastlingState[(Depth + 0)], 7) == 0)
                    {
                        If (SourceIdx == VirtualBoard[64])
                        {
                            Call SetCastlingStateFlag(Depth)(7)(1);
                        }
                    }
                    If (Operator.LetterOf(CastlingState[(Depth + 0)], 8) == 0)
                    {
                        If (SourceIdx == VirtualBoard[57])
                        {
                            Call SetCastlingStateFlag(Depth)(8)(1);
                        }
                    }
                }
            }
        }
        If (TargetPiece > 0)
        {
            IdxSub = ((PieceIdxLookup[(TargetPiece + 0)] * 10000) + (TargetPiecesIdx[(Depth + 0)] * 100));
            Call TaperedEval.GetScalarResult(MovePosLookupMgOwn[(IdxSub + 0)])(MovePosLookupOwnEg[(IdxSub + 0)])(TaperedEval.ScaleFactor)(TaperedEval.Phase);
            List.ReplaceItem(PosScoreDelta, (Depth + 0), (PosScoreDelta[(Depth + 0)] + TaperedEval.ScalarResult));
            CurrentBoardHash += MoveHashLookupOwn[(IdxSub + 0)];
            If ((TargetPiece == GoK_OwnPawn) Or (TargetPiece == GoK_OwnKing))
            {
                CurrentBoardHash2 += MoveHashLookupOwn[(IdxSub + 0)];
            }
            If (TargetPiece == GoK_OwnPawn)
            {
                PawnCounttOwnLocal += -1;
            }
            Else
            {
                If (TargetPiece < GoK_OwnQueen)
                {
                    RookMinorCounttOwnLocal += -1;
                    If (TargetPiece == GoK_OwnRook)
                    {
                        RookCounttOwnLocal += -1;
                    }
                    If (TargetPiece == GoK_OwnBishop)
                    {
                        BishopCounttOwnLocal += -1;
                    }
                }
                Else
                {
                    If (TargetPiece == GoK_OwnQueen)
                    {
                        QueenCounttOwnLocal += -1;
                    }
                }
            }
        }
        Else
        {
            If (TargetPiece < 0)
            {
                IdxSub = ((PieceIdxLookup[(0 - TargetPiece)] * 10000) + (TargetPiecesIdx[(Depth + 0)] * 100));
                Call TaperedEval.GetScalarResult(MovePosLookupOppMg[(IdxSub + 0)])(MovePosLookupOppEg[(IdxSub + 0)])(TaperedEval.ScaleFactor)(TaperedEval.Phase);
                List.ReplaceItem(PosScoreDelta, (Depth + 0), (PosScoreDelta[(Depth + 0)] + TaperedEval.ScalarResult));
                CurrentBoardHash += MoveHashLookupOpp[(IdxSub + 0)];
                If ((TargetPiece == GoK_OppPawn) Or (TargetPiece == GoK_OppKing))
                {
                    CurrentBoardHash2 += MoveHashLookupOpp[(IdxSub + 0)];
                }
                If (TargetPiece == GoK_OppPawn)
                {
                    PawnCountOppLocal += -1;
                }
                Else
                {
                    If (TargetPiece > GoK_OppQueen)
                    {
                        RookMinorCountLocalOpp += -1;
                        If (TargetPiece == GoK_OppRook)
                        {
                            RookCountOppLocal += -1;
                        }
                        If (TargetPiece == GoK_OppBishop)
                        {
                            BishopCountOppLocal += -1;
                        }
                    }
                    Else
                    {
                        If (TargetPiece == GoK_OppQueen)
                        {
                            QueenCountOppLocal += -1;
                        }
                    }
                }
            }
        }
    }
    Else
    {
        If (CurrentMove == GoK_OppKingsideCastling)
        {
            List.ReplaceItem(SourcePieces, Depth, GoK_OppKing);
            List.ReplaceItem(Board, VirtualBoard[61], 0);
            List.ReplaceItem(Board, VirtualBoard[62], GoK_OppRook);
            List.ReplaceItem(Board, VirtualBoard[63], GoK_OppKing);
            List.ReplaceItem(Board, VirtualBoard[64], 0);
            KingIdxOpp = VirtualBoard[63];
            Call UpdateMoveHashPosScore(GoK_OppKing)(VirtualBoard[61])(VirtualBoard[63])((1 == 0))(Depth);
            Call UpdateMoveHashPosScore(GoK_OppRook)(VirtualBoard[64])(VirtualBoard[62])((1 == 1))(Depth);
            Call SetCastlingStateFlag(Depth)(5)(1);
        }
        Else
        {
            If (CurrentMove == GoK_OppQueensideCastling)
            {
                List.ReplaceItem(SourcePieces, Depth, GoK_OppKing);
                List.ReplaceItem(Board, VirtualBoard[57], 0);
                List.ReplaceItem(Board, VirtualBoard[59], GoK_OppKing);
                List.ReplaceItem(Board, VirtualBoard[60], GoK_OppRook);
                List.ReplaceItem(Board, VirtualBoard[61], 0);
                KingIdxOpp = VirtualBoard[59];
                Call UpdateMoveHashPosScore(GoK_OppKing)(VirtualBoard[61])(VirtualBoard[59])((1 == 0))(Depth);
                Call UpdateMoveHashPosScore(GoK_OppRook)(VirtualBoard[57])(VirtualBoard[60])((1 == 1))(Depth);
                Call SetCastlingStateFlag(Depth)(5)(1);
            }
            Else
            {
                If (CurrentMove == GoK_OwnKingsideCastling)
                {
                    List.ReplaceItem(SourcePieces, Depth, GoK_OwnKing);
                    List.ReplaceItem(Board, VirtualBoard[5], 0);
                    List.ReplaceItem(Board, VirtualBoard[6], GoK_OwnRook);
                    List.ReplaceItem(Board, VirtualBoard[7], GoK_OwnKing);
                    List.ReplaceItem(Board, VirtualBoard[8], 0);
                    KingIdxtOwn = VirtualBoard[7];
                    Call UpdateMoveHashPosScore(GoK_OwnKing)(VirtualBoard[5])(VirtualBoard[7])((1 == 0))(Depth);
                    Call UpdateMoveHashPosScore(GoK_OwnRook)(VirtualBoard[8])(VirtualBoard[6])((1 == 1))(Depth);
                    Call SetCastlingStateFlag(Depth)(1)(1);
                }
                Else
                {
                    If (CurrentMove == GoK_OwnQueensideCastling)
                    {
                        List.ReplaceItem(SourcePieces, Depth, GoK_OwnKing);
                        List.ReplaceItem(Board, VirtualBoard[1], 0);
                        List.ReplaceItem(Board, VirtualBoard[3], GoK_OwnKing);
                        List.ReplaceItem(Board, VirtualBoard[4], GoK_OwnRook);
                        List.ReplaceItem(Board, VirtualBoard[5], 0);
                        KingIdxtOwn = VirtualBoard[3];
                        Call UpdateMoveHashPosScore(GoK_OwnKing)(VirtualBoard[5])(VirtualBoard[3])((1 == 0))(Depth);
                        Call UpdateMoveHashPosScore(GoK_OwnRook)(VirtualBoard[1])(VirtualBoard[4])((1 == 1))(Depth);
                        Call SetCastlingStateFlag(Depth)(1)(1);
                    }
                }
            }
        }
    }
    If (Not ((AppliedMove[Depth] == 0)))
    {
        If (Quiescence[Depth] == 0)
        {
            NodeCount += 1;
        }
        Else
        {
            NodeCountQ += 1;
        }
    }
}

Define ApplyMoveLight(string Depth) (warp=true)
{
    List.ReplaceItem(PreviousBoardHash, Depth, CurrentBoardHash);
    Call GetCurrentMove(Depth);
    List.ReplaceItem(AppliedMove, Depth, CurrentMove);
    SourceIdx = floor((CurrentMove / 100));
    If (SourceIdx > 0)
    {
        TargetIdx = floor((CurrentMove % 100));
        SourcePiece = Board[(SourceIdx + 0)];
        TargetPiece = Board[(TargetIdx + 0)];
        List.ReplaceItem(SourcePieces, Depth, SourcePiece);
        List.ReplaceItem(TargetPiecesIdx, Depth, TargetIdx);
        List.ReplaceItem(TargetPieces, Depth, TargetPiece);
        List.ReplaceItem(PromotionPieces, Depth, 0);
        List.ReplaceItem(Board, TargetIdx, SourcePiece);
        List.ReplaceItem(Board, SourceIdx, 0);
        If (SourcePiece > 0)
        {
            CurrentBoardHash += MoveHashLookupOwn[((PieceIdxLookup[(SourcePiece + 0)] * 10000) + ((SourceIdx * 100) + TargetIdx))];
        }
        Else
        {
            CurrentBoardHash += MoveHashLookupOpp[((PieceIdxLookup[(0 - SourcePiece)] * 10000) + ((SourceIdx * 100) + TargetIdx))];
        }
        If (TargetPiece > 0)
        {
            CurrentBoardHash += MoveHashLookupOwn[((PieceIdxLookup[(TargetPiece + 0)] * 10000) + (TargetIdx * 100))];
        }
        Else
        {
            If (TargetPiece < 0)
            {
                CurrentBoardHash += MoveHashLookupOpp[((PieceIdxLookup[(0 - TargetPiece)] * 10000) + (TargetIdx * 100))];
            }
        }
    }
    Else
    {
        List.ReplaceItem(PosScoreDelta, Depth, 0);
        List.ReplaceItem(SourcePieces, Depth, 0);
        List.ReplaceItem(TargetPiecesIdx, Depth, "");
        List.ReplaceItem(TargetPieces, Depth, 0);
        List.ReplaceItem(PromotionPieces, Depth, 0);
        If (CurrentMove == GoK_OppKingsideCastling)
        {
            List.ReplaceItem(SourcePieces, Depth, GoK_OppKing);
            List.ReplaceItem(Board, VirtualBoard[61], 0);
            List.ReplaceItem(Board, VirtualBoard[62], GoK_OppRook);
            List.ReplaceItem(Board, VirtualBoard[63], GoK_OppKing);
            List.ReplaceItem(Board, VirtualBoard[64], 0);
            KingIdxOpp = VirtualBoard[63];
            Call UpdateMoveHash(GoK_OppKing)(VirtualBoard[61])(VirtualBoard[63])(Depth);
            Call UpdateMoveHash(GoK_OppRook)(VirtualBoard[64])(VirtualBoard[62])(Depth);
        }
        Else
        {
            If (CurrentMove == GoK_OppQueensideCastling)
            {
                List.ReplaceItem(SourcePieces, Depth, GoK_OppKing);
                List.ReplaceItem(Board, VirtualBoard[57], 0);
                List.ReplaceItem(Board, VirtualBoard[59], GoK_OppKing);
                List.ReplaceItem(Board, VirtualBoard[60], GoK_OppRook);
                List.ReplaceItem(Board, VirtualBoard[61], 0);
                KingIdxOpp = VirtualBoard[59];
                Call UpdateMoveHash(GoK_OppKing)(VirtualBoard[61])(VirtualBoard[59])(Depth);
                Call UpdateMoveHash(GoK_OppRook)(VirtualBoard[57])(VirtualBoard[60])(Depth);
            }
            Else
            {
                If (CurrentMove == GoK_OwnKingsideCastling)
                {
                    List.ReplaceItem(SourcePieces, Depth, GoK_OwnKing);
                    List.ReplaceItem(Board, VirtualBoard[5], 0);
                    List.ReplaceItem(Board, VirtualBoard[6], GoK_OwnRook);
                    List.ReplaceItem(Board, VirtualBoard[7], GoK_OwnKing);
                    List.ReplaceItem(Board, VirtualBoard[8], 0);
                    KingIdxtOwn = VirtualBoard[7];
                    Call UpdateMoveHash(GoK_OwnKing)(VirtualBoard[5])(VirtualBoard[7])(Depth);
                    Call UpdateMoveHash(GoK_OwnRook)(VirtualBoard[8])(VirtualBoard[6])(Depth);
                }
                Else
                {
                    If (CurrentMove == GoK_OwnQueensideCastling)
                    {
                        List.ReplaceItem(SourcePieces, Depth, GoK_OwnKing);
                        List.ReplaceItem(Board, VirtualBoard[1], 0);
                        List.ReplaceItem(Board, VirtualBoard[3], GoK_OwnKing);
                        List.ReplaceItem(Board, VirtualBoard[4], GoK_OwnRook);
                        List.ReplaceItem(Board, VirtualBoard[5], 0);
                        KingIdxtOwn = VirtualBoard[3];
                        Call UpdateMoveHash(GoK_OwnKing)(VirtualBoard[5])(VirtualBoard[3])(Depth);
                        Call UpdateMoveHash(GoK_OwnRook)(VirtualBoard[1])(VirtualBoard[4])(Depth);
                    }
                }
            }
        }
    }
}

Define ASM(string SourceIdx)(string Depth)(bool CapturesOnly)(bool SlidingMoveTypeStraight) (warp=true)
{
    ASMA.SourcePiece = Board[(SourceIdx + 0)];
    ASMA.Idx = MoveLookupLineIndexOffset[(SourceIdx + 0)];
    ASMA.Count = 1;
    ASMA.InvIdx = 8;
    Repeat Until (ASMA.Count > 32)
    {
        If SlidingMoveTypeStraight
        {
            ASMA.TargetIdx = MoveLookupStraight[(ASMA.Idx + ASMA.Count)];
        }
        Else
        {
            ASMA.TargetIdx = MoveLookupCross[(ASMA.Idx + ASMA.Count)];
        }
        If (ASMA.TargetIdx == -1)
        {
            ASMA.Count += ASMA.InvIdx;
            ASMA.InvIdx = 8;
        }
        Else
        {
            If (Board[(ASMA.TargetIdx + 0)] == 0)
            {
                If CapturesOnly
                {
                    Call AddPotentialQuiescenceMove(SourceIdx)(ASMA.TargetIdx)(ASMA.SourcePiece)(Depth);
                }
                Else
                {
                    Call AddMoveImpl(SourceIdx)(ASMA.TargetIdx)(Depth)((1 == 0))(CapturesOnly);
                }
                ASMA.Count += 1;
                ASMA.InvIdx += -1;
            }
            Else
            {
                If (ASMA.SourcePiece > 0)
                {
                    If (Board[(ASMA.TargetIdx + 0)] < 0)
                    {
                        Call AddMoveImpl(SourceIdx)(ASMA.TargetIdx)(Depth)((1 == 0))(CapturesOnly);
                    }
                }
                Else
                {
                    If (Board[(ASMA.TargetIdx + 0)] > 0)
                    {
                        Call AddMoveImpl(SourceIdx)(ASMA.TargetIdx)(Depth)((1 == 0))(CapturesOnly);
                    }
                }
                ASMA.Count += ASMA.InvIdx;
                ASMA.InvIdx = 8;
            }
        }
    }
}

Define ASMAttack(string SourceIdx)(string Depth)(bool SlidingMoveTypeStraight) (warp=true)
{
    ASMA.SourcePiece = (Board[(SourceIdx + 0)] + 0);
    ASMA.Idx = (MoveLookupLineIndexOffset[(SourceIdx + 0)] + 0);
    ASMA.Count = 1;
    ASMA.InvIdx = 8;
    List.DeleteAll(KingAttackLinesTemp);
    Repeat Until (ASMA.Count > 32)
    {
        If SlidingMoveTypeStraight
        {
            ASMA.TargetIdx = (MoveLookupStraight[(ASMA.Idx + ASMA.Count)] + 0);
        }
        Else
        {
            ASMA.TargetIdx = (MoveLookupCross[(ASMA.Idx + ASMA.Count)] + 0);
        }
        If (ASMA.TargetIdx == -1)
        {
            ASMA.Count += ASMA.InvIdx;
            ASMA.InvIdx = 8;
            List.DeleteAll(KingAttackLinesTemp);
        }
        Else
        {
            Call AddMoveImpl(SourceIdx)(ASMA.TargetIdx)(Depth)((1 == 1))((1 == 0));
            ASMA.TargetPiece = (Board[(ASMA.TargetIdx + 0)] + 0);
            If (ASMA.TargetPiece == 0)
            {
                List.Add(KingAttackLinesTemp, ASMA.TargetIdx);
                ASMA.Count += 1;
                ASMA.InvIdx += -1;
            }
            Else
            {
                IsXRay = 0;
                ASMA.TargetPieceAbs = abs(ASMA.TargetPiece);
                If (ASMA.TargetPieceAbs == GoK_OwnKing)
                {
                    If (((ASMA.SourcePiece > 0) And (ASMA.TargetPiece == GoK_OppKing)) Or ((ASMA.SourcePiece < 0) And (ASMA.TargetPiece == GoK_OwnKing)))
                    {
                        Idx = 1;
                        Repeat (List.Length(KingAttackLinesTemp))
                        {
                            List.Add(KingAttackLines, KingAttackLinesTemp[(Idx + 0)]);
                            Idx += 1;
                        }
                    }
                }
                Else
                {
                    If (ASMA.TargetPieceAbs > GoK_OwnKnight)
                    {
                        If (((ASMA.SourcePiece > 0) And (ASMA.TargetPiece > 0)) Or ((ASMA.SourcePiece < 0) And (ASMA.TargetPiece < 0)))
                        {
                            If SlidingMoveTypeStraight
                            {
                                If ((ASMA.TargetPieceAbs == GoK_OwnQueen) Or (ASMA.TargetPieceAbs == GoK_OwnRook))
                                {
                                    IsXRay = 1;
                                }
                            }
                            Else
                            {
                                If ((ASMA.TargetPieceAbs == GoK_OwnQueen) Or (ASMA.TargetPieceAbs == GoK_OwnBishop))
                                {
                                    IsXRay = 1;
                                }
                            }
                        }
                    }
                }
                If (IsXRay == 1)
                {
                    ASMA.Count += 1;
                    ASMA.InvIdx += -1;
                }
                Else
                {
                    ASMA.Count += ASMA.InvIdx;
                    ASMA.InvIdx = 8;
                }
                List.DeleteAll(KingAttackLinesTemp);
            }
        }
    }
}

Define CalcBoardAttackedByMove(string Depth) (warp=true)
{
    Call ClearBoardAttackedByMove(Depth);
    Call GenerateMovesImplWrapper(Depth)((1 == 1))((1 == 0));
}

Define CalcBoardAttackedByMoveChecked(string Depth) (warp=true)
{
    Call TTProbeNode(CurrentBoardHash)((Depth + 1));
    If ((TTProbeRes == 1) And (Not ((TTProbeCheckedRes == ""))))
    {
        If ((Depth % 2) == 1)
        {
            IsOppSideChecked = TTProbeCheckedRes;
        }
        Else
        {
            IsOwnSideChecked = TTProbeCheckedRes;
        }
        Stop(this script);
    }
    List.ReplaceItem(CastlingState, (Depth + 1), CastlingState[Depth]);
    List.ReplaceItem(EnPassantTarget, (Depth + 1), EnPassantTarget[Depth]);
    If ((Depth % 2) == 1)
    {
        IsOppSideChecked = 0;
        IdxOuter2 = 1;
        Repeat (64)
        {
            If (Board[(IdxOuter2 + 0)] > 0)
            {
                Call IsCheckingPiece(IdxOuter2);
                If (IsCheckingPieceRes == 1)
                {
                    IsOppSideChecked = 1;
                }
            }
            IdxOuter2 += 1;
        }
        Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(IsOppSideChecked)("")("")("")("")("")("")("");
    }
    Else
    {
        IsOwnSideChecked = 0;
        IdxOuter2 = 1;
        Repeat (64)
        {
            If (Board[(IdxOuter2 + 0)] < 0)
            {
                Call IsCheckingPiece(IdxOuter2);
                If (IsCheckingPieceRes == 1)
                {
                    IsOwnSideChecked = 1;
                }
            }
            IdxOuter2 += 1;
        }
        Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(IsOwnSideChecked)("")("")("")("")("")("")("");
    }
}

Define CalcBoardAttackedOnDemand(string Depth)(bool Quiescence)(bool ForceOnCheck)(string MaxDepth) (warp=true)
{
    If (BoardAttackedCalculated[Depth] == 0)
    {
        If ((ForceOnCheck And (CheckedState[Depth] == 1)) Or ((Not ((Depth > MaxDepth))) And (Not (Quiescence))))
        {
            Call CalcBoardAttackedByMove((Depth + 1));
            Call StoreAttackInfo((Depth + 1))(Depth);
            List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
        }
    }
}

Define CalcBoardStats (warp=true)
{
    KingIdxtOwn = "";
    KingIdxOpp = "";
    CurrentBoardHash = 0;
    CurrentBoardHash2 = 0;
    Idx = 1;
    Repeat (8)
    {
        List.ReplaceItem(PawnCountOwn, Idx, 0);
        List.ReplaceItem(PawnCountOpp, Idx, 0);
        Idx += 1;
    }
    Idx = 1;
    Repeat (64)
    {
        If (Board[Idx] == GoK_OppPawn)
        {
            List.ReplaceItem(PawnCountOpp, IdxToFile[Idx], (PawnCountOpp[IdxToFile[Idx]] + 1));
        }
        Else
        {
            If (Board[Idx] == GoK_OwnPawn)
            {
                List.ReplaceItem(PawnCountOwn, IdxToFile[Idx], (PawnCountOwn[IdxToFile[Idx]] + 1));
            }
            Else
            {
                If (Board[Idx] == GoK_OppKing)
                {
                    KingIdxOpp = Idx;
                }
                Else
                {
                    If (Board[Idx] == GoK_OwnKing)
                    {
                        KingIdxtOwn = Idx;
                    }
                }
            }
        }
        Call GetPiecePosHash(Board[Idx])(Idx);
        CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
        If ((abs(Board[Idx]) == GoK_OwnPawn) Or (abs(Board[Idx]) == GoK_OwnKing))
        {
            CurrentBoardHash2 = (CurrentBoardHash2 + PiecePosHash);
        }
        Idx += 1;
    }
    RookMinorCounttOwn = 0;
    QueenCounttOwn = 0;
    PawnCounttOwn = 0;
    RookCounttOwn = 0;
    BishopCountOwn = 0;
    QueenCountOpp = 0;
    RookMinorCountOpp = 0;
    PawnCountOpp = 0;
    RookCountOpp = 0;
    BishopCountOpp = 0;
    Idx = 1;
    Repeat (64)
    {
        If (Board[Idx] == GoK_OppQueen)
        {
            QueenCountOpp += 1;
        }
        If (Board[Idx] == GoK_OwnQueen)
        {
            QueenCounttOwn += 1;
        }
        If ((Board[Idx] == GoK_OppKnight) Or ((Board[Idx] == GoK_OppBishop) Or (Board[Idx] == GoK_OppRook)))
        {
            RookMinorCountOpp += 1;
            If (Board[Idx] == GoK_OppRook)
            {
                RookCountOpp += 1;
            }
            If (Board[Idx] == GoK_OppBishop)
            {
                BishopCountOpp += 1;
            }
        }
        If ((Board[Idx] == GoK_OwnKnight) Or ((Board[Idx] == GoK_OwnBishop) Or (Board[Idx] == GoK_OwnRook)))
        {
            RookMinorCounttOwn += 1;
            If (Board[Idx] == GoK_OwnRook)
            {
                RookCounttOwn += 1;
            }
            If (Board[Idx] == GoK_OwnBishop)
            {
                BishopCountOwn += 1;
            }
        }
        If (Board[Idx] == GoK_OppPawn)
        {
            PawnCountOpp += 1;
        }
        If (Board[Idx] == GoK_OwnPawn)
        {
            PawnCounttOwn += 1;
        }
        Idx += 1;
    }
    If ((((QueenCountOpp + RookMinorCountOpp) + (QueenCounttOwn + RookMinorCounttOwn)) < 3) And ((QueenCountOpp == 0) Or (QueenCounttOwn == 0)))
    {
        IsEndgame2 = 1;
        IsEndgame = 1;
    }
    Else
    {
        IsEndgame2 = 0;
        IsEndgame = 0;
        Call GetAttackForce((1 == 0));
        If (AttackForce < 13)
        {
            IsEndgame = 1;
        }
        Call GetAttackForce((1 == 1));
        If (AttackForce < 13)
        {
            IsEndgame = 1;
        }
    }
    If ((HasOwnCastled == 0) And ((HasOwnKingMoved == 0) And ((HasOwnRookKSMoved == 0) Or (HasOwnRookQSMoved == 0))))
    {
        IsOwnSideCastlingPossible = 1;
    }
    Else
    {
        IsOwnSideCastlingPossible = 0;
    }
    If ((HasOppCastled == 0) And ((HasOppKingMoved == 0) And ((HasOppRookKSMoved == 0) Or (HasOppRookQSMoved == 0))))
    {
        IsOppSideCastlingPossible = 1;
    }
    Else
    {
        IsOppSideCastlingPossible = 0;
    }
    QueenCountOppLocal = QueenCountOpp;
    RookMinorCountLocalOpp = RookMinorCountOpp;
    QueenCounttOwnLocal = QueenCounttOwn;
    RookMinorCounttOwnLocal = RookMinorCounttOwn;
    RookCountOppLocal = RookCountOpp;
    RookCounttOwnLocal = RookCounttOwn;
    PawnCountOppLocal = PawnCountOpp;
    PawnCounttOwnLocal = PawnCounttOwn;
    BishopCountOppLocal = BishopCountOpp;
    BishopCounttOwnLocal = BishopCountOwn;
    List.ReplaceItem(CastlingState, 1, Operator.Join(Operator.Join(Operator.Join(HasOwnCastled, HasOwnKingMoved), Operator.Join(HasOwnRookKSMoved, HasOwnRookQSMoved)), Operator.Join(Operator.Join(HasOppCastled, HasOppKingMoved), Operator.Join(HasOppRookKSMoved, HasOppRookQSMoved))));
    List.ReplaceItem(CastlingState, 2, CastlingState[1]);
}

Define CalculateMaterialImbalance(string Depth) (warp=true)
{
    MaterialImbalanceRes = 0;
    List.DeleteAll(TmpList1);
    List.DeleteAll(TmpList2);
    If (BishopCounttOwnLocal == 2)
    {
        List.Add(TmpList1, 1);
    }
    Else
    {
        List.Add(TmpList1, 0);
    }
    List.Add(TmpList1, PawnCounttOwnLocal);
    List.Add(TmpList1, (RookMinorCounttOwnLocal - (RookCounttOwnLocal + BishopCounttOwnLocal)));
    List.Add(TmpList1, BishopCounttOwnLocal);
    List.Add(TmpList1, RookCounttOwnLocal);
    List.Add(TmpList1, QueenCounttOwnLocal);
    If (BishopCountOppLocal == 2)
    {
        List.Add(TmpList2, 1);
    }
    Else
    {
        List.Add(TmpList2, 0);
    }
    List.Add(TmpList2, PawnCountOppLocal);
    List.Add(TmpList2, (RookMinorCountLocalOpp - (RookCountOppLocal + BishopCountOppLocal)));
    List.Add(TmpList2, BishopCountOppLocal);
    List.Add(TmpList2, RookCountOppLocal);
    List.Add(TmpList2, QueenCountOppLocal);
    Idx = 1;
    Repeat (6)
    {
        CurrentValue = 0;
        If ((((Depth % 2) == 1) And (TmpList1[Idx] > 0)) Or (((Depth % 2) == 0) And (TmpList2[Idx] > 0)))
        {
            IdxSub = 1;
            Repeat Until (IdxSub > Idx)
            {
                If ((Depth % 2) == 1)
                {
                    CurrentValue += ((ImbalanceSameSide[(((Idx - 1) * 6) + IdxSub)] * TmpList1[IdxSub]) + (ImbalanceOppSide[(((Idx - 1) * 6) + IdxSub)] * TmpList2[IdxSub]));
                }
                Else
                {
                    CurrentValue += ((ImbalanceSameSide[(((Idx - 1) * 6) + IdxSub)] * TmpList2[IdxSub]) + (ImbalanceOppSide[(((Idx - 1) * 6) + IdxSub)] * TmpList1[IdxSub]));
                }
                IdxSub += 1;
            }
            If ((Depth % 2) == 1)
            {
                MaterialImbalanceRes += (TmpList1[Idx] * CurrentValue);
            }
            Else
            {
                MaterialImbalanceRes += (TmpList2[Idx] * CurrentValue);
            }
        }
        Idx += 1;
    }
}

Define ClearBoardAttackedByMove(num Depth) (warp=true)
{
    If ((Depth % 2) == 1)
    {
        List.DeleteAll(BoardAttackedByOwn);
        List.DeleteAll(BoardAttackedByOwnPiece);
        Repeat (64)
        {
            List.Add(BoardAttackedByOwn, 0);
            List.Add(BoardAttackedByOwnPiece, 0);
        }
        IsOppSideChecked = 0;
    }
    Else
    {
        List.DeleteAll(BoardAttackedByOpp);
        List.DeleteAll(BoardAttackedByOppPiece);
        Repeat (64)
        {
            List.Add(BoardAttackedByOpp, 0);
            List.Add(BoardAttackedByOppPiece, 0);
        }
        IsOwnSideChecked = 0;
    }
    List.DeleteAll(KingAttackLines);
}

Define ClearMoveList(num Depth) (warp=true)
{
    List.ReplaceItem(MovesCount, Depth, 0);
    If (Depth == 1)
    {
        List.DeleteAll(Moves1);
    }
    Else
    {
        If (Depth == 2)
        {
            List.DeleteAll(Moves2);
        }
    }
}

Define ClearTT (warp=true)
{
    If (IsScratch3 == 1)
    {
        Call ClearTTImpl(100000);
    }
    Else
    {
        Call ClearTTImpl(1000000);
    }
}

Define ClearTTImpl(string Size) (warp=true)
{
    List.DeleteItem(TTNodeHash, all);
    List.DeleteItem(TTNodeBestMove, all);
    List.DeleteItem(TTNodeScore, all);
    List.DeleteItem(TTNodeDepth, all);
    List.DeleteItem(TTNodeAge, all);
    List.DeleteItem(TTNodeIsDynamic, all);
    List.DeleteItem(TTNodeType, all);
    List.DeleteItem(TTNodeChecked, all);
    List.DeleteItem(TTNodeHorizon, all);
    List.DeleteItem(TTNodeBoardAttackedByOpp, all);
    List.DeleteItem(TTNodeBoardAttackedByOppPiece, all);
    List.DeleteItem(TTNodeCheckedAttackLines, all);
    List.DeleteItem(TTBoardAge, all);
    List.DeleteItem(TTBoardHash, all);
    List.DeleteItem(TTBoardScore1, all);
    List.DeleteItem(TTBoardScore2, all);
    List.DeleteItem(TTBoardScore3, all);
    List.DeleteItem(TTBoardScoreSum, all);
    Repeat (Size)
    {
        List.Add(TTNodeHash, 0);
        List.Add(TTNodeAge, 0);
        List.Add(TTNodeIsDynamic, "");
        List.Add(TTNodeBestMove, "");
        List.Add(TTNodeScore, "");
        List.Add(TTNodeDepth, "");
        List.Add(TTNodeType, "");
        List.Add(TTNodeChecked, "");
        List.Add(TTNodeHorizon, "");
        List.Add(TTNodeBoardAttackedByOpp, "");
        List.Add(TTNodeBoardAttackedByOppPiece, "");
        List.Add(TTNodeCheckedAttackLines, "");
        List.Add(TTBoardAge, 0);
        List.Add(TTBoardHash, 0);
        List.Add(TTBoardScore1, "");
        List.Add(TTBoardScore2, "");
        List.Add(TTBoardScore3, "");
        List.Add(TTBoardScoreSum, "");
    }
}

Define CreateCurrentBoardHash (warp=true)
{
    CurrentBoardHash = 0;
    CurrentBoardHash2 = 0;
    Idx = 1;
    Repeat (64)
    {
        Call GetPiecePosHash(Board[Idx])(Idx);
        CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
        If ((abs(Board[Idx]) == GoK_OwnPawn) Or (abs(Board[Idx]) == GoK_OwnKing))
        {
            CurrentBoardHash2 = (CurrentBoardHash2 + PiecePosHash);
        }
        Idx += 1;
    }
}

Define DrawBoardAndWait (warp=false)
{
    List.DeleteAll(GoK_Board);
    List.DeleteAll(GoK_VirtualBoard);
    Idx = 1;
    Repeat (64)
    {
        List.Add(GoK_Board, Board[Idx]);
        List.Add(GoK_VirtualBoard, VirtualBoard[Idx]);
        Idx += 1;
    }
    GoK_ProgressValue = 0;
    Event.BroadcastAndWait("drawboard");
    Event.BroadcastAndWait("progressvaluechanged");
    Event.BroadcastAndWait("evaluationvaluechanged");
}

Define EnterExecution (warp=false)
{
    ExecutionDepth += 1;
    If (ExecutionDepth == 1)
    {
        IsExecutionRunning = 1;
        Event.BroadcastAndWait("calcmode");
    }
}

Define Evaluate(string Depth)(bool FullEval) (warp=true)
{
    EvaluateRes = "";
    EvaluateResIsDynamic = 0;
    If (Depth == 0)
    {
        Call EvaluateBoard;
        EvalResultBase = Eval;
        Stop(this script);
    }
    If (IsBlockProfilerEnabled == 1)
    {
        Call Profile_MethodEnter(Depth);
    }
    Call //("Incremental Evaluation");
    If (Depth == 1)
    {
        List.ReplaceItem(PosScoreDeltaSum, Depth, PosScoreDelta[Depth]);
        List.ReplaceItem(CapturesDeltaSum, Depth, TargetPieces[Depth]);
        Call PrepareEvalPiecesData(Depth);
        Call EvaluatePawns(Depth);
        List.ReplaceItem(EvalExtended1, Depth, EvalPawnsResult);
        Call EvaluateMajorsMinors(Depth);
        List.ReplaceItem(EvalExtended2, Depth, EvalMajorsMinorsResult);
        Call EvaluateThreats(Depth);
        List.ReplaceItem(EvalExtended3, Depth, EvalThreatsResult);
    }
    Else
    {
        List.ReplaceItem(PosScoreDeltaSum, Depth, (PosScoreDeltaSum[(Depth - 1)] + PosScoreDelta[Depth]));
        List.ReplaceItem(CapturesDeltaSum, Depth, (CapturesDeltaSum[(Depth - 1)] + TargetPieces[Depth]));
        List.ReplaceItem(EvalExtended1, Depth, EvalExtended1[(Depth - 1)]);
        List.ReplaceItem(EvalExtended2, Depth, EvalExtended2[(Depth - 1)]);
        List.ReplaceItem(EvalExtended3, Depth, EvalExtended3[(Depth - 1)]);
    }
    If (Not ((PromotionPieces[Depth] == 0)))
    {
        List.ReplaceItem(CapturesDeltaSum, Depth, ((CapturesDeltaSum[Depth] - PromotionPieces[Depth]) + SourcePieces[Depth]));
    }
    If FullEval
    {
        If (Eval.DebugLog == 0)
        {
            Call TTProbeBoard(CurrentBoardHash)(Depth);
            If ((TTProbeRes == 1) And (Not ((TTProbeBoardScoreSumRes == ""))))
            {
                EvaluateRes = TTProbeBoardScoreSumRes;
                If (IsBlockProfilerEnabled == 1)
                {
                    Call Profile_MethodExit(Depth);
                }
                Stop(this script);
            }
        }
        Call PrepareEvalPiecesData(Depth);
        Call EvaluatePawns(Depth);
        List.ReplaceItem(EvalExtended1, Depth, EvalPawnsResult);
        If (Eval.DebugLog == 1)
        {
            Call Log("----------------------------------------")("")("")("")("")("")("")("");
        }
        Call EvaluateMajorsMinors(Depth);
        List.ReplaceItem(EvalExtended2, Depth, EvalMajorsMinorsResult);
        If (Eval.DebugLog == 1)
        {
            Call Log("----------------------------------------")("")("")("")("")("")("")("");
        }
        Call EvaluateThreats(Depth);
        List.ReplaceItem(EvalExtended3, Depth, EvalThreatsResult);
        If (Eval.DebugLog == 1)
        {
            Call Log("----------------------------------------")("")("")("")("")("")("")("");
        }
        EvaluateRes = ((EvalResultBase + ((EvalExtended1[Depth] + EvalExtended2[Depth]) + EvalExtended3[Depth])) + (PosScoreDeltaSum[Depth] - CapturesDeltaSum[Depth]));
        Call //("Tempo");
        If ((Depth % 2) == 1)
        {
            EvaluateRes += -14;
        }
        Else
        {
            EvaluateRes += 14;
        }
        EvaluateResIsDynamic = 0;
        Call CalculateMaterialImbalance(1);
        CountOuter1 = MaterialImbalanceRes;
        Call CalculateMaterialImbalance(2);
        CountOuter2 = MaterialImbalanceRes;
        EvaluateRes += Operator.Round(((CountOuter1 - CountOuter2) / 1));
        If (Eval.DebugLog == 1)
        {
            Call Log("Eval.BaseEval = ")(EvalResultBase)("")("")("")("")("")("");
            Call Log("Eval.PSTDelta = ")(PosScoreDeltaSum[Depth])("")("")("")("")("")("");
            Call Log("Eval.MaterialDelta = ")((0 - CapturesDeltaSum[Depth]))("")("")("")("")("")("");
            Call Log("Eval.PSTDeltaList = ")(PosScoreDelta)("")("")("")("")("")("");
            Call Log("Eval.MaterialCaptureList = ")(TargetPieces)("")("")("")("")("")("");
            Call Log("Eval.MaterialPromotionList = ")(PromotionPieces)("")("")("")("")("")("");
            Call Log("Eval.Pawns = ")(EvalPawnsResult)("")("")("")("")("")("");
            Call Log("Eval.MajorsMinors = ")(EvalMajorsMinorsResult)("")("")("")("")("")("");
            Call Log("Eval.Threats = ")(EvalThreatsResult)("")("")("")("")("")("");
            Call Log("Eval.Imbalance = ")(Operator.Round(((CountOuter1 - CountOuter2) / 1)))("")("")("")("")("")("");
            Call Log("Eval.Total= ")(EvaluateRes)("")("")("")("")("")("");
            Call Log("----------------------------------------")("")("")("")("")("")("")("");
        }
        Call TTStoreBoard(CurrentBoardHash)(Depth)("")("")("")(EvaluateRes);
    }
    If (IsBlockProfilerEnabled == 1)
    {
        Call Profile_MethodExit(Depth);
    }
}

Define EvaluateBoard (warp=true)
{
    Call TaperedEval.Init;
    Eval = 0;
    Idx = 1;
    Repeat (64)
    {
        CurrentPiece = Board[Idx];
        If (Not ((CurrentPiece == 0)))
        {
            Eval += CurrentPiece;
            Call TaperedEval.GetPiecePosResult(CurrentPiece)(Idx);
            Eval += TaperedEval.PiecePosResult;
        }
        Idx += 1;
    }
}

Define EvaluateMajorsMinors(string Depth) (warp=true)
{
    EvalMajorsMinorsResult = 0;
    If (1 == 0)
    {
        Call TTProbeBoard(CurrentBoardHash)(Depth);
        If ((TTProbeRes == 1) And (Not ((TTProbeBoardScore2Res == ""))))
        {
            EvalMajorsMinorsResult = TTProbeBoardScore2Res;
            Stop(this script);
        }
    }
    Call //("Tapered evaluation, interpolating between midgame and game");
    Call EvaluateMajorsMinorsImpl(Depth);
    If (1 == 0)
    {
        Call TTStoreBoard(CurrentBoardHash)(Depth)("")(EvalMajorsMinorsResult)("")("");
    }
}

Define EvaluateMajorsMinorsImpl(string Depth) (warp=true)
{
    EvalMajorsMinorsResult = 0;
    Call TaperedEval.Init;
    If (1 == 0)
    {
        Call TaperedEval.Add(0)((40 * RookMinorCounttOwnLocal))("")("")("")("");
        Call TaperedEval.Add(0)((-40 * RookMinorCountLocalOpp))("")("")("")("");
        Call TaperedEval.Add(0)((75 * QueenCounttOwnLocal))("")("")("")("");
        Call TaperedEval.Add(0)((-75 * QueenCountOppLocal))("")("")("")("");
    }
    EvalPieceIdx = 1;
    Repeat (List.Length(EvalPiecesIdx_NonPawns))
    {
        TE.Idx = EvalPiecesIdx_NonPawns[(EvalPieceIdx + 0)];
        CurrentPiece = Board[(TE.Idx + 0)];
        Factor = (((CurrentPiece > 0) * 2) - 1);
        CurrentPieceAbs = abs(CurrentPiece);
        If (CurrentPiece > 0)
        {
            KingIdx = KingIdxtOwn;
        }
        Else
        {
            KingIdx = KingIdxOpp;
        }
        If (IsExtendedEvalLocal == 1)
        {
            IdxSub = ((PieceMobility[(TE.Idx + 0)] * 2) + 1);
            If (CurrentPieceAbs == GoK_OwnRook)
            {
                Call TaperedEval.Add((RookMobilityBonus[(IdxSub + 0)] * Factor))((RookMobilityBonus[(IdxSub + 1)] * Factor))("")("")("")("");
            }
            Else
            {
                If (CurrentPieceAbs == GoK_OwnBishop)
                {
                    Call TaperedEval.Add((BishopMobilityBonus[(IdxSub + 0)] * Factor))((BishopMobilityBonus[(IdxSub + 1)] * Factor))("")("")("")("");
                }
                Else
                {
                    If (CurrentPieceAbs == GoK_OwnKnight)
                    {
                        Call TaperedEval.Add((KnightMobilityBonus[(IdxSub + 0)] * Factor))((KnightMobilityBonus[(IdxSub + 1)] * Factor))("")("")("")("");
                    }
                    Else
                    {
                        If (CurrentPieceAbs == GoK_OwnQueen)
                        {
                            Call TaperedEval.Add((QueenMobilityBonus[(IdxSub + 0)] * Factor))((QueenMobilityBonus[(IdxSub + 1)] * Factor))("")("")("")("");
                        }
                    }
                }
            }
        }
        If ((CurrentPieceAbs == GoK_OwnKnight) Or (CurrentPieceAbs == GoK_OwnBishop))
        {
            Rank = IdxToRank[(TE.Idx + 0)];
            File = IdxToFile[(TE.Idx + 0)];
            If (IsExtendedEvalLocal == 1)
            {
                If ((Rank > (2 + (CurrentPiece > 0))) And (Rank < (6 + (CurrentPiece > 0))))
                {
                    Call GetAttackDefenseInfo((TE.Idx + 0));
                    If ((Defended > 0) And (DefenderPieceAbs == GoK_OwnPawn))
                    {
                        If ((Attacked == 0) Or (AttackerPieceAbs > GoK_OwnPawn))
                        {
                            Call //("Outposts");
                            If (CurrentPieceAbs == GoK_OwnKnight)
                            {
                                Call TaperedEval.Add((34 * Factor))((11 * Factor))("Eval.MajorsMinors.KnightOutpost")(TE.Idx)("")("");
                                If (1 == 0)
                                {
                                    If (((File == 4) Or (File == 5)) And ((Rank == 4) Or (Rank == 5)))
                                    {
                                        Call TaperedEval.Add((10 * Factor))((5 * Factor))("")("")("")("");
                                    }
                                }
                            }
                            Else
                            {
                                Call TaperedEval.Add((17 * Factor))((6 * Factor))("Eval.MajorsMinors.BishopOutpost")(TE.Idx)("")("");
                            }
                        }
                    }
                }
            }
            If (Board[(TE.Idx - (8 * Factor))] == (GoK_OwnPawn * Factor))
            {
                Call TaperedEval.Add((8 * Factor))((1 * Factor))("Eval.MajorsMinors.FriendlyPawnBehind")(TE.Idx)("")("");
            }
            Delta = ChebyshevDistance[((TE.Idx * 100) + KingIdx)];
            Call TaperedEval.Add(((-3 * Delta) * Factor))(((-4 * Delta) * Factor))("Eval.MajorsMinors.KingTropism")(TE.Idx)("")("");
            If (CurrentPieceAbs == GoK_OwnBishop)
            {
                CurrentValue = 0;
                EvalPieceIdx2 = 1;
                Repeat (List.Length(EvalPiecesIdx_Pawns))
                {
                    IdxSub = EvalPiecesIdx_Pawns[(EvalPieceIdx2 + 0)];
                    If ((TE.Idx % 2) == (IdxSub % 2))
                    {
                        If (((CurrentPiece > 0) And (Board[(IdxSub + 0)] > 0)) Or ((CurrentPiece < 0) And (Board[(IdxSub + 0)] < 0)))
                        {
                            File = IdxToFile[(IdxSub + 0)];
                            Rank = IdxToRank[(IdxSub + 0)];
                            CurrentValue += (1 + (2 * (((File == 4) Or (File == 5)) And ((Rank == 4) Or (Rank == 5)))));
                        }
                    }
                    EvalPieceIdx2 += 1;
                }
                Call TaperedEval.Add((-1 * (CurrentValue * Factor)))((-3 * (CurrentValue * Factor)))("Eval.MajorsMinors.Bishop.SameColorPawns")(TE.Idx)("")("");
                If ((TE.Idx % 9) == 1)
                {
                    Call GetSliderBlockerCount(TE.Idx)(28);
                    If (SliderBlockerCountRes == 0)
                    {
                        Call GetSliderBlockerCount(TE.Idx)(37);
                        If (SliderBlockerCountRes == 0)
                        {
                            Call TaperedEval.Add((21 * Factor))(0)("Eval.MajorsMinors.Bishop.AttacksCentralSquares")(TE.Idx)("")("");
                        }
                    }
                }
                Else
                {
                    If ((TE.Idx % 7) == 1)
                    {
                        If ((TE.Idx > 1) And (TE.Idx < 64))
                        {
                            Call GetSliderBlockerCount(TE.Idx)(29);
                            If (SliderBlockerCountRes == 0)
                            {
                                Call GetSliderBlockerCount(TE.Idx)(36);
                                If (SliderBlockerCountRes == 0)
                                {
                                    Call TaperedEval.Add((21 * Factor))(0)("Eval.MajorsMinors.Bishop.AttacksCentralSquares")(TE.Idx)("")("");
                                }
                            }
                        }
                    }
                }
            }
            If (1 == 0)
            {
                If (IsExtendedEvalLocal == 1)
                {
                    If (PieceMobility[(TE.Idx + 0)] == 0)
                    {
                        If (CurrentPiece > 0)
                        {
                            If ((Rank > 6) And (BoardAttackedByOwn[(TE.Idx + 0)] == 0))
                            {
                                Call TaperedEval.AddIdentical(-280)("Eval.MajorsMinors.TrappedMinor")(TE.Idx)(1)("");
                            }
                        }
                        Else
                        {
                            If ((Rank < 3) And (BoardAttackedByOpp[(TE.Idx + 0)] == 0))
                            {
                                Call TaperedEval.AddIdentical(280)("Eval.MajorsMinors.TrappedMinor")(TE.Idx)(2)("");
                            }
                        }
                    }
                }
            }
        }
        If (CurrentPieceAbs == GoK_OwnRook)
        {
            File = IdxToFile[(TE.Idx + 0)];
            Rank = IdxToRank[(TE.Idx + 0)];
            If (CurrentPiece > 0)
            {
                Count1 = PawnCountOwn[(File + 0)];
                Count2 = PawnCountOpp[(File + 0)];
                KingFile = IdxToFile[KingIdxtOwn];
            }
            Else
            {
                Count1 = PawnCountOpp[(File + 0)];
                Count2 = PawnCountOwn[(File + 0)];
                KingFile = IdxToFile[KingIdxOpp];
            }
            If ((Count1 == 0) And (Count2 == 0))
            {
                Call TaperedEval.Add((16 * Factor))((12 * Factor))("Eval.MajorsMinors.RookOnOpenFile")(TE.Idx)("")("");
            }
            Else
            {
                If (Count1 == 0)
                {
                    Call TaperedEval.Add((8 * Factor))((6 * Factor))("Eval.MajorsMinors.RookOnSemiFile")(TE.Idx)("")("");
                }
                Else
                {
                    If ((IsExtendedEvalLocal == 1) And (PieceMobility[(TE.Idx + 0)] < 4))
                    {
                        If ((KingFile > 4) == (File > KingFile))
                        {
                            Call TaperedEval.Add((-42 * Factor))((-32 * Factor))("Eval.MajorsMinors.TrappedRook")(TE.Idx)("")("");
                        }
                    }
                }
            }
            If ((Count2 > 0) And (((CurrentPiece > 0) And (Rank > 3)) Or ((CurrentPiece < 0) And (Rank < 6))))
            {
                Call TaperedEval.Add((3 * Factor))((12 * Factor))("Eval.MajorsMinors.RookPawnAlign")(TE.Idx)("")("");
            }
            If (((CurrentPiece > 0) And ((Rank == 7) And (IdxToRank[(KingIdxOpp + 0)] == 8))) Or ((CurrentPiece < 0) And ((Rank == 2) And (IdxToRank[(KingIdxtOwn + 0)] == 1))))
            {
                Call TaperedEval.Add((10 * Factor))((40 * Factor))("Eval.MajorsMinors.RookAtOpponentBase")(TE.Idx)("")("");
            }
        }
        If (CurrentPieceAbs == GoK_OwnQueen)
        {
            IsUnsafeQueen = 0;
            EvalPieceIdx2 = 1;
            Repeat (List.Length(EvalPiecesIdx_NonPawns))
            {
                If (IsUnsafeQueen == 0)
                {
                    IdxSub2 = EvalPiecesIdx_NonPawns[(EvalPieceIdx2 + 0)];
                    CurrentPiece2 = Board[(IdxSub2 + 0)];
                    CurrentPiece2Abs = abs(CurrentPiece2);
                    If ((CurrentPiece2Abs == GoK_OwnRook) Or (CurrentPiece2Abs == GoK_OwnBishop))
                    {
                        If ((CurrentPiece2 > 0) == (CurrentPiece < 0))
                        {
                            Call GetSliderBlockerCount(IdxSub2)(TE.Idx);
                            If (SliderBlockerCountRes == 1)
                            {
                                IsUnsafeQueen = 1;
                            }
                        }
                    }
                }
                EvalPieceIdx2 += 1;
            }
            If (IsUnsafeQueen == 1)
            {
                Call TaperedEval.Add((-23 * Factor))((-7 * Factor))("Eval.MajorsMinors.UnsafeQueen")(TE.Idx)("")("");
            }
        }
        EvalPieceIdx += 1;
    }
    If (Not ((Board[VirtualBoard[4]] == GoK_OwnQueen)))
    {
        Count1 = 0;
        Count1 += ((Board[VirtualBoard[2]] == GoK_OwnKnight) + (Board[VirtualBoard[3]] == GoK_OwnBishop));
        Count1 += ((Board[VirtualBoard[6]] == GoK_OwnBishop) + (Board[VirtualBoard[7]] == GoK_OwnKnight));
        Count1 += ((Board[VirtualBoard[12]] == GoK_OwnPawn) + (Board[VirtualBoard[13]] == GoK_OwnPawn));
        Call TaperedEval.Add((-3 * Count1))(0)("Eval.MajorsMinors.QueenEarlyMove")("")(1)("");
    }
    If (Not ((Board[VirtualBoard[60]] == GoK_OppQueen)))
    {
        Count1 = 0;
        Count1 += ((Board[VirtualBoard[63]] == GoK_OppKnight) + (Board[VirtualBoard[62]] == GoK_OppBishop));
        Count1 += ((Board[VirtualBoard[59]] == GoK_OppBishop) + (Board[VirtualBoard[58]] == GoK_OppKnight));
        Count1 += ((Board[VirtualBoard[53]] == GoK_OppPawn) + (Board[VirtualBoard[52]] == GoK_OppPawn));
        Call TaperedEval.Add((3 * Count1))(0)("Eval.MajorsMinors.QueenEarlyMove")("")(2)("");
    }
    If (1 == 0)
    {
        Call //("Evaluate early castling > enabled castling > possible castling > impossible castling");
        CurrentValue = CastlingState[Depth];
        Side = 1;
        Repeat (2)
        {
            Factor = (((Side == 1) * 2) - 1);
            Idx = ((Side - 1) * 4);
            If (Operator.LetterOf(CurrentValue, (Idx + 1)) == 1)
            {
                If (1 == 0)
                {
                    Call TaperedEval.Add((35 * Factor))((25 * Factor))("")("")("")("");
                }
            }
            Else
            {
                If ((Operator.LetterOf(CurrentValue, (Idx + 2)) == 1) Or ((Operator.LetterOf(CurrentValue, (Idx + 3)) == 1) And (Operator.LetterOf(CurrentValue, (Idx + 4)) == 1)))
                {
                    Call TaperedEval.Add((-30 * Factor))((-20 * Factor))("Eval.MajorsMinors.NoCastling")("")(Side)("");
                }
            }
            Side += 1;
        }
    }
    If (IsExtendedEvalLocal == 1)
    {
        Count1 = ((QueenCounttOwnLocal * 9) + ((RookCounttOwnLocal * 5) + ((RookMinorCounttOwnLocal - RookCounttOwnLocal) * 3)));
        Count2 = ((QueenCountOppLocal * 9) + ((RookCountOppLocal * 5) + ((RookMinorCountLocalOpp - RookCountOppLocal) * 3)));
        If ((Count1 + Count2) > 42)
        {
            BlockedCount = 0;
            Idx = 9;
            Repeat (48)
            {
                CurrentPiece = Board[(Idx + 0)];
                If (abs(CurrentPiece) == GoK_OwnPawn)
                {
                    Factor = (((CurrentPiece > 0) * 2) - 1);
                    If (Board[(Idx + (8 * Factor))] == (GoK_OppPawn * Factor))
                    {
                        BlockedCount += 1;
                    }
                    Else
                    {
                        File = IdxToFile[(Idx + 0)];
                        If ((File > 1) And (File < 8))
                        {
                            If (Board[(Idx + (15 * Factor))] == (GoK_OppPawn * Factor))
                            {
                                If (Board[(Idx + (17 * Factor))] == (GoK_OppPawn * Factor))
                                {
                                    BlockedCount += 1;
                                }
                            }
                        }
                    }
                }
                Idx += 1;
            }
            Side = 1;
            Repeat (2)
            {
                SpaceBonus = 0;
                Factor = (((Side == 1) * 2) - 1);
                If (Side == 1)
                {
                    Rank = 2;
                }
                Else
                {
                    Rank = 5;
                }
                Repeat (3)
                {
                    File = 3;
                    Repeat (4)
                    {
                        PE.Idx = (((Rank - 1) * 8) + File);
                        If (Not ((Board[(PE.Idx + 0)] == (GoK_OwnPawn * Factor))))
                        {
                            Attacked = 0;
                            AttackerIdx = 0;
                            If (Side == 1)
                            {
                                AttackerIdx = BoardAttackedByOppPiece[(PE.Idx + 0)];
                            }
                            Else
                            {
                                AttackerIdx = BoardAttackedByOwnPiece[(PE.Idx + 0)];
                            }
                            If (Not ((AttackerIdx == 0)))
                            {
                                Attacked = (abs(Board[(AttackerIdx + 0)]) == GoK_OwnPawn);
                            }
                            If (Attacked == 0)
                            {
                                SpaceBonus += 1;
                                If (Side == 1)
                                {
                                    Attacked = (BoardAttackedByOpp[(PE.Idx + 0)] > 0);
                                }
                                Else
                                {
                                    Attacked = (BoardAttackedByOwn[(PE.Idx + 0)] > 0);
                                }
                                If (Attacked == 0)
                                {
                                    If ((Board[(PE.Idx + (8 * Factor))] == (GoK_OwnPawn * Factor)) Or ((Board[(PE.Idx + (16 * Factor))] == (GoK_OwnPawn * Factor)) Or (Board[(PE.Idx + (24 * Factor))] == (GoK_OwnPawn * Factor))))
                                    {
                                        SpaceBonus += 1;
                                    }
                                }
                            }
                        }
                        File += 1;
                    }
                    Rank += 1;
                }
                If (Side == 1)
                {
                    Weight = ((RookMinorCounttOwnLocal + (QueenCounttOwnLocal + PawnCounttOwnLocal)) - 3);
                }
                Else
                {
                    Weight = ((RookMinorCountLocalOpp + (QueenCountOppLocal + PawnCountOppLocal)) - 3);
                }
                If (BlockedCount > 9)
                {
                    Weight += 9;
                }
                Else
                {
                    Weight += BlockedCount;
                }
                CurrentValue = floor((((SpaceBonus * (Weight * Weight)) / 48) * (((Count1 + Count2) - 42) / (62 - 42))));
                Call TaperedEval.Add((CurrentValue * Factor))(0)("Eval.MajorsMinors.Space")("")(Side)("");
                Side += 1;
            }
        }
    }
    Call TaperedEval.GetSumResult;
    EvalMajorsMinorsResult = TaperedEval.SumResult;
    If (Eval.DebugLog == 1)
    {
        Call LogPVEvalLine("Eval.MajorsMinors.Total")(EvalMajorsMinorsResult)("")("")("")("");
    }
}

Define EvaluatePawns(string Depth) (warp=true)
{
    EvalPawnsResult = 0;
    Call //("Positional evaluation: king and pawn structure");
    If (1 == 0)
    {
        Call TTProbeBoard(CurrentBoardHash)(Depth);
        If ((TTProbeRes == 1) And (Not ((TTProbeBoardScore1Res == ""))))
        {
            EvalPawnsResult = TTProbeBoardScore1Res;
            Stop(this script);
        }
    }
    Call EvaluatePawnsImpl(Depth);
    If (1 == 0)
    {
        Call TTStoreBoard(CurrentBoardHash)(Depth)(EvalPawnsResult)("")("")("");
    }
}

Define EvaluatePawnsImpl(string Depth) (warp=true)
{
    EvalPawnsResult = 0;
    Call TaperedEval.Init;
    If (1 == 1)
    {
        Call TaperedEval.Add(0)((20 * PawnCounttOwnLocal))("Eval.Pawns.EG")("")(1)("");
        Call TaperedEval.Add(0)((-20 * PawnCountOppLocal))("Eval.Pawns.EG")("")(2)("");
    }
    If (((Operator.LetterOf(CastlingState[Depth], 1) == 0) And (Operator.LetterOf(CastlingState[Depth], 2) == 0)) And ((Operator.LetterOf(CastlingState[Depth], 3) == 0) Or (Operator.LetterOf(CastlingState[Depth], 4) == 0)))
    {
        IsOwnSideCastlingPossibleLocal = 1;
    }
    Else
    {
        IsOwnSideCastlingPossibleLocal = 0;
    }
    If (((Operator.LetterOf(CastlingState[Depth], 5) == 0) And (Operator.LetterOf(CastlingState[Depth], 6) == 0)) And ((Operator.LetterOf(CastlingState[Depth], 7) == 0) Or (Operator.LetterOf(CastlingState[Depth], 8) == 0)))
    {
        IsOppSideCastlingPossibleLocal = 1;
    }
    Else
    {
        IsOppSideCastlingPossibleLocal = 0;
    }
    Sum1 = 0;
    Sum2 = 0;
    EvalPieceIdx = 1;
    Repeat (List.Length(EvalPiecesIdx_Pawns))
    {
        Idx = EvalPiecesIdx_Pawns[(EvalPieceIdx + 0)];
        CurrentPiece = Board[(Idx + 0)];
        If (CurrentPiece > 0)
        {
            Sum1 += ChebyshevDistance[((Idx * 100) + KingIdxtOwn)];
        }
        Else
        {
            Sum2 += ChebyshevDistance[((Idx * 100) + KingIdxOpp)];
        }
        EvalPieceIdx += 1;
    }
    If (PawnCounttOwnLocal > 0)
    {
        Call TaperedEval.Add(0)(Operator.Round((-5 * (Sum1 / PawnCounttOwnLocal))))("Eval.Pawns.PawnKingTropism")("")(1)("");
    }
    If (PawnCountOppLocal > 0)
    {
        Call TaperedEval.Add(0)(Operator.Round((5 * (Sum2 / PawnCountOppLocal))))("Eval.Pawns.PawnKingTropism")("")(2)("");
    }
    Call //("Doubled pawns, passed pawns, open-file pawns");
    CountOuter1 = 0;
    CountOuter2 = 0;
    If (Not ((List.Length(PE.NormalizedRank) == 8)))
    {
        List.DeleteAll(PE.NormalizedRank);
        Repeat (8)
        {
            List.Add(PE.NormalizedRank, 0);
        }
    }
    Side = 1;
    Repeat (2)
    {
        If (Side == 1)
        {
            PE.IsCastlingPossible = IsOwnSideCastlingPossibleLocal;
            PE.Forward = 8;
            PE.Backward = -8;
            PE.OwnKingIdx = KingIdxtOwn;
            PE.OppKingIdx = KingIdxOpp;
            PE.OppQueenCount = QueenCountOppLocal;
            PE.OppRookCount = RookCountOppLocal;
        }
        Else
        {
            PE.IsCastlingPossible = IsOppSideCastlingPossibleLocal;
            PE.Forward = -8;
            PE.Backward = 8;
            PE.OwnKingIdx = KingIdxOpp;
            PE.OppKingIdx = KingIdxtOwn;
            PE.OppQueenCount = QueenCounttOwnLocal;
            PE.OppRookCount = RookCounttOwnLocal;
        }
        Idx = 1;
        Repeat (8)
        {
            If (Side == 1)
            {
                List.ReplaceItem(PE.NormalizedRank, Idx, Idx);
            }
            Else
            {
                List.ReplaceItem(PE.NormalizedRank, Idx, (9 - Idx));
            }
            Idx += 1;
        }
        PE.File = 1;
        Repeat (8)
        {
            If (Side == 1)
            {
                PE.OwnForwardRank = PawnAdvancePerFile[(PE.File + 24)];
            }
            Else
            {
                PE.OwnForwardRank = PawnAdvancePerFile[(PE.File + 8)];
            }
            If (Not ((PE.OwnForwardRank == 0)))
            {
                PE.Factor = (1 - (2 * (Side == 2)));
                If (Side == 1)
                {
                    PE.OwnBackwardRank = PawnAdvancePerFile[(PE.File + 16)];
                    PE.OppForwardRank = PawnAdvancePerFile[(PE.File + 8)];
                    PE.OppBackwardRank = PawnAdvancePerFile[(PE.File + 0)];
                    PE.OwnPawnCount = PawnCountOwn[(PE.File + 0)];
                    PE.OppPawnCount = PawnCountOpp[(PE.File + 0)];
                    If (PE.File > 1)
                    {
                        PE.LeftOwnPawnRank = PawnAdvancePerFile[((PE.File + 24) - 1)];
                        PE.LeftOppPawnRank = PawnAdvancePerFile[(PE.File - 1)];
                    }
                    Else
                    {
                        PE.LeftOwnPawnRank = 0;
                        PE.LeftOppPawnRank = 0;
                    }
                    If (PE.File < 8)
                    {
                        PE.RightOwnPawnRank = PawnAdvancePerFile[((PE.File + 24) + 1)];
                        PE.RightOppPawnRank = PawnAdvancePerFile[(PE.File + 1)];
                    }
                    Else
                    {
                        PE.RightOwnPawnRank = 0;
                        PE.RightOppPawnRank = 0;
                    }
                }
                Else
                {
                    PE.OwnBackwardRank = PawnAdvancePerFile[(PE.File + 0)];
                    PE.OppForwardRank = PawnAdvancePerFile[(PE.File + 24)];
                    PE.OppBackwardRank = PawnAdvancePerFile[(PE.File + 16)];
                    PE.OwnPawnCount = PawnCountOpp[(PE.File + 0)];
                    PE.OppPawnCount = PawnCountOwn[(PE.File + 0)];
                    If (PE.File > 1)
                    {
                        PE.LeftOwnPawnRank = PawnAdvancePerFile[((PE.File + 8) - 1)];
                        PE.LeftOppPawnRank = PawnAdvancePerFile[((PE.File + 16) - 1)];
                    }
                    Else
                    {
                        PE.LeftOwnPawnRank = 0;
                        PE.LeftOppPawnRank = 0;
                    }
                    If (PE.File < 8)
                    {
                        PE.RightOwnPawnRank = PawnAdvancePerFile[((PE.File + 8) + 1)];
                        PE.RightOppPawnRank = PawnAdvancePerFile[((PE.File + 16) + 1)];
                    }
                    Else
                    {
                        PE.RightOwnPawnRank = 0;
                        PE.RightOppPawnRank = 0;
                    }
                }
                PE.OwnForwardIdx = (((PE.OwnForwardRank - 1) * 8) + PE.File);
                If ((((PE.OppQueenCount == 0) And (PE.OppRookCount < 2)) Or ((PE.File == 4) Or (PE.File == 5))) Or ((PE.IsCastlingPossible == 0) And ((((IdxToFile[PE.OwnKingIdx] < 4) And (Not ((PE.File < 4)))) Or ((IdxToFile[PE.OwnKingIdx] > 5) And (Not ((PE.File > 5))))) Or (Not ((PE.NormalizedRank[IdxToRank[PE.OwnKingIdx]] < PE.NormalizedRank[PE.OwnBackwardRank]))))))
                {
                    IsPawnShelter = 0;
                }
                Else
                {
                    IsPawnShelter = 1;
                }
                PE.OwnForwardRankNormalized = PE.NormalizedRank[PE.OwnForwardRank];
                Opposed = ((Not ((PE.OppBackwardRank == 0))) And (PE.NormalizedRank[PE.OppBackwardRank] > PE.OwnForwardRankNormalized));
                PE.Passed = ((Opposed == 0) And (((PE.LeftOppPawnRank == 0) Or (Not ((PE.NormalizedRank[PE.LeftOppPawnRank] > PE.OwnForwardRankNormalized)))) And ((PE.RightOppPawnRank == 0) Or (Not ((PE.NormalizedRank[PE.RightOppPawnRank] > PE.OwnForwardRankNormalized))))));
                If ((PE.OwnPawnCount > 1) And (PE.Passed == 0))
                {
                    Call TaperedEval.Add(((-16 * PE.Factor) * (PE.OwnPawnCount - 1)))(((-28 * PE.Factor) * (PE.OwnPawnCount - 1)))("Eval.Pawns.DoubledPawn")(PE.OwnForwardIdx)(Side)("");
                }
                If (IsPawnShelter == 0)
                {
                    BlockerIdx = (((PE.OwnForwardRank - 1) * 8) + (PE.File + PE.Forward));
                    If (PE.OwnForwardRankNormalized > 2)
                    {
                        Call TaperedEval.AddIdentical(((5 * PE.Factor) * (PE.OwnForwardRankNormalized - 2)))("Eval.Pawns.Advance")(PE.OwnForwardIdx)("")("");
                        Call TaperedEval.AddIdentical(((-10 * PE.Factor) * (Board[(BlockerIdx + 0)] == (GoK_OppPawn * PE.Factor))))("Eval.Pawns.AdvanceBlocked")(PE.OwnForwardIdx)(Side)("");
                    }
                }
                If (Opposed == 0)
                {
                    Call //("Unopposed pawn");
                    If (PE.Passed == 1)
                    {
                        Call //("Passed pawn");
                        PassedFactor = floor((((PE.OwnForwardRankNormalized - 3) * (PE.OwnForwardRankNormalized - 2)) / 2));
                        If (PassedFactor < 1)
                        {
                            PassedFactor = 1;
                        }
                        Call TaperedEval.Add(0)(((((-2 * PE.Factor) * ChebyshevDistance[((BlockerIdx * 100) + PE.OwnKingIdx)]) + ((5 * PE.Factor) * ChebyshevDistance[((BlockerIdx * 100) + PE.OppKingIdx)])) * PassedFactor))("Eval.Pawns.Passed.KingTropism")(PE.OwnForwardIdx)(Side)("");
                        IdxSub = ((PE.OwnForwardRankNormalized * 2) - 1);
                        IdxSub2 = ((PE.File * 2) - 1);
                        CurrentValue = (PawnPassedRankBonus[(IdxSub + 0)] - PawnPassedFilePenalty[(IdxSub2 + 0)]);
                        CurrentValue2 = (PawnPassedRankBonus[(IdxSub + 1)] - PawnPassedFilePenalty[(IdxSub2 + 1)]);
                        If ((PE.OwnForwardRankNormalized == 7) And (((Side == 1) And (BoardAttackedByOwn[(BlockerIdx + 0)] == 0)) Or ((Side == 2) And (BoardAttackedByOpp[(BlockerIdx + 0)] == 0))))
                        {
                            If (1 == 0)
                            {
                                CurrentPiece = Board[(BlockerIdx + 0)];
                                If (((Side == 1) And (CurrentPiece < 0)) Or ((Side == 2) And (CurrentPiece > 0)))
                                {
                                    If ((CurrentPiece == (GoK_OppBishop * PE.Factor)) Or (CurrentPiece == (GoK_OppKnight * PE.Factor)))
                                    {
                                        CurrentValue = Operator.Round((CurrentValue * 0.7));
                                        CurrentValue2 = Operator.Round((CurrentValue2 * 0.7));
                                    }
                                    Else
                                    {
                                        CurrentValue = Operator.Round((CurrentValue * 0.5));
                                        CurrentValue2 = Operator.Round((CurrentValue2 * 0.5));
                                    }
                                }
                            }
                        }
                        Call TaperedEval.Add(Operator.Round((CurrentValue * PE.Factor)))(Operator.Round((CurrentValue2 * PE.Factor)))("Eval.Pawns.Passed.RankBonus")(PE.OwnForwardIdx)(Side)("");
                        If (IsExtendedEvalLocal == 1)
                        {
                            If ((PE.OwnForwardRankNormalized > 3) And (Board[(BlockerIdx + 0)] == 0))
                            {
                                PE.Idx = (((PE.OwnForwardRank - 1) * 8) + (PE.File + PE.Backward));
                                If (Side == 1)
                                {
                                    CountOuter1 += 1;
                                }
                                Else
                                {
                                    CountOuter2 += 1;
                                }
                                FrontFileAttacked = 0;
                                FrontAreaAttacked = 0;
                                OwnMajorsBehind = 0;
                                OppMajorsBehind = 0;
                                Repeat ((PE.OwnForwardRankNormalized - 1))
                                {
                                    CurrentPiece = Board[PE.Idx];
                                    If ((CurrentPiece == (GoK_OppRook * PE.Factor)) Or (CurrentPiece == (GoK_OppQueen * PE.Factor)))
                                    {
                                        OppMajorsBehind = 1;
                                    }
                                    If ((CurrentPiece == (GoK_OwnRook * PE.Factor)) Or (CurrentPiece == (GoK_OwnQueen * PE.Factor)))
                                    {
                                        OwnMajorsBehind = 1;
                                    }
                                    PE.Idx += PE.Backward;
                                }
                                PE.Idx = (((PE.OwnForwardRank - 1) * 8) + (PE.File + PE.Forward));
                                Repeat ((8 - PE.OwnForwardRankNormalized))
                                {
                                    If (PE.File > 1)
                                    {
                                        If (((Side == 1) And (BoardAttackedByOpp[(PE.Idx - 1)] > 0)) Or ((Side == 2) And (BoardAttackedByOwn[(PE.Idx - 1)] > 0)))
                                        {
                                            FrontAreaAttacked = 1;
                                        }
                                    }
                                    If (((Side == 1) And (BoardAttackedByOpp[PE.Idx] > 0)) Or ((Side == 2) And (BoardAttackedByOwn[PE.Idx] > 0)))
                                    {
                                        FrontAreaAttacked = 1;
                                        FrontFileAttacked = 1;
                                    }
                                    If (PE.File < 8)
                                    {
                                        If (((Side == 1) And (BoardAttackedByOpp[(PE.Idx + 1)] > 0)) Or ((Side == 2) And (BoardAttackedByOwn[(PE.Idx + 1)] > 0)))
                                        {
                                            FrontAreaAttacked = 1;
                                        }
                                    }
                                    PE.Idx += PE.Forward;
                                }
                                If ((((Side == 1) And (BoardAttackedByOwn[(BlockerIdx + 0)] > 0)) Or ((Side == 2) And (BoardAttackedByOpp[(BlockerIdx + 0)] > 0))) Or (OwnMajorsBehind == 1))
                                {
                                    Call TaperedEval.Add(((2 * PE.Factor) * PassedFactor))(((3 * PE.Factor) * PassedFactor))("Eval.Pawns.Passed.DefendedNext")(PE.OwnForwardIdx)(Side)("");
                                }
                                If ((OppMajorsBehind == 0) And (FrontAreaAttacked == 0))
                                {
                                    Call TaperedEval.Add(((16 * PE.Factor) * PassedFactor))(((18 * PE.Factor) * PassedFactor))("Eval.Pawns.Passed.NoOpponents")(PE.OwnForwardIdx)(Side)("");
                                }
                                Else
                                {
                                    If (FrontFileAttacked == 0)
                                    {
                                        Call TaperedEval.Add(((9 * PE.Factor) * PassedFactor))(((11 * PE.Factor) * PassedFactor))("Eval.Pawns.Passed.FreeFrontFile")(PE.OwnForwardIdx)(Side)("");
                                    }
                                    Else
                                    {
                                        If (((Side == 1) And (BoardAttackedByOpp[(BlockerIdx + 0)] == 0)) Or ((Side == 2) And (BoardAttackedByOwn[(BlockerIdx + 0)] == 0)))
                                        {
                                            Call TaperedEval.Add(((4 * PE.Factor) * PassedFactor))(((6 * PE.Factor) * PassedFactor))("Eval.Pawns.Passed.NonAttackedNext")(PE.OwnForwardIdx)(Side)("");
                                        }
                                    }
                                }
                            }
                        }
                    }
                    Else
                    {
                        If (((PE.LeftOppPawnRank == 0) Or (Not ((PE.NormalizedRank[PE.LeftOppPawnRank] > (PE.OwnForwardRankNormalized + 1))))) And ((PE.RightOppPawnRank == 0) Or (Not ((PE.NormalizedRank[PE.RightOppPawnRank] > (PE.OwnForwardRankNormalized + 1))))))
                        {
                            PassedFactor = (PE.OwnForwardRankNormalized - 1);
                            If (PassedFactor < 1)
                            {
                                PassedFactor = 1;
                            }
                            If ((Board[(BlockerIdx + 0)] == 0) And (((Side == 1) And ((BoardAttackedByOwn[(BlockerIdx + 0)] > 0) And (BoardAttackedByOpp[(BlockerIdx + 0)] == 0))) Or ((Side == 2) And ((BoardAttackedByOpp[(BlockerIdx + 0)] > 0) And (BoardAttackedByOwn[(BlockerIdx + 0)] == 0)))))
                            {
                                Call TaperedEval.Add(((6 * PE.Factor) * PassedFactor))(((10 * PE.Factor) * PassedFactor))("Eval.Pawns.NonPassed.Unopposed.Unblocked")(PE.OwnForwardIdx)(Side)("");
                            }
                            Else
                            {
                                Call TaperedEval.Add(((4 * PE.Factor) * PassedFactor))(((7 * PE.Factor) * PassedFactor))("Eval.Pawns.NonPassed.Unopposed.Blocked")(PE.OwnForwardIdx)(Side)("");
                            }
                        }
                    }
                }
                If (((PE.File == 1) Or (((Side == 1) And (PawnCountOwn[(PE.File - 1)] == 0)) Or ((Side == 2) And (PawnCountOpp[(PE.File - 1)] == 0)))) And ((PE.File == 8) Or (((Side == 1) And (PawnCountOwn[(PE.File + 1)] == 0)) Or ((Side == 2) And (PawnCountOpp[(PE.File + 1)] == 0)))))
                {
                    If (PE.Passed == 0)
                    {
                        Call TaperedEval.AddIdentical((-16 * PE.Factor))("Eval.Pawns.Isolated")(PE.OwnForwardIdx)(Side)("");
                    }
                }
                Else
                {
                    IsBackward = 0;
                    If ((IsPawnShelter == 0) And (PE.OwnForwardRankNormalized < 6))
                    {
                        If ((PE.LeftOwnPawnRank == 0) Or (PE.NormalizedRank[PE.LeftOwnPawnRank] > PE.OwnForwardRankNormalized))
                        {
                            If ((PE.RightOwnPawnRank == 0) Or (PE.NormalizedRank[PE.RightOwnPawnRank] > PE.OwnForwardRankNormalized))
                            {
                                If (((PE.LeftOppPawnRank > 0) And (PE.NormalizedRank[PE.LeftOppPawnRank] == (PE.OwnForwardRankNormalized + 1))) Or ((PE.RightOppPawnRank > 0) And (PE.NormalizedRank[PE.RightOppPawnRank] == (PE.OwnForwardRankNormalized + 1))))
                                {
                                    IsBackward = 1;
                                }
                            }
                        }
                    }
                    If (IsBackward == 1)
                    {
                        If (Opposed == 1)
                        {
                            Call TaperedEval.Add((-10 * PE.Factor))((-5 * PE.Factor))("Eval.Pawns.NonIsolated.Backward.Opposed")((((PE.OwnBackwardRank - 1) * 8) + PE.File))(Side)("");
                        }
                        Else
                        {
                            Call TaperedEval.Add((-16 * PE.Factor))((-11 * PE.Factor))("Eval.Pawns.NonIsolated.Backward.Unopposed")((((PE.OwnBackwardRank - 1) * 8) + PE.File))(Side)("");
                        }
                    }
                    Else
                    {
                        If (IsPawnShelter == 0)
                        {
                            LeverCount = 0;
                            If ((PE.LeftOppPawnRank > 0) And (PE.NormalizedRank[PE.LeftOppPawnRank] == (PE.OwnForwardRankNormalized - 1)))
                            {
                                LeverCount += 1;
                            }
                            If ((PE.RightOppPawnRank > 0) And (PE.NormalizedRank[PE.RightOppPawnRank] == (PE.OwnForwardRankNormalized - 1)))
                            {
                                LeverCount += 1;
                            }
                            If (LeverCount > 0)
                            {
                                IdxSub = ((PE.OwnForwardRankNormalized * 2) - 1);
                                Call TaperedEval.Add((PawnLeverBonus[IdxSub] * PE.Factor))((PawnLeverBonus[(IdxSub + 1)] * PE.Factor))("Eval.Pawns.Lever")(PE.OwnForwardIdx)(Side)("");
                            }
                            Delta = 9;
                            Delta2 = 9;
                            If (Not ((PE.LeftOwnPawnRank == 0)))
                            {
                                Delta = (PE.NormalizedRank[PE.LeftOwnPawnRank] - PE.OwnForwardRankNormalized);
                            }
                            If (Not ((PE.RightOwnPawnRank == 0)))
                            {
                                Delta2 = (PE.NormalizedRank[PE.RightOwnPawnRank] - PE.OwnForwardRankNormalized);
                            }
                            Count1 = ((Delta == 0) + (Delta2 == 0));
                            Count2 = ((Delta == -1) + (Delta2 == -1));
                            If (Count1 > 0)
                            {
                                IdxSub = ((PE.OwnForwardRankNormalized * 2) - 1);
                                If (Opposed == 1)
                                {
                                    Call TaperedEval.Add((PawnPhalanxBonusOpposed[IdxSub] * PE.Factor))((PawnPhalanxBonusOpposed[(IdxSub + 1)] * PE.Factor))("Eval.Pawns.Phalanx.Opposed")(PE.OwnForwardIdx)(Side)("");
                                }
                                Else
                                {
                                    Call TaperedEval.Add((PawnPhalanxBonus[IdxSub] * PE.Factor))((PawnPhalanxBonus[(IdxSub + 1)] * PE.Factor))("Eval.Pawns.Phalanx.Unopposed")(PE.OwnForwardIdx)(Side)("");
                                }
                            }
                            If (Count2 > 0)
                            {
                                CurrentValue = Operator.Round((((PawnConnectedBonus[PE.OwnForwardRankNormalized] * 2) / (1 + Opposed)) + (Count2 * 8)));
                                Call TaperedEval.Add((CurrentValue * PE.Factor))(Operator.Round((((CurrentValue * PE.Factor) * (PE.OwnForwardRankNormalized - 2)) / 4)))("Eval.Pawns.Connected")(PE.OwnForwardIdx)(Side)("");
                            }
                        }
                    }
                }
            }
            PE.File += 1;
        }
        Side += 1;
    }
    Call TaperedEval.GetSumResult;
    EvalPawnsResult = TaperedEval.SumResult;
    If (Eval.DebugLog == 1)
    {
        Call LogPVEvalLine("Eval.Pawns.Base.Total")(EvalPawnsResult)("")("")("")("");
    }
    Call //("Early promotion detection via Rule-of-Squares / Chebyshev distance");
    If (((QueenCountOppLocal + RookMinorCountLocalOpp) == 0) And ((QueenCounttOwnLocal + RookMinorCounttOwnLocal) == 0))
    {
        Idx = 1;
        Repeat (8)
        {
            PawnForwardRankOpp = PawnAdvancePerFile[(Idx + 8)];
            PawnForwardRanktOwn = PawnAdvancePerFile[(Idx + 24)];
            If ((QueenCounttOwnLocal + RookMinorCounttOwnLocal) == 0)
            {
                If ((PawnForwardRankOpp < 7) And (PawnForwardRankOpp > 0))
                {
                    PawnBackwardRanktOwn = PawnAdvancePerFile[(Idx + 16)];
                    If ((PawnForwardRankOpp < PawnBackwardRanktOwn) Or (PawnBackwardRanktOwn == 0))
                    {
                        PE.LeftOppPawnRank = PawnAdvancePerFile[((Idx + 16) - 1)];
                        If (((Idx == 1) Or (PE.LeftOppPawnRank == 0)) Or (PawnForwardRankOpp < PE.LeftOppPawnRank))
                        {
                            PE.RightOppPawnRank = PawnAdvancePerFile[((Idx + 16) + 1)];
                            If (((Idx == 8) Or (PE.RightOppPawnRank == 0)) Or (PawnForwardRankOpp < PE.RightOppPawnRank))
                            {
                                TargetIdx = Idx;
                                Delta = (PawnForwardRankOpp - 1);
                                If (Delta > 5)
                                {
                                    Delta = 5;
                                }
                                If ((ChebyshevDistance[((KingIdxtOwn * 100) + TargetIdx)] - ((Depth + 1) % 2)) > Delta)
                                {
                                    EvalPawnsResult += ((GoK_OppQueen - GoK_OppPawn) + 100);
                                    If (Eval.DebugLog == 1)
                                    {
                                        Call LogPVEvalLine("Eval.Pawns.RuleOfSquare")(((GoK_OppQueen - GoK_OppPawn) + 100))("")("")(2)("");
                                    }
                                }
                            }
                        }
                    }
                }
            }
            If ((QueenCountOppLocal + RookMinorCountLocalOpp) == 0)
            {
                If (PawnForwardRanktOwn > 2)
                {
                    PawnBackwardRankOpp = PawnAdvancePerFile[Idx];
                    If (PawnForwardRanktOwn > PawnBackwardRankOpp)
                    {
                        PE.LeftOppPawnRank = PawnAdvancePerFile[(Idx - 1)];
                        If (((Idx == 1) Or (PE.LeftOppPawnRank == 0)) Or (PawnForwardRanktOwn > PE.LeftOppPawnRank))
                        {
                            PE.RightOppPawnRank = PawnAdvancePerFile[(Idx + 1)];
                            If (((Idx == 8) Or (PE.RightOppPawnRank == 0)) Or (PawnForwardRanktOwn > PE.RightOppPawnRank))
                            {
                                TargetIdx = (56 + Idx);
                                Delta = (8 - PawnForwardRanktOwn);
                                If (Delta > 5)
                                {
                                    Delta = 5;
                                }
                                If ((ChebyshevDistance[((KingIdxOpp * 100) + TargetIdx)] - (Depth % 2)) > Delta)
                                {
                                    EvalPawnsResult += ((GoK_OwnQueen - GoK_OwnPawn) - 100);
                                    If (Eval.DebugLog == 1)
                                    {
                                        Call LogPVEvalLine("Eval.Pawns.RuleOfSquare")(((GoK_OwnQueen - GoK_OwnPawn) - 100))("")("")(1)("");
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Idx += 1;
        }
    }
    If ((((QueenCounttOwnLocal + RookMinorCounttOwnLocal) == 0) And ((QueenCountOppLocal + RookMinorCountLocalOpp) > 0)) Or (((QueenCountOppLocal + RookMinorCountLocalOpp) == 0) And ((QueenCounttOwnLocal + RookMinorCounttOwnLocal) > 0)))
    {
        If ((QueenCounttOwnLocal + RookMinorCounttOwnLocal) > 0)
        {
            Side = 1;
        }
        Else
        {
            If ((QueenCountOppLocal + RookMinorCountLocalOpp) > 0)
            {
                Side = 2;
            }
        }
        CurrentValue = ChebyshevDistance[((KingIdxOpp * 100) + KingIdxtOwn)];
        If (Side == 1)
        {
            If (PawnCountOppLocal == 0)
            {
                EvalPawnsResult += (-20 * CurrentValue);
            }
        }
        Else
        {
            If (PawnCounttOwnLocal == 0)
            {
                EvalPawnsResult += (20 * CurrentValue);
            }
        }
        If (Side == 1)
        {
            KingIdx = KingIdxOpp;
        }
        Else
        {
            KingIdx = KingIdxtOwn;
        }
        File = IdxToFile[KingIdx];
        Rank = IdxToRank[KingIdx];
        Delta = 0;
        Delta2 = 0;
        If (Rank < 4)
        {
            Delta = (4 - Rank);
        }
        Else
        {
            If (Rank > 5)
            {
                Delta = (Rank - 5);
            }
        }
        If (File < 4)
        {
            Delta2 = (4 - File);
        }
        Else
        {
            If (File > 5)
            {
                Delta2 = (File - 5);
            }
        }
        If (Side == 1)
        {
            EvalPawnsResult += (20 * (Delta + Delta2));
        }
        Else
        {
            EvalPawnsResult += (-20 * (Delta + Delta2));
        }
    }
    If (Eval.DebugLog == 1)
    {
        Call LogPVEvalLine("Eval.Pawns.Total ")(EvalPawnsResult)("")("")("")("");
    }
}

Define EvaluateThreats(string Depth) (warp=true)
{
    EvalThreatsResult = 0;
    If (1 == 0)
    {
        Call TTProbeBoard(CurrentBoardHash)(Depth);
        If ((TTProbeRes == 1) And (Not ((TTProbeBoardScore3Res == ""))))
        {
            EvalThreatsResult = TTProbeBoardScore3Res;
            Stop(this script);
        }
    }
    Call EvaluateThreatsImpl(Depth);
    If (1 == 0)
    {
        Call TTStoreBoard(CurrentBoardHash)(Depth)("")("")(EvalThreatsResult)("");
    }
}

Define EvaluateThreatsImpl(string Depth) (warp=true)
{
    EvalThreatsResult = 0;
    If (IsExtendedEvalLocal == 0)
    {
        Stop(this script);
    }
    Call TaperedEval.Init;
    TE.MobilityEval = 0;
    EvalPieceIdx = 1;
    Repeat (List.Length(EvalPiecesIdx_NonPawns))
    {
        Idx = EvalPiecesIdx_NonPawns[(EvalPieceIdx + 0)];
        CurrentPiece = Board[(Idx + 0)];
        CurrentPieceAbs = abs(CurrentPiece);
        If (Not ((CurrentPieceAbs == GoK_OwnKing)))
        {
            Factor = (((CurrentPiece > 0) * 2) - 1);
            IdxSub = ((PieceMobility[(Idx + 0)] * 2) + 1);
            If (CurrentPieceAbs == GoK_OwnRook)
            {
                TE.MobilityEval += (RookMobilityBonus[(IdxSub + 0)] * Factor);
            }
            Else
            {
                If (CurrentPieceAbs == GoK_OwnBishop)
                {
                    TE.MobilityEval += (BishopMobilityBonus[(IdxSub + 0)] * Factor);
                }
                Else
                {
                    If (CurrentPieceAbs == GoK_OwnKnight)
                    {
                        TE.MobilityEval += (KnightMobilityBonus[(IdxSub + 0)] * Factor);
                    }
                    Else
                    {
                        If (CurrentPieceAbs == GoK_OwnQueen)
                        {
                            TE.MobilityEval += (QueenMobilityBonus[(IdxSub + 0)] * Factor);
                        }
                    }
                }
            }
        }
        EvalPieceIdx += 1;
    }
    If (Eval.DebugLog == 1)
    {
        Call LogPVEvalLine("Eval.Threats.Mobility.Total")(TE.MobilityEval)("")("")("")("");
    }
    EvalPieceIdx = 1;
    Repeat (List.Length(EvalPiecesIdx_All))
    {
        Idx = EvalPiecesIdx_All[(EvalPieceIdx + 0)];
        CurrentPiece = Board[(Idx + 0)];
        Factor = (((CurrentPiece > 0) * 2) - 1);
        CurrentPieceAbs = abs(CurrentPiece);
        If (CurrentPieceAbs > GoK_OwnPawn)
        {
            File = IdxToFile[(Idx + 0)];
            Rank = IdxToRank[(Idx + 0)];
            If (File > 1)
            {
                IdxSub = (Idx + (15 * Factor));
                If (((IdxSub > 8) And (IdxSub < 57)) And (Board[(IdxSub + 0)] == (GoK_OppPawn * Factor)))
                {
                    Call FindAndAddSafePawnPush(IdxSub)((Idx + (7 * Factor)))(CurrentPiece)(Factor);
                }
                If (((Rank == 4) And (CurrentPiece > 0)) Or ((Rank == 5) And (CurrentPiece < 0)))
                {
                    StartRank = (2 + (5 * (CurrentPiece > 0)));
                    IdxSub = (Idx + (23 * Factor));
                    If (((IdxSub > 8) And (IdxSub < 57)) And ((IdxToRank[(IdxSub + 0)] == StartRank) And (Board[(IdxSub + 0)] == (GoK_OppPawn * Factor))))
                    {
                        Call FindAndAddSafePawnPush(IdxSub)((Idx + (7 * Factor)))(CurrentPiece)(Factor);
                    }
                }
            }
            If (File < 8)
            {
                IdxSub = (Idx + (17 * Factor));
                If (((IdxSub > 8) And (IdxSub < 57)) And (Board[(IdxSub + 0)] == (GoK_OppPawn * Factor)))
                {
                    Call FindAndAddSafePawnPush(IdxSub)((Idx + (9 * Factor)))(CurrentPiece)(Factor);
                }
                If (((Rank == 4) And (CurrentPiece > 0)) Or ((Rank == 5) And (CurrentPiece < 0)))
                {
                    StartRank = (2 + (5 * (CurrentPiece > 0)));
                    IdxSub = (Idx + (25 * Factor));
                    If (((IdxSub > 8) And (IdxSub < 57)) And ((IdxToRank[(IdxSub + 0)] == StartRank) And (Board[(IdxSub + 0)] == (GoK_OppPawn * Factor))))
                    {
                        Call FindAndAddSafePawnPush(IdxSub)((Idx + (9 * Factor)))(CurrentPiece)(Factor);
                    }
                }
            }
        }
        If (CurrentPiece > 0)
        {
            Attacked = BoardAttackedByOpp[(Idx + 0)];
        }
        Else
        {
            Attacked = BoardAttackedByOwn[(Idx + 0)];
        }
        If (Attacked > 0)
        {
            Call GetAttackDefenseInfo(Idx);
            StronglyProtectedCurrentPiece = ((DefenderPieceAbs == GoK_OwnPawn) Or ((Defended > 1) And (Attacked < 2)));
            StronglyProtectedCurrentPieceNonPawn = ((CurrentPieceAbs > GoK_OwnPawn) And (StronglyProtectedCurrentPiece == 1));
            IsWeakCurrentPiece = ((Attacked > 0) And (StronglyProtectedCurrentPiece == 0));
            If (CurrentPiece > 0)
            {
                SafeAttacker = ((BoardAttackedByOwn[(AttackerIdx + 0)] == 0) Or (BoardAttackedByOpp[(AttackerIdx + 0)] > 0));
            }
            Else
            {
                SafeAttacker = ((BoardAttackedByOpp[(AttackerIdx + 0)] == 0) Or (BoardAttackedByOwn[(AttackerIdx + 0)] > 0));
            }
            IdxSub = ((PieceIdxLookup[(CurrentPieceAbs + 0)] * 2) - 1);
            If ((IsWeakCurrentPiece == 1) Or (StronglyProtectedCurrentPieceNonPawn == 1))
            {
                If ((AttackerPieceAbs == GoK_OwnKnight) Or (AttackerPieceAbs == GoK_OwnBishop))
                {
                    Call //("Minor threats");
                    Call TaperedEval.Add(((0 - MinorAttackWeight[IdxSub]) * Factor))(((0 - MinorAttackWeight[(IdxSub + 1)]) * Factor))("Eval.Threats.MinorThreat")("")("")(((AttackerIdx * 100) + Idx));
                    If (CurrentPieceAbs > GoK_OwnPawn)
                    {
                        If (CurrentPiece > 0)
                        {
                            Call TaperedEval.Add(((-6 * (8 - IdxToRank[Idx])) * Factor))(0)("Eval.Threats.MinorThreat.NonPawnTarget")("")("")(((AttackerIdx * 100) + Idx));
                        }
                        Else
                        {
                            Call TaperedEval.Add(((-6 * (IdxToRank[Idx] - 1)) * Factor))(0)("Eval.Threats.MinorThreat.NonPawnTarget")("")("")(((AttackerIdx * 100) + Idx));
                        }
                    }
                }
            }
            If (IsWeakCurrentPiece == 1)
            {
                If (1 == 0)
                {
                    If (CurrentPieceAbs == GoK_OwnQueen)
                    {
                        Call //("Unsafe queen");
                        Call TaperedEval.Add((-23 * Factor))((-7 * Factor))("Eval.Threats.UnsafeQueen")(Idx)("")("");
                    }
                }
                If ((Defended == 0) Or ((CurrentPieceAbs > GoK_OwnPawn) And (Attacked > 1)))
                {
                    Call //("Hanging pieces");
                    Call TaperedEval.Add((-32 * Factor))((-17 * Factor))("Eval.Threats.HangingPiece")(Idx)("")("");
                }
                If (AttackerPieceAbs == GoK_OwnRook)
                {
                    Call //("Rook threats");
                    Call TaperedEval.Add(((0 - RookAttackWeight[IdxSub]) * Factor))(((0 - RookAttackWeight[(IdxSub + 1)]) * Factor))("Eval.Threats.RookThreat")("")("")(((AttackerIdx * 100) + Idx));
                    If (CurrentPieceAbs > GoK_OwnPawn)
                    {
                        If (CurrentPiece > 0)
                        {
                            Call TaperedEval.Add(((-6 * (8 - IdxToRank[Idx])) * Factor))(0)("Eval.Threats.RookThreat.NonPawnTarget")("")("")(((AttackerIdx * 100) + Idx));
                        }
                        Else
                        {
                            Call TaperedEval.Add(((-6 * (IdxToRank[Idx] - 1)) * Factor))(0)("Eval.Threats.RookThreat.NonPawnTarget")("")("")(((AttackerIdx * 100) + Idx));
                        }
                    }
                }
                If (AttackerPieceAbs == GoK_OwnKing)
                {
                    Call //("King threat");
                    Call TaperedEval.Add((-11 * Factor))((-42 * Factor))("Eval.Threats.KingThreat")("")("")(((AttackerIdx * 100) + Idx));
                }
            }
            If (SafeAttacker == 1)
            {
                If ((AttackerPieceAbs == GoK_OwnPawn) And (CurrentPieceAbs > GoK_OwnPawn))
                {
                    Call //("Safe pawn attack");
                    Call TaperedEval.Add((-85 * Factor))((-46 * Factor))("Eval.Threats.SafePawnAttack")("")("")(((AttackerIdx * 100) + Idx));
                }
                If (CurrentPieceAbs == GoK_OwnQueen)
                {
                    If ((AttackerPieceAbs == GoK_OwnBishop) Or (AttackerPieceAbs == GoK_OwnRook))
                    {
                        Call //("Sliders attack queen");
                        Call TaperedEval.Add((-28 * Factor))((-8 * Factor))("Eval.Threats.SliderQueenAttack")("")("")(((AttackerIdx * 100) + Idx));
                    }
                    If (AttackerPieceAbs == GoK_OwnKnight)
                    {
                        Call //("Knight attacks queen");
                        Call TaperedEval.Add((-8 * Factor))((-6 * Factor))("Eval.Threats.KnightQueenAttack")("")("")(((AttackerIdx * 100) + Idx));
                    }
                }
            }
        }
        EvalPieceIdx += 1;
    }
    Call TaperedEval.GetSumResult;
    EvalThreatsResult += TaperedEval.SumResult;
    If (Eval.DebugLog == 1)
    {
        Call LogPVEvalLine("Eval.Threats.Base.Total")("")(TaperedEval.SumResult)("")("")("");
    }
    List.DeleteAll(KingRingAttackersCount);
    List.DeleteAll(KingRingAttacksCount);
    List.DeleteAll(KingRingAttacksWeight);
    List.DeleteAll(KingRingAttacksOnWeakCount);
    List.DeleteAll(KingRingAttacksBishopDefenders);
    List.DeleteAll(KingRingAttacksKnightDefenders);
    List.DeleteAll(KingRingAttackSafeChecks);
    List.DeleteAll(KingRingAttackUnsafeChecks);
    List.DeleteAll(KingRingAttacksEscapeCount);
    List.DeleteAll(KingRingPawnProtection);
    List.DeleteAll(KingRingSliderBlockers);
    Repeat (2)
    {
        List.Add(KingRingAttackersCount, 0);
        List.Add(KingRingAttacksCount, 0);
        List.Add(KingRingAttacksWeight, 0);
        List.Add(KingRingAttacksOnWeakCount, 0);
        List.Add(KingRingAttacksBishopDefenders, 0);
        List.Add(KingRingAttacksKnightDefenders, 0);
        List.Add(KingRingAttackSafeChecks, 0);
        List.Add(KingRingAttackUnsafeChecks, 0);
        List.Add(KingRingAttacksEscapeCount, 0);
        List.Add(KingRingPawnProtection, 0);
        List.Add(KingRingSliderBlockers, 0);
    }
    List.DeleteAll(AttacksWeight);
    List.Add(AttacksWeight, 0);
    List.Add(AttacksWeight, 36);
    List.Add(AttacksWeight, 26);
    List.Add(AttacksWeight, 21);
    List.Add(AttacksWeight, 5);
    List.Add(AttacksWeight, 0);
    List.DeleteAll(TmpList2);
    List.Add(TmpList2, 1);
    List.Add(TmpList2, 10);
    List.Add(TmpList2, 100);
    List.Add(TmpList2, 1000);
    Side = 1;
    Repeat (2)
    {
        List.DeleteAll(TmpList1);
        CastlingStateLocal = CastlingState[(Depth + 0)];
        If (Side == 1)
        {
            Call GetKingShelterStorm(KingIdxtOwn)((1 == 1))(1);
            CurrentValue2 = KingShelterStorm;
            If ((Operator.LetterOf(CastlingStateLocal, 1) == 0) And (Operator.LetterOf(CastlingStateLocal, 2) == 0))
            {
                If (BoardAttackedByOpp[VirtualBoard[5]] == 0)
                {
                    If (Operator.LetterOf(CastlingStateLocal, 3) == 0)
                    {
                        If (BoardAttackedByOpp[VirtualBoard[6]] == 0)
                        {
                            If (BoardAttackedByOpp[VirtualBoard[7]] == 0)
                            {
                                Call GetKingShelterStorm(VirtualBoard[7])((1 == 1))(1);
                                If (KingShelterStorm > CurrentValue2)
                                {
                                    CurrentValue2 = KingShelterStorm;
                                }
                            }
                        }
                    }
                    If (Operator.LetterOf(CastlingStateLocal, 4) == 0)
                    {
                        If (BoardAttackedByOpp[VirtualBoard[4]] == 0)
                        {
                            If (BoardAttackedByOpp[VirtualBoard[3]] == 0)
                            {
                                If (BoardAttackedByOpp[VirtualBoard[2]] == 0)
                                {
                                    Call GetKingShelterStorm(VirtualBoard[2])((1 == 1))(1);
                                    If (KingShelterStorm > CurrentValue2)
                                    {
                                        CurrentValue2 = KingShelterStorm;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Call LogPVEvalLine("Eval.Threats.ShelterStorm.PreScale")(CurrentValue2)("")("")(Side)("");
            List.ReplaceItem(KingRingPawnProtection, (Side + 0), CurrentValue2);
            Call LogPVEvalLine("Eval.Threats.ShelterStorm")(KingRingPawnProtection[(Side + 0)])("")("")(Side)("");
        }
        Else
        {
            Call GetKingShelterStorm(KingIdxOpp)((1 == 0))(0.8);
            CurrentValue2 = KingShelterStorm;
            If ((Operator.LetterOf(CastlingStateLocal, 5) == 0) And (Operator.LetterOf(CastlingStateLocal, 6) == 0))
            {
                If (BoardAttackedByOwn[VirtualBoard[61]] == 0)
                {
                    If (Operator.LetterOf(CastlingStateLocal, 7) == 0)
                    {
                        If (BoardAttackedByOwn[VirtualBoard[62]] == 0)
                        {
                            If (BoardAttackedByOwn[VirtualBoard[63]] == 0)
                            {
                                Call GetKingShelterStorm(VirtualBoard[63])((1 == 0))(0.8);
                                If (KingShelterStorm > CurrentValue2)
                                {
                                    CurrentValue2 = KingShelterStorm;
                                }
                            }
                        }
                    }
                    If (Operator.LetterOf(CastlingStateLocal, 8) == 0)
                    {
                        If (BoardAttackedByOwn[VirtualBoard[60]] == 0)
                        {
                            If (BoardAttackedByOwn[VirtualBoard[59]] == 0)
                            {
                                If (BoardAttackedByOwn[VirtualBoard[58]] == 0)
                                {
                                    Call GetKingShelterStorm(VirtualBoard[58])((1 == 0))(0.8);
                                    If (KingShelterStorm > CurrentValue2)
                                    {
                                        CurrentValue2 = KingShelterStorm;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Call LogPVEvalLine("Eval.Threats.ShelterStorm.PreScale")(CurrentValue2)("")("")(Side)("");
            List.ReplaceItem(KingRingPawnProtection, (Side + 0), CurrentValue2);
            Call LogPVEvalLine("Eval.Threats.ShelterStorm")(KingRingPawnProtection[(Side + 0)])("")("")(Side)("");
        }
        If (Side == 1)
        {
            KingIdx = KingIdxtOwn;
        }
        Else
        {
            KingIdx = KingIdxOpp;
        }
        EvalPieceIdx = 1;
        Repeat (List.Length(EvalPiecesIdx_NonPawns))
        {
            Idx = EvalPiecesIdx_NonPawns[(EvalPieceIdx + 0)];
            CurrentPiece = Board[(Idx + 0)];
            If (((Side == 1) And (CurrentPiece < 0)) Or ((Side == 2) And (CurrentPiece > 0)))
            {
                CurrentPieceAbs = abs(CurrentPiece);
                If ((CurrentPieceAbs > GoK_OwnKnight) And (CurrentPieceAbs < GoK_OwnKing))
                {
                    CurrentMove = ((Idx * 100) + KingIdx);
                    IdxSub = ((PieceIdxLookup[CurrentPieceAbs] * 10000) + CurrentMove);
                    If (((Side == 1) And (MovePosLookupOppLegal[IdxSub] == 1)) Or ((Side == 2) And (MovePosLookupOwnLegal[IdxSub] == 1)))
                    {
                        BlockedCount = 0;
                        SourceIdx = Idx;
                        IdxInc = MovePathStepInc[(CurrentMove + 0)];
                        Repeat Until ((SourceIdx + IdxInc) == KingIdx)
                        {
                            SourceIdx += IdxInc;
                            If (Not ((Board[(SourceIdx + 0)] == 0)))
                            {
                                BlockedCount += 1;
                            }
                        }
                        If (BlockedCount == 1)
                        {
                            List.ReplaceItem(KingRingSliderBlockers, (Side + 0), (KingRingSliderBlockers[(Side + 0)] + 1));
                        }
                    }
                }
            }
            EvalPieceIdx += 1;
        }
        IdxOuter = (((KingIdx - 1) * 10) + 1);
        Repeat (9)
        {
            Idx = KingRings[(IdxOuter + 0)];
            If (Not ((Idx == -1)))
            {
                IsWeakCurrentPiece = 0;
                If (Side == 1)
                {
                    Count1 = BoardAttackedByOpp[(Idx + 0)];
                }
                Else
                {
                    Count1 = BoardAttackedByOwn[(Idx + 0)];
                }
                If (Count1 > 0)
                {
                    If (Side == 1)
                    {
                        IdxSub = BoardAttackedByOppPiece[(Idx + 0)];
                        DefenderPiece = Board[BoardAttackedByOwnPiece[(Idx + 0)]];
                        If ((BoardAttackedByOwn[(Idx + 0)] == 0) Or ((DefenderPiece == GoK_OwnQueen) Or (DefenderPiece == GoK_OwnKing)))
                        {
                            IsWeakCurrentPiece = 1;
                        }
                    }
                    Else
                    {
                        IdxSub = BoardAttackedByOwnPiece[(Idx + 0)];
                        DefenderPiece = Board[BoardAttackedByOppPiece[(Idx + 0)]];
                        If ((BoardAttackedByOpp[(Idx + 0)] == 0) Or ((DefenderPiece == GoK_OppQueen) Or (DefenderPiece == GoK_OppKing)))
                        {
                            IsWeakCurrentPiece = 1;
                        }
                    }
                    List.ReplaceItem(KingRingAttacksCount, (Side + 0), (KingRingAttacksCount[(Side + 0)] + Count1));
                    If (IsWeakCurrentPiece == 1)
                    {
                        List.ReplaceItem(KingRingAttacksOnWeakCount, (Side + 0), (KingRingAttacksOnWeakCount[(Side + 0)] + 1));
                    }
                    If (Not (List.ContainsItem(TmpList1, IdxSub)))
                    {
                        List.ReplaceItem(KingRingAttackersCount, (Side + 0), (KingRingAttackersCount[(Side + 0)] + 1));
                        List.ReplaceItem(KingRingAttacksWeight, (Side + 0), (KingRingAttacksWeight[(Side + 0)] + AttacksWeight[PieceIdxLookup[abs(Board[(IdxSub + 0)])]]));
                        List.Add(TmpList1, IdxSub);
                    }
                    If (abs(DefenderPiece) == GoK_OwnBishop)
                    {
                        List.ReplaceItem(KingRingAttacksBishopDefenders, (Side + 0), (KingRingAttacksBishopDefenders[(Side + 0)] + 1));
                    }
                    Else
                    {
                        If (abs(DefenderPiece) == GoK_OwnKnight)
                        {
                            List.ReplaceItem(KingRingAttacksKnightDefenders, (Side + 0), (KingRingAttacksKnightDefenders[(Side + 0)] + 1));
                        }
                    }
                }
            }
            IdxOuter += 1;
        }
        TE.Idx = 1;
        Repeat (64)
        {
            Factor = (((Side == 1) * 2) - 1);
            AttackerPieceAbs = 0;
            DefenderPiece = 0;
            If (Side == 1)
            {
                Attacked = BoardAttackedByOpp[(TE.Idx + 0)];
                If (Attacked > 0)
                {
                    AttackerIdx = BoardAttackedByOppPiece[(TE.Idx + 0)];
                    AttackerPieceAbs = abs(Board[AttackerIdx]);
                }
                Defended = BoardAttackedByOwn[(TE.Idx + 0)];
                If (Defended > 0)
                {
                    DefenderPiece = Board[BoardAttackedByOwnPiece[(TE.Idx + 0)]];
                }
            }
            Else
            {
                Attacked = BoardAttackedByOwn[(TE.Idx + 0)];
                If (Attacked > 0)
                {
                    AttackerIdx = BoardAttackedByOwnPiece[(TE.Idx + 0)];
                    AttackerPieceAbs = abs(Board[AttackerIdx]);
                }
                Defended = BoardAttackedByOpp[(TE.Idx + 0)];
                If (Defended > 0)
                {
                    DefenderPiece = Board[BoardAttackedByOppPiece[(TE.Idx + 0)]];
                }
            }
            If (Attacked > 0)
            {
                If ((AttackerPieceAbs == GoK_OwnPawn) Or ((Attacked > 1) And (Defended < 2)))
                {
                    If (Defended > 0)
                    {
                        Call TaperedEval.AddIdentical((-3 * Factor))("Eval.Threats.MobilityRestrictions")(TE.Idx)(Side)("");
                    }
                }
                If ((AttackerPieceAbs > GoK_OwnPawn) And (Not ((AttackerPieceAbs == GoK_OwnKing))))
                {
                    CurrentMove = ((TE.Idx * 100) + KingIdx);
                    IdxSub = ((PieceIdxLookup[(AttackerPieceAbs + 0)] * 10000) + CurrentMove);
                    If (((Side == 1) And (MovePosLookupOppLegal[(IdxSub + 0)] == 1)) Or ((Side == 2) And (MovePosLookupOwnLegal[(IdxSub + 0)] == 1)))
                    {
                        TargetPiece = Board[(TE.Idx + 0)];
                        If (((Side == 1) And (Not ((TargetPiece < 0)))) Or ((Side == 2) And (Not ((TargetPiece > 0)))))
                        {
                            Found = 1;
                            If (Not ((AttackerPieceAbs == GoK_OwnKnight)))
                            {
                                SourceIdx = (TE.Idx + 0);
                                IdxInc = (MovePathStepInc[(CurrentMove + 0)] + 0);
                                Repeat Until ((Found == 0) Or ((SourceIdx + IdxInc) == KingIdx))
                                {
                                    SourceIdx += IdxInc;
                                    If (Not ((Board[(SourceIdx + 0)] == 0)))
                                    {
                                        Found = 0;
                                    }
                                }
                            }
                            If (Found == 1)
                            {
                                IsWeak = ((Defended == 0) Or ((Defended < 2) And (abs(DefenderPiece) > GoK_OwnRook)));
                                If ((Defended == 0) Or ((IsWeak == 1) And (Attacked > 1)))
                                {
                                    List.ReplaceItem(KingRingAttackSafeChecks, (Side + 0), (KingRingAttackSafeChecks[(Side + 0)] + TmpList2[(PieceIdxLookup[(AttackerPieceAbs + 0)] - 1)]));
                                    If (Eval.DebugLog == 1)
                                    {
                                        Call LogPVEvalLine("Eval.Threats.SafeCheck")("")("")("")(Side)(CurrentMove);
                                    }
                                }
                                Else
                                {
                                    If (Not ((AttackerPieceAbs == GoK_OwnQueen)))
                                    {
                                        If ((Defended == 0) Or (abs(DefenderPiece) > GoK_OwnPawn))
                                        {
                                            List.ReplaceItem(KingRingAttackUnsafeChecks, (Side + 0), (KingRingAttackUnsafeChecks[(Side + 0)] + 1));
                                            If (Eval.DebugLog == 1)
                                            {
                                                Call LogPVEvalLine("Eval.Threats.UnsafeCheck")("")("")("")(Side)(CurrentMove);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Idx += 1;
        }
        KingFlankAttacks = 0;
        If (Side == 1)
        {
            KingFile = IdxToFile[(KingIdxtOwn + 0)];
            Rank = IdxToRank[(KingIdxtOwn + 0)];
        }
        Else
        {
            KingFile = IdxToFile[(KingIdxOpp + 0)];
            Rank = (IdxToRank[(KingIdxOpp + 0)] - 4);
        }
        If ((KingFile == 1) Or (KingFile == 3))
        {
            KingFile = 2;
        }
        Else
        {
            If ((KingFile == 6) Or (KingFile == 8))
            {
                KingFile = 7;
            }
        }
        If (Side == 1)
        {
            KingPawnlessFlank = ((PawnCountOwn[(KingFile - 1)] == 0) And ((PawnCountOwn[(KingFile + 0)] == 0) And (PawnCountOwn[(KingFile + 1)] == 0)));
        }
        Else
        {
            KingPawnlessFlank = ((PawnCountOpp[(KingFile - 1)] == 0) And ((PawnCountOpp[(KingFile + 0)] == 0) And (PawnCountOpp[(KingFile + 1)] == 0)));
        }
        File = (KingFile - 1);
        Idx = (((Rank - 1) * 8) + File);
        Repeat (5)
        {
            Repeat (3)
            {
                If ((Idx > 0) And (Idx < 65))
                {
                    If (Side == 1)
                    {
                        KingFlankAttacks += BoardAttackedByOpp[(Idx + 0)];
                    }
                    Else
                    {
                        KingFlankAttacks += BoardAttackedByOwn[(Idx + 0)];
                    }
                }
                Idx += 1;
            }
            Idx += 5;
        }
        KingDanger = 0;
        KingDanger += Operator.Round((0.25 * KingFlankAttacks));
        Call TaperedEval.GetScalarResult(KingRingPawnProtection[(Side + 0)])(0)(TaperedEval.ScaleFactor)(TaperedEval.Phase);
        KingDanger += Operator.Round((-0.66 * TaperedEval.ScalarResult));
        KingDanger += (KingRingAttacksWeight[(Side + 0)] * KingRingAttackersCount[(Side + 0)]);
        KingDanger += (32 * KingRingAttacksCount[(Side + 0)]);
        KingDanger += (86 * KingRingAttacksOnWeakCount[(Side + 0)]);
        KingDanger += (-47 * KingRingAttacksKnightDefenders[(Side + 0)]);
        KingDanger += (-18 * KingRingAttacksBishopDefenders[(Side + 0)]);
        KingDanger += (65 * KingRingAttackUnsafeChecks[(Side + 0)]);
        KingDanger += (65 * KingRingSliderBlockers[(Side + 0)]);
        CurrentValue2 = MoveToZeroPadStr[(KingRingAttackSafeChecks[(Side + 0)] + 1)];
        If (Operator.LetterOf(CurrentValue2, 2) == 0)
        {
            KingDanger += (((360 * 1) - 0) * (Operator.LetterOf(CurrentValue2, 1) > 0));
        }
        KingDanger += (((500 * 1) - 0) * (Operator.LetterOf(CurrentValue2, 2) > 0));
        If (Operator.LetterOf(CurrentValue2, 1) == 0)
        {
            KingDanger += (((300 * 1) - 0) * (Operator.LetterOf(CurrentValue2, 3) > 0));
        }
        KingDanger += (((360 * 1) - 0) * (Operator.LetterOf(CurrentValue2, 4) > 0));
        If (Side == 1)
        {
            If (QueenCountOppLocal == 0)
            {
                KingDanger += -410;
            }
            KingDanger += (0 - TE.MobilityEval);
        }
        Else
        {
            If (QueenCounttOwnLocal == 0)
            {
                KingDanger += -410;
            }
            KingDanger += TE.MobilityEval;
        }
        If (Eval.DebugLog == 1)
        {
            Call LogPVEvalLine("Eval.Threats.KingDanger.FlankAttacks.PreScale")(Operator.Round((0.25 * KingFlankAttacks)))("")("")(Side)("");
            Call LogPVEvalLine("Eval.Threats.KingDanger.PawnProtection.PreScale")(Operator.Round((-0.66 * KingRingPawnProtection[(Side + 0)])))("")("")(Side)("");
            Call LogPVEvalLine("Eval.Threats.KingDanger.AttacksWeightTimesAttackerCount.PreScale")((KingRingAttacksWeight[(Side + 0)] * KingRingAttackersCount[(Side + 0)]))("")("")(Side)("");
            Call LogPVEvalLine("Eval.Threats.KingDanger.AttackCount.PreScale")((32 * KingRingAttacksCount[(Side + 0)]))("")("")(Side)("");
            Call LogPVEvalLine("Eval.Threats.KingDanger.AttacksOnWeakSquareCount .PreScale")((86 * KingRingAttacksOnWeakCount[(Side + 0)]))("")("")(Side)("");
            Call LogPVEvalLine("Eval.Threats.KingDanger.KnightDefenders.PreScale")((-47 * KingRingAttacksKnightDefenders[(Side + 0)]))("")("")(Side)("");
            Call LogPVEvalLine("Eval.Threats.KingDanger.BishopDefenders.PreScale")((-18 * KingRingAttacksBishopDefenders[(Side + 0)]))("")("")(Side)("");
            Call LogPVEvalLine("Eval.Threats.KingDanger.UnsafeChecks.PreScale")((65 * KingRingAttackUnsafeChecks[(Side + 0)]))("")("")(Side)("");
            Call LogPVEvalLine("Eval.Threats.KingDanger.SliderBlockers.PreScale")((65 * KingRingSliderBlockers[(Side + 0)]))("")("")(Side)("");
            Call LogPVEvalLine("Eval.Threats.KingDanger.SafeChecks.MetaData.QRBK")(MoveToZeroPadStr[(KingRingAttackSafeChecks[(Side + 0)] + 1)])("")("")(Side)("");
        }
        Call TaperedEval.Init;
        If (KingDanger > 0)
        {
            Call TaperedEval.Add((0 - Operator.Round(((KingDanger * KingDanger) / 2048))))((0 - Operator.Round((KingDanger / 16))))("Eval.Threats.KingDanger")("")(Side)("");
        }
        Call TaperedEval.Add((-4 * KingFlankAttacks))(0)("Eval.Threats.KingFlankAttacks")("")(Side)("");
        Call TaperedEval.Add((-8 * KingPawnlessFlank))((-45 * KingPawnlessFlank))("Eval.Threats.KingPawnlessFlank")("")(Side)("");
        Call TaperedEval.Add(KingRingPawnProtection[(Side + 0)])(0)("Eval.Threats.KingDanger.PawnProtection")("")(Side)("");
        Call LogPVEvalLine("Eval.Threats.KingDanger.Extended")(TaperedEval.Mg)(TaperedEval.Eg)("")(Side)("");
        If (1 == 1)
        {
            If (TaperedEval.Mg > 80)
            {
                TaperedEval.Mg = 80;
                If (Eval.DebugLog == 1)
                {
                    Call LogPVEvalLine("Eval.Threats.KingDanger.Extended.Capped")(TaperedEval.Mg)(TaperedEval.Eg)("")(Side)("");
                }
            }
        }
        Call TaperedEval.GetSumResult;
        CurrentValue = (Operator.Round((TaperedEval.SumResult * 1)) * (((Side == 1) * 2) - 1));
        EvalThreatsResult += CurrentValue;
        Call LogPVEvalLine("Eval.Threats.KingDanger.Extended.TaperedAndSigned.Total")(CurrentValue)("")("")(Side)("");
        Side += 1;
    }
    If (Eval.DebugLog == 1)
    {
        Call LogPVEvalLine("Eval.Threats.Total")(EvalThreatsResult)("")("")(Side)("");
    }
}

Define ExecuteEngineMove (warp=false)
{
    Call EnterExecution;
    Call ExecuteEngineMoveImpl;
    Call ExitExecution;
}

Define ExecuteEngineMoveImpl (warp=false)
{
    If (GoK_IsGameSuspended == 1)
    {
        Stop(this script);
    }
    Event.Broadcast("OpeningBookHide");
    BestMove = "";
    If (Level > 2)
    {
        Call GetOpeningMoves;
        If (List.Length(OpeningMovesRes) > 0)
        {
            Event.Broadcast("OpeningBookShow");
            BestMove = OpeningMovesRes[Operator.Random(1 , List.Length(OpeningMovesRes))];
        }
    }
    Call IsEngineValidMove(BestMove);
    If (ValidMoveRes == 0)
    {
        Looks.Think("Thinking...");
        Control.Wait(0);
        If (Level > 2)
        {
            If (Level > 4)
            {
                Call GetBestMoveMedDiff;
            }
            Else
            {
                Call GetBestMoveBlitz;
            }
        }
        Else
        {
            Call GetBestMoveEasy;
        }
    }
    Event.BroadcastAndWait("hidebestmove");
    Call OnProgressChanged(100);
    Control.Wait(0);
    Call IsEngineValidMove(BestMove);
    If (ValidMoveRes == 0)
    {
        Looks.Say(Operator.Join("Internal Error: No valid move found. Sorry, this should not happen. Maybe you cleared lookup lists in the editor? If you are running a normal game, please export board data and report bug via project comment", Operator.Join(" Move: ", BestMove)), 10);
        GoK_IsGameSuspended = 1;
        Stop(this script);
    }
    Looks.Think("");
    Pieces_MovePieceFromIdx = floor((BestMove / 100));
    Pieces_MovePieceToIdx = floor((BestMove % 100));
    If (((BestMove == GoK_OwnQueensideCastling) Or (BestMove == GoK_OwnKingsideCastling)) Or ((BestMove == GoK_OppQueensideCastling) Or (BestMove == GoK_OppKingsideCastling)))
    {
        Pieces_MovePieceSpecial = BestMove;
    }
    Else
    {
        Pieces_MovePieceSpecial = "";
    }
    Event.BroadcastAndWait("movepiece");
    Event.Broadcast("SoundMove");
    GameMoves = Operator.Join(GameMoves, MoveToZeroPadStr[floor((BestMove + 1))]);
    Call GetMoveNotation(BestMove);
    List.Add(GameMovesAN, MoveNotationRes);
    Call ClearMoveList(1);
    Call AddMoveToList(BestMove)(1);
    List.ReplaceItem(MovesIdx, 1, 1);
    Call ApplyMove(1);
    Call DrawBoardAndWait;
    If (Board[(BestMove % 100)] == GoK_OwnKing)
    {
        HasOwnKingMoved = 1;
    }
    If (Board[(BestMove % 100)] == GoK_OwnRook)
    {
        If (floor((BestMove / 100)) == VirtualBoard[1])
        {
            HasOwnRookQSMoved = 1;
        }
        If (floor((BestMove / 100)) == VirtualBoard[8])
        {
            HasOwnRookKSMoved = 1;
        }
    }
    If ((BestMove == GoK_OwnQueensideCastling) Or (BestMove == GoK_OwnKingsideCastling))
    {
        HasOwnKingMoved = 1;
        HasOwnCastled = 1;
    }
    Call AddBoardToHistory(1);
    Call GetRepetitionCount;
    If (RepetitionCountRes > 2)
    {
        Looks.Say("Draw!");
        Event.Broadcast("SoundDraw");
        GoK_IsGameSuspended = 1;
    }
    Else
    {
        Call IsDrawByMaterial;
        If (IsDrawRes == 1)
        {
            Looks.Say("Draw!");
            Event.Broadcast("SoundDraw");
            GoK_IsGameSuspended = 1;
        }
        Else
        {
            Call IsOppKingCheckMate;
            If (IsOppKingCheckMateRes == 1)
            {
                Looks.Say("Checkmate!");
                Event.Broadcast("SoundCheckmate");
                GoK_IsGameSuspended = 1;
            }
            Else
            {
                Call IsDrawByStalemate(2);
                If (IsDrawRes == 1)
                {
                    Looks.Say("Draw!");
                    Event.Broadcast("SoundDraw");
                    GoK_IsGameSuspended = 1;
                }
                Else
                {
                    Call CalcBoardAttackedByMove(1);
                    If (IsOppSideChecked == 1)
                    {
                        Call SayAsync("Check!")(2);
                        Event.Broadcast("SoundCheck");
                    }
                }
            }
        }
    }
}

Define ExecuteInit (warp=false)
{
    ExecutionDepth = 0;
    IsExecutionRunning = 0;
    If (IsPlayerBlack == 1)
    {
        Call ExecuteEngineMove;
    }
}

Define ExecuteUserMove(string UserMove) (warp=false)
{
    Call EnterExecution;
    Call ExecuteUserMoveImpl(UserMove);
    Call ExitExecution;
}

Define ExecuteUserMoveImpl(string UserMoveParam) (warp=false)
{
    If (GoK_IsGameSuspended == 1)
    {
        Stop(this script);
    }
    Pieces_MovePieceFromIdx = floor((UserMoveParam / 100));
    Pieces_MovePieceToIdx = floor((UserMoveParam % 100));
    If (((UserMoveParam == GoK_OwnQueensideCastling) Or (UserMoveParam == GoK_OwnKingsideCastling)) Or ((UserMoveParam == GoK_OppQueensideCastling) Or (UserMoveParam == GoK_OppKingsideCastling)))
    {
        Pieces_MovePieceSpecial = UserMoveParam;
    }
    Else
    {
        Pieces_MovePieceSpecial = "";
    }
    Event.BroadcastAndWait("movepiece");
    Event.Broadcast("SoundMove");
    Stg_FromSquareIdx = -1;
    Stg_ToSquareIdx = -1;
    Event.BroadcastAndWait("fromsquareselected");
    Event.BroadcastAndWait("tosquareselected");
    Call GenerateMovesPublic(2);
    If (Not (List.ContainsItem(Moves2, UserMoveParam)))
    {
        Call ClearMoveList(2);
        Call AddMoveToList(UserMoveParam)(2);
        List.ReplaceItem(MovesIdx, 2, 1);
        Call ApplyMove(2);
        Call CalcBoardAttackedByMove(3);
        If (IsOppSideChecked == 1)
        {
            Call SayAsync("Invalid move - Check!")(2);
            Event.Broadcast("SoundInvalidMoveCheck");
        }
        Else
        {
            Call SayAsync("Invalid move!")(2);
            Event.Broadcast("SoundInvalidMove");
        }
        Call RevertMove(2);
        Call DrawBoardAndWait;
        Stop(this script);
    }
    UserMove = UserMoveParam;
    If (Operator.LetterOf(UserMove, (Variable.Length(UserMove) - 1)) == ".")
    {
        Looks.Say("Please select promotion piece");
        Event.BroadcastAndWait("selectpromotionpiecewhite");
        Looks.Say("");
        If (Pieces_SelectedPromotionPiece == GoK_OppQueen)
        {
            UserMove = (floor(UserMove) + 0.1);
        }
        Else
        {
            If (Pieces_SelectedPromotionPiece == GoK_OppRook)
            {
                UserMove = (floor(UserMove) + 0.2);
            }
            Else
            {
                If (Pieces_SelectedPromotionPiece == GoK_OppBishop)
                {
                    UserMove = (floor(UserMove) + 0.3);
                }
                Else
                {
                    If (Pieces_SelectedPromotionPiece == GoK_OppKnight)
                    {
                        UserMove = (floor(UserMove) + 0.4);
                    }
                }
            }
        }
    }
    Call GetMoveNotation(UserMove);
    Call ClearMoveList(2);
    Call AddMoveToList(UserMove)(2);
    List.ReplaceItem(MovesIdx, 2, 1);
    Call ApplyMove(2);
    Call DrawBoardAndWait;
    Call CalcBoardAttackedByMove(1);
    If (IsOppSideChecked == 1)
    {
        Call RevertMove(2);
        Call DrawBoardAndWait;
        Control.Wait(0);
        Call SayAsync("Invalid move - Check!")(2);
        Event.Broadcast("SoundInvalidMoveCheck");
        Stop(this script);
    }
    List.Add(GameMovesAN, MoveNotationRes);
    GameMoves = Operator.Join(GameMoves, MoveToZeroPadStr[floor((UserMove + 1))]);
    Looks.Think("Thinking...");
    Call DrawBoardAndWait;
    Control.Wait(0);
    SourceIdx = floor((UserMove / 100));
    TargetIdx = floor((UserMove % 100));
    If (Board[TargetIdx] == GoK_OppKing)
    {
        HasOppKingMoved = 1;
    }
    If (Board[TargetIdx] == GoK_OppRook)
    {
        If (SourceIdx == VirtualBoard[57])
        {
            HasOppRookQSMoved = 1;
        }
        If (SourceIdx == VirtualBoard[64])
        {
            HasOppRookKSMoved = 1;
        }
    }
    If ((UserMove == GoK_OppQueensideCastling) Or (UserMove == GoK_OppKingsideCastling))
    {
        HasOppCastled = 1;
        HasOppKingMoved = 1;
    }
    PrevPly1Move = UserMove;
    Call AddBoardToHistory(0);
    Call IsOwnKingCheckMate;
    If (IsOwnKingCheckMateRes == 1)
    {
        Looks.Say("Checkmate!");
        Event.Broadcast("SoundCheckmate");
        GoK_IsGameSuspended = 1;
    }
    Else
    {
        Call IsDrawByStalemate(1);
        If (IsDrawRes == 1)
        {
            Looks.Say("Draw!");
            Event.Broadcast("SoundDraw");
            GoK_IsGameSuspended = 1;
        }
        Else
        {
            Call GetRepetitionCount;
            If (RepetitionCountRes > 2)
            {
                Looks.Say("Draw!");
                Event.Broadcast("SoundDraw");
                GoK_IsGameSuspended = 1;
            }
            Else
            {
                Call IsDrawByMaterial;
                If (IsDrawRes == 1)
                {
                    Looks.Say("Draw!");
                    Event.Broadcast("SoundDraw");
                    GoK_IsGameSuspended = 1;
                }
                Else
                {
                    Call ExecuteEngineMove;
                }
            }
        }
    }
}

Define ExitExecution (warp=false)
{
    ExecutionDepth += -1;
    If (ExecutionDepth == 0)
    {
        IsExecutionRunning = 0;
        Event.BroadcastAndWait("inputmode");
    }
}

Define ExportBoardFEN(bool IsPlayerBlack)(bool IsPlayerTurn) (warp=true)
{
    ExportDataFEN = "";
    ExportDataFENLichess = "https://lichess.org/analysis/";
    Idx = 1;
    Repeat Until (Idx > 64)
    {
        If IsPlayerBlack
        {
            CurrentPiece = (0 - Board[(65 - Idx)]);
        }
        Else
        {
            CurrentPiece = Board[Idx];
        }
        If (CurrentPiece == GoK_OwnPawn)
        {
            CurrentValue = "p";
        }
        If (CurrentPiece == GoK_OwnKnight)
        {
            CurrentValue = "n";
        }
        If (CurrentPiece == GoK_OwnBishop)
        {
            CurrentValue = "b";
        }
        If (CurrentPiece == GoK_OwnRook)
        {
            CurrentValue = "r";
        }
        If (CurrentPiece == GoK_OwnQueen)
        {
            CurrentValue = "q";
        }
        If (CurrentPiece == GoK_OwnKing)
        {
            CurrentValue = "k";
        }
        If (CurrentPiece == GoK_OppPawn)
        {
            CurrentValue = "P";
        }
        If (CurrentPiece == GoK_OppKnight)
        {
            CurrentValue = "N";
        }
        If (CurrentPiece == GoK_OppBishop)
        {
            CurrentValue = "B";
        }
        If (CurrentPiece == GoK_OppRook)
        {
            CurrentValue = "R";
        }
        If (CurrentPiece == GoK_OppQueen)
        {
            CurrentValue = "Q";
        }
        If (CurrentPiece == GoK_OppKing)
        {
            CurrentValue = "K";
        }
        If (CurrentPiece == 0)
        {
            IdxSub = Idx;
            Repeat Until (((IdxSub % 8) == 0) Or (((Not (IsPlayerBlack)) And (Not ((Board[(IdxSub + 1)] == 0)))) Or (IsPlayerBlack And (Not ((Board[(65 - (IdxSub + 1))] == 0))))))
            {
                IdxSub += 1;
            }
            CurrentValue = ((IdxSub - Idx) + 1);
            Idx += (IdxSub - Idx);
        }
        ExportDataFEN = Operator.Join(ExportDataFEN, CurrentValue);
        ExportDataFENLichess = Operator.Join(ExportDataFENLichess, CurrentValue);
        If (((Idx % 8) == 0) And (Idx < 64))
        {
            ExportDataFEN = Operator.Join(ExportDataFEN, "/");
            ExportDataFENLichess = Operator.Join(ExportDataFENLichess, "/");
        }
        Idx += 1;
    }
    If ((IsPlayerBlack And IsPlayerTurn) Or ((Not (IsPlayerBlack)) And (Not (IsPlayerTurn))))
    {
        ExportDataFEN = Operator.Join(ExportDataFEN, " b");
        ExportDataFENLichess = Operator.Join(ExportDataFENLichess, "_b");
    }
    Else
    {
        ExportDataFEN = Operator.Join(ExportDataFEN, " w");
        ExportDataFENLichess = Operator.Join(ExportDataFENLichess, "_w");
    }
}

Define ExportMovesPGN (warp=true)
{
    ExportMovesPGN = "";
    Idx = 1;
    Repeat (List.Length(GameMovesAN))
    {
        If ((Idx % 2) == 1)
        {
            ExportMovesPGN = Operator.Join(ExportMovesPGN, Operator.Join((((Idx - 1) / 2) + 1), ". "));
        }
        ExportMovesPGN = Operator.Join(ExportMovesPGN, Operator.Join(GameMovesAN[Idx], " "));
        Idx += 1;
    }
}

Define FillBoard (warp=true)
{
    List.DeleteItem(VirtualBoard, all);
    Idx = 1;
    Repeat (64)
    {
        If (IsPlayerBlack == 0)
        {
            List.Add(VirtualBoard, Idx);
        }
        Else
        {
            List.Add(VirtualBoard, (((IdxToRank[Idx] - 1) * 8) + (9 - IdxToFile[Idx])));
        }
        Idx += 1;
    }
    List.DeleteItem(Board, all);
    Repeat (64)
    {
        List.Add(Board, 0);
    }
    List.ReplaceItem(Board, VirtualBoard[1], GoK_OwnRook);
    List.ReplaceItem(Board, VirtualBoard[2], GoK_OwnKnight);
    List.ReplaceItem(Board, VirtualBoard[3], GoK_OwnBishop);
    List.ReplaceItem(Board, VirtualBoard[4], GoK_OwnQueen);
    List.ReplaceItem(Board, VirtualBoard[5], GoK_OwnKing);
    List.ReplaceItem(Board, VirtualBoard[6], GoK_OwnBishop);
    List.ReplaceItem(Board, VirtualBoard[7], GoK_OwnKnight);
    List.ReplaceItem(Board, VirtualBoard[8], GoK_OwnRook);
    Idx = 9;
    Repeat (8)
    {
        List.ReplaceItem(Board, VirtualBoard[Idx], GoK_OwnPawn);
        Idx += 1;
    }
    Idx = 49;
    Repeat (8)
    {
        List.ReplaceItem(Board, VirtualBoard[Idx], GoK_OppPawn);
        Idx += 1;
    }
    List.ReplaceItem(Board, VirtualBoard[57], GoK_OppRook);
    List.ReplaceItem(Board, VirtualBoard[58], GoK_OppKnight);
    List.ReplaceItem(Board, VirtualBoard[59], GoK_OppBishop);
    List.ReplaceItem(Board, VirtualBoard[60], GoK_OppQueen);
    List.ReplaceItem(Board, VirtualBoard[61], GoK_OppKing);
    List.ReplaceItem(Board, VirtualBoard[62], GoK_OppBishop);
    List.ReplaceItem(Board, VirtualBoard[63], GoK_OppKnight);
    List.ReplaceItem(Board, VirtualBoard[64], GoK_OppRook);
}

Define FindAndAddSafePawnPush(string SourceIdx)(string TargetIdx)(string AttackedPiece)(string Factor) (warp=true)
{
    If ((TargetIdx > 8) And (TargetIdx < 57))
    {
        If ((Board[(SourceIdx + 0)] == (GoK_OppPawn * Factor)) And (Board[(TargetIdx + 0)] == 0))
        {
            If ((Not ((abs((TargetIdx - SourceIdx)) == 16))) Or (Board[((TargetIdx + SourceIdx) / 2)] == 0))
            {
                If (((AttackedPiece < 0) And ((BoardAttackedByOpp[(TargetIdx + 0)] == 0) Or (Board[BoardAttackedByOppPiece[(TargetIdx + 0)]] < GoK_OppPawn))) Or ((AttackedPiece > 0) And ((BoardAttackedByOwn[(TargetIdx + 0)] == 0) Or (Board[BoardAttackedByOwnPiece[(TargetIdx + 0)]] > GoK_OwnPawn))))
                {
                    If (((AttackedPiece < 0) And ((BoardAttackedByOpp[(TargetIdx + 0)] == 0) Or (BoardAttackedByOwn[(TargetIdx + 0)] > 0))) Or ((AttackedPiece > 0) And ((BoardAttackedByOwn[(TargetIdx + 0)] == 0) Or (BoardAttackedByOpp[(TargetIdx + 0)] > 0))))
                    {
                        Call TaperedEval.Add((-20 * Factor))((-12 * Factor))("Eval.Threats.SafePawnPush")("")("")(((SourceIdx * 100) + TargetIdx));
                    }
                }
            }
        }
    }
}

Define GenerateMovesForSource(string Depth)(string SourceIdx)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    SourcePieceOuter2 = Board[(SourceIdx + 0)];
    File = IdxToFile[(SourceIdx + 0)];
    Rank = IdxToRank[(SourceIdx + 0)];
    Call //("Pawn moves (generated via code logic)");
    If (SourcePieceOuter2 == GoK_OwnPawn)
    {
        If (File > 1)
        {
            If (CalcAttackState Or (Board[(SourceIdx + 7)] < 0))
            {
                Call AddMoveImpl(SourceIdx)((SourceIdx + 7))(Depth)(CalcAttackState)(CapturesOnly);
            }
        }
        If (File < 8)
        {
            If (CalcAttackState Or (Board[(SourceIdx + 9)] < 0))
            {
                Call AddMoveImpl(SourceIdx)((SourceIdx + 9))(Depth)(CalcAttackState)(CapturesOnly);
            }
        }
        If (Not (CalcAttackState))
        {
            If (Board[(SourceIdx + 8)] == 0)
            {
                If CapturesOnly
                {
                    Call AddPotentialQuiescenceMove(SourceIdx)((SourceIdx + 8))(GoK_OwnPawn)(Depth);
                }
                Else
                {
                    Call AddMoveImpl(SourceIdx)((SourceIdx + 8))(Depth)(CalcAttackState)(CapturesOnly);
                }
                If ((Rank == 2) And (Board[(SourceIdx + 16)] == 0))
                {
                    If CapturesOnly
                    {
                        Call AddPotentialQuiescenceMove(SourceIdx)((SourceIdx + 16))(GoK_OwnPawn)(Depth);
                    }
                    Else
                    {
                        Call AddMoveImpl(SourceIdx)((SourceIdx + 16))(Depth)(CalcAttackState)(CapturesOnly);
                    }
                }
            }
        }
        If (Not ((EnPassantTarget[Depth] == "")))
        {
            TargetIdx = EnPassantTarget[Depth];
            If ((Not (CalcAttackState)) And (IdxToRank[SourceIdx] == IdxToRank[TargetIdx]))
            {
                If (abs((IdxToFile[SourceIdx] - IdxToFile[TargetIdx])) == 1)
                {
                    Call AddMoveImpl(SourceIdx)((TargetIdx + 8))(Depth)(CalcAttackState)(CapturesOnly);
                }
            }
        }
        Stop(this script);
    }
    If (SourcePieceOuter2 == GoK_OppPawn)
    {
        If (File > 1)
        {
            If (CalcAttackState Or (Board[(SourceIdx - 9)] > 0))
            {
                Call AddMoveImpl(SourceIdx)((SourceIdx - 9))(Depth)(CalcAttackState)(CapturesOnly);
            }
        }
        If (File < 8)
        {
            If (CalcAttackState Or (Board[(SourceIdx - 7)] > 0))
            {
                Call AddMoveImpl(SourceIdx)((SourceIdx - 7))(Depth)(CalcAttackState)(CapturesOnly);
            }
        }
        If (Not (CalcAttackState))
        {
            If (Board[(SourceIdx - 8)] == 0)
            {
                If CapturesOnly
                {
                    Call AddPotentialQuiescenceMove(SourceIdx)((SourceIdx - 8))(GoK_OppPawn)(Depth);
                }
                Else
                {
                    Call AddMoveImpl(SourceIdx)((SourceIdx - 8))(Depth)(CalcAttackState)(CapturesOnly);
                }
                If ((Rank == 7) And (Board[(SourceIdx - 16)] == 0))
                {
                    If CapturesOnly
                    {
                        Call AddPotentialQuiescenceMove(SourceIdx)((SourceIdx - 16))(GoK_OppPawn)(Depth);
                    }
                    Else
                    {
                        Call AddMoveImpl(SourceIdx)((SourceIdx - 16))(Depth)(CalcAttackState)(CapturesOnly);
                    }
                }
            }
        }
        If (Not ((EnPassantTarget[(Depth + 0)] == "")))
        {
            TargetIdx = EnPassantTarget[(Depth + 0)];
            If ((Not (CalcAttackState)) And (Rank == IdxToRank[(TargetIdx + 0)]))
            {
                If (abs((File - IdxToFile[(TargetIdx + 0)])) == 1)
                {
                    Call AddMoveImpl(SourceIdx)((TargetIdx - 8))(Depth)(CalcAttackState)(CapturesOnly);
                }
            }
        }
        Stop(this script);
    }
    Call //("Non-pawn moves (generated via lookup tables)");
    SourcePieceOuter2 = abs(SourcePieceOuter2);
    If (SourcePieceOuter2 == GoK_OwnRook)
    {
        Call AddSlidingMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 1));
        Stop(this script);
    }
    If (SourcePieceOuter2 == GoK_OwnBishop)
    {
        Call AddSlidingMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 0));
        Stop(this script);
    }
    If (SourcePieceOuter2 == GoK_OwnKnight)
    {
        Call AddLookupMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 0));
        Stop(this script);
    }
    If (SourcePieceOuter2 == GoK_OwnKing)
    {
        Call AddLookupMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 1));
        Stop(this script);
    }
    If (SourcePieceOuter2 == GoK_OwnQueen)
    {
        Call AddSlidingMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 1));
        Call AddSlidingMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 0));
        Stop(this script);
    }
}

Define GenerateMovesForSourceEx(string Depth)(string SourceIdx)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    List.DeleteAll(CalcMovesMoveList);
    List.DeleteAll(CalcMovesScoreList);
    IsPotentialNonCapQuiescMove = 0;
    If CapturesOnly
    {
        Call IsQuiescentCheckCond(Depth);
        IsPotentialNonCapQuiescMove = IsQuiescentCheckRes;
    }
    GenerateMovesRequiresAttackRecalc = 0;
    Call GenerateMovesForSource(Depth)(SourceIdx)(CalcAttackState)(CapturesOnly);
    Call SortMoveList(Depth);
}

Define GenerateMovesImpl(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool IsBlackMove) (warp=true)
{
    If (Not (CalcAttackState))
    {
        If (BoardAttackedCalculated[Depth] == 0)
        {
            If IsBlackMove
            {
                Call GenerateMovesForSource(Depth)(KingIdxtOwn)(CalcAttackState)(CapturesOnly);
                If (GenerateMovesRequiresAttackRecalc == 1)
                {
                    Stop(this script);
                }
            }
            Else
            {
                Call GenerateMovesForSource(Depth)(KingIdxOpp)(CalcAttackState)(CapturesOnly);
                If (GenerateMovesRequiresAttackRecalc == 1)
                {
                    Stop(this script);
                }
            }
            If (Not (CapturesOnly))
            {
                If IsBlackMove
                {
                    If ((Operator.LetterOf(CastlingState[Depth], 1) == 0) And (Operator.LetterOf(CastlingState[Depth], 2) == 0))
                    {
                        If (Operator.LetterOf(CastlingState[Depth], 4) == 0)
                        {
                            GenerateMovesRequiresAttackRecalc = 1;
                            Stop(this script);
                        }
                        If (Operator.LetterOf(CastlingState[Depth], 3) == 0)
                        {
                            GenerateMovesRequiresAttackRecalc = 1;
                            Stop(this script);
                        }
                    }
                }
                Else
                {
                    If ((Operator.LetterOf(CastlingState[Depth], 5) == 0) And (Operator.LetterOf(CastlingState[Depth], 6) == 0))
                    {
                        If (Operator.LetterOf(CastlingState[Depth], 8) == 0)
                        {
                            GenerateMovesRequiresAttackRecalc = 1;
                            Stop(this script);
                        }
                        If (Operator.LetterOf(CastlingState[Depth], 7) == 0)
                        {
                            GenerateMovesRequiresAttackRecalc = 1;
                            Stop(this script);
                        }
                    }
                }
            }
        }
    }
    List.DeleteAll(CalcMovesScoreList);
    List.DeleteAll(CalcMovesMoveList);
    Call PrepareCurrentKillerMoves(Depth);
    Call ClearMoveList(Depth);
    SourceIdxOuter2 = 1;
    Repeat (64)
    {
        CurrentPiece = Board[(SourceIdxOuter2 + 0)];
        If ((IsBlackMove And (CurrentPiece > 0)) Or ((Not (IsBlackMove)) And (CurrentPiece < 0)))
        {
            Call GenerateMovesForSource(Depth)(SourceIdxOuter2)(CalcAttackState)(CapturesOnly);
        }
        SourceIdxOuter2 += 1;
    }
    Call //("Castling moves");
    If ((Not (CalcAttackState)) And (Not (CapturesOnly)))
    {
        If IsBlackMove
        {
            If ((Operator.LetterOf(CastlingState[Depth], 1) == 0) And (Operator.LetterOf(CastlingState[Depth], 2) == 0))
            {
                If (Operator.LetterOf(CastlingState[Depth], 4) == 0)
                {
                    If ((((Board[VirtualBoard[1]] == GoK_OwnRook) And (Board[VirtualBoard[2]] == 0)) And ((Board[VirtualBoard[3]] == 0) And (Board[VirtualBoard[4]] == 0))) And (Board[VirtualBoard[5]] == GoK_OwnKing))
                    {
                        If ((PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[3])] == 0) And ((PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[4])] == 0) And (PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[5])] == 0)))
                        {
                            Call AddSpecialMove(GoK_OwnQueensideCastling)(Depth);
                        }
                    }
                }
                If (Operator.LetterOf(CastlingState[Depth], 3) == 0)
                {
                    If (((Board[VirtualBoard[5]] == GoK_OwnKing) And (Board[VirtualBoard[6]] == 0)) And ((Board[VirtualBoard[7]] == 0) And (Board[VirtualBoard[8]] == GoK_OwnRook)))
                    {
                        If ((PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[5])] == 0) And ((PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[6])] == 0) And (PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[7])] == 0)))
                        {
                            Call AddSpecialMove(GoK_OwnKingsideCastling)(Depth);
                        }
                    }
                }
            }
        }
        Else
        {
            If ((Operator.LetterOf(CastlingState[Depth], 5) == 0) And (Operator.LetterOf(CastlingState[Depth], 6) == 0))
            {
                If (Operator.LetterOf(CastlingState[Depth], 8) == 0)
                {
                    If (((Board[VirtualBoard[57]] == GoK_OppRook) And (Board[VirtualBoard[58]] == 0)) And ((Board[VirtualBoard[59]] == 0) And ((Board[VirtualBoard[60]] == 0) And (Board[VirtualBoard[61]] == GoK_OppKing))))
                    {
                        If ((PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[59])] == 0) And ((PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[60])] == 0) And (PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[61])] == 0)))
                        {
                            Call AddSpecialMove(GoK_OppQueensideCastling)(Depth);
                        }
                    }
                }
                If (Operator.LetterOf(CastlingState[Depth], 7) == 0)
                {
                    If (((Board[VirtualBoard[62]] == 0) And (Board[VirtualBoard[61]] == GoK_OppKing)) And ((Board[VirtualBoard[63]] == 0) And (Board[VirtualBoard[64]] == GoK_OppRook)))
                    {
                        If ((PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[61])] == 0) And ((PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[62])] == 0) And (PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + VirtualBoard[63])] == 0)))
                        {
                            Call AddSpecialMove(GoK_OppKingsideCastling)(Depth);
                        }
                    }
                }
            }
        }
    }
    Call //("Move ordering");
    If (Not (CalcAttackState))
    {
        Call SortMoveList(Depth);
    }
}

Define GenerateMovesImplWrapper(string Depth)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    If (IsBlockProfilerEnabled == 1)
    {
        Call Profile_MethodEnter(((((3 * MaxSearchDepthStackFrames) - (MaxSearchDepthStackFrames * CapturesOnly)) - ((2 * MaxSearchDepthStackFrames) * CalcAttackState)) + Depth));
    }
    IsPotentialNonCapQuiescMove = 0;
    If CapturesOnly
    {
        Call IsQuiescentCheckCond(Depth);
        IsPotentialNonCapQuiescMove = IsQuiescentCheckRes;
    }
    GenerateMovesRequiresAttackRecalc = 0;
    Call GenerateMovesImpl(Depth)(CalcAttackState)(CapturesOnly)(((Depth % 2) == 1));
    If (IsBlockProfilerEnabled == 1)
    {
        Call Profile_MethodExit(((((3 * MaxSearchDepthStackFrames) - (MaxSearchDepthStackFrames * CapturesOnly)) - ((2 * MaxSearchDepthStackFrames) * CalcAttackState)) + Depth));
    }
}

Define GenerateMovesPublic(string Depth) (warp=true)
{
    Idx = 1;
    Repeat (64)
    {
        If (Board[Idx] == GoK_OppKing)
        {
            KingIdxOpp = Idx;
        }
        Else
        {
            If (Board[Idx] == GoK_OwnKing)
            {
                KingIdxtOwn = Idx;
            }
        }
        Idx += 1;
    }
    Call CalcBoardAttackedByMove((Depth + 1));
    Call StoreAttackInfo((Depth + 1))(Depth);
    List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
    Call SetInitialEnPassantTarget(Depth);
    List.ReplaceItem(CastlingState, Depth, Operator.Join(Operator.Join(Operator.Join(HasOwnCastled, HasOwnKingMoved), Operator.Join(HasOwnRookKSMoved, HasOwnRookQSMoved)), Operator.Join(Operator.Join(HasOppCastled, HasOppKingMoved), Operator.Join(HasOppRookKSMoved, HasOppRookQSMoved))));
    Call GenerateMovesImplWrapper(Depth)((1 == 0))((1 == 0));
    List.ReplaceItem(EnPassantTarget, Depth, "");
    List.ReplaceItem(BoardAttackedCalculated, Depth, 0);
    List.ReplaceItem(CastlingState, Depth, "");
}

Define GetAttackDefenseInfo(string Idx) (warp=true)
{
    Attacked = 0;
    Defended = 0;
    AttackerIdx = 0;
    DefenderIdx = 0;
    AttackerPiece = 0;
    DefenderPieceAbs = 0;
    DefenderPiece = 0;
    DefenderPieceAbs = 0;
    If (Board[(Idx + 0)] > 0)
    {
        Attacked = BoardAttackedByOpp[(Idx + 0)];
        Defended = BoardAttackedByOwn[(Idx + 0)];
        If (Attacked > 0)
        {
            AttackerIdx = BoardAttackedByOppPiece[(Idx + 0)];
        }
        If (Defended > 0)
        {
            DefenderIdx = BoardAttackedByOwnPiece[(Idx + 0)];
        }
    }
    Else
    {
        If (Board[(Idx + 0)] < 0)
        {
            Attacked = BoardAttackedByOwn[(Idx + 0)];
            Defended = BoardAttackedByOpp[(Idx + 0)];
            If (Attacked > 0)
            {
                AttackerIdx = BoardAttackedByOwnPiece[(Idx + 0)];
            }
            If (Defended > 0)
            {
                DefenderIdx = BoardAttackedByOppPiece[(Idx + 0)];
            }
        }
    }
    If (Attacked > 0)
    {
        AttackerPiece = Board[(AttackerIdx + 0)];
        AttackerPieceAbs = abs(AttackerPiece);
    }
    If (Defended > 0)
    {
        DefenderPiece = Board[(DefenderIdx + 0)];
        DefenderPieceAbs = abs(DefenderPiece);
    }
}

Define GetAttackForce(bool Black) (warp=true)
{
    If Black
    {
        AttackForce = ((QueenCounttOwnLocal * 14) + ((RookCounttOwnLocal * 6) + ((RookMinorCounttOwnLocal - RookCounttOwnLocal) * 3)));
    }
    Else
    {
        AttackForce = ((QueenCountOppLocal * 14) + ((RookCountOppLocal * 6) + ((RookMinorCountLocalOpp - RookCountOppLocal) * 3)));
    }
}

Define GetBestMoveBlitz (warp=false)
{
    MaxSearchDepth = 20;
    ThinkTimeLimit = ((Level - 2) * 2);
    ThinkTimeStart = (Sensing.DaysSince2000() * 86400);
    IsMinMaxTimeout = 0;
    IsDeepeningDone = 0;
    IdxDeepening = 1;
    BestMove = "";
    BestMinMaxRes = "";
    ThinkTimeLimitMinMax = ThinkTimeLimit;
    Repeat ((((Level - 2) * 2) * (2 - IsScratch3)))
    {
        If ((IsMinMaxTimeout == 0) And ((IdxDeepening == 1) Or (abs(BestMinMaxRes) < AbsMinCheckmateEval)))
        {
            Call AlphaBetaMinMax(-100000)(100000)(1)((IdxDeepening + 1))((IdxDeepening == 1))((MaxSearchDepth - IdxDeepening))((1 == 1));
            If (Not ((MinMaxMoveRes == "")))
            {
                If ((BestMove == "") Or List.ContainsItem(MinMaxPly1EvalMoves, BestMove))
                {
                    BestMove = MinMaxMoveRes;
                    BestMinMaxRes = MinMaxEvalRes;
                }
            }
        }
        IdxDeepening += 1;
    }
}

Define GetBestMoveEasy (warp=false)
{
    ThinkTimeStart = (Sensing.DaysSince2000() * 86400);
    ThinkTimeLimitMinMax = 10;
    BestMove = "";
    If (Level == 1)
    {
        JuniorDistQuota = 100;
        JuniorSearchQuota = 0;
    }
    Else
    {
        If (Level == 2)
        {
            JuniorDistQuota = 40;
            JuniorSearchQuota = 20;
        }
    }
    Call AlphaBetaMinMax(-100000)(100000)(1)(2)((1 == 0))(3)((1 == 1));
    BestMove = MinMaxMoveRes;
    CurrentValue = Operator.Random(1 , 100);
    If ((CurrentValue > ((JuniorSearchQuota + 100) / 2)) Or (((BoardAttackedByOpp[floor((BestMove / 100))] == 0) And (Board[floor((BestMove % 100))] == 0)) And (CurrentValue > JuniorSearchQuota)))
    {
        Call GenerateMovesPublic(1);
        List.ReplaceItem(MovesIdx, 1, Operator.Random(1 , ceiling((List.Length(Moves1) * (JuniorDistQuota / 100)))));
        Call ApplyMove(1);
        Call CalcBoardAttackedByMove(2);
        Call RevertMove(1);
        Repeat Until (IsOwnSideChecked == 0)
        {
            List.ReplaceItem(MovesIdx, 1, Operator.Random(1 , List.Length(Moves1)));
            Call ApplyMove(1);
            Call CalcBoardAttackedByMove(2);
            Call RevertMove(1);
        }
        BestMove = Moves1[MovesIdx[1]];
    }
}

Define GetBestMoveMedDiff (warp=false)
{
    MaxSearchDepth = (MaxSearchDepthStackFrames - 5);
    IsEvalStable = 1;
    If (Level == 5)
    {
        If (IsEndgame2 == 0)
        {
            ThinkTimeLimit = 15;
        }
        Else
        {
            ThinkTimeLimit = 15;
        }
    }
    Else
    {
        If (IsEndgame == 0)
        {
            ThinkTimeLimit = 25;
        }
        Else
        {
            If (IsEndgame2 == 0)
            {
                ThinkTimeLimit = 20;
            }
            Else
            {
                ThinkTimeLimit = 15;
            }
        }
    }
    If (CustomThinkTime > 0)
    {
        ThinkTimeLimit = CustomThinkTime;
    }
    List.DeleteAll(AWSize);
    List.Add(AWSize, 30);
    ThinkTimeStart = (Sensing.DaysSince2000() * 86400);
    IsMinMaxTimeout = 0;
    IsDeepeningDone = 0;
    IdxDeepening = 1;
    BestMove = "";
    BestMinMaxRes = "";
    Repeat Until (IsDeepeningDone == 1)
    {
        If (IsScratch3 == 1)
        {
            QuiescenceDepth = 8;
        }
        Else
        {
            QuiescenceDepth = 8;
        }
        AWCount = 1;
        AWDelta = AWSize[1];
        If (Not ((BestMinMaxRes == "")))
        {
            CurrentValue = Operator.Round(abs((BestMinMaxRes / 4)));
            If (CurrentValue > 0)
            {
                CurrentValue = 0;
            }
            AWDelta = (AWDelta + CurrentValue);
        }
        If (((IdxDeepening > 6) And (1 == 1)) And ((Not ((BestMinMaxRes == ""))) And (abs(BestMinMaxRes) < AbsMinCheckmateEval)))
        {
            AWAlpha = Operator.Round((BestMinMaxRes - AWDelta));
            AWBeta = Operator.Round((BestMinMaxRes + AWDelta));
        }
        Else
        {
            AWAlpha = -100000;
            AWBeta = 100000;
        }
        IsAWDone = 0;
        Repeat Until ((IsAWDone == 1) Or (IsMinMaxTimeout == 1))
        {
            ThinkTimeLimitMinMax = ThinkTimeLimit;
            Call AlphaBetaMinMax(AWAlpha)(AWBeta)(1)((IdxDeepening + 1))((IdxDeepening == 1))(QuiescenceDepth)((1 == 1));
            If (Not ((MinMaxMoveRes == "")))
            {
                If ((BestMove == "") Or List.ContainsItem(MinMaxPly1EvalMoves, BestMove))
                {
                    BestMove = MinMaxMoveRes;
                    BestMinMaxRes = MinMaxEvalRes;
                }
                Call OnEvaluationChanged(BestMinMaxRes);
            }
            Call Log(IdxDeepening)(" : AW : ")(AWAlpha)(" : ")(AWBeta)(" : ")(MinMaxResults[1])(Operator.Join(" : ", ((Not ((MinMaxResults[1] == ""))) And ((Not ((MinMaxResults[1] > AWAlpha))) Or (Not ((MinMaxResults[1] < AWBeta)))))));
            If ((IsMinMaxTimeout == 0) And ((Not ((MinMaxResults[1] == ""))) And ((Not ((MinMaxResults[1] > AWAlpha))) Or (Not ((MinMaxResults[1] < AWBeta))))))
            {
                IsEvalStable = 0;
                IsMinMaxTimeout = 0;
                AWCount += 1;
                If ((Not ((AWCount > List.Length(AWSize)))) And (abs(MinMaxResults[1]) < AbsMinCheckmateEval))
                {
                    AWDelta = Operator.Round((AWDelta + AWSize[AWCount]));
                    CurrentValue = Operator.Round(abs((MinMaxResults[1] / 4)));
                    If (CurrentValue > 0)
                    {
                        CurrentValue = 0;
                    }
                    AWDelta = (AWDelta + CurrentValue);
                    If (Not ((MinMaxResults[1] > AWAlpha)))
                    {
                        AWAlpha += (0 - AWDelta);
                        If (Not ((MinMaxResults[1] > AWAlpha)))
                        {
                            AWAlpha = (MinMaxResults[1] - AWDelta);
                        }
                        If (1 == 0)
                        {
                            AWBeta = Operator.Round(((AWAlpha + (3 * AWBeta)) / 4));
                        }
                    }
                    Else
                    {
                        AWBeta += AWDelta;
                        If (Not ((MinMaxResults[1] < AWBeta)))
                        {
                            AWBeta = (MinMaxResults[1] + AWDelta);
                        }
                    }
                }
                Else
                {
                    AWAlpha = -100000;
                    AWBeta = 100000;
                }
            }
            Else
            {
                IsAWDone = 1;
                IsEvalStable = 1;
            }
        }
        If (((IsMinMaxTimeout == 1) Or (IdxDeepening == MaxSearchDepth)) Or (abs(BestMinMaxRes) > (AbsMaxCheckmateEval - (IdxDeepening * 1000))))
        {
            IsDeepeningDone = 1;
        }
        Else
        {
            IdxDeepening += 1;
        }
    }
}

Define GetBoardString (warp=true)
{
    GetBoardStringRes = "";
    Idx = 1;
    Repeat (64)
    {
        GetBoardStringRes = Operator.Join(GetBoardStringRes, Operator.Join(Board[Idx], ","));
        Idx += 1;
    }
}

Define GetCurrentMove(num Depth) (warp=true)
{
    CurrentMove = Moves[(((Depth - 1) * MaxMovesPerGeneration) + MovesIdx[(Depth + 0)])];
}

Define GetEndgameLocal (warp=true)
{
    IsEndgameLocal = 0;
    Call GetAttackForce((1 == 0));
    If (AttackForce < 13)
    {
        IsEndgameLocal = 1;
    }
    Call GetAttackForce((1 == 1));
    If (AttackForce < 13)
    {
        IsEndgameLocal = 1;
    }
}

Define GetKingShelterStorm(string KingIdx)(bool IsBlack)(string ShelterFactor) (warp=true)
{
    KingShelterStorm = 0;
    KingRank = IdxToRank[KingIdx];
    KingFile = IdxToFile[KingIdx];
    If ((KingFile == 1) Or (KingFile == 3))
    {
        KingFile = 2;
    }
    Else
    {
        If ((KingFile == 6) Or (KingFile == 8))
        {
            KingFile = 7;
        }
    }
    If IsBlack
    {
        File = (KingFile - 1);
        Repeat (3)
        {
            PawnForwardRankOpp = PawnAdvancePerFile[(File + 8)];
            PawnBackwardRanktOwn = PawnAdvancePerFile[(File + 16)];
            If ((PawnBackwardRanktOwn > 0) And (KingRank < PawnBackwardRanktOwn))
            {
                KingShelterStorm += Operator.Round((PawnShelter[(((File - 1) * 8) + PawnBackwardRanktOwn)] * ShelterFactor));
            }
            Else
            {
                KingShelterStorm += Operator.Round((PawnShelter[(((File - 1) * 8) + 1)] * ShelterFactor));
            }
            If ((PawnBackwardRanktOwn > 0) And (PawnBackwardRanktOwn < PawnForwardRankOpp))
            {
                If ((PawnForwardRankOpp > 0) And (KingRank < PawnForwardRankOpp))
                {
                    KingShelterStorm += PawnStorm[(((File - 1) * 8) + PawnForwardRankOpp)];
                }
                Else
                {
                    KingShelterStorm += PawnStorm[(((File - 1) * 8) + 1)];
                }
            }
            File += 1;
        }
    }
    Else
    {
        File = (KingFile - 1);
        Repeat (3)
        {
            PawnBackwardRankOpp = PawnAdvancePerFile[File];
            PawnForwardRanktOwn = PawnAdvancePerFile[(File + 24)];
            If ((PawnBackwardRankOpp > 0) And (KingRank > PawnBackwardRankOpp))
            {
                KingShelterStorm += Operator.Round((PawnShelter[((((9 - File) - 1) * 8) + (9 - PawnBackwardRankOpp))] * ShelterFactor));
            }
            Else
            {
                KingShelterStorm += Operator.Round((PawnShelter[((((9 - File) - 1) * 8) + 1)] * ShelterFactor));
            }
            If ((PawnBackwardRankOpp > 0) And (PawnBackwardRankOpp > PawnForwardRanktOwn))
            {
                If ((PawnForwardRanktOwn > 0) And (KingRank > PawnForwardRanktOwn))
                {
                    KingShelterStorm += PawnStorm[((((9 - File) - 1) * 8) + (9 - PawnForwardRanktOwn))];
                }
                Else
                {
                    KingShelterStorm += PawnStorm[((((9 - File) - 1) * 8) + 1)];
                }
            }
            File += 1;
        }
    }
}

Define GetMoveNotation(num Move) (warp=true)
{
    Call GetVirtualMove(Move);
    MoveNotationRes = "";
    If ((VirtualMove == GoK_OwnKingsideCastling) Or (VirtualMove == GoK_OppKingsideCastling))
    {
        MoveNotationRes = "O-O";
        Stop(this script);
    }
    If ((VirtualMove == GoK_OwnQueensideCastling) Or (VirtualMove == GoK_OppQueensideCastling))
    {
        MoveNotationRes = "O-O-O";
        Stop(this script);
    }
    SourceIdx = floor((VirtualMove / 100));
    TargetIdx = floor((VirtualMove % 100));
    CurrentPiece = Board[floor((Move / 100))];
    If ((CurrentPiece == GoK_OwnBishop) Or (CurrentPiece == GoK_OppBishop))
    {
        MoveNotationRes = "B";
    }
    If ((CurrentPiece == GoK_OwnKing) Or (CurrentPiece == GoK_OppKing))
    {
        MoveNotationRes = "K";
    }
    If ((CurrentPiece == GoK_OwnRook) Or (CurrentPiece == GoK_OppRook))
    {
        MoveNotationRes = "R";
    }
    If ((CurrentPiece == GoK_OwnKnight) Or (CurrentPiece == GoK_OppKnight))
    {
        MoveNotationRes = "N";
    }
    If ((CurrentPiece == GoK_OppQueen) Or (CurrentPiece == GoK_OwnQueen))
    {
        MoveNotationRes = "Q";
    }
    X = IdxToFile[SourceIdx];
    Y = (9 - IdxToRank[SourceIdx]);
    MoveNotationRes = Operator.Join(MoveNotationRes, Operator.Join(Operator.LetterOf("abcdefgh", X), Y));
    If (Not ((Board[floor((Move % 100))] == 0)))
    {
        MoveNotationRes = Operator.Join(MoveNotationRes, "x");
    }
    X = IdxToFile[TargetIdx];
    Y = (9 - IdxToRank[TargetIdx]);
    MoveNotationRes = Operator.Join(MoveNotationRes, Operator.Join(Operator.LetterOf("abcdefgh", X), Y));
    If (Operator.LetterOf(VirtualMove, (Variable.Length(VirtualMove) - 1)) == ".")
    {
        If (Operator.LetterOf(VirtualMove, Variable.Length(VirtualMove)) == 1)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "=Q");
        }
        If (Operator.LetterOf(VirtualMove, Variable.Length(VirtualMove)) == 2)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "=R");
        }
        If (Operator.LetterOf(VirtualMove, Variable.Length(VirtualMove)) == 3)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "=B");
        }
        If (Operator.LetterOf(VirtualMove, Variable.Length(VirtualMove)) == 4)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "=N");
        }
    }
}

Define GetMoveScore(string SourcePieceParam)(string TargetPieceParam)(string FromIdx)(string ToIdx)(string Move)(string Depth) (warp=true)
{
    MoveScoreRes = 0;
    GMS.Factor = (((SourcePieceParam > 0) * 2) - 1);
    Call //("1: Hash moves, handled by staged move generator / PickMove()");
    If (Depth == 1)
    {
        Call TTProbeNode(CurrentBoardHash)(Depth);
        If ((TTProbeRes == 1) And ((Not ((TTProbeBestMoveRes == ""))) And (TTProbeBestMoveRes == Move)))
        {
            MoveScoreRes = (9100000 * GMS.Factor);
            Stop(this script);
        }
    }
    If (CheckedState[(Depth + 0)] == 1)
    {
        Call //("2: Check evasions");
        If (abs(SourcePieceParam) == GoK_OwnKing)
        {
            MoveScoreRes = (9000000 * GMS.Factor);
            Stop(this script);
        }
        If (Operator.LetterOf(CheckedStateAttackLines[(Depth + 0)], ToIdx) == 1)
        {
            MoveScoreRes = (8900000 * GMS.Factor);
            Stop(this script);
        }
    }
    If (Not ((Move == floor(Move))))
    {
        Call //("Promotions");
        MoveScoreRes = ((7500005 - ((Move * 10) % 10)) * GMS.Factor);
        Stop(this script);
    }
    If (TargetPieceParam == 0)
    {
        If (1 == 0)
        {
            Call IsCheckingPieceImpl(ToIdx)(SourcePieceParam);
            If (IsCheckingPieceRes == 1)
            {
                Call ClearMoveList((Depth + 2));
                Call AddMoveToList(Move)((Depth + 2));
                List.ReplaceItem(MovesIdx, (Depth + 2), 1);
                Call ApplyMoveLight((Depth + 2));
                Call SEE((Depth + 2));
                Call RevertMoveLight((Depth + 2));
                If ((((Depth % 2) == 1) And (Not ((SEE.Result < 0)))) Or (((Depth % 2) == 0) And (Not ((SEE.Result > 0)))))
                {
                    MoveScoreRes = ((3000000 + MvvLvaScore) * GMS.Factor);
                    Stop(this script);
                }
            }
        }
    }
    If (Not ((TargetPieceParam == 0)))
    {
        MvvLvaScore = ((PieceIdxLookup[abs(TargetPieceParam)] * 100) + (7 - PieceIdxLookup[abs(SourcePieceParam)]));
        If (Quiescence[(Depth + 0)] == 1)
        {
            MoveScoreRes = ((7000000 + MvvLvaScore) * GMS.Factor);
            Stop(this script);
        }
        Else
        {
            Call ClearMoveList((Depth + 2));
            Call AddMoveToList(Move)((Depth + 2));
            List.ReplaceItem(MovesIdx, (Depth + 2), 1);
            Call ApplyMoveLight((Depth + 2));
            Call SEE((Depth + 2));
            Call RevertMoveLight((Depth + 2));
            If ((((Depth % 2) == 1) And (Not ((SEE.Result < 0)))) Or (((Depth % 2) == 0) And (Not ((SEE.Result > 0)))))
            {
                MoveScoreRes = ((7500000 + MvvLvaScore) * GMS.Factor);
                Stop(this script);
            }
            Else
            {
                MoveScoreRes = ((0 + MvvLvaScore) * GMS.Factor);
                Stop(this script);
            }
        }
    }
    Call //("4: Killer moves");
    Call PrepareCurrentKillerMoves(Depth);
    If (CurrentKillerMoves[1] == Move)
    {
        MoveScoreRes = (6000000 * GMS.Factor);
        Stop(this script);
    }
    Else
    {
        If (CurrentKillerMoves[2] == Move)
        {
            MoveScoreRes = (5000000 * GMS.Factor);
            Stop(this script);
        }
    }
    Call //("5. Counter Moves");
    If (Depth > 1)
    {
        If (HistoryCounterMoves[(((Depth % 2) * 1000) + ((PieceIdxLookup[abs(SourcePieces[(Depth - 1)])] * 100) + floor((AppliedMove[(Depth - 1)] % 100))))] == Move)
        {
            MoveScoreRes = (4000000 * GMS.Factor);
            Stop(this script);
        }
    }
    Call //("6: Quiets with high history score");
    IdxSub = ((PieceIdxLookup[abs(SourcePieceParam)] * 100) + ToIdx);
    MoveScoreRes = ((10000 + HistoryMoveScores[(((Depth % 2) * 1000) + IdxSub)]) * GMS.Factor);
    IdxSub = ((PieceIdxLookup[abs(SourcePieceParam)] * 64) + ToIdx);
    Idx = -1;
    If (Depth > 1)
    {
        Idx = ((((PieceIdxLookup[abs(SourcePieces[(Depth - 1)])] * 64) + floor((AppliedMove[(Depth - 1)] % 100))) * 384) + IdxSub);
    }
    Else
    {
        If (Not ((PrevPly1Move == "")))
        {
            Idx = ((((PieceIdxLookup[abs(Board[floor((PrevPly1Move % 100))])] * 64) + floor((PrevPly1Move % 100))) * 384) + IdxSub);
        }
    }
    If (Not ((Idx == -1)))
    {
        If ((Depth % 2) == 1)
        {
            MoveScoreRes += ((HistoryContinuationOwn[Idx] * 1) * GMS.Factor);
        }
        Else
        {
            MoveScoreRes += ((HistoryContinuationOpp[Idx] * 1) * GMS.Factor);
        }
    }
    If (Depth > 2)
    {
        Idx = ((((PieceIdxLookup[abs(SourcePieces[(Depth - 2)])] * 64) + floor((AppliedMove[(Depth - 2)] % 100))) * 384) + IdxSub);
        If ((Depth % 2) == 1)
        {
            MoveScoreRes += ((HistoryContinuation2Own[Idx] * 1) * GMS.Factor);
        }
        Else
        {
            MoveScoreRes += ((HistoryContinuation2Opp[Idx] * 1) * GMS.Factor);
        }
    }
    If (1 == 1)
    {
        If (BoardAttackedCalculated[(Depth + 0)] == 1)
        {
            If (PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + FromIdx)] > 0)
            {
                CurrentValue = abs(SourcePieceParam);
                Idx = PersistedBoardAttackedByOppPieceSnapshot[(((Depth - 1) * 100) + ToIdx)];
                If (Idx == 0)
                {
                    CurrentValue2 = 0;
                }
                Else
                {
                    CurrentValue2 = abs(Board[Idx]);
                }
                If ((CurrentValue2 == 0) Or (((CurrentValue == GoK_OwnQueen) And (Not ((CurrentValue2 < GoK_OwnQueen)))) Or (((CurrentValue == GoK_OwnRook) And (Not ((CurrentValue2 < GoK_OwnRook)))) Or (((CurrentValue == GoK_OwnBishop) Or (CurrentValue == GoK_OwnKnight)) And (Not ((CurrentValue2 < GoK_OwnKnight)))))))
                {
                    MoveScoreRes += ((1000 * PieceIdxLookup[CurrentValue]) * GMS.Factor);
                    Stop(this script);
                }
            }
        }
    }
}

Define GetNormalizedMove(string Move) (warp=true)
{
    If (Move == floor(Move))
    {
        NormalizedMoveRes = MoveToZeroPadStr[(Move + 1)];
    }
    Else
    {
        NormalizedMoveRes = Operator.Join(MoveToZeroPadStr[(floor(Move) + 1)], Operator.Join(".", Operator.LetterOf(Move, Variable.Length(Move))));
    }
}

Define GetOpeningMoves (warp=true)
{
    List.DeleteItem(OpeningMovesRes, all);
    If (1 == 0)
    {
        If (List.Length(BoardHistoryHash) > 13)
        {
            If (Operator.Random(1 , 4) == 4)
            {
                Stop(this script);
            }
        }
    }
    Call GenerateMovesPublic(1);
    Call CreateCurrentBoardHash;
    IdxOuter = 1;
    Repeat (List.Length(OpeningMovesMapHash))
    {
        If (OpeningMovesMapHash[IdxOuter] == CurrentBoardHash)
        {
            If List.ContainsItem(Moves1, OpeningMovesMapMove[IdxOuter])
            {
                List.Add(OpeningMovesRes, OpeningMovesMapMove[IdxOuter]);
            }
        }
        IdxOuter += 1;
    }
}

Define GetPiecePosHash(string Piece)(string Pos) (warp=true)
{
    PiecePosHash = 0;
    If ((Not ((Pos > 0))) Or (Piece == 0))
    {
        Stop(this script);
    }
    If (Piece > 0)
    {
        PiecePosHash = PosPieceHashLookup[((64 * (PieceIdxLookup[Piece] - 1)) + Pos)];
    }
    Else
    {
        PiecePosHash = PosPieceHashLookup[(384 + ((64 * (PieceIdxLookup[abs(Piece)] - 1)) + Pos))];
    }
}

Define GetPiecePosScoreRaw(string Piece)(string Idx) (warp=true)
{
    PiecePosScoreRes.Mg = 0;
    PiecePosScoreRes.Eg = 0;
    If ((Idx == 0) Or (Piece == 0))
    {
        Stop(this script);
    }
    If (Piece > 0)
    {
        If (Piece == GoK_OwnPawn)
        {
            PiecePosScoreRes.Mg = PawnPieceSquare[Idx];
            PiecePosScoreRes.Eg = PawnPieceSquareEndgame[Idx];
            Stop(this script);
        }
        If (Piece == GoK_OwnKnight)
        {
            PiecePosScoreRes.Mg = KnightPieceSquare[Idx];
            PiecePosScoreRes.Eg = KnightPieceSquareEndgame[Idx];
            Stop(this script);
        }
        If (Piece == GoK_OwnBishop)
        {
            PiecePosScoreRes.Mg = BishopPieceSquare[Idx];
            PiecePosScoreRes.Eg = BishopPieceSquareEndgame[Idx];
            Stop(this script);
        }
        If (Piece == GoK_OwnRook)
        {
            PiecePosScoreRes.Mg = RookPieceSquare[Idx];
            PiecePosScoreRes.Eg = RookPieceSquareEndgame[Idx];
            Stop(this script);
        }
        If (Piece == GoK_OwnQueen)
        {
            PiecePosScoreRes.Mg = QueenPieceSquare[Idx];
            PiecePosScoreRes.Eg = QueenPieceSquareEndgame[Idx];
            Stop(this script);
        }
        If (Piece == GoK_OwnKing)
        {
            PiecePosScoreRes.Mg = KingPieceSquare[Idx];
            PiecePosScoreRes.Eg = KingPieceSquareEndgame[Idx];
            Stop(this script);
        }
    }
    Else
    {
        If (Piece == GoK_OppPawn)
        {
            PiecePosScoreRes.Mg = (0 - PawnPieceSquare[(65 - Idx)]);
            PiecePosScoreRes.Eg = (0 - PawnPieceSquareEndgame[(65 - Idx)]);
            Stop(this script);
        }
        If (Piece == GoK_OppKnight)
        {
            PiecePosScoreRes.Mg = (0 - KnightPieceSquare[(65 - Idx)]);
            PiecePosScoreRes.Eg = (0 - KnightPieceSquareEndgame[(65 - Idx)]);
            Stop(this script);
        }
        If (Piece == GoK_OppBishop)
        {
            PiecePosScoreRes.Mg = (0 - BishopPieceSquare[(65 - Idx)]);
            PiecePosScoreRes.Eg = (0 - BishopPieceSquareEndgame[(65 - Idx)]);
            Stop(this script);
        }
        If (Piece == GoK_OppRook)
        {
            PiecePosScoreRes.Mg = (0 - RookPieceSquare[(65 - Idx)]);
            PiecePosScoreRes.Eg = (0 - RookPieceSquareEndgame[(65 - Idx)]);
            Stop(this script);
        }
        If (Piece == GoK_OppQueen)
        {
            PiecePosScoreRes.Mg = (0 - QueenPieceSquare[(65 - Idx)]);
            PiecePosScoreRes.Eg = (0 - QueenPieceSquareEndgame[(65 - Idx)]);
            Stop(this script);
        }
        If (Piece == GoK_OppKing)
        {
            PiecePosScoreRes.Mg = (0 - KingPieceSquare[(65 - Idx)]);
            PiecePosScoreRes.Eg = (0 - KingPieceSquareEndgame[(65 - Idx)]);
            Stop(this script);
        }
    }
}

Define GetRepetitionCount (warp=true)
{
    RepetitionCountRes = 1;
    Idx = (List.Length(BoardHistory) - 2);
    Repeat Until (Idx < 1)
    {
        If (BoardHistory[Idx] == BoardHistory[List.Length(BoardHistory)])
        {
            RepetitionCountRes += 1;
        }
        Idx += -2;
    }
}

Define GetSliderBlockerCount(string FromIdx)(string ToIdx) (warp=true)
{
    SliderBlockerCountRes = 0;
    Piece = Board[(FromIdx + 0)];
    If ((abs(Piece) < GoK_OwnBishop) Or (abs(Piece) > GoK_OwnQueen))
    {
        SliderBlockerCountRes = 99;
        Stop(this script);
    }
    CurrentMove = ((FromIdx * 100) + ToIdx);
    IdxIsReachable = ((PieceIdxLookup[abs(Piece)] * 10000) + CurrentMove);
    If (((Piece > 0) And (MovePosLookupOwnLegal[IdxIsReachable] == 0)) Or ((Piece < 0) And (MovePosLookupOppLegal[IdxIsReachable] == 0)))
    {
        SliderBlockerCountRes = 99;
        Stop(this script);
    }
    GSBC.SourceIdx = FromIdx;
    IdxInc = MovePathStepInc[(CurrentMove + 0)];
    Repeat ((MovePathDelta[(CurrentMove + 0)] - 1))
    {
        GSBC.SourceIdx += IdxInc;
        If (Not ((Board[(GSBC.SourceIdx + 0)] == 0)))
        {
            SliderBlockerCountRes += 1;
        }
    }
}

Define GetSubstring(string Text)(num FromIdx)(num ToIdx) (warp=true)
{
    SubstringRes = "";
    IdxString = FromIdx;
    Repeat (((ToIdx - FromIdx) + 1))
    {
        SubstringRes = Operator.Join(SubstringRes, Operator.LetterOf(Text, IdxString));
        IdxString += 1;
    }
}

Define GetSubstringLeft(string Text)(num Count) (warp=true)
{
    Call GetSubstring(Text)(1)(Count);
}

Define GetSubstringRight(string Text)(num Count) (warp=true)
{
    Call GetSubstring(Text)(((Variable.Length(Text) - Count) + 1))(Variable.Length(Text));
}

Define GetTargetIdx(num SourceIdx)(num DeltaX)(num DeltaY) (warp=true)
{
    GetTargetIdxRes = -1;
    X = (IdxToFile[SourceIdx] + DeltaX);
    If ((X > 0) And (X < 9))
    {
        Y = (IdxToRank[SourceIdx] + DeltaY);
        If ((Y > 0) And (Y < 9))
        {
            GetTargetIdxRes = (X + ((Y - 1) * 8));
        }
    }
}

Define GetTTNodeHash(string BoardHash)(string Depth) (warp=true)
{
    TTNodeHashResult = ((Depth % 2) + 1);
    TTNodeHashResult = ((TTNodeHashResult * 97) + (CastlingState[Depth] + 1));
    TTNodeHashResult = ((TTNodeHashResult * 97) + (EnPassantTarget[Depth] + 1));
    TTNodeHashResult = ((TTNodeHashResult * 97) + BoardHash);
}

Define GetVirtualMove(num Move) (warp=true)
{
    If (IsPlayerBlack == 0)
    {
        VirtualMove = Move;
    }
    Else
    {
        If (Not ((floor((Move / 100)) == 0)))
        {
            VirtualMove = (((65 - floor((Move / 100))) * 100) + (65 - floor((Move % 100))));
            If (Operator.LetterOf(Move, (Variable.Length(Move) - 1)) == ".")
            {
                VirtualMove = (VirtualMove + (0.1 * Operator.LetterOf(Move, Variable.Length(Move))));
            }
        }
        Else
        {
            If (Move == GoK_OwnKingsideCastling)
            {
                VirtualMove = GoK_OppKingsideCastling;
            }
            Else
            {
                If (Move == GoK_OwnQueensideCastling)
                {
                    VirtualMove = GoK_OppQueensideCastling;
                }
                Else
                {
                    If (Move == GoK_OppKingsideCastling)
                    {
                        VirtualMove = GoK_OwnKingsideCastling;
                    }
                    Else
                    {
                        If (Move == GoK_OppQueensideCastling)
                        {
                            VirtualMove = GoK_OwnQueensideCastling;
                        }
                    }
                }
            }
        }
    }
}

Define ImportBoard(string ImpBoard) (warp=false)
{
    Call EnterExecution;
    Call ExportBoardFEN((IsPlayerBlack == 1))((1 == 1));
    Call ImportBoardFEN(ImpBoard);
    Call CalcBoardStats;
    If ((KingIdxtOwn == "") Or (KingIdxOpp == ""))
    {
        Call SayAsync("Invalid FEN data")(5);
        Call ImportBoardFEN(ExportDataFEN);
        Call CalcBoardStats;
    }
    Else
    {
        Stg_FromSquareIdx = -1;
        Stg_ToSquareIdx = -1;
        Event.BroadcastAndWait("fromsquareselected");
        Event.BroadcastAndWait("tosquareselected");
        IsImportedBoard = 1;
        HasOppKingMoved = 0;
        HasOwnKingMoved = 0;
        HasOppCastled = 0;
        HasOwnCastled = 0;
        HasOppRookKSMoved = 0;
        HasOppRookQSMoved = 0;
        HasOwnRookKSMoved = 0;
        HasOwnRookQSMoved = 0;
        GameMoves = "";
        List.DeleteItem(BoardHistory, all);
        List.DeleteItem(BoardHistoryHash, all);
        List.DeleteItem(BoardHistoryFiftyMoves, all);
        List.DeleteItem(BoardHistoryMetaState, all);
        List.DeleteItem(BoardHistoryWasEngineMove, all);
        List.DeleteItem(GameMovesAN, all);
        If (Not ((Board[VirtualBoard[1]] == GoK_OwnRook)))
        {
            HasOwnRookQSMoved = 1;
        }
        If (Not ((Board[VirtualBoard[5]] == GoK_OwnKing)))
        {
            HasOwnKingMoved = 1;
            HasOwnCastled = 1;
        }
        If (Not ((Board[VirtualBoard[8]] == GoK_OwnRook)))
        {
            HasOwnRookKSMoved = 1;
        }
        If (Not ((Board[VirtualBoard[57]] == GoK_OppRook)))
        {
            HasOppRookQSMoved = 1;
        }
        If (Not ((Board[VirtualBoard[61]] == GoK_OppKing)))
        {
            HasOppKingMoved = 1;
            HasOppCastled = 1;
        }
        If (Not ((Board[VirtualBoard[64]] == GoK_OppRook)))
        {
            HasOppRookKSMoved = 1;
        }
        Call InitHistoryScores;
        Call AddBoardToHistory("");
        Call AddToFiftyMoves((1 == 0));
        Call DrawBoardAndWait;
        GoK_IsGameSuspended = 0;
        Call CalcBoardAttackedByMoveChecked(1);
        Call CalcBoardAttackedByMoveChecked(2);
        IdxString += 1;
        CurrentValue = Operator.LetterOf(ImpBoard, IdxString);
        If (((CurrentValue == "B") And (IsPlayerBlack == 0)) Or ((CurrentValue == "W") And (IsPlayerBlack == 1)))
        {
            If (IsOppSideChecked == 1)
            {
                Call SayAsync("Checkmate!")(5);
                GoK_IsGameSuspended = 1;
            }
            Else
            {
                Call IsDrawByStalemate(1);
                If (IsDrawRes == 1)
                {
                    Call SayAsync("Draw!")(5);
                    GoK_IsGameSuspended = 1;
                }
                Else
                {
                    Call ExecuteEngineMove;
                }
            }
        }
        Else
        {
            If (((CurrentValue == "W") And (IsPlayerBlack == 0)) Or ((CurrentValue == "B") And (IsPlayerBlack == 1)))
            {
                If (IsOwnSideChecked == 1)
                {
                    Call SayAsync("Checkmate!")(5);
                    GoK_IsGameSuspended = 1;
                }
                Else
                {
                    Call IsDrawByStalemate(2);
                    If (IsDrawRes == 1)
                    {
                        Call SayAsync("Draw!")(5);
                        GoK_IsGameSuspended = 1;
                    }
                }
            }
        }
    }
    Call ExitExecution;
}

Define ImportBoardFEN(string ImpBoard) (warp=false)
{
    Idx = 1;
    Repeat (64)
    {
        List.ReplaceItem(Board, Idx, 0);
        Idx += 1;
    }
    If (IsPlayerBlack == 0)
    {
        Idx = 1;
        IdxInc = 1;
    }
    Else
    {
        Idx = 64;
        IdxInc = -1;
    }
    IdxString = 1;
    Repeat Until (((Idx > 64) Or (Idx < 1)) Or (IdxString > Variable.Length(ImpBoard)))
    {
        CurrentValue = Operator.LetterOf(ImpBoard, IdxString);
        If ((Not ((CurrentValue < "A"))) And (Not ((CurrentValue > "Z"))))
        {
            CurrentPiece = 0;
            If (CurrentValue == "P")
            {
                CurrentPiece = GoK_OwnPawn;
            }
            If (CurrentValue == "N")
            {
                CurrentPiece = GoK_OwnKnight;
            }
            If (CurrentValue == "B")
            {
                CurrentPiece = GoK_OwnBishop;
            }
            If (CurrentValue == "R")
            {
                CurrentPiece = GoK_OwnRook;
            }
            If (CurrentValue == "Q")
            {
                CurrentPiece = GoK_OwnQueen;
            }
            If (CurrentValue == "K")
            {
                CurrentPiece = GoK_OwnKing;
            }
            Call IsLowerCase(CurrentValue);
            If (IsLowerCaseRes == 0)
            {
                CurrentPiece = (CurrentPiece * -1);
            }
            If (IsPlayerBlack == 1)
            {
                CurrentPiece = (CurrentPiece * -1);
            }
            List.ReplaceItem(Board, Idx, CurrentPiece);
            Idx += IdxInc;
        }
        Else
        {
            If ((Not ((CurrentValue < 0))) And (Not ((CurrentValue > 9))))
            {
                Repeat (CurrentValue)
                {
                    List.ReplaceItem(Board, Idx, 0);
                    Idx += IdxInc;
                }
            }
            Else
            {
                If (CurrentValue == "/")
                {
                    Repeat Until ((((Idx % 8) == 1) And (IsPlayerBlack == 0)) Or (((Idx % 8) == 0) And (IsPlayerBlack == 1)))
                    {
                        List.ReplaceItem(Board, Idx, 0);
                        Idx += IdxInc;
                    }
                }
            }
        }
        IdxString += 1;
    }
}

Define ImportBoardImpl(string ImpBoard) (warp=true)
{
    Idx = 1;
    IdxString = 1;
    CurrentPiece = "";
    Repeat Until (IdxString > Variable.Length(ImpBoard))
    {
        If (Operator.LetterOf(ImpBoard, IdxString) == ",")
        {
            List.ReplaceItem(Board, Idx, CurrentPiece);
            Idx += 1;
            CurrentPiece = "";
        }
        Else
        {
            CurrentPiece = Operator.Join(CurrentPiece, Operator.LetterOf(ImpBoard, IdxString));
        }
        IdxString += 1;
    }
}

Define InitAlphaBeta(string MaxDepth)(bool InitialDeepening) (warp=true)
{
    IsInNullMove = 0;
    IsMinMaxTimeout = 0;
    If InitialDeepening
    {
        PV = "";
        List.DeleteAll(PVStable);
        List.DeleteAll(PVStablePrev);
        Call Profile_Reset;
        PrevProgressUpdate = (Sensing.DaysSince2000() * 86400);
        TTCurrentAge = ((floor((TTCurrentAge / 100)) + 1) * 100);
        If ((IsScratch3 == 0) And (Level > 3))
        {
            IdxOuter = 1;
            Repeat (List.Length(TTNodeHash))
            {
                If (Not ((TTNodeHash[(IdxOuter + 0)] == 0)))
                {
                    If (((floor((TTNodeAge[(IdxOuter + 0)] / 100)) * 2) + TTNodeDepth[(IdxOuter + 0)]) < ((floor((TTCurrentAge / 100)) * 2) + 1))
                    {
                        List.ReplaceItem(TTNodeHash, (IdxOuter + 0), 0);
                    }
                }
                IdxOuter += 1;
            }
            If (1 == 0)
            {
                IdxOuter = 1;
                Repeat (List.Length(TTNodeHash))
                {
                    List.ReplaceItem(TTNodeHash, IdxOuter, 0);
                    List.ReplaceItem(TTNodeAge, IdxOuter, 0);
                    IdxOuter += 1;
                }
            }
        }
        IdxOuter = 1;
        Repeat (List.Length(HistoryCounterMoves))
        {
            List.ReplaceItem(HistoryCounterMoves, (IdxOuter + 0), 0);
            IdxOuter += 1;
        }
        IdxOuter = 1;
        Repeat (List.Length(HistoryMoveScores))
        {
            List.ReplaceItem(HistoryMoveScores, (IdxOuter + 0), 0);
            IdxOuter += 1;
        }
        IdxOuter = 1;
        Repeat (List.Length(MaxHistoryMoveScore))
        {
            List.ReplaceItem(MaxHistoryMoveScore, (IdxOuter + 0), 0);
            IdxOuter += 1;
        }
        IdxOuter = 1;
        Repeat (List.Length(HistoryContinuationOwn))
        {
            List.ReplaceItem(HistoryContinuationOwn, (IdxOuter + 0), 0);
            List.ReplaceItem(HistoryContinuationOpp, (IdxOuter + 0), 0);
            List.ReplaceItem(HistoryContinuation2Own, (IdxOuter + 0), 0);
            List.ReplaceItem(HistoryContinuation2Opp, (IdxOuter + 0), 0);
            IdxOuter += 1;
        }
    }
    Call SetInitialEnPassantTarget(1);
    List.DeleteItem(MinMaxPly1EvalMoves, all);
    TTCurrentAge += 1;
    Call CalcBoardStats;
    CalcAttackStateWithMobility = 0;
    Call CreateCurrentBoardHash;
    Call Log(MaxDepth)(" : ")("Search start, depth = ")(MaxDepth)("")("")("")("");
}

Define InitBoard (warp=true)
{
    PV = "";
    Stg_FromSquareIdx = -1;
    Stg_ToSquareIdx = -1;
    ProfilerMode = 0;
    DebugMode = 0;
    TimeControl = 0;
    PlayingMode = 0;
    MoveFromIdx = -1;
    MoveToIdx = -1;
    GoK_ProgressValue = 0;
    GoK_EvaluationValue = 0;
    IsAdvisorEnabled = 1;
    IsInUndo = 0;
    IsBlockProfilerEnabled = 0;
    IsEndgame = 0;
    IsEndgame2 = 0;
    IsImportedBoard = 0;
    GoK_OwnKingsideCastling = 90;
    GoK_OppKingsideCastling = 92;
    GoK_OwnQueensideCastling = 91;
    GoK_OppQueensideCastling = 93;
    HasOwnCastled = 0;
    HasOppKingMoved = 0;
    HasOppCastled = 0;
    HasOwnKingMoved = 0;
    HasOppRookKSMoved = 0;
    HasOppRookQSMoved = 0;
    HasOwnRookKSMoved = 0;
    HasOwnRookQSMoved = 0;
    GameMoves = "";
    GoK_IsGameSuspended = 0;
    PrevProgressUpdate = 0;
    GoK_Empty = 0;
    GoK_OppKing = -50000;
    GoK_OppQueen = -1185;
    GoK_OppRook = -605;
    GoK_OppBishop = -390;
    GoK_OppKnight = -365;
    GoK_OppPawn = -80;
    GoK_OwnKing = 50000;
    GoK_OwnQueen = 1185;
    GoK_OwnRook = 605;
    GoK_OwnBishop = 390;
    GoK_OwnKnight = 365;
    GoK_OwnPawn = 80;
    AbsMinCheckmateEval = (GoK_OwnKing - 10000);
    AbsMaxCheckmateEval = 97000;
    DrawByRepetitionEval = -19.9;
    MaxPly1DeepeningMoveOrderScore = 9999999;
    MaxMoveOrderScore = 9999999;
    MaxSearchDepthStackFrames = 40;
    MaxMovesPerGeneration = 300;
    Call InitCoordLookup;
    Call FillBoard;
    List.DeleteAll(PieceIdxLookup);
    Idx = 1;
    Repeat (GoK_OwnKing)
    {
        List.Add(PieceIdxLookup, "");
        Idx += 1;
    }
    List.ReplaceItem(PieceIdxLookup, GoK_OwnPawn, 1);
    List.ReplaceItem(PieceIdxLookup, GoK_OwnKnight, 2);
    List.ReplaceItem(PieceIdxLookup, GoK_OwnBishop, 3);
    List.ReplaceItem(PieceIdxLookup, GoK_OwnRook, 4);
    List.ReplaceItem(PieceIdxLookup, GoK_OwnQueen, 5);
    List.ReplaceItem(PieceIdxLookup, GoK_OwnKing, 6);
    CharsUpperCase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    List.DeleteItem(CharsUpperCaseList, all);
    Idx = 1;
    Repeat (List.Length(CharsUpperCaseList))
    {
        List.Add(CharsUpperCaseList, Operator.LetterOf(CharsUpperCase, Idx));
        Idx += 1;
    }
    List.DeleteItem(KillerMoves, all);
    Repeat ((2 * MaxSearchDepthStackFrames))
    {
        List.Add(KillerMoves, "");
    }
    List.DeleteItem(HistoryMoveScores, all);
    Repeat (2000)
    {
        List.Add(HistoryMoveScores, 0);
    }
    List.DeleteItem(MaxHistoryMoveScore, all);
    Repeat (2)
    {
        List.Add(MaxHistoryMoveScore, 0);
    }
    List.DeleteItem(HistoryCounterMoves, all);
    Repeat (10000)
    {
        List.Add(HistoryCounterMoves, "");
    }
    List.DeleteItem(HistoryContinuationOwn, all);
    List.DeleteItem(HistoryContinuationOpp, all);
    List.DeleteItem(HistoryContinuation2Own, all);
    List.DeleteItem(HistoryContinuation2Opp, all);
    Repeat (200000)
    {
        List.Add(HistoryContinuationOwn, 0);
        List.Add(HistoryContinuationOpp, 0);
        List.Add(HistoryContinuation2Own, 0);
        List.Add(HistoryContinuation2Opp, 0);
    }
    List.DeleteItem(BoardHistory, all);
    List.DeleteItem(BoardHistoryHash, all);
    List.DeleteItem(BoardHistoryFiftyMoves, all);
    List.DeleteItem(BoardHistoryMetaState, all);
    List.DeleteItem(BoardHistoryWasEngineMove, all);
    List.DeleteItem(GameMovesAN, all);
    List.DeleteItem(BoardAttackedByOpp, all);
    List.DeleteItem(BoardAttackedByOwn, all);
    List.DeleteItem(PieceMobility, all);
    List.DeleteItem(BoardAttackedByOppPiece, all);
    List.DeleteItem(BoardAttackedByOwnPiece, all);
    Repeat (64)
    {
        List.Add(BoardAttackedByOpp, 0);
        List.Add(BoardAttackedByOwn, 0);
        List.Add(PieceMobility, 0);
        List.Add(BoardAttackedByOppPiece, 0);
        List.Add(BoardAttackedByOwnPiece, 0);
    }
    Call //("Due to the lack of local variables in Scratch, we emulate a method stack for recursive Minimax using lists");
    List.DeleteItem(Alphas, all);
    List.DeleteItem(Betas, all);
    List.DeleteItem(AlphasOld, all);
    List.DeleteItem(BetasOld, all);
    List.DeleteItem(MinMaxResults, all);
    List.DeleteItem(MinMaxResultsIsDynamic, all);
    List.DeleteItem(MovesCount, all);
    List.DeleteItem(MovesIdx, all);
    List.DeleteItem(MovesIdxBestMove, all);
    List.DeleteItem(TargetPieces, all);
    List.DeleteItem(PreviousBoardHash, all);
    List.DeleteItem(PreviousBoardHash2, all);
    List.DeleteItem(ScoreTypes, all);
    List.DeleteItem(PickMoveRes, all);
    List.DeleteItem(PickPhase, all);
    List.DeleteItem(PickedMoves, all);
    List.DeleteItem(PickedMoveCount, all);
    List.DeleteItem(PickedMoveCountQuiet, all);
    List.DeleteItem(BestMoves, all);
    List.DeleteItem(CheckedState, all);
    List.DeleteItem(CheckedStateAttackLines, all);
    List.DeleteItem(PromotionPieces, all);
    List.DeleteItem(TargetPiecesIdx, all);
    List.DeleteItem(PosScoreDelta, all);
    List.DeleteItem(BoardAttackedCalculated, all);
    List.DeleteItem(PutsInCheck, all);
    List.DeleteItem(EvalExtended1, all);
    List.DeleteItem(PlyExtension, all);
    List.DeleteItem(SourcePieces, all);
    List.DeleteItem(EvalExtended2, all);
    List.DeleteItem(EvalExtended3, all);
    List.DeleteItem(MobBonusOwn, all);
    List.DeleteItem(MobBonusOpp, all);
    List.DeleteItem(AppliedMove, all);
    List.DeleteItem(CapturesDeltaSum, all);
    List.DeleteItem(PosScoreDeltaSum, all);
    List.DeleteItem(PlyExtensionTagged, all);
    List.DeleteItem(BoardAttackedByOwnPieceSnapshot, all);
    List.DeleteItem(BoardAttackedByOwnSnapshot, all);
    List.DeleteItem(BoardAttackedByOppPieceSnapshot, all);
    List.DeleteItem(BoardAttackedByOppSnapshot, all);
    List.DeleteItem(Quiescence, all);
    List.DeleteItem(EnPassantTarget, all);
    List.DeleteItem(PassedOppPawnOnEndgame, all);
    List.DeleteItem(CastlingState, all);
    List.DeleteItem(PawnShelterCapture, all);
    List.DeleteItem(BoardEval, all);
    List.DeleteItem(HashMoveMetaData, all);
    List.DeleteItem(HashMove, all);
    Repeat (MaxSearchDepthStackFrames)
    {
        List.Add(Alphas, "");
        List.Add(Betas, "");
        List.Add(AlphasOld, "");
        List.Add(BetasOld, "");
        List.Add(MinMaxResults, "");
        List.Add(MinMaxResultsIsDynamic, "");
        List.Add(MovesCount, 0);
        List.Add(MovesIdx, "");
        List.Add(MovesIdxBestMove, "");
        List.Add(TargetPieces, "");
        List.Add(PreviousBoardHash, 0);
        List.Add(PreviousBoardHash2, 0);
        List.Add(ScoreTypes, "");
        List.Add(PickMoveRes, "");
        List.Add(PickPhase, "");
        List.Add(PickedMoves, "");
        List.Add(PickedMoveCount, 0);
        List.Add(PickedMoveCountQuiet, 0);
        List.Add(BestMoves, "");
        List.Add(CheckedState, "");
        List.Add(CheckedStateAttackLines, "");
        List.Add(PromotionPieces, "");
        List.Add(TargetPiecesIdx, "");
        List.Add(PosScoreDelta, "");
        List.Add(BoardAttackedCalculated, "");
        List.Add(PutsInCheck, "");
        List.Add(EvalExtended1, "");
        List.Add(PlyExtension, "");
        List.Add(SourcePieces, 0);
        List.Add(EvalExtended2, "");
        List.Add(EvalExtended3, "");
        List.Add(MobBonusOwn, "");
        List.Add(MobBonusOpp, "");
        List.Add(AppliedMove, "");
        List.Add(CapturesDeltaSum, "");
        List.Add(PosScoreDeltaSum, "");
        List.Add(PlyExtensionTagged, "");
        List.Add(BoardAttackedByOwnPieceSnapshot, "");
        List.Add(BoardAttackedByOwnSnapshot, "");
        List.Add(BoardAttackedByOppPieceSnapshot, "");
        List.Add(BoardAttackedByOppSnapshot, "");
        List.Add(Quiescence, "");
        List.Add(EnPassantTarget, "");
        List.Add(PassedOppPawnOnEndgame, 0);
        List.Add(CastlingState, 0);
        List.Add(PawnShelterCapture, 0);
        List.Add(BoardEval, "");
        List.Add(HashMoveMetaData, "");
        List.Add(HashMove, "");
    }
    List.DeleteItem(PersistedBoardAttackedByOppSnapshot, all);
    List.DeleteItem(PersistedBoardAttackedByOppSnapshot, all);
    Repeat ((100 * MaxSearchDepthStackFrames))
    {
        List.Add(PersistedBoardAttackedByOppSnapshot, "");
        List.Add(PersistedBoardAttackedByOppPieceSnapshot, "");
    }
    List.DeleteItem(PV, all);
    List.DeleteItem(PVRaw, all);
    List.DeleteItem(PVStable, all);
    List.DeleteItem(PVStablePrev, all);
    Repeat ((MaxSearchDepthStackFrames * MaxSearchDepthStackFrames))
    {
        List.Add(PV, 0);
        List.Add(PVRaw, 0);
    }
    List.DeleteItem(CastlingStateLookup, all);
    Idx = 0;
    Repeat (256)
    {
        List.Add(CastlingStateLookup, Operator.Join(Operator.Join(Operator.Join((floor((Idx / 128)) % 2), (floor((Idx / 64)) % 2)), Operator.Join((floor((Idx / 32)) % 2), (floor((Idx / 16)) % 2))), Operator.Join(Operator.Join((floor((Idx / 8)) % 2), (floor((Idx / 4)) % 2)), Operator.Join((floor((Idx / 2)) % 2), (Idx % 2)))));
        Idx += 1;
    }
    List.DeleteItem(CastlingStatePow2, all);
    Idx = 128;
    Repeat (8)
    {
        List.Add(CastlingStatePow2, Idx);
        Idx = (Idx / 2);
    }
    List.DeleteItem(PawnCountOwn, all);
    List.DeleteItem(PawnCountOpp, all);
    Repeat (8)
    {
        List.Add(PawnCountOwn, 0);
        List.Add(PawnCountOpp, 0);
    }
    Call //("Generated moves are stores in per-ply segments within Moves list");
    List.DeleteAll(Moves);
    Repeat ((MaxMovesPerGeneration * MaxSearchDepthStackFrames))
    {
        List.Add(Moves, "");
    }
    List.DeleteAll(PieceMobility);
    Repeat (64)
    {
        List.Add(PieceMobility, 0);
    }
    List.DeleteAll(PieceMobilityPrep);
    Repeat ((64 * 32))
    {
        List.Add(PieceMobilityPrep, 0);
    }
}

Define InitBoardPhase2 (warp=true)
{
    Call InitHashLookup;
    Call InitMoveLookup;
    Call InitMobilityBonusLookup;
    Call InitKingSafety;
    Call InitPieceSquareTables;
    Call InitImbalanceLookup;
    Call CalcBoardStats;
    Call InitMovePosLookup;
    Call InitOpeningBook;
    Call InitOpeningMovesMap;
    Call InitChebyshev;
    Call InitHistoryScores;
    Call AddBoardToHistory("");
    Call AddToFiftyMoves((1 == 0));
}

Define InitChebyshev (warp=true)
{
    List.DeleteAll(ChebyshevDistance);
    Repeat (6500)
    {
        List.Add(ChebyshevDistance, "");
    }
    Idx = 1;
    Repeat (64)
    {
        IdxSub = 1;
        Repeat (64)
        {
            Delta = abs((IdxToRank[Idx] - IdxToRank[IdxSub]));
            Delta2 = abs((IdxToFile[Idx] - IdxToFile[IdxSub]));
            If (Delta > Delta2)
            {
                List.ReplaceItem(ChebyshevDistance, ((Idx * 100) + IdxSub), Delta);
            }
            Else
            {
                List.ReplaceItem(ChebyshevDistance, ((Idx * 100) + IdxSub), Delta2);
            }
            IdxSub += 1;
        }
        Idx += 1;
    }
}

Define InitCoordLookup (warp=true)
{
    List.DeleteItem(IdxToFile, all);
    List.DeleteItem(IdxToRank, all);
    Idx = 1;
    Repeat (64)
    {
        List.Add(IdxToFile, (((Idx - 1) % 8) + 1));
        List.Add(IdxToRank, ceiling((Idx / 8)));
        Idx += 1;
    }
}

Define InitHashLookup (warp=true)
{
    TTCurrentAge = 0;
    List.DeleteItem(PosPieceHashLookup, all);
    Repeat (1024)
    {
        List.Add(PosPieceHashLookup, Operator.Random(1 , ((65536 * 65536) * (65536 * 1))));
    }
    Call ClearTT;
}

Define InitHistoryScores (warp=true)
{
    IdxOuter = 1;
    Repeat (List.Length(HistoryMoveScores))
    {
        List.ReplaceItem(HistoryMoveScores, IdxOuter, 0);
        IdxOuter += 1;
    }
    IdxOuter = 1;
    Repeat (List.Length(MaxHistoryMoveScore))
    {
        List.ReplaceItem(MaxHistoryMoveScore, IdxOuter, 0);
        IdxOuter += 1;
    }
}

Define InitImbalanceLookup (warp=true)
{
    List.DeleteAll(ImbalanceSameSide);
    List.DeleteAll(ImbalanceOppSide);
    List.DeleteAll(ImbalanceFactor);
    Call LoadList("42, 0,  0,  0, 0, 0, 1, 1,  0,  0, 0, 0, 1, 7, -1,  0, 0, 0, 0, 3,  0,  0, 0, 0, -1, 1,  3, -6, 0, 0, -5, 3,  4, -4, 0, 0")("ImbalanceSameSide");
    Call LoadList("0, 0,  0,  0, 0, 0,  1, 0,  0,  0, 0, 0, 0, 2,  0,  0, 0, 0, 2, 2,  1,  0, 0, 0,1, 1,  1, -1, 0, 0, 3, 3, -1,  4, 9, 0")("ImbalanceOppSide");
    If (1 == 0)
    {
        Call LoadList("7, 7, 7, 7, 7, 7, 39, 2, 7, 7, 7, 7, 35, 271, -4, 7, 7, 7, 7, 25, 4, 7, 7, 7, -27, -2, 46, 100, 56, 7, 58, 29, 83, 148, -3, -25")("ImbalanceSameSide");
        Call LoadList("41, 41, 41, 41, 41, 41, 37, 41, 41, 41, 41, 41, 10, 62, 41, 41, 41, 41, 57, 64, 39, 41, 41, 41, 50, 40, 23, -22, 41, 41, 106, 101, 3, 151, 171, 41")("ImbalanceOppSide");
        Call LoadList("1617, -162, -1172, -190, 105, 26")("ImbalanceFactor");
    }
}

Define InitKingSafety (warp=true)
{
    List.DeleteItem(PawnStorm, all);
    Call LoadList("0,   0, -38, -28, -11,  16,  11,   0,  0,   0,  28, -10,   2,  34,  27,   0,  0,   0, -15, -12,  -3,   0,   2,   0,  0,   0, -30, -14,   1,   4,   2,   0,  0,   0, -30,   0,   9,  15,   3,   0,  0,   0,  -7,  -1,  -5,  -8,   6,   0,  0,   0,  22, -16,  -5,   8,  27,   0,  0,   0, -38, -35,  -5,   9,   7,   0")("PawnStorm");
    List.DeleteItem(PawnShelter, all);
    Call LoadList("    -3, 38,  44,  27,  18,   8,  12, 0,    -20, 29,  16, -23, -14,  -5, -30, 0,     -5, 35,  11,  -1,  15,   1, -21, 0,    -18, -6, -14, -24, -23, -31, -78, 0,    -18, -6, -14, -24, -23, -31, -78, 0,     -5, 35,  11,  -1,  15,   1, -21, 0,    -20, 29,  16, -23, -14,  -5, -30, 0,     -3, 38,  44,  27,  18,   8,  12, 0,")("PawnShelter");
    List.DeleteItem(PawnPassedFilePenalty, all);
    Call LoadList("0, 0, 5, 4, 10, 8, 15, 12, 15, 12, 10, 8, 5, 4, 0, 0")("PawnPassedFilePenalty");
    List.DeleteItem(PawnPassedRankBonus, all);
    Call LoadList("0, 0, 4, 13, 8, 15, 7, 19, 29, 34, 79, 83, 130, 122, 0, 0")("PawnPassedRankBonus");
    List.DeleteItem(PawnConnectedBonus, all);
    Call LoadList("0, 3, 4, 6, 14, 23, 40, 0")("PawnConnectedBonus");
    List.DeleteItem(PawnPhalanxBonus, all);
    Call LoadList("0, 0, 8, 0, 9, 0, 16, 2, 37, 18, 57, 43, 105, 105, 0, 0")("PawnPhalanxBonus");
    List.DeleteItem(PawnPhalanxBonusOpposed, all);
    Call LoadList("0, 0, 4, 0, 4, 0, 9, 1, 18, 9, 29, 21, 52, 52, 0, 0")("PawnPhalanxOpposedBonus");
    List.DeleteItem(PawnLeverBonus, all);
    Call LoadList("0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 13, 13, 0, 0, 0, 0")("PawnLeverBonus");
    List.DeleteItem(MinorAttackWeight, all);
    Call LoadList("0, 15, 19, 20, 28, 22, 34, 55, 30, 59, 0, 0")("MinorAttackWeight");
    List.DeleteItem(RookAttackWeight, all);
    Call LoadList("0, 11, 18, 34, 16, 32, 0, 17, 25, 19, 0, 0")("RookAttackWeight");
    List.DeleteAll(KingRings);
    Repeat (640)
    {
        List.Add(KingRings, -1);
    }
    KingIdx = 1;
    Repeat (64)
    {
        Idx = (((KingIdx - 1) * 10) + 1);
        KingRank = IdxToRank[KingIdx];
        KingFile = IdxToFile[KingIdx];
        Rank = (KingRank - 1);
        Repeat (3)
        {
            If ((Rank > 0) And (Rank < 9))
            {
                File = (KingFile - 1);
                Repeat (3)
                {
                    If ((File > 0) And (File < 9))
                    {
                        If ((Not ((File == KingFile))) Or (Not ((Rank == KingRank))))
                        {
                            List.ReplaceItem(KingRings, Idx, (((Rank - 1) * 8) + File));
                            Idx += 1;
                        }
                    }
                    File += 1;
                }
            }
            Rank += 1;
        }
        KingIdx += 1;
    }
}

Define InitMobilityBonusLookup (warp=true)
{
    List.DeleteItem(QueenMobilityBonus, all);
    List.DeleteItem(BishopMobilityBonus, all);
    List.DeleteItem(RookMobilityBonus, all);
    List.DeleteItem(KnightMobilityBonus, all);
    Call LoadList("-25, -40, -8, -2, 0, 6, 1, 9, 5, 18, 8, 23, 12, 28, 15, 32, 16, 34, 19, 38, 21, 42, 24, 45, 25, 46, 27, 46, 27, 49, 28, 51, 29, 52, 30, 54, 32, 56, 34, 58, 35, 62, 39, 66, 40, 70, 40, 75, 41, 79, 43, 81, 44, 83, 45, 84")("QueenMobilityBonus");
    Call LoadList("-21, -32, -9, -11, 8, 1, 12, 6, 17, 11, 21, 16, 24, 23, 29, 27, 30, 31, 32, 34, 37, 36, 38, 39, 41, 40, 44, 43")("BishopMobilityBonus");
    Call LoadList("-27, -36, -13, -8, -7, 12, -4, 19, -3, 25, -1, 36, 4, 45, 8, 47, 12, 53, 12, 57, 14, 63, 15, 65, 17, 67, 20, 68, 23, 68")("RookMobilityBonus");
    Call LoadList("-29, -35, -22, -25, -5, -12, -2, -6, 2, 4, 6, 8, 9, 11, 12, 14, 14, 15")("KnightMobilityBonus");
}

Define InitMoveLookup (warp=true)
{
    List.DeleteItem(KnightMoveOffsets, all);
    List.DeleteItem(KingMoveOffsets, all);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 1);
    List.DeleteItem(MoveLookupStraight, all);
    List.DeleteItem(MoveLookupCross, all);
    List.DeleteItem(MoveLookupOffsetsStraight, all);
    List.DeleteItem(MoveLookupOffsetsCross, all);
    List.DeleteItem(MoveLookupKnight, all);
    List.DeleteItem(MoveLookupKing, all);
    List.DeleteItem(MoveLookupIndexOffset, all);
    List.DeleteItem(MoveLookupLineIndexOffset, all);
    List.Add(MoveLookupOffsetsStraight, 1);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, 1);
    List.Add(MoveLookupOffsetsStraight, -1);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, -1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, -1);
    List.Add(MoveLookupOffsetsCross, -1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, -1);
    List.Add(MoveLookupOffsetsCross, -1);
    Idx = 1;
    Repeat (64)
    {
        IdxSub = 1;
        Repeat (4)
        {
            X = IdxToFile[Idx];
            Y = IdxToRank[Idx];
            Repeat (8)
            {
                X += MoveLookupOffsetsStraight[IdxSub];
                Y += MoveLookupOffsetsStraight[(IdxSub + 1)];
                List.Add(MoveLookupStraight, -1);
                If ((Y > 0) And (Y < 9))
                {
                    If ((X > 0) And (X < 9))
                    {
                        TargetIdx = (X + ((Y - 1) * 8));
                        List.ReplaceItem(MoveLookupStraight, List.Length(MoveLookupStraight), TargetIdx);
                    }
                }
            }
            IdxSub += 2;
        }
        IdxSub = 1;
        Repeat (4)
        {
            X = IdxToFile[Idx];
            Y = IdxToRank[Idx];
            Repeat (8)
            {
                X += MoveLookupOffsetsCross[IdxSub];
                Y += MoveLookupOffsetsCross[(IdxSub + 1)];
                List.Add(MoveLookupCross, -1);
                If ((Y > 0) And (Y < 9))
                {
                    If ((X > 0) And (X < 9))
                    {
                        TargetIdx = (X + ((Y - 1) * 8));
                        List.ReplaceItem(MoveLookupCross, List.Length(MoveLookupCross), TargetIdx);
                    }
                }
            }
            IdxSub += 2;
        }
        Idx += 1;
    }
    Idx = 1;
    Repeat (64)
    {
        List.InsertItem(MoveLookupIndexOffset, Idx, ((Idx - 1) * 8));
        List.InsertItem(MoveLookupLineIndexOffset, Idx, ((Idx - 1) * 32));
        Idx += 1;
    }
    Idx = 1;
    Repeat (64)
    {
        IdxSub = 1;
        Repeat (8)
        {
            Call GetTargetIdx(Idx)(KingMoveOffsets[IdxSub])(KingMoveOffsets[(IdxSub + 1)]);
            If (Not ((GetTargetIdxRes == -1)))
            {
                List.Add(MoveLookupKing, GetTargetIdxRes);
            }
            IdxSub += 2;
        }
        Repeat Until (List.Length(MoveLookupKing) == (Idx * 8))
        {
            List.Add(MoveLookupKing, -1);
        }
        IdxSub = 1;
        Repeat (8)
        {
            Call GetTargetIdx(Idx)(KnightMoveOffsets[IdxSub])(KnightMoveOffsets[(IdxSub + 1)]);
            If (Not ((GetTargetIdxRes == -1)))
            {
                List.Add(MoveLookupKnight, GetTargetIdxRes);
            }
            IdxSub += 2;
        }
        Repeat Until (List.Length(MoveLookupKnight) == (Idx * 8))
        {
            List.Add(MoveLookupKnight, -1);
        }
        Idx += 1;
    }
    List.DeleteItem(MoveToZeroPadStr, all);
    List.DeleteItem(MovePathDelta, all);
    List.DeleteItem(MovePathStepInc, all);
    Idx = 0;
    Repeat (10000)
    {
        If (Idx < 10)
        {
            List.Add(MoveToZeroPadStr, Operator.Join(000, Idx));
        }
        Else
        {
            If (Idx < 100)
            {
                List.Add(MoveToZeroPadStr, Operator.Join(00, Idx));
            }
            Else
            {
                If (Idx < 1000)
                {
                    List.Add(MoveToZeroPadStr, Operator.Join(0, Idx));
                }
                Else
                {
                    List.Add(MoveToZeroPadStr, Idx);
                }
            }
        }
        Idx += 1;
    }
    Repeat (10000)
    {
        List.Add(MovePathDelta, "");
        List.Add(MovePathStepInc, "");
    }
    Idx = 1;
    Repeat (64)
    {
        IdxSub = 1;
        Repeat (64)
        {
            X = (IdxToFile[IdxSub] - IdxToFile[Idx]);
            Y = (IdxToRank[IdxSub] - IdxToRank[Idx]);
            If ((Not ((Idx == IdxSub))) And (((X == 0) Or (Y == 0)) Or (abs(X) == abs(Y))))
            {
                If (abs(X) > abs(Y))
                {
                    Delta = abs(X);
                }
                Else
                {
                    Delta = abs(Y);
                }
                List.ReplaceItem(MovePathDelta, ((Idx * 100) + IdxSub), Delta);
                List.ReplaceItem(MovePathStepInc, ((Idx * 100) + IdxSub), ((8 * (Y / Delta)) + (X / Delta)));
            }
            IdxSub += 1;
        }
        Idx += 1;
    }
}

Define InitMovePosLookup (warp=true)
{
    List.DeleteAll(MovePosLookupMgOwn);
    List.DeleteAll(MovePosLookupOppMg);
    List.DeleteAll(MovePosLookupOwnEg);
    List.DeleteAll(MovePosLookupOppEg);
    List.DeleteAll(MoveHashLookupOwn);
    List.DeleteAll(MoveHashLookupOpp);
    List.DeleteAll(MovePosLookupOwnLegal);
    List.DeleteAll(MovePosLookupOppLegal);
    Repeat (100000)
    {
        List.Add(MovePosLookupOwnEg, "");
        List.Add(MovePosLookupOppEg, "");
        List.Add(MovePosLookupMgOwn, "");
        List.Add(MovePosLookupOppMg, "");
        List.Add(MoveHashLookupOwn, "");
        List.Add(MoveHashLookupOpp, "");
        List.Add(MovePosLookupOwnLegal, 0);
        List.Add(MovePosLookupOppLegal, 0);
    }
    List.DeleteAll(Pieces);
    List.Add(Pieces, GoK_OwnKing);
    List.Add(Pieces, GoK_OwnQueen);
    List.Add(Pieces, GoK_OwnRook);
    List.Add(Pieces, GoK_OwnBishop);
    List.Add(Pieces, GoK_OwnKnight);
    List.Add(Pieces, GoK_OwnPawn);
    List.Add(Pieces, GoK_OppKing);
    List.Add(Pieces, GoK_OppQueen);
    List.Add(Pieces, GoK_OppRook);
    List.Add(Pieces, GoK_OppBishop);
    List.Add(Pieces, GoK_OppKnight);
    List.Add(Pieces, GoK_OppPawn);
    IdxOuter = 1;
    Repeat (List.Length(Pieces))
    {
        SourcePiece = Pieces[IdxOuter];
        IsSlidingPiece = 0;
        If (abs(SourcePiece) == GoK_OwnBishop)
        {
            IsSlidingPiece = 1;
        }
        If (abs(SourcePiece) == GoK_OwnRook)
        {
            IsSlidingPiece = 2;
        }
        If (abs(SourcePiece) == GoK_OwnQueen)
        {
            IsSlidingPiece = 3;
        }
        SourceIdx = 0;
        Repeat (65)
        {
            File = IdxToFile[SourceIdx];
            Rank = IdxToRank[SourceIdx];
            Call GetPiecePosScoreRaw(SourcePiece)(SourceIdx);
            PiecePosScoreRes2.Mg = PiecePosScoreRes.Mg;
            PiecePosScoreRes2.Eg = PiecePosScoreRes.Eg;
            Call GetPiecePosHash(SourcePiece)(SourceIdx);
            PiecePosHash2 = PiecePosHash;
            TargetIdx = 0;
            Repeat (65)
            {
                IsLegalMove = 0;
                If (((Not ((SourceIdx == 0))) And (Not ((TargetIdx == 0)))) And (Not ((SourceIdx == TargetIdx))))
                {
                    X = abs((IdxToFile[TargetIdx] - File));
                    Y = abs((IdxToRank[TargetIdx] - Rank));
                    If (IsSlidingPiece == 0)
                    {
                        If (((X < 2) And (Y < 3)) Or ((X < 3) And (Y < 2)))
                        {
                            If (SourcePiece == GoK_OwnPawn)
                            {
                                If (((IdxToRank[TargetIdx] - Rank) == 1) And (X < 2))
                                {
                                    IsLegalMove = 1;
                                }
                                Else
                                {
                                    If ((Rank == 2) And ((TargetIdx - SourceIdx) == 16))
                                    {
                                        IsLegalMove = 1;
                                    }
                                }
                            }
                            Else
                            {
                                If (SourcePiece == GoK_OppPawn)
                                {
                                    If (((IdxToRank[TargetIdx] - Rank) == -1) And (X < 2))
                                    {
                                        IsLegalMove = 1;
                                    }
                                    Else
                                    {
                                        If ((Rank == 7) And ((TargetIdx - SourceIdx) == -16))
                                        {
                                            IsLegalMove = 1;
                                        }
                                    }
                                }
                                Else
                                {
                                    If (abs(SourcePiece) == GoK_OwnKing)
                                    {
                                        If (((X == 1) And (Y < 2)) Or ((Y == 1) And (X < 2)))
                                        {
                                            IsLegalMove = 1;
                                        }
                                    }
                                    Else
                                    {
                                        If (abs(SourcePiece) == GoK_OwnKnight)
                                        {
                                            If (((X == 1) And (Y == 2)) Or ((X == 2) And (Y == 1)))
                                            {
                                                IsLegalMove = 1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    Else
                    {
                        If ((X == 0) Or (Y == 0))
                        {
                            If (IsSlidingPiece > 1)
                            {
                                IsLegalMove = 1;
                            }
                        }
                        Else
                        {
                            If (X == Y)
                            {
                                If (Not ((IsSlidingPiece == 2)))
                                {
                                    IsLegalMove = 1;
                                }
                            }
                        }
                    }
                }
                If ((IsLegalMove == 1) Or ((SourceIdx == 0) Or (TargetIdx == 0)))
                {
                    Call GetPiecePosScoreRaw(SourcePiece)(TargetIdx);
                    Call GetPiecePosHash(SourcePiece)(TargetIdx);
                    If (SourcePiece > 0)
                    {
                        IdxOuter2 = ((PieceIdxLookup[SourcePiece] * 10000) + ((SourceIdx * 100) + TargetIdx));
                        List.ReplaceItem(MovePosLookupMgOwn, IdxOuter2, (PiecePosScoreRes.Mg - PiecePosScoreRes2.Mg));
                        List.ReplaceItem(MovePosLookupOwnEg, IdxOuter2, (PiecePosScoreRes.Eg - PiecePosScoreRes2.Eg));
                        List.ReplaceItem(MoveHashLookupOwn, IdxOuter2, (PiecePosHash - PiecePosHash2));
                        List.ReplaceItem(MovePosLookupOwnLegal, IdxOuter2, 1);
                    }
                    Else
                    {
                        IdxOuter2 = ((PieceIdxLookup[(0 - SourcePiece)] * 10000) + ((SourceIdx * 100) + TargetIdx));
                        List.ReplaceItem(MovePosLookupOppMg, IdxOuter2, (PiecePosScoreRes.Mg - PiecePosScoreRes2.Mg));
                        List.ReplaceItem(MovePosLookupOppEg, IdxOuter2, (PiecePosScoreRes.Eg - PiecePosScoreRes2.Eg));
                        List.ReplaceItem(MoveHashLookupOpp, IdxOuter2, (PiecePosHash - PiecePosHash2));
                        List.ReplaceItem(MovePosLookupOppLegal, IdxOuter2, 1);
                    }
                }
                TargetIdx += 1;
            }
            SourceIdx += 1;
        }
        IdxOuter += 1;
    }
}

Define InitOpeningBook (warp=true)
{
    List.DeleteItem(OpeningMoves, all);
    Idx = 1;
    Repeat (List.Length(OpeningMovesNeutral))
    {
        List.Add(OpeningMoves, OpeningMovesNeutral[Idx]);
        Idx += 1;
    }
    If (IsPlayerBlack == 1)
    {
        Idx = 1;
        Repeat (List.Length(OpeningMovesOpp))
        {
            List.Add(OpeningMoves, OpeningMovesOpp[Idx]);
            Idx += 1;
        }
    }
    Else
    {
        Idx = 1;
        Repeat (List.Length(OpeningMovesOwn))
        {
            List.Add(OpeningMoves, OpeningMovesOwn[Idx]);
            Idx += 1;
        }
    }
    If (IsPlayerBlack == 1)
    {
        Idx = 1;
        Repeat (List.Length(OpeningMoves))
        {
            CurrentValue = OpeningMoves[Idx];
            CurrentValue2 = "";
            IdxSub = 1;
            Repeat ((Variable.Length(CurrentValue) / 4))
            {
                CurrentMoveOuter = Operator.Join(Operator.Join(Operator.LetterOf(CurrentValue, IdxSub), Operator.LetterOf(CurrentValue, (IdxSub + 1))), Operator.Join(Operator.LetterOf(CurrentValue, (IdxSub + 2)), Operator.LetterOf(CurrentValue, (IdxSub + 3))));
                Call GetVirtualMove(CurrentMoveOuter);
                CurrentValue2 = Operator.Join(CurrentValue2, MoveToZeroPadStr[(floor(VirtualMove) + 1)]);
                IdxSub += 4;
            }
            If ((Operator.Join(Operator.LetterOf(CurrentValue2, 1), Operator.LetterOf(CurrentValue2, 2)) == 9) Or (Operator.Join(Operator.LetterOf(CurrentValue2, 1), Operator.LetterOf(CurrentValue2, 2)) == 16))
            {
                List.ReplaceItem(OpeningMoves, Idx, "");
            }
            Else
            {
                List.ReplaceItem(OpeningMoves, Idx, CurrentValue2);
            }
            Idx += 1;
        }
    }
}

Define InitOpeningMovesMap (warp=true)
{
    List.DeleteAll(OpeningMovesMapHash);
    List.DeleteAll(OpeningMovesMapMove);
    List.DeleteAll(OpeningMovesMapStack);
    Repeat (List.Length(OpeningMoves))
    {
        List.Add(OpeningMovesMapStack, 1);
    }
    Call CreateCurrentBoardHash;
    Call InitOpeningMovesMapImpl((1 + IsPlayerBlack))(0)("")((1 == 1));
}

Define InitOpeningMovesMapImpl(string Depth)(string GameMovesLen)(string Move)(bool Init) (warp=true)
{
    List.DeleteAll(OpeningMovesRes);
    Idx = 1;
    Repeat (List.Length(OpeningMovesMapStack))
    {
        IsEqual = 0;
        CurrentValue = OpeningMoves[Idx];
        If ((OpeningMovesMapStack[Idx] % 2) == 1)
        {
            IsEqual = 1;
            IdxString = 1;
            If (Not (Init))
            {
                Repeat Until ((IsEqual == 0) Or (IdxString > 4))
                {
                    If (Not ((Operator.LetterOf(Move, IdxString) == Operator.LetterOf(CurrentValue, (GameMovesLen + IdxString)))))
                    {
                        IsEqual = 0;
                    }
                    IdxString += 1;
                }
            }
        }
        If (IsEqual == 1)
        {
            CurrentMoveOuter = Operator.Join(Operator.Join(Operator.LetterOf(CurrentValue, (GameMovesLen + IdxString)), Operator.LetterOf(CurrentValue, ((GameMovesLen + IdxString) + 1))), Operator.Join(Operator.LetterOf(CurrentValue, ((GameMovesLen + IdxString) + 2)), Operator.LetterOf(CurrentValue, ((GameMovesLen + IdxString) + 3))));
            If (Not ((CurrentMoveOuter == "")))
            {
                List.Add(OpeningMovesRes, CurrentMoveOuter);
            }
            List.ReplaceItem(OpeningMovesMapStack, Idx, ((OpeningMovesMapStack[Idx] * 2) + 1));
        }
        Else
        {
            List.ReplaceItem(OpeningMovesMapStack, Idx, ((OpeningMovesMapStack[Idx] * 2) + 0));
        }
        Idx += 1;
    }
    If (List.Length(OpeningMovesRes) > 0)
    {
        List.DeleteAll(TmpList1);
        Call ClearMoveList(Depth);
        IdxOuter = 1;
        Repeat (List.Length(OpeningMovesRes))
        {
            CurrentMoveOuter = OpeningMovesRes[IdxOuter];
            List.Add(OpeningMovesMapHash, CurrentBoardHash);
            List.Add(OpeningMovesMapMove, CurrentMoveOuter);
            If (Not (List.ContainsItem(TmpList1, CurrentMoveOuter)))
            {
                Call AddMoveToList(CurrentMoveOuter)(Depth);
                List.Add(TmpList1, CurrentMoveOuter);
            }
            IdxOuter += 1;
        }
        List.ReplaceItem(MovesIdx, Depth, 1);
        Repeat (MovesCount[Depth])
        {
            Call ApplyMoveLight(Depth);
            Call GetCurrentMove(Depth);
            If Init
            {
                Call InitOpeningMovesMapImpl((Depth + 1))(0)(AppliedMove[Depth])((1 == 0));
            }
            Else
            {
                Call InitOpeningMovesMapImpl((Depth + 1))((GameMovesLen + 4))(AppliedMove[Depth])((1 == 0));
            }
            Call RevertMoveLight(Depth);
            List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
        }
    }
    Idx = 1;
    Repeat (List.Length(OpeningMovesMapStack))
    {
        List.ReplaceItem(OpeningMovesMapStack, Idx, floor((OpeningMovesMapStack[Idx] / 2)));
        Idx += 1;
    }
}

Define InitPieceSquareTables (warp=true)
{
    List.DeleteItem(PawnPieceSquare, all);
    Call LoadList(" 0,  0,  0,  0,  0,  0,  0,  0,  -1,  2,  7,  9,  9,  7,  2, -1,  -7, -3,  8, 11, 11,  8, -3, -7,  -5, -5,  6, 14, 14,  6, -5, -5,    4, -3, -4, 14, 14, -4, -3,  4,  -5, -7, -3, 11, 11, -3, -7, -5,  -4,  4, -5,  9,  9, -5,  4, -4,    0,  0,  0,  0,  0,  0,  0,  0")("PawnPieceSquare");
    List.DeleteItem(PawnPieceSquareEndgame, all);
    Call LoadList(" 0,  0,  0,  0,  0,  0,  0,  0, -7, -2,  4,  5,  5,  4, -2, -7, -3, -4, -2,  2,  2, -2, -4, -3, -1, -3, -5, -4, -4, -5, -3, -1,  4,  4, -1, -6, -6, -1,  4,  4, 10,  6,  7, 14, 14,  7,  6, 10,  2, -2,  8, 11, 11,  8, -2,  2,  0,  0,  0,  0,  0,  0,  0,  0")("PawnPieceSquareEndgame");
    List.DeleteItem(KnightPieceSquare, all);
    Call LoadList("-79, -45, -38, -37, -37, -38, -45, -79, -37, -18, -11,  -4,  -4, -11, -18, -37, -30,  -9,   2,   9,   9,   2,  -9, -30, -13,   2,  19,  22,  22,  19,   2, -13, -14,   6,  20,  24,  24,  20,   6, -14,  -5,  13,  30,  26,  26,  30,  13,  -5, -120, -30,   3,  17,  17,   3, -30, -120, -94, -38, -25, -15, -15, -25, -38, -94")("KnightPieceSquare");
    List.DeleteItem(KnightPieceSquareEndgame, all);
    Call LoadList("-49, -35, -22,  -8,  -8, -22, -35, -49, -33, -26,  -7,   3,   3,  -7, -26, -33, -18, -15,  -2,  13,  13,  -2, -15, -18, -17,   0,   6,  16,  16,   6,   0, -17, -19,  -9,   2,  16,  16,   2,  -9, -19, -24, -18,  -8,   9,   9,  -8, -18, -24, -80, -40, -17,   8,   8, -17, -40, -80, -46, -42, -25,  -8,  -8, -25, -42, -46")("KnightPieceSquareEndgame");
    List.DeleteItem(BishopPieceSquare, all);
    Call LoadList(" -21,  -2,  -5, -13, -13,  -5,  -2, -21,   -8,   3,   7,   1,   1,   7,   3,  -8,   -4,  11,  -1,   7,   7,  -1,  11,  -4,    0,   4,  12,  17,  17,  12,   4,   0,   -3,  14,  11,  13,  13,  11,  14,  -3,   -8,   2,   0,   4,   4,   0,   2,  -8,  -10,  -9,   5,  -3,  -3,   5,  -9, -10,  -23,  -1,  -6, -12, -12,  -6,  -1, -23")("BishopPieceSquare");
    List.DeleteItem(BishopPieceSquareEndgame, all);
    Call LoadList(" -30, -14, -16,  -4,  -4, -16, -14, -30,  -18,  -6,  -7,   0,   0,  -7,  -6, -18,   -8,   0,  -3,   6,   6,  -3,   0,  -8,  -12,  -1,   0,   8,   8,   0,  -1, -12,  -11,  -3,  -5,   8,   8,  -5,  -3, -11,  -12,   1,   0,   8,   8,   0,   1, -12,  -16,  -8,  -3,   4,   4,  -3,  -8, -16,  -24, -19, -18,  -9,  -9, -18, -19, -24")("BishopPieceSquareEndgame");
    List.DeleteItem(RookPieceSquare, all);
    Call LoadList("-11,  -6,  -3,   1,   1,  -3,  -6, -11,  -8,  -5,  -2,   4,   4,  -2,  -5,  -8, -10,  -3,   1,   0,   0,   1,  -3, -10,  -6,  -2,  -2,  -3,  -3,  -2,  -2,  -6, -11,  -6,   0,   3,   3,   0,  -6, -11, -11,  -2,   2,   5,   5,   2,  -2, -11,  -4,   3,   5,   6,   6,   5,   3,  -4, -10, -11,  -3,   2,   2,  -3, -11, -10")("RookPieceSquare");
    List.DeleteItem(RookPieceSquareEndgame, all);
    Call LoadList(" -1,  -3,  -1,  -1,  -1,  -1,  -3,  -1,  -5,  -3,   0,   0,   0,   0,  -3,  -5,   5,  -2,   1,  -1,  -1,   1,  -2,   5,  -2,   1,  -4,   4,   4,  -4,   1,  -2,  -4,   2,   2,  -4,  -4,   2,   2,  -4,   1,  -1,  -5,   3,   3,  -5,  -1,   1,   0,   1,   8,  -4,  -4,   8,   1,   0,   6,  -3,   6,   3,   3,   6,  -3,   6")("RookPieceSquareEndgame");
    List.DeleteItem(QueenPieceSquare, all);
    Call LoadList("  1,  -2,  -2,   2,   2,  -2,  -2,   1,  -1,   2,   4,   6,   6,   4,   2,  -1,  -1,   3,   6,   3,   3,   6,   3,  -1,   2,   2,   4,   4,   4,   4,   2,   2,   0,   7,   6,   2,   2,   6,   7,   0,  -2,   5,   3,   4,   4,   3,   5,  -2,  -2,   3,   5,   4,   4,   5,   3,  -2,  -1,  -1,   0,  -1,  -1,   0,  -1,  -1")("QueenPieceSquare");
    List.DeleteItem(QueenPieceSquareEndgame, all);
    Call LoadList("-32, -27, -22, -12, -12, -22, -27, -32, -26, -15, -10,  -2,  -2, -10, -15, -26, -18,  -8,  -4,   1,   1,  -4,  -8, -18, -11,  -1,   6,  11,  11,   6,  -1, -11, -14,  -3,   4,  10,  10,   4,  -3, -14, -18,  -8,  -6,   0,   0,  -6,  -8, -18, -23, -13, -11,  -4,  -4, -11, -13, -23, -35, -24, -20, -17, -17, -20, -24, -35")("QueenPieceSquareEndgame");
    List.DeleteItem(KingPieceSquare, all);
    Call LoadList("128, 153, 128,  89,  89, 128, 153, 128, 130, 143, 112,  86,  86, 112, 143, 130,  93, 119,  79,  56,  56,  79, 119,  93,  79,  90,  64,  51,  51,  64,  90,  79,  68,  83,  53,  32,  32,  53,  83,  68,  56,  75,  40,  17,  17,  40,  75,  56,  41,  56,  30,  12,  12,  30,  56,  41,  30,  41,  23,   0,   0,  23,  41,  30")("KingPieceSquare");
    List.DeleteItem(KingPieceSquareEndgame, all);
    Call LoadList("  0,  19,  38,  44,  44,  38,  19,   0,  27,  46,  65,  62,  62,  65,  46,  27,  40,  65,  77,  81,  81,  77,  65,  40,  48,  71,  79,  79,  79,  79,  71,  48,  46,  78,  92,  91,  91,  92,  78,  46,  41,  77,  82,  89,  89,  82,  77,  41,  19,  46,  60,  66,  66,  60,  46,  19,   2,  28,  35,  35,  35,  35,  28,   2")("KingPieceSquareEndgame");
}

Define IsCheckingPiece(string Idx) (warp=true)
{
    Call IsCheckingPieceImpl(Idx)(Board[(Idx + 0)]);
}

Define IsCheckingPieceDiscovery(string SourceIdx)(string TargetIdx)(string Depth) (warp=true)
{
    IsCheckingPieceRes = 0;
    If (PersistedBoardAttackedByOppSnapshot[(((Depth - 2) * 100) + SourceIdx)] > 0)
    {
        SourceIdxOuter1 = PersistedBoardAttackedByOppPieceSnapshot[(((Depth - 2) * 100) + SourceIdx)];
        If (abs(Board[SourceIdxOuter1]) > GoK_OwnKnight)
        {
            Call IsCheckingPiece(SourceIdxOuter1);
        }
    }
}

Define IsCheckingPieceImpl(string Idx)(string Piece) (warp=true)
{
    IsCheckingPieceRes = 0;
    CurrentPiece = Piece;
    If (abs(CurrentPiece) == GoK_OwnKing)
    {
        Stop(this script);
    }
    If (CurrentPiece > 0)
    {
        If (MovePosLookupOwnLegal[((PieceIdxLookup[(CurrentPiece + 0)] * 10000) + ((Idx * 100) + KingIdxOpp))] == 0)
        {
            Stop(this script);
        }
        If (CurrentPiece == GoK_OwnPawn)
        {
            If (IdxToFile[(Idx + 0)] == IdxToFile[(KingIdxOpp + 0)])
            {
                Stop(this script);
            }
            IsCheckingPieceRes = 1;
            Stop(this script);
        }
        If (CurrentPiece == GoK_OwnKnight)
        {
            IsCheckingPieceRes = 1;
            Stop(this script);
        }
        CurrentMove = ((Idx * 100) + KingIdxOpp);
    }
    Else
    {
        If (CurrentPiece < 0)
        {
            If (MovePosLookupOppLegal[((PieceIdxLookup[(0 - CurrentPiece)] * 10000) + ((Idx * 100) + KingIdxtOwn))] == 0)
            {
                Stop(this script);
            }
            If (CurrentPiece == GoK_OppPawn)
            {
                If (IdxToFile[(Idx + 0)] == IdxToFile[(KingIdxtOwn + 0)])
                {
                    Stop(this script);
                }
                IsCheckingPieceRes = 1;
                Stop(this script);
            }
            If (CurrentPiece == GoK_OppKnight)
            {
                IsCheckingPieceRes = 1;
                Stop(this script);
            }
            CurrentMove = ((Idx * 100) + KingIdxtOwn);
        }
    }
    SourceIdx = Idx;
    IdxInc = MovePathStepInc[(CurrentMove + 0)];
    Repeat ((MovePathDelta[(CurrentMove + 0)] - 1))
    {
        SourceIdx += IdxInc;
        If (Not ((Board[(SourceIdx + 0)] == 0)))
        {
            Stop(this script);
        }
    }
    IsCheckingPieceRes = 1;
}

Define IsDrawByMaterial (warp=true)
{
    IsDrawRes = 0;
    CurrentValue = 0;
    CurrentValue2 = 0;
    Idx = 1;
    Repeat (64)
    {
        CurrentPiece = Board[Idx];
        If (Not ((CurrentPiece == 0)))
        {
            If ((CurrentPiece == GoK_OwnBishop) Or (CurrentPiece == GoK_OwnKnight))
            {
                CurrentValue += 1;
            }
            Else
            {
                If ((CurrentPiece == GoK_OppBishop) Or (CurrentPiece == GoK_OppKnight))
                {
                    CurrentValue2 += 1;
                }
                Else
                {
                    If (Not ((abs(CurrentPiece) == GoK_OwnKing)))
                    {
                        Stop(this script);
                    }
                }
            }
        }
        Idx += 1;
    }
    If ((CurrentValue + CurrentValue2) < 2)
    {
        IsDrawRes = 1;
    }
}

Define IsDrawByStalemate(string Depth) (warp=true)
{
    Call CalcBoardAttackedByMoveChecked((Depth + 1));
    If ((((Depth % 2) == 1) And (IsOwnSideChecked == 1)) Or (((Depth % 2) == 0) And (IsOppSideChecked == 1)))
    {
        IsDrawRes = 0;
        Stop(this script);
    }
    List.ReplaceItem(Quiescence, Depth, 0);
    Call CalcBoardAttackedByMove((Depth + 1));
    Call StoreAttackInfo((Depth + 1))(Depth);
    List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
    Call GenerateMovesImplWrapper(Depth)((1 == 0))((1 == 0));
    List.ReplaceItem(BoardAttackedCalculated, Depth, 0);
    If (Quiescence[Depth] == 0)
    {
        MoveCount += MovesCount[Depth];
    }
    Else
    {
        MoveCountQ += MovesCount[Depth];
    }
    List.ReplaceItem(MovesIdx, Depth, 1);
    IsDrawRes = 1;
    Repeat (MovesCount[Depth])
    {
        Call ApplyMove(Depth);
        Call CalcBoardAttackedByMoveChecked((Depth + 1));
        If ((((Depth % 2) == 1) And (IsOwnSideChecked == 0)) Or (((Depth % 2) == 0) And (IsOppSideChecked == 0)))
        {
            IsDrawRes = 0;
            Call RevertMove(Depth);
            Stop(this script);
        }
        Call RevertMove(Depth);
        List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
    }
}

Define IsEngineValidMove(string Move) (warp=true)
{
    Call GenerateMovesPublic(1);
    If List.ContainsItem(Moves1, Move)
    {
        ValidMoveRes = 1;
    }
    Else
    {
        ValidMoveRes = 0;
    }
}

Define IsLowerCase(string Char) (warp=true)
{
    Chars = "";
    CharsIdx = 1;
    Repeat (Variable.Length(CharsUpperCase))
    {
        If (Operator.LetterOf(CharsUpperCase, CharsIdx) == Char)
        {
            Chars = Operator.Join(Chars, Char);
        }
        Else
        {
            Chars = Operator.Join(Chars, Operator.LetterOf(CharsUpperCase, CharsIdx));
        }
        CharsIdx += 1;
    }
    Looks.SwitchCostumeTo(_ABCDEFGHIJKLMNOPQRSTUVWXYZ);
    Looks.SwitchCostumeTo(Chars);
    If (Costume.GetNumberName(number) == 1)
    {
        IsLowerCaseRes = 0;
    }
    Else
    {
        IsLowerCaseRes = 1;
    }
}

Define IsOppKingCheckMate (warp=true)
{
    IsOppKingCheckMateRes = 0;
    Call CalcBoardAttackedByMove(1);
    If (IsOppSideChecked == 1)
    {
        IsOppKingCheckMateRes = 1;
        Call GenerateMovesPublic(2);
        List.ReplaceItem(MovesIdx, 2, 1);
        Repeat (MovesCount[2])
        {
            If (IsOppKingCheckMateRes == 1)
            {
                Call ApplyMove(2);
                Call CalcBoardAttackedByMove(1);
                If (IsOppSideChecked == 0)
                {
                    IsOppKingCheckMateRes = 0;
                }
                Call RevertMove(2);
            }
            List.ReplaceItem(MovesIdx, 2, (MovesIdx[2] + 1));
        }
    }
}

Define IsOwnKingCheckMate (warp=true)
{
    IsOwnKingCheckMateRes = 0;
    Call CalcBoardAttackedByMove(2);
    If (IsOwnSideChecked == 1)
    {
        IsOwnKingCheckMateRes = 1;
        Call GenerateMovesPublic(1);
        List.ReplaceItem(MovesIdx, 1, 1);
        Repeat (MovesCount[1])
        {
            If (IsOwnKingCheckMateRes == 1)
            {
                Call ApplyMove(1);
                Call CalcBoardAttackedByMove(2);
                If (IsOwnSideChecked == 0)
                {
                    IsOwnKingCheckMateRes = 0;
                }
                Call RevertMove(1);
            }
            List.ReplaceItem(MovesIdx, 1, (MovesIdx[1] + 1));
        }
    }
}

Define IsPassedPawnDanger(string Piece)(string Move) (warp=true)
{
    IsPassedPawnDangerRes = 0;
    If (abs(Piece) == GoK_OwnPawn)
    {
        TargetIdx = floor((Move % 100));
        File = IdxToFile[TargetIdx];
        Rank = IdxToRank[TargetIdx];
        If (Piece > 0)
        {
            North = 8;
            NorthWest = 7;
            NorthEast = 9;
            StartRank = 6;
            StopRank = 7;
            Factor = 1;
        }
        Else
        {
            North = -8;
            NorthWest = -9;
            NorthEast = -7;
            StartRank = 3;
            StopRank = 2;
            Factor = -1;
        }
        If (Rank == StopRank)
        {
            IsPassedPawnDangerRes = 1;
        }
        Else
        {
            If (1 == 1)
            {
                If (Rank == StartRank)
                {
                    If (Not ((Board[(TargetIdx + North)] == (GoK_OppPawn * Factor))))
                    {
                        If ((File == 1) Or (Not ((Board[(TargetIdx + NorthWest)] == (GoK_OppPawn * Factor)))))
                        {
                            If ((File == 8) Or (Not ((Board[(TargetIdx + NorthEast)] == (GoK_OppPawn * Factor)))))
                            {
                                IsPassedPawnDangerRes = 1;
                            }
                        }
                    }
                }
            }
        }
    }
}

Define IsQuiescentCheckCond(string Depth) (warp=true)
{
    Call //("Quiescence search extension for checking moves, esp. check sequences. Return value defined whether check sequences should pursued at this point");
    IsQuiescentCheckRes = 0;
    If (Level > 4)
    {
        Call GetEndgameLocal;
        If ((1 == 0) And ((IsScratch3 == 1) Or (IsEndgameLocal == 1)))
        {
            If (Quiescence[(Depth - 1)] == 0)
            {
                IsQuiescentCheckRes = 1;
                Stop(this script);
            }
            If (1 == 0)
            {
                If (Quiescence[(Depth - 2)] == 0)
                {
                    If (CheckedState[(Depth - 1)] == 1)
                    {
                        IsQuiescentCheckRes = 1;
                        Stop(this script);
                    }
                }
            }
        }
    }
}

Define LoadList(string Data)(string ListName) (warp=true)
{
    IdxString = 1;
    CurrentValue = "";
    Repeat Until (IdxString > Variable.Length(Data))
    {
        If ((Not ((Operator.LetterOf(Data, IdxString) == " "))) And (Not ((Operator.LetterOf(Data, IdxString) == ","))))
        {
            CurrentValue = Operator.Join(CurrentValue, Operator.LetterOf(Data, IdxString));
        }
        If ((Operator.LetterOf(Data, IdxString) == ",") Or (IdxString == Variable.Length(Data)))
        {
            If (ListName == "PawnPieceSquare")
            {
                List.Add(PawnPieceSquare, Operator.Round((CurrentValue * 0)));
            }
            If (ListName == "PawnPieceSquareEndgame")
            {
                List.Add(PawnPieceSquareEndgame, Operator.Round((CurrentValue * 0)));
            }
            If (ListName == "KingPieceSquare")
            {
                List.Add(KingPieceSquare, Operator.Round((CurrentValue * 0.2)));
            }
            If (ListName == "KingPieceSquareEndgame")
            {
                List.Add(KingPieceSquareEndgame, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "QueenPieceSquare")
            {
                List.Add(QueenPieceSquare, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "QueenPieceSquareEndgame")
            {
                List.Add(QueenPieceSquareEndgame, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "RookPieceSquare")
            {
                List.Add(RookPieceSquare, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "RookPieceSquareEndgame")
            {
                List.Add(RookPieceSquareEndgame, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "BishopPieceSquare")
            {
                List.Add(BishopPieceSquare, Operator.Round((CurrentValue * 0.8)));
            }
            If (ListName == "BishopPieceSquareEndgame")
            {
                List.Add(BishopPieceSquareEndgame, Operator.Round((CurrentValue * 0.8)));
            }
            If (ListName == "KnightPieceSquare")
            {
                List.Add(KnightPieceSquare, Operator.Round((CurrentValue * 0.4)));
            }
            If (ListName == "KnightPieceSquareEndgame")
            {
                List.Add(KnightPieceSquareEndgame, Operator.Round((CurrentValue * 0.4)));
            }
            If (ListName == "KnightMobilityBonus")
            {
                List.Add(KnightMobilityBonus, Operator.Round((CurrentValue * 0.8)));
            }
            If (ListName == "BishopMobilityBonus")
            {
                List.Add(BishopMobilityBonus, Operator.Round((CurrentValue * 0.8)));
            }
            If (ListName == "RookMobilityBonus")
            {
                List.Add(RookMobilityBonus, Operator.Round((CurrentValue * 0.8)));
            }
            If (ListName == "QueenMobilityBonus")
            {
                List.Add(QueenMobilityBonus, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "PawnStorm")
            {
                List.Add(PawnStorm, Operator.Round((CurrentValue * 0)));
            }
            If (ListName == "PawnShelter")
            {
                List.Add(PawnShelter, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "ImbalanceSameSide")
            {
                List.Add(ImbalanceSameSide, CurrentValue);
            }
            If (ListName == "ImbalanceOppSide")
            {
                List.Add(ImbalanceOppSide, CurrentValue);
            }
            If (ListName == "ImbalanceFactor")
            {
                List.Add(ImbalanceFactor, CurrentValue);
            }
            If (ListName == "PawnPassedFilePenalty")
            {
                List.Add(PawnPassedFilePenalty, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "PawnPassedRankBonus")
            {
                List.Add(PawnPassedRankBonus, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "PawnConnectedBonus")
            {
                List.Add(PawnConnectedBonus, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "PawnPhalanxBonus")
            {
                List.Add(PawnPhalanxBonus, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "PawnPhalanxOpposedBonus")
            {
                List.Add(PawnPhalanxBonusOpposed, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "PawnLeverBonus")
            {
                List.Add(PawnLeverBonus, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "MinorAttackWeight")
            {
                List.Add(MinorAttackWeight, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "RookAttackWeight")
            {
                List.Add(RookAttackWeight, Operator.Round((CurrentValue * 1)));
            }
            CurrentValue = "";
        }
        IdxString += 1;
    }
}

Define Log(string Txt1)(string Txt2)(string Txt3)(string Txt4)(string Txt5)(string Txt6)(string Txt7)(string Txt8) (warp=true)
{
    Tmp = (floor((((Sensing.DaysSince2000() * 86400) - ThinkTimeStart) * 1000)) / 1000);
    If Operator.Contains(Tmp, ".")
    {
        If ((Operator.LetterOf(Tmp, (Variable.Length(Tmp) - 1)) == ".") Or (Operator.LetterOf(Tmp, (Variable.Length(Tmp) - 2)) == "."))
        {
            Tmp = Operator.Join(Tmp, 0);
        }
    }
    Else
    {
        Tmp = Operator.Join(Tmp, .000);
    }
    List.Add(Logfile, Operator.Join(Operator.Join(Tmp, ": "), Operator.Join(Txt1, Operator.Join(Txt2, Operator.Join(Txt3, Operator.Join(Txt4, Operator.Join(Txt5, Operator.Join(Txt6, Operator.Join(Txt7, Txt8)))))))));
}

Define LogEval (warp=true)
{
    Call Evaluate(0)((1 == 0));
    List.ReplaceItem(CastlingState, 1, Operator.Join(Operator.Join(Operator.Join(HasOwnCastled, HasOwnKingMoved), Operator.Join(HasOwnRookKSMoved, HasOwnRookQSMoved)), Operator.Join(Operator.Join(HasOppCastled, HasOppKingMoved), Operator.Join(HasOppRookKSMoved, HasOppRookQSMoved))));
    Call ClearMoveList(1);
    Call AddMoveToList(0)(1);
    List.ReplaceItem(MovesIdx, 1, 1);
    Call ApplyMove(1);
    Call Evaluate(1)((1 == 0));
    Call ClearMoveList(2);
    Call AddMoveToList(0)(2);
    List.ReplaceItem(MovesIdx, 2, 1);
    Call ApplyMove(2);
    Call Evaluate(2)((1 == 0));
    Call Log("========================================")("")("")("")("")("")("")("");
    Call LogEvalImpl(2)((1 == 1));
    Call Log("========================================")("")("")("")("")("")("")("");
    Call RevertMove(2);
    Call RevertMove(1);
}

Define LogEvalImpl(string Depth)(bool IsPlayerTurn) (warp=true)
{
    Call Log("Evaluation Analysis")("")("")("")("")("")("")("");
    Call ExportBoardFEN((IsPlayerBlack == 1))(IsPlayerTurn);
    Call Log(ExportDataFEN)("")("")("")("")("")("")("");
    Call Log(ExportDataFENLichess)("")("")("")("")("")("")("");
    Call Log("----------------------------------------")("")("")("")("")("")("")("");
    Call TaperedEval.Init;
    Call Log("Eval.TaperedEval.ScaleFacor")(" = ")(TaperedEval.ScaleFactor)("")("")("")("")("");
    Call Log("Eval.TaperedEval.Phase")(" = ")(TaperedEval.Phase)("")("")("")("")("");
    Call Log("----------------------------------------")("")("")("")("")("")("")("");
    Eval.DebugLog = 1;
    Call Evaluate(Depth)((1 == 1));
    Eval.DebugLog = 0;
}

Define LogPVEval (warp=true)
{
    If (List.Length(PVStable) > 1)
    {
        Call Log("========================================")("")("")("")("")("")("")("");
        Call Log("PV Leaf Evaluation Analysis")("")("")("")("")("")("")("");
        Call ExportBoardFEN((IsPlayerBlack == 1))((1 == 0));
        Call Log("PV: ")("[FEN "")(ExportDataFEN)(""] ")(PV)("")("")("");
        Call Log("----------------------------------------")("")("")("")("")("")("")("");
        List.ReplaceItem(CastlingState, 1, Operator.Join(Operator.Join(Operator.Join(HasOwnCastled, HasOwnKingMoved), Operator.Join(HasOwnRookKSMoved, HasOwnRookQSMoved)), Operator.Join(Operator.Join(HasOppCastled, HasOppKingMoved), Operator.Join(HasOppRookKSMoved, HasOppRookQSMoved))));
        Call Evaluate(0)((1 == 0));
        LogPVEval.Idx = 1;
        Repeat (List.Length(PVStable))
        {
            Call ClearMoveList(LogPVEval.Idx);
            Call AddMoveToList(PVStable[LogPVEval.Idx])(LogPVEval.Idx);
            List.ReplaceItem(MovesIdx, LogPVEval.Idx, 1);
            Call ApplyMove(LogPVEval.Idx);
            Call Evaluate(LogPVEval.Idx)((1 == 0));
            LogPVEval.Idx += 1;
        }
        Call LogEvalImpl(List.Length(PVStable))((1 == 0));
        Call Log("========================================")("")("")("")("")("")("")("");
        LogPVEval.Idx = List.Length(PVStable);
        Repeat (List.Length(PVStable))
        {
            Call RevertMove(LogPVEval.Idx);
            LogPVEval.Idx += -1;
        }
    }
}

Define LogPVEvalLine(string Key)(string Val1)(string Val2)(string SquareIdx)(string Side)(string Move) (warp=true)
{
    If (Eval.DebugLog == 1)
    {
        If ((Variable.Length(Key) > 0) And (Variable.Length(Val1) > 0))
        {
            Log.Tmp1 = Operator.Join("(", Val1);
            If (Variable.Length(Val2) > 0)
            {
                Log.Tmp1 = Operator.Join(Operator.Join(Log.Tmp1, ", "), Val2);
            }
            Log.Tmp1 = Operator.Join(Log.Tmp1, ")");
            Log.Tmp2 = "[ ]";
            If (Variable.Length(SquareIdx) > 0)
            {
                If (IsPlayerBlack == 1)
                {
                    Log.Idx = (65 - SquareIdx);
                }
                Else
                {
                    Log.Idx = SquareIdx;
                }
                Log.Tmp2 = Operator.Join(Operator.Join(" [", Operator.Join(Operator.LetterOf("abcdefgh", IdxToFile[Log.Idx]), (9 - IdxToRank[Log.Idx]))), "]");
            }
            Log.Tmp3 = "[ ]";
            If (Side == 1)
            {
                Log.Tmp3 = "[Engine]";
            }
            Else
            {
                If (Side == 2)
                {
                    Log.Tmp3 = "[Player]";
                }
            }
            Log.Tmp4 = "[ ]";
            If (Variable.Length(Move) > 0)
            {
                If (IsPlayerBlack == 1)
                {
                    Log.SourceIdx = (65 - floor((Move / 100)));
                    Log.TargetIdx = (65 - floor((Move % 100)));
                }
                Else
                {
                    Log.SourceIdx = floor((Move / 100));
                    Log.TargetIdx = floor((Move % 100));
                }
                Log.Tmp4 = Operator.Join(Operator.Join(" [", Operator.Join(Operator.Join(Operator.LetterOf("abcdefgh", IdxToFile[Log.SourceIdx]), (9 - IdxToRank[Log.SourceIdx])), Operator.Join(Operator.LetterOf("abcdefgh", IdxToFile[Log.TargetIdx]), (9 - IdxToRank[Log.TargetIdx])))), "]");
            }
            Call Log(Operator.Join(Key, " = "))(Log.Tmp1)(" ")(Log.Tmp2)(" ")(Log.Tmp4)(" ")(Log.Tmp3);
        }
    }
}

Define OnEvaluationChanged(string Eval) (warp=false)
{
    If (Level > 2)
    {
        If (Eval > 1000)
        {
            GoK_EvaluationValue = 100;
        }
        Else
        {
            If (Eval < -1000)
            {
                GoK_EvaluationValue = -100;
            }
            Else
            {
                GoK_EvaluationValue = (Eval / 10);
            }
        }
    }
    Else
    {
        GoK_EvaluationValue = 0;
    }
    Event.Broadcast("evaluationvaluechanged");
    Control.Wait(0);
}

Define OnProgressChanged(string Progress) (warp=false)
{
    If (Progress < 100)
    {
        GoK_ProgressValue = Progress;
    }
    Else
    {
        GoK_ProgressValue = 100;
    }
    Event.Broadcast("progressvaluechanged");
    Control.Wait(0);
}

Define OnRestart (warp=true)
{
    Looks.Say("");
    List.DeleteAll(Logfile);
    List.Hide(BoardHistory);
    List.Hide(GameMovesAN);
    List.Hide(ExportData);
    List.Hide(ExportMoves);
    List.Hide(Logfile);
    List.Hide(Profile_Data);
    Variable.Hide(IdxDeepening);
    Variable.Hide(BestMinMaxRes);
    Variable.Hide(BestMove);
    Variable.Hide(NPS);
    Variable.Hide(MPS);
    Variable.Hide(PV);
    Variable.Hide(CustomThinkTime);
    ProfilerMode = -1;
    DebugMode = -1;
    TimeControl = -1;
    IdxDeepening = "";
    BestMinMaxRes = "";
    BestMove = "";
    NPS = "";
    MPS = "";
    CustomThinkTime = 0;
}

Define PickMove(string Depth)(bool Quiescence) (warp=true)
{
    Call //("Staged move-generator implementation");
    If (PickPhase[(Depth + 0)] == 1)
    {
        Call //("Phase 1: Look up hash-move from transposition table");
        List.ReplaceItem(HashMoveMetaData, Depth, "");
        List.ReplaceItem(HashMove, Depth, "");
        List.ReplaceItem(PickedMoves, Depth, ":");
        List.ReplaceItem(PickedMoveCount, Depth, 0);
        List.ReplaceItem(PickedMoveCountQuiet, Depth, 0);
        List.ReplaceItem(MovesCount, Depth, 0);
        List.ReplaceItem(MovesIdx, Depth, 0);
        List.ReplaceItem(MovesIdxBestMove, Depth, 0);
        List.DeleteAll(CalcMovesMoveList);
        List.DeleteAll(CalcMovesScoreList);
        List.DeleteAll(TmpList1);
        List.DeleteAll(TmpList2);
        Call ClearMoveList(Depth);
        If ((Depth > 1) Or (1 == 1))
        {
            TTProbeRes = 0;
            TTProbeBestMoveRes = "";
            TTProbeHorizonRes = "";
            If (Depth > 1)
            {
                Call TTProbeNode(CurrentBoardHash)(Depth);
                If (TTProbeRes == 1)
                {
                    If (Not ((TTProbeCheckedRes == "")))
                    {
                        Call //("Retrieve attack tables from TT");
                        List.ReplaceItem(CheckedState, Depth, TTProbeCheckedRes);
                    }
                }
            }
            PM.Move = "";
            PM.Found = 0;
            If (Not ((Depth > List.Length(PVStablePrev))))
            {
                PM.Found = 1;
                Idx = 1;
                IdxSub = 1;
                Repeat Until ((Idx == Depth) Or (PM.Found == 0))
                {
                    If (Not ((AppliedMove[Idx] == PVStablePrev[(IdxSub + 0)])))
                    {
                        PM.Found = 0;
                    }
                    Idx += 1;
                    IdxSub += 1;
                }
                If (PM.Found == 1)
                {
                    PM.Move = PVStablePrev[Depth];
                    If (1 == 1)
                    {
                        Call CalcBoardAttackedOnDemand(Depth)(Quiescence)((1 == 1))(99);
                        List.DeleteAll(CalcMovesMoveList);
                        Call GenerateMovesImplWrapper(Depth)((1 == 0))(Quiescence);
                        PM.Found = 0;
                        If List.ContainsItem(CalcMovesMoveList, PM.Move)
                        {
                            PM.Found = 1;
                        }
                    }
                    If (PM.Found == 1)
                    {
                        TTProbeRes = 1;
                        TTProbeBestMoveRes = PM.Move;
                        If Quiescence
                        {
                            TTProbeHorizonRes = -1;
                        }
                        Else
                        {
                            TTProbeHorizonRes = 1;
                        }
                    }
                }
            }
            If ((TTProbeRes == 1) And (Not ((TTProbeBestMoveRes == ""))))
            {
                PM.SourceIdx = floor((TTProbeBestMoveRes / 100));
                If (((Not (Quiescence)) And (Not ((TTProbeHorizonRes == -1)))) Or (Quiescence And (TTProbeHorizonRes == -1)))
                {
                    Call ClearMoveList(Depth);
                    Call AddMoveToList(TTProbeBestMoveRes)(Depth);
                    List.ReplaceItem(MovesIdx, Depth, 1);
                    Call ApplyMove(Depth);
                    Call GetNormalizedMove(AppliedMove[Depth]);
                    List.ReplaceItem(PickedMoves, Depth, Operator.Join(PickedMoves[(Depth + 0)], Operator.Join(NormalizedMoveRes, ":")));
                    List.ReplaceItem(PickedMoveCount, Depth, (PickedMoveCount[Depth] + 1));
                    If (TargetPieces[Depth] == 0)
                    {
                        List.ReplaceItem(PickedMoveCountQuiet, Depth, (PickedMoveCountQuiet[Depth] + 1));
                    }
                    List.ReplaceItem(PickPhase, Depth, 2);
                    List.ReplaceItem(PickMoveRes, Depth, 1);
                    List.ReplaceItem(HashMove, Depth, AppliedMove[Depth]);
                    List.ReplaceItem(HashMoveMetaData, Depth, (Not ((TargetPieces[Depth] == 0))));
                    Stop(this script);
                }
            }
        }
        List.ReplaceItem(PickPhase, Depth, 2);
    }
    Call //("Phase 2: Search for MVV-LVA captures via attack tables (and from recently moved pieces when attack tables not up-to-date)");
    If (PickPhase[(Depth + 0)] == 2)
    {
        If ((Quiescence Or (Depth < 4)) Or ((CheckedState[(Depth + 0)] == 1) Or (((QueenCountOppLocal + RookMinorCountLocalOpp) + (QueenCounttOwnLocal + RookMinorCounttOwnLocal)) < 5)))
        {
            List.ReplaceItem(PickPhase, Depth, 6);
        }
        Else
        {
            List.ReplaceItem(CastlingState, (Depth + 2), CastlingState[Depth]);
            List.ReplaceItem(EnPassantTarget, (Depth + 2), EnPassantTarget[Depth]);
            Call GenerateMovesImplWrapper((Depth + 2))((1 == 0))((1 == 1));
            If (GenerateMovesRequiresAttackRecalc == 1)
            {
                Call CalcBoardAttackedByMove((Depth + 1));
                Call StoreAttackInfo((Depth + 1))((Depth + 0));
                List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
                Call StoreAttackInfo((Depth + 1))((Depth + 2));
                List.ReplaceItem(BoardAttackedCalculated, (Depth + 2), 1);
                Call GenerateMovesImplWrapper((Depth + 2))((1 == 0))((1 == 1));
            }
            Idx = 1;
            Repeat (List.Length(CalcMovesMoveList))
            {
                If (Not ((abs(CalcMovesScoreList[Idx]) < 7000000)))
                {
                    Call GetNormalizedMove(CalcMovesMoveList[Idx]);
                    If (Not (Operator.Contains(PickedMoves[(Depth + 0)], NormalizedMoveRes)))
                    {
                        Call AddMoveToList(CalcMovesMoveList[Idx])(Depth);
                    }
                }
                Idx += 1;
            }
            List.ReplaceItem(PickPhase, Depth, 3);
        }
    }
    Call //("Phase 3: Return moves found in phase 2 on subsequent PickMove() invocations");
    If (PickPhase[(Depth + 0)] == 3)
    {
        If (MovesIdx[(Depth + 0)] < MovesCount[(Depth + 0)])
        {
            List.ReplaceItem(MovesIdx, Depth, (MovesIdx[(Depth + 0)] + 1));
            Call ApplyMove(Depth);
            Call GetNormalizedMove(AppliedMove[(Depth + 0)]);
            List.ReplaceItem(PickedMoves, Depth, Operator.Join(PickedMoves[(Depth + 0)], Operator.Join(NormalizedMoveRes, ":")));
            List.ReplaceItem(PickedMoveCount, Depth, (PickedMoveCount[(Depth + 0)] + 1));
            If (TargetPieces[Depth] == 0)
            {
                List.ReplaceItem(PickedMoveCountQuiet, Depth, (PickedMoveCountQuiet[Depth] + 1));
            }
            List.ReplaceItem(PickMoveRes, Depth, 1);
            Stop(this script);
        }
        List.ReplaceItem(PickPhase, Depth, 4);
    }
    Call //("Phase 4: Search for killer moves that can be applied on current board");
    If (PickPhase[(Depth + 0)] == 4)
    {
        If ((Quiescence Or (CheckedState[Depth] == 1)) Or ((Depth == 1) Or (1 == 0)))
        {
            List.ReplaceItem(PickPhase, Depth, 6);
        }
        Else
        {
            If (1 == 0)
            {
                Call CalcBoardAttackedOnDemand(Depth)(Quiescence)((1 == 1))(99);
            }
            List.DeleteAll(TmpList1);
            List.DeleteAll(TmpList2);
            FactorOuter = (((Depth % 2) * 2) - 1);
            Call PrepareCurrentKillerMoves(Depth);
            If (Depth > 1)
            {
                CurrentValue = HistoryCounterMoves[(((Depth % 2) * 1000) + ((PieceIdxLookup[abs(SourcePieces[(Depth - 1)])] * 100) + floor((AppliedMove[(Depth - 1)] % 100))))];
                If (Not ((CurrentValue == "")))
                {
                    List.InsertItem(CurrentKillerMoves, 1, CurrentValue);
                }
            }
            IdxOuter3 = List.Length(CurrentKillerMoves);
            Repeat Until (IdxOuter3 == 0)
            {
                CurrentMoveOuter = CurrentKillerMoves[(IdxOuter3 + 0)];
                SourceIdxOuter2 = floor((CurrentMoveOuter / 100));
                TargetIdxOuter2 = floor((CurrentMoveOuter % 100));
                SourcePiece = Board[(SourceIdxOuter2 + 0)];
                If ((SourceIdxOuter2 > 0) And (Board[(TargetIdxOuter2 + 0)] == 0))
                {
                    If ((SourcePiece * FactorOuter) > 0)
                    {
                        IdxOuter2 = ((PieceIdxLookup[abs(SourcePiece)] * 10000) + ((SourceIdxOuter2 * 100) + TargetIdxOuter2));
                        If ((((Depth % 2) == 1) And (MovePosLookupOwnLegal[(IdxOuter2 + 0)] == 1)) Or (((Depth % 2) == 0) And (MovePosLookupOppLegal[(IdxOuter2 + 0)] == 1)))
                        {
                            Call //("When killer move is applicable, add to temp list");
                            Call StagedMoveGenKillerMoves(Depth)(CurrentMoveOuter)(SourceIdxOuter2)(TargetIdxOuter2)(abs(SourcePiece));
                        }
                    }
                }
                IdxOuter3 += -1;
            }
            If (List.Length(TmpList1) > 0)
            {
                Call //("Convert temp list to move list and sort moves");
                If (List.Length(TmpList1) == 1)
                {
                    Call AddMoveToList(TmpList1[1])(Depth);
                }
                Else
                {
                    List.DeleteAll(CalcMovesMoveList);
                    List.DeleteAll(CalcMovesScoreList);
                    Idx = 1;
                    Repeat (List.Length(TmpList1))
                    {
                        List.Add(CalcMovesMoveList, TmpList1[Idx]);
                        List.Add(CalcMovesScoreList, TmpList2[Idx]);
                        Idx += 1;
                    }
                    Call SortMoveList((Depth + 2));
                    List.ReplaceItem(MovesIdx, (Depth + 2), 1);
                    Repeat (MovesCount[(Depth + 2)])
                    {
                        Call GetCurrentMove((Depth + 2));
                        Call AddMoveToList(CurrentMove)(Depth);
                        List.ReplaceItem(MovesIdx, (Depth + 2), (MovesIdx[(Depth + 2)] + 1));
                    }
                }
            }
            List.ReplaceItem(PickPhase, Depth, 5);
        }
    }
    Call //("Phase 5: Return moves found in phase 4 on subsequent PickMove() invocations");
    If (PickPhase[(Depth + 0)] == 5)
    {
        If (MovesIdx[(Depth + 0)] < MovesCount[(Depth + 0)])
        {
            List.ReplaceItem(MovesIdx, Depth, (MovesIdx[(Depth + 0)] + 1));
            Call ApplyMove(Depth);
            Call GetNormalizedMove(AppliedMove[(Depth + 0)]);
            List.ReplaceItem(PickedMoves, Depth, Operator.Join(PickedMoves[(Depth + 0)], Operator.Join(NormalizedMoveRes, ":")));
            List.ReplaceItem(PickedMoveCount, Depth, (PickedMoveCount[(Depth + 0)] + 1));
            If (TargetPieces[Depth] == 0)
            {
                List.ReplaceItem(PickedMoveCountQuiet, Depth, (PickedMoveCountQuiet[Depth] + 1));
            }
            List.ReplaceItem(PickMoveRes, Depth, 1);
            Stop(this script);
        }
        List.ReplaceItem(PickPhase, Depth, 6);
    }
    Call //("Phase 6: Full move generator for all moves not found yet");
    If (PickPhase[(Depth + 0)] == 6)
    {
        Call CalcBoardAttackedOnDemand(Depth)(Quiescence)((1 == 1))(99);
        Call GenerateMovesImplWrapper(Depth)((1 == 0))((Quiescence Or (CheckedState[(Depth + 0)] == 1)));
        If (GenerateMovesRequiresAttackRecalc == 1)
        {
            Call CalcBoardAttackedByMove((Depth + 1));
            Call StoreAttackInfo((Depth + 1))(Depth);
            List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
            Call GenerateMovesImplWrapper(Depth)((1 == 0))((Quiescence Or (CheckedState[(Depth + 0)] == 1)));
        }
        List.ReplaceItem(MovesIdx, Depth, 0);
        List.ReplaceItem(PickPhase, Depth, 7);
    }
    Call //("Pick next move detected in phase 6, skip those applied in earlier stages");
    If (PickPhase[(Depth + 0)] == 7)
    {
        If (MovesIdx[(Depth + 0)] < MovesCount[(Depth + 0)])
        {
            List.ReplaceItem(MovesIdx, Depth, (MovesIdx[(Depth + 0)] + 1));
            Call GetCurrentMove(Depth);
            Call GetNormalizedMove(CurrentMove);
            If (Variable.Length(PickedMoves[(Depth + 0)]) > 0)
            {
                Repeat Until (Not (Operator.Contains(PickedMoves[(Depth + 0)], NormalizedMoveRes)))
                {
                    List.ReplaceItem(MovesIdx, Depth, (MovesIdx[(Depth + 0)] + 1));
                    If (MovesIdx[(Depth + 0)] > MovesCount[(Depth + 0)])
                    {
                        List.ReplaceItem(PickPhase, Depth, "*");
                        List.ReplaceItem(PickMoveRes, Depth, 0);
                        Stop(this script);
                    }
                    Call GetCurrentMove(Depth);
                    Call GetNormalizedMove(CurrentMove);
                }
            }
            Call ApplyMove(Depth);
            List.ReplaceItem(PickMoveRes, Depth, 1);
            List.ReplaceItem(PickedMoves, Depth, Operator.Join(PickedMoves[(Depth + 0)], Operator.Join(NormalizedMoveRes, ":")));
            List.ReplaceItem(PickedMoveCount, Depth, (PickedMoveCount[(Depth + 0)] + 1));
            If (TargetPieces[Depth] == 0)
            {
                List.ReplaceItem(PickedMoveCountQuiet, Depth, (PickedMoveCountQuiet[Depth] + 1));
            }
            Stop(this script);
        }
        List.ReplaceItem(PickPhase, Depth, "*");
        List.ReplaceItem(PickMoveRes, Depth, 0);
    }
    List.ReplaceItem(PickMoveRes, Depth, 0);
}

Define PrepareCurrentKillerMoves(string Depth) (warp=true)
{
    List.DeleteAll(CurrentKillerMoves);
    Idx = (((Depth - 1) * 2) + 1);
    List.Add(CurrentKillerMoves, KillerMoves[Idx]);
    List.Add(CurrentKillerMoves, KillerMoves[(Idx + 1)]);
}

Define PrepareEvalPiecesData(string Depth) (warp=true)
{
    Call GetEndgameLocal;
    If ((IsScratch3 == 1) Or ((((QueenCountOppLocal + QueenCounttOwnLocal) + (RookCountOppLocal + RookCounttOwnLocal)) == 0) Or ((((QueenCountOppLocal + QueenCounttOwnLocal) + (RookCountOppLocal + RookCounttOwnLocal)) < 2) And ((RookMinorCountLocalOpp + RookMinorCounttOwnLocal) == 0))))
    {
        IsExtendedEvalLocal = 0;
    }
    Else
    {
        IsExtendedEvalLocal = 1;
    }
    If (Eval.DebugLog == 1)
    {
        Call Log("IsExtendedEvalLocal =")(IsExtendedEvalLocal)("")("")("")("")("")("");
    }
    List.DeleteAll(EvalPiecesIdx_All);
    List.DeleteAll(EvalPiecesIdx_Pawns);
    List.DeleteAll(EvalPiecesIdx_NonPawns);
    List.DeleteAll(EvalPiecesIdx_Rooks);
    SingleBishopIdxOppLocal = 0;
    SingleBishopIdxtOwnLocal = 0;
    Idx = 1;
    Repeat (64)
    {
        CurrentPiece = Board[(Idx + 0)];
        If (Not ((CurrentPiece == 0)))
        {
            CurrentPieceAbs = abs(CurrentPiece);
            List.Add(EvalPiecesIdx_All, Idx);
            If (CurrentPieceAbs == GoK_OwnPawn)
            {
                List.Add(EvalPiecesIdx_Pawns, Idx);
            }
            Else
            {
                List.Add(EvalPiecesIdx_NonPawns, Idx);
                If (CurrentPieceAbs == GoK_OwnRook)
                {
                    List.Add(EvalPiecesIdx_Rooks, Idx);
                }
                Else
                {
                    If (CurrentPiece == GoK_OppBishop)
                    {
                        If (BishopCountOppLocal == 1)
                        {
                            SingleBishopIdxOppLocal = Idx;
                        }
                    }
                    Else
                    {
                        If (CurrentPiece == GoK_OwnBishop)
                        {
                            If (BishopCounttOwnLocal == 1)
                            {
                                SingleBishopIdxtOwnLocal = Idx;
                            }
                        }
                    }
                }
            }
        }
        Idx += 1;
    }
    List.DeleteItem(PawnCountOwn, all);
    List.DeleteItem(PawnCountOpp, all);
    Repeat (8)
    {
        List.Add(PawnCountOwn, 0);
        List.Add(PawnCountOpp, 0);
    }
    List.DeleteItem(PawnAdvancePerFile, all);
    Repeat (32)
    {
        List.Add(PawnAdvancePerFile, 0);
    }
    EvalPieceIdx = 1;
    Repeat (List.Length(EvalPiecesIdx_Pawns))
    {
        Idx = (EvalPiecesIdx_Pawns[(EvalPieceIdx + 0)] + 0);
        CurrentPiece = (Board[(Idx + 0)] + 0);
        File = (IdxToFile[(Idx + 0)] + 0);
        Rank = (IdxToRank[(Idx + 0)] + 0);
        If (CurrentPiece > 0)
        {
            List.ReplaceItem(PawnCountOwn, (File + 0), (PawnCountOwn[(File + 0)] + 1));
            If ((PawnAdvancePerFile[(File + 16)] == 0) Or (Rank < PawnAdvancePerFile[(File + 16)]))
            {
                List.ReplaceItem(PawnAdvancePerFile, (File + 16), Rank);
            }
            If (Rank > PawnAdvancePerFile[(File + 24)])
            {
                List.ReplaceItem(PawnAdvancePerFile, (File + 24), Rank);
            }
        }
        Else
        {
            List.ReplaceItem(PawnCountOpp, (File + 0), (PawnCountOpp[(File + 0)] + 1));
            If (Rank > PawnAdvancePerFile[(File + 0)])
            {
                List.ReplaceItem(PawnAdvancePerFile, (File + 0), Rank);
            }
            If ((PawnAdvancePerFile[(File + 8)] == 0) Or (Rank < PawnAdvancePerFile[(File + 8)]))
            {
                List.ReplaceItem(PawnAdvancePerFile, (File + 8), Rank);
            }
        }
        EvalPieceIdx += 1;
    }
    Idx = 1;
    Repeat (64)
    {
        List.ReplaceItem(PieceMobility, (Idx + 0), 0);
        List.ReplaceItem(PieceMobilityPrep, (((Idx - 1) * 32) + 1), 0);
        Idx += 1;
    }
    If (IsExtendedEvalLocal == 0)
    {
        Call ClearBoardAttackedByMove((Depth + 1));
        Call ClearBoardAttackedByMove((Depth + 2));
    }
    Else
    {
        CalcAttackStateWithMobility = 1;
        Call CalcBoardAttackedByMove((Depth + 1));
        Call CalcBoardAttackedByMove((Depth + 2));
        CalcAttackStateWithMobility = 0;
        EvalPieceIdx = 1;
        Repeat (List.Length(EvalPiecesIdx_NonPawns))
        {
            Idx = (EvalPiecesIdx_NonPawns[(EvalPieceIdx + 0)] + 0);
            CurrentPiece = (Board[(Idx + 0)] + 0);
            IdxSub = (((Idx - 1) * 32) + 1);
            Count1 = (PieceMobilityPrep[(IdxSub + 0)] + 0);
            IdxSub += 1;
            Repeat (Count1)
            {
                TargetIdx = (PieceMobilityPrep[(IdxSub + 0)] + 0);
                If (CurrentPiece > 0)
                {
                    If ((BoardAttackedByOpp[(TargetIdx + 0)] == 0) And (Not ((Board[(TargetIdx + 0)] > 0))))
                    {
                        List.ReplaceItem(PieceMobility, (Idx + 0), (PieceMobility[(Idx + 0)] + 1));
                    }
                }
                Else
                {
                    If ((BoardAttackedByOwn[(TargetIdx + 0)] == 0) And (Not ((Board[(TargetIdx + 0)] < 0))))
                    {
                        List.ReplaceItem(PieceMobility, (Idx + 0), (PieceMobility[(Idx + 0)] + 1));
                    }
                }
                IdxSub += 1;
            }
            EvalPieceIdx += 1;
        }
    }
    If (Eval.DebugLog == 1)
    {
        Call Log("BoardAttackedByOpp= ")(BoardAttackedByOpp)("")("")("")("")("")("");
        Call Log("BoardAttackedByOwn = ")(BoardAttackedByOwn)("")("")("")("")("")("");
        Call Log("PieceMobility = ")(PieceMobility)("")("")("")("")("")("");
    }
}

Define Profile_MethodEnter(num Id) (warp=true)
{
    Repeat Until (Not ((List.Length(Profile_Data) < Id)))
    {
        List.Add(Profile_Data, 0);
    }
    List.ReplaceItem(Profile_Data, Id, (Profile_Data[Id] - ((Sensing.DaysSince2000() * 24) * 3600)));
}

Define Profile_MethodExit(num Id) (warp=false)
{
    List.ReplaceItem(Profile_Data, Id, (Profile_Data[Id] + ((Sensing.DaysSince2000() * 24) * 3600)));
}

Define Profile_Reset (warp=true)
{
    List.DeleteItem(Profile_Data, all);
}

Define QuickSort (warp=true)
{
    List.DeleteAll(QSPartStack);
    Call QuickSortImpl(1)(List.Length(CalcMovesScoreList));
}

Define QuickSortImpl(string Lo)(string Hi) (warp=true)
{
    QSPivot = CalcMovesScoreList[floor(((Lo + Hi) / 2))];
    QSLower = Lo;
    QSUpper = Hi;
    Repeat Until (QSLower > QSUpper)
    {
        Repeat Until (Not ((CalcMovesScoreList[(QSLower + 0)] < QSPivot)))
        {
            QSLower += 1;
        }
        Repeat Until (Not ((CalcMovesScoreList[(QSUpper + 0)] > QSPivot)))
        {
            QSUpper += -1;
        }
        If (Not ((QSLower > QSUpper)))
        {
            QSSwap = CalcMovesScoreList[(QSLower + 0)];
            List.ReplaceItem(CalcMovesScoreList, (QSLower + 0), CalcMovesScoreList[(QSUpper + 0)]);
            List.ReplaceItem(CalcMovesScoreList, (QSUpper + 0), QSSwap);
            QSSwap = CalcMovesMoveList[(QSLower + 0)];
            List.ReplaceItem(CalcMovesMoveList, (QSLower + 0), CalcMovesMoveList[(QSUpper + 0)]);
            List.ReplaceItem(CalcMovesMoveList, (QSUpper + 0), QSSwap);
            QSLower += 1;
            QSUpper += -1;
        }
    }
    If (Lo < QSUpper)
    {
        List.Add(QSPartStack, QSLower);
        Call QuickSortImpl(Lo)(QSUpper);
        QSLower = QSPartStack[(List.Length(QSPartStack) + 0)];
        List.DeleteItem(QSPartStack, (List.Length(QSPartStack) + 0));
    }
    If (QSLower < Hi)
    {
        Call QuickSortImpl(QSLower)(Hi);
    }
}

Define RevertMove(num Depth) (warp=true)
{
    If (Depth == 1)
    {
        Call SetInitialEnPassantTarget(1);
        List.ReplaceItem(CastlingState, (Depth + 0), Operator.Join(Operator.Join(Operator.Join(HasOwnCastled, HasOwnKingMoved), Operator.Join(HasOwnRookKSMoved, HasOwnRookQSMoved)), Operator.Join(Operator.Join(HasOppCastled, HasOppKingMoved), Operator.Join(HasOppRookKSMoved, HasOppRookQSMoved))));
    }
    Else
    {
        List.ReplaceItem(EnPassantTarget, Depth, EnPassantTarget[(Depth - 1)]);
        List.ReplaceItem(CastlingState, Depth, CastlingState[(Depth - 1)]);
    }
    CurrentMove = AppliedMove[(Depth + 0)];
    SourceIdx = floor((CurrentMove / 100));
    If (SourceIdx > 0)
    {
        TargetIdx = floor((CurrentMove % 100));
        List.ReplaceItem(Board, (SourceIdx + 0), Board[(TargetIdx + 0)]);
        List.ReplaceItem(Board, (TargetIdx + 0), 0);
        List.ReplaceItem(Board, TargetPiecesIdx[(Depth + 0)], TargetPieces[(Depth + 0)]);
        If (PromotionPieces[(Depth + 0)] > 0)
        {
            PromotionVal = Operator.LetterOf(CurrentMove, Variable.Length(CurrentMove));
            If (PromotionVal == 1)
            {
                QueenCounttOwnLocal += -1;
            }
            If (PromotionVal == 2)
            {
                RookCounttOwnLocal += -1;
                RookMinorCounttOwnLocal += -1;
            }
            If (PromotionVal == 3)
            {
                BishopCounttOwnLocal += -1;
                RookMinorCounttOwnLocal += -1;
            }
            If (PromotionVal == 4)
            {
                RookMinorCounttOwnLocal += -1;
            }
            List.ReplaceItem(Board, SourceIdx, GoK_OwnPawn);
            PawnCounttOwnLocal += 1;
        }
        Else
        {
            If (PromotionPieces[(Depth + 0)] < 0)
            {
                PromotionVal = Operator.LetterOf(CurrentMove, Variable.Length(CurrentMove));
                If (PromotionVal == 1)
                {
                    QueenCountOppLocal += -1;
                }
                If (PromotionVal == 2)
                {
                    RookCountOppLocal += -1;
                    RookMinorCountLocalOpp += -1;
                }
                If (PromotionVal == 3)
                {
                    BishopCountOppLocal += -1;
                    RookMinorCountLocalOpp += -1;
                }
                If (PromotionVal == 4)
                {
                    RookMinorCountLocalOpp += -1;
                }
                List.ReplaceItem(Board, SourceIdx, GoK_OppPawn);
                PawnCountOppLocal += 1;
            }
        }
        If (Board[(SourceIdx + 0)] == GoK_OwnKing)
        {
            KingIdxtOwn = SourceIdx;
        }
        If (Board[(SourceIdx + 0)] == GoK_OppKing)
        {
            KingIdxOpp = SourceIdx;
        }
        TargetPiece = TargetPieces[(Depth + 0)];
        If (TargetPiece > 0)
        {
            If (TargetPiece == GoK_OwnPawn)
            {
                PawnCounttOwnLocal += 1;
            }
            Else
            {
                If (TargetPiece < GoK_OwnQueen)
                {
                    RookMinorCounttOwnLocal += 1;
                    If (TargetPiece == GoK_OwnRook)
                    {
                        RookCounttOwnLocal += 1;
                    }
                    If (TargetPiece == GoK_OwnBishop)
                    {
                        BishopCounttOwnLocal += 1;
                    }
                }
                Else
                {
                    If (TargetPiece == GoK_OwnQueen)
                    {
                        QueenCounttOwnLocal += 1;
                    }
                    Else
                    {
                        If (TargetPiece == GoK_OwnKing)
                        {
                            KingIdxtOwn = TargetIdx;
                        }
                    }
                }
            }
        }
        If (TargetPiece < 0)
        {
            If (TargetPiece == GoK_OppPawn)
            {
                PawnCountOppLocal += 1;
            }
            Else
            {
                If (TargetPiece > GoK_OppQueen)
                {
                    RookMinorCountLocalOpp += 1;
                    If (TargetPiece == GoK_OppRook)
                    {
                        RookCountOppLocal += 1;
                    }
                    If (TargetPiece == GoK_OppBishop)
                    {
                        BishopCountOppLocal += 1;
                    }
                }
                Else
                {
                    If (TargetPiece == GoK_OppQueen)
                    {
                        QueenCountOppLocal += 1;
                    }
                    Else
                    {
                        If (TargetPiece == GoK_OppKing)
                        {
                            KingIdxOpp = TargetIdx;
                        }
                    }
                }
            }
        }
    }
    Else
    {
        If (CurrentMove == GoK_OppKingsideCastling)
        {
            List.ReplaceItem(Board, VirtualBoard[61], GoK_OppKing);
            List.ReplaceItem(Board, VirtualBoard[62], 0);
            List.ReplaceItem(Board, VirtualBoard[63], 0);
            List.ReplaceItem(Board, VirtualBoard[64], GoK_OppRook);
            KingIdxOpp = VirtualBoard[61];
        }
        Else
        {
            If (CurrentMove == GoK_OppQueensideCastling)
            {
                List.ReplaceItem(Board, VirtualBoard[57], GoK_OppRook);
                List.ReplaceItem(Board, VirtualBoard[59], 0);
                List.ReplaceItem(Board, VirtualBoard[60], 0);
                List.ReplaceItem(Board, VirtualBoard[61], GoK_OppKing);
                KingIdxOpp = VirtualBoard[61];
            }
            Else
            {
                If (CurrentMove == GoK_OwnKingsideCastling)
                {
                    List.ReplaceItem(Board, VirtualBoard[5], GoK_OwnKing);
                    List.ReplaceItem(Board, VirtualBoard[6], 0);
                    List.ReplaceItem(Board, VirtualBoard[7], 0);
                    List.ReplaceItem(Board, VirtualBoard[8], GoK_OwnRook);
                    KingIdxtOwn = VirtualBoard[5];
                }
                Else
                {
                    If (CurrentMove == GoK_OwnQueensideCastling)
                    {
                        List.ReplaceItem(Board, VirtualBoard[1], GoK_OwnRook);
                        List.ReplaceItem(Board, VirtualBoard[4], 0);
                        List.ReplaceItem(Board, VirtualBoard[3], 0);
                        List.ReplaceItem(Board, VirtualBoard[5], GoK_OwnKing);
                        KingIdxtOwn = VirtualBoard[5];
                    }
                }
            }
        }
    }
    CurrentBoardHash = PreviousBoardHash[(Depth + 0)];
    CurrentBoardHash2 = PreviousBoardHash2[(Depth + 0)];
    List.ReplaceItem(AppliedMove, (Depth + 0), "");
    List.ReplaceItem(PosScoreDelta, (Depth + 0), 0);
    List.ReplaceItem(SourcePieces, (Depth + 0), 0);
    List.ReplaceItem(TargetPiecesIdx, (Depth + 0), "");
    List.ReplaceItem(TargetPieces, (Depth + 0), 0);
    List.ReplaceItem(PromotionPieces, (Depth + 0), 0);
    List.DeleteItem(BoardHistoryFiftyMoves, List.Length(BoardHistoryFiftyMoves));
}

Define RevertMoveLight(string Depth) (warp=true)
{
    CurrentMove = AppliedMove[Depth];
    SourceIdx = floor((CurrentMove / 100));
    If (SourceIdx > 0)
    {
        TargetIdx = floor((CurrentMove % 100));
        List.ReplaceItem(Board, SourceIdx, Board[TargetIdx]);
        List.ReplaceItem(Board, TargetIdx, 0);
        List.ReplaceItem(Board, TargetPiecesIdx[Depth], TargetPieces[Depth]);
    }
    Else
    {
        If (CurrentMove == GoK_OppKingsideCastling)
        {
            List.ReplaceItem(Board, VirtualBoard[61], GoK_OppKing);
            List.ReplaceItem(Board, VirtualBoard[62], 0);
            List.ReplaceItem(Board, VirtualBoard[63], 0);
            List.ReplaceItem(Board, VirtualBoard[64], GoK_OppRook);
        }
        Else
        {
            If (CurrentMove == GoK_OppQueensideCastling)
            {
                List.ReplaceItem(Board, VirtualBoard[57], GoK_OppRook);
                List.ReplaceItem(Board, VirtualBoard[59], 0);
                List.ReplaceItem(Board, VirtualBoard[60], 0);
                List.ReplaceItem(Board, VirtualBoard[61], GoK_OppKing);
            }
            Else
            {
                If (CurrentMove == GoK_OwnKingsideCastling)
                {
                    List.ReplaceItem(Board, VirtualBoard[5], GoK_OwnKing);
                    List.ReplaceItem(Board, VirtualBoard[6], 0);
                    List.ReplaceItem(Board, VirtualBoard[7], 0);
                    List.ReplaceItem(Board, VirtualBoard[8], GoK_OwnRook);
                }
                Else
                {
                    If (CurrentMove == GoK_OwnQueensideCastling)
                    {
                        List.ReplaceItem(Board, VirtualBoard[1], GoK_OwnRook);
                        List.ReplaceItem(Board, VirtualBoard[4], 0);
                        List.ReplaceItem(Board, VirtualBoard[3], 0);
                        List.ReplaceItem(Board, VirtualBoard[5], GoK_OwnKing);
                    }
                }
            }
        }
    }
    CurrentBoardHash = PreviousBoardHash[Depth];
    List.ReplaceItem(AppliedMove, (Depth + 0), "");
    List.ReplaceItem(PosScoreDelta, (Depth + 0), 0);
    List.ReplaceItem(SourcePieces, (Depth + 0), 0);
    List.ReplaceItem(TargetPiecesIdx, (Depth + 0), "");
    List.ReplaceItem(TargetPieces, (Depth + 0), 0);
    List.ReplaceItem(PromotionPieces, (Depth + 0), 0);
}

Define SayAsync(string Text)(num Duration) (warp=false)
{
    SayAsyncText = Text;
    SayAsyncDuration = Duration;
    Event.Broadcast("sayasyncmsg");
}

Define SEE(string MoveDepth) (warp=true)
{
    SEE.Depth = MoveDepth;
    SEE.TargetIdx = floor((AppliedMove[SEE.Depth] % 100));
    SEE.Result = (0 - TargetPieces[SEE.Depth]);
    List.DeleteAll(SEE.TmpList3);
    List.DeleteAll(SEE.TmpList4);
    Idx = 1;
    Repeat (List.Length(CalcMovesMoveList))
    {
        List.Add(SEE.TmpList3, CalcMovesMoveList[(Idx + 0)]);
        Idx += 1;
    }
    Idx = 1;
    Repeat (List.Length(CalcMovesScoreList))
    {
        List.Add(SEE.TmpList4, CalcMovesScoreList[(Idx + 0)]);
        Idx += 1;
    }
    If ((MoveDepth % 2) == 1)
    {
        Side = 2;
    }
    Else
    {
        Side = 1;
    }
    IsDone = 0;
    Repeat Until (IsDone == 1)
    {
        List.DeleteAll(CalcMovesMoveList);
        List.DeleteAll(CalcMovesScoreList);
        SEE.SourceIdx = 1;
        Repeat (64)
        {
            SEE.SourcePiece = Board[(SEE.SourceIdx + 0)];
            If (((Side == 1) And (SEE.SourcePiece > 0)) Or ((Side == 2) And (SEE.SourcePiece < 0)))
            {
                If ((Not ((abs(SEE.SourcePiece) == GoK_OwnPawn))) Or (Not ((IdxToFile[(SEE.SourceIdx + 0)] == IdxToFile[(SEE.TargetIdx + 0)]))))
                {
                    SEE.Idx = ((PieceIdxLookup[abs(SEE.SourcePiece)] * 10000) + ((SEE.SourceIdx * 100) + SEE.TargetIdx));
                    If (((Side == 1) And (MovePosLookupOwnLegal[(SEE.Idx + 0)] == 1)) Or ((Side == 2) And (MovePosLookupOppLegal[(SEE.Idx + 0)] == 1)))
                    {
                        Call SEE.IsCounterCaptureReachable(abs(Board[(SEE.SourceIdx + 0)]))(SEE.SourceIdx)(SEE.TargetIdx);
                        If (IsReachableRes == 1)
                        {
                            List.Add(CalcMovesMoveList, SEE.SourceIdx);
                            List.Add(CalcMovesScoreList, (0 - SEE.SourcePiece));
                        }
                    }
                }
            }
            SEE.SourceIdx += 1;
        }
        If (List.Length(CalcMovesMoveList) == 0)
        {
            IsDone = 1;
        }
        Else
        {
            If ((MaxSearchDepthStackFrames % 2) == 1)
            {
                Call SortMoveList(((MaxSearchDepthStackFrames + 1) - Side));
            }
            Else
            {
                Call SortMoveList((MaxSearchDepthStackFrames - Side));
            }
            SEE.SourceIdx = CalcMovesMoveList[1];
            SEE.SourcePiece = Board[(SEE.SourceIdx + 0)];
            SEE.Move = ((SEE.SourceIdx * 100) + SEE.TargetIdx);
            SEE.Depth += 1;
            Call ClearMoveList(SEE.Depth);
            Call AddMoveToList(SEE.Move)(SEE.Depth);
            List.ReplaceItem(MovesIdx, SEE.Depth, 1);
            Call ApplyMoveLight(SEE.Depth);
            If (abs(TargetPieces[SEE.Depth]) == GoK_OwnKing)
            {
                SEE.Result += TargetPieces[(SEE.Depth - 1)];
                IsDone = 1;
            }
            Else
            {
                SEE.Result += (0 - TargetPieces[SEE.Depth]);
                If (Side == 1)
                {
                    If (SEE.Result < 0)
                    {
                        IsDone = 1;
                    }
                }
                Else
                {
                    If (SEE.Result > 0)
                    {
                        IsDone = 1;
                    }
                }
            }
            MoveCountQ += 1;
            NodeCountQ += 1;
            If (Side == 1)
            {
                Side = 2;
            }
            Else
            {
                Side = 1;
            }
        }
    }
    Repeat Until (SEE.Depth == MoveDepth)
    {
        Call RevertMoveLight(SEE.Depth);
        SEE.Depth += -1;
    }
    List.DeleteAll(CalcMovesMoveList);
    List.DeleteAll(CalcMovesScoreList);
    Idx = 1;
    Repeat (List.Length(SEE.TmpList3))
    {
        List.Add(CalcMovesMoveList, SEE.TmpList3[(Idx + 0)]);
        Idx += 1;
    }
    Idx = 1;
    Repeat (List.Length(SEE.TmpList4))
    {
        List.Add(CalcMovesScoreList, SEE.TmpList4[(Idx + 0)]);
        Idx += 1;
    }
}

Define SEE.IsCounterCaptureReachable(string SourcePieceAbs)(string SourceIdx)(string TargetIdx) (warp=true)
{
    IsReachableRes = 0;
    If ((SourcePieceAbs == GoK_OwnKing) Or (SourcePieceAbs == GoK_OwnKnight))
    {
        IsReachableRes = 1;
        Stop(this script);
    }
    If (SourcePieceAbs == GoK_OwnPawn)
    {
        If (Not ((IdxToFile[(SourceIdx + 0)] == IdxToFile[(TargetIdx + 0)])))
        {
            IsReachableRes = 1;
        }
        Stop(this script);
    }
    SEECC.Idx = ((SourceIdx * 100) + TargetIdx);
    SEECC.SourceIdx = SourceIdx;
    Repeat ((MovePathDelta[(SEECC.Idx + 0)] - 1))
    {
        SEECC.SourceIdx += MovePathStepInc[(SEECC.Idx + 0)];
        If (Not ((Board[(SEECC.SourceIdx + 0)] == 0)))
        {
            Stop(this script);
        }
    }
    IsReachableRes = 1;
}

Define SetCastlingStateFlag(string Depth)(string Offset)(string Val) (warp=true)
{
    CurrentValue = CastlingState[Depth];
    If (Not ((Operator.LetterOf(CurrentValue, Offset) == Val)))
    {
        Idx = (((((Operator.LetterOf(CurrentValue, 1) * 128) + (Operator.LetterOf(CurrentValue, 2) * 64)) + ((Operator.LetterOf(CurrentValue, 3) * 32) + (Operator.LetterOf(CurrentValue, 4) * 16))) + (((Operator.LetterOf(CurrentValue, 5) * 8) + (Operator.LetterOf(CurrentValue, 6) * 4)) + ((Operator.LetterOf(CurrentValue, 7) * 2) + Operator.LetterOf(CurrentValue, 8)))) + 1);
        If (Val == 1)
        {
            List.ReplaceItem(CastlingState, Depth, CastlingStateLookup[(Idx + CastlingStatePow2[Offset])]);
        }
        Else
        {
            List.ReplaceItem(CastlingState, Depth, CastlingStateLookup[(Idx - CastlingStatePow2[Offset])]);
        }
    }
}

Define SetInitialEnPassantTarget(string Depth) (warp=true)
{
    List.ReplaceItem(EnPassantTarget, Depth, "");
    Call GetSubstringRight(GameMoves)(4);
    SourceIdx = floor((SubstringRes / 100));
    TargetIdx = floor((SubstringRes % 100));
    If ((abs(Board[TargetIdx]) == GoK_OwnPawn) And (abs((TargetIdx - SourceIdx)) == 16))
    {
        List.ReplaceItem(EnPassantTarget, Depth, TargetIdx);
    }
}

Define SortMoveList(string Depth) (warp=true)
{
    If ((Depth % 2) == 1)
    {
        Idx = 1;
        Repeat (List.Length(CalcMovesScoreList))
        {
            List.ReplaceItem(CalcMovesScoreList, (Idx + 0), (0 - CalcMovesScoreList[(Idx + 0)]));
            Idx += 1;
        }
    }
    If (Depth == 1)
    {
        List.DeleteAll(Moves1);
    }
    If (Depth == 2)
    {
        List.DeleteAll(Moves2);
    }
    If (List.Length(CalcMovesMoveList) > 1)
    {
        Call QuickSort;
    }
    IdxSub = ((Depth - 1) * MaxMovesPerGeneration);
    Idx = 1;
    Repeat (List.Length(CalcMovesMoveList))
    {
        List.ReplaceItem(Moves, (IdxSub + Idx), CalcMovesMoveList[(Idx + 0)]);
        If (Depth == 1)
        {
            List.Add(Moves1, CalcMovesMoveList[(Idx + 0)]);
        }
        If (Depth == 2)
        {
            List.Add(Moves2, CalcMovesMoveList[(Idx + 0)]);
        }
        Idx += 1;
    }
    List.ReplaceItem(MovesCount, Depth, List.Length(CalcMovesMoveList));
    If ((Depth % 2) == 1)
    {
        Idx = 1;
        Repeat (List.Length(CalcMovesScoreList))
        {
            List.ReplaceItem(CalcMovesScoreList, (Idx + 0), (0 - CalcMovesScoreList[(Idx + 0)]));
            Idx += 1;
        }
    }
}

Define StagedMoveGenKillerMoves(string Depth)(string Move)(string FromIdx)(string ToIdx)(string SourcePieceAbs) (warp=true)
{
    If List.ContainsItem(TmpList1, Move)
    {
        Stop(this script);
    }
    Call GetNormalizedMove(Move);
    If Operator.Contains(PickedMoves[(Depth + 0)], NormalizedMoveRes)
    {
        Stop(this script);
    }
    If (SourcePieceAbs == GoK_OwnPawn)
    {
        If ((ToIdx > 56) Or (ToIdx < 9))
        {
            Stop(this script);
        }
        If (abs((ToIdx - FromIdx)) == 16)
        {
            If (Not ((Board[((ToIdx + FromIdx) / 2)] == 0)))
            {
                Stop(this script);
            }
        }
        If (Not ((IdxToFile[(FromIdx + 0)] == IdxToFile[(ToIdx + 0)])))
        {
            Stop(this script);
        }
    }
    If (SourcePieceAbs == GoK_OwnKing)
    {
        If (BoardAttackedCalculated[(Depth + 0)] == 0)
        {
            Stop(this script);
        }
        If (PersistedBoardAttackedByOppSnapshot[(((Depth - 1) * 100) + ToIdx)] > 0)
        {
            Stop(this script);
        }
    }
    If (SourcePieceAbs > GoK_OwnKnight)
    {
        SourceIdx = FromIdx;
        IdxInc = MovePathStepInc[(Move + 0)];
        Repeat ((MovePathDelta[(Move + 0)] - 1))
        {
            SourceIdx += IdxInc;
            If (Not ((Board[(SourceIdx + 0)] == 0)))
            {
                Stop(this script);
            }
        }
    }
    Call GetMoveScore(Board[(FromIdx + 0)])(Board[(ToIdx + 0)])(FromIdx)(ToIdx)(Move)(Depth);
    List.Add(TmpList1, Move);
    List.Add(TmpList2, MoveScoreRes);
}

Define StoreAttackInfo(string Depth)(string StoreDepth) (warp=true)
{
    If ((Depth % 2) == 1)
    {
        If ((StoreDepth % 2) == 0)
        {
            Idx = 1;
            IdxSub = (((StoreDepth - 1) * 100) + 1);
            Repeat (64)
            {
                List.ReplaceItem(PersistedBoardAttackedByOppSnapshot, IdxSub, BoardAttackedByOwn[Idx]);
                List.ReplaceItem(PersistedBoardAttackedByOppPieceSnapshot, IdxSub, BoardAttackedByOwnPiece[Idx]);
                Idx += 1;
                IdxSub += 1;
            }
            List.ReplaceItem(CheckedState, StoreDepth, IsOppSideChecked);
            If (IsOppSideChecked == 0)
            {
                List.ReplaceItem(CheckedStateAttackLines, StoreDepth, "");
            }
            Else
            {
                CurrentValue = "";
                Idx = 1;
                Repeat (64)
                {
                    If List.ContainsItem(KingAttackLines, Idx)
                    {
                        CurrentValue = Operator.Join(CurrentValue, 1);
                    }
                    Else
                    {
                        CurrentValue = Operator.Join(CurrentValue, 0);
                    }
                    Idx += 1;
                }
                List.ReplaceItem(CheckedStateAttackLines, StoreDepth, CurrentValue);
            }
            Call TTStoreNode(CurrentBoardHash)(StoreDepth)("")("")("")(CheckedState[StoreDepth])("")("")("")("")("")("")("");
        }
    }
    Else
    {
        If ((StoreDepth % 2) == 1)
        {
            Idx = 1;
            IdxSub = (((StoreDepth - 1) * 100) + 1);
            Repeat (64)
            {
                List.ReplaceItem(PersistedBoardAttackedByOppSnapshot, IdxSub, BoardAttackedByOpp[Idx]);
                List.ReplaceItem(PersistedBoardAttackedByOppPieceSnapshot, IdxSub, BoardAttackedByOppPiece[Idx]);
                Idx += 1;
                IdxSub += 1;
            }
            List.ReplaceItem(CheckedState, StoreDepth, IsOwnSideChecked);
            If (IsOwnSideChecked == 0)
            {
                List.ReplaceItem(CheckedStateAttackLines, StoreDepth, "");
            }
            Else
            {
                CurrentValue = "";
                Idx = 1;
                Repeat (64)
                {
                    If List.ContainsItem(KingAttackLines, Idx)
                    {
                        CurrentValue = Operator.Join(CurrentValue, 1);
                    }
                    Else
                    {
                        CurrentValue = Operator.Join(CurrentValue, 0);
                    }
                    Idx += 1;
                }
                List.ReplaceItem(CheckedStateAttackLines, StoreDepth, CurrentValue);
            }
            Call TTStoreNode(CurrentBoardHash)(StoreDepth)("")("")("")(CheckedState[StoreDepth])("")("")("")("")("")("")("");
        }
    }
}

Define StoreKillerMove(string Depth)(string Move)(string MaxDepth) (warp=true)
{
    IdxSub = (((Depth - 1) * 2) + 1);
    If (Not ((KillerMoves[(IdxSub + 1)] == Move)))
    {
        List.ReplaceItem(KillerMoves, IdxSub, KillerMoves[(IdxSub + 1)]);
        List.ReplaceItem(KillerMoves, (IdxSub + 1), Move);
    }
    Idx = (((Depth % 2) * 1000) + ((PieceIdxLookup[abs(Board[floor((Move / 100))])] * 100) + floor((Move % 100))));
    CurrentValue = (HistoryMoveScores[Idx] + ((MaxDepth - Depth) * (MaxDepth - Depth)));
    List.ReplaceItem(HistoryMoveScores, Idx, CurrentValue);
    If (CurrentValue > MaxHistoryMoveScore[((Depth % 2) + 1)])
    {
        List.ReplaceItem(MaxHistoryMoveScore, ((Depth % 2) + 1), CurrentValue);
    }
    If (Depth > 1)
    {
        List.ReplaceItem(HistoryCounterMoves, (((Depth % 2) * 1000) + ((PieceIdxLookup[abs(SourcePieces[(Depth - 1)])] * 100) + floor((AppliedMove[(Depth - 1)] % 100)))), Move);
    }
    Idx = -1;
    If (Depth > 1)
    {
        Idx = ((((PieceIdxLookup[abs(SourcePieces[(Depth - 1)])] * 64) + floor((AppliedMove[(Depth - 1)] % 100))) * 384) + ((PieceIdxLookup[abs(Board[floor((Move / 100))])] * 64) + floor((Move % 100))));
    }
    Else
    {
        If (Not ((PrevPly1Move == "")))
        {
            Idx = ((((PieceIdxLookup[abs(Board[floor((PrevPly1Move % 100))])] * 64) + floor((PrevPly1Move % 100))) * 384) + ((PieceIdxLookup[abs(Board[floor((Move / 100))])] * 64) + floor((Move % 100))));
        }
    }
    If (Not ((Idx == -1)))
    {
        If ((Depth % 2) == 1)
        {
            List.ReplaceItem(HistoryContinuationOwn, Idx, (HistoryContinuationOwn[Idx] + ((MaxDepth - Depth) * (MaxDepth - Depth))));
        }
        Else
        {
            List.ReplaceItem(HistoryContinuationOpp, Idx, (HistoryContinuationOpp[Idx] + ((MaxDepth - Depth) * (MaxDepth - Depth))));
        }
    }
    If (Depth > 2)
    {
        Idx = ((((PieceIdxLookup[abs(SourcePieces[(Depth - 2)])] * 64) + floor((AppliedMove[(Depth - 2)] % 100))) * 384) + ((PieceIdxLookup[abs(Board[floor((Move / 100))])] * 64) + floor((Move % 100))));
        If ((Depth % 2) == 1)
        {
            List.ReplaceItem(HistoryContinuation2Own, Idx, (HistoryContinuation2Own[Idx] + ((MaxDepth - Depth) * (MaxDepth - Depth))));
        }
        Else
        {
            List.ReplaceItem(HistoryContinuation2Opp, Idx, (HistoryContinuation2Opp[Idx] + ((MaxDepth - Depth) * (MaxDepth - Depth))));
        }
    }
}

Define StoreMinMaxDrawResult(string BoardHash)(string Depth) (warp=true)
{
    List.ReplaceItem(MinMaxResults, Depth, 0);
    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
    Call TTStoreNode(BoardHash)(Depth)(0)("")("E")("")(99)("")("")("")("")("")(0);
}

Define TaperedEval.Add(string Mg)(string Eg)(string LogKey)(string LogSquare)(string LogSide)(string LogMove) (warp=true)
{
    TaperedEval.Mg += Mg;
    TaperedEval.Eg += Eg;
    Call LogPVEvalLine(LogKey)(Mg)(Eg)(LogSquare)(LogSide)(LogMove);
}

Define TaperedEval.AddIdentical(string Val)(string LogKey)(string LogSquare)(string LogSide)(string LogMove) (warp=true)
{
    TaperedEval.Mg += Val;
    TaperedEval.Eg += Val;
    Call LogPVEvalLine(LogKey)(Val)(Val)(LogSquare)(LogSide)(LogMove);
}

Define TaperedEval.GetPiecePosResult(string Piece)(string Idx) (warp=true)
{
    TaperedEval.PiecePosResult = 0;
    IdxSub2 = ((PieceIdxLookup[abs(Piece)] * 10000) + Idx);
    If (Piece > 0)
    {
        Call TaperedEval.GetScalarResult(MovePosLookupMgOwn[IdxSub2])(MovePosLookupOwnEg[IdxSub2])(TaperedEval.ScaleFactor)(TaperedEval.Phase);
        TaperedEval.PiecePosResult = TaperedEval.ScalarResult;
    }
    Else
    {
        If (Piece < 0)
        {
            Call TaperedEval.GetScalarResult(MovePosLookupOppMg[IdxSub2])(MovePosLookupOppEg[IdxSub2])(TaperedEval.ScaleFactor)(TaperedEval.Phase);
            TaperedEval.PiecePosResult = TaperedEval.ScalarResult;
        }
    }
}

Define TaperedEval.GetScalarResult(string Mg)(string Eg)(string ScaleFactor)(string ScalePhase) (warp=true)
{
    TaperedEval.ScalarResult = Operator.Round((((Mg * ScalePhase) + (Eg * ((128 - ScalePhase) * (ScaleFactor / 128)))) / 128));
}

Define TaperedEval.GetSumResult (warp=true)
{
    Call TaperedEval.GetScalarResult(TaperedEval.Mg)(TaperedEval.Eg)(TaperedEval.ScaleFactor)(TaperedEval.Phase);
    TaperedEval.SumResult = TaperedEval.ScalarResult;
}

Define TaperedEval.Init (warp=true)
{
    TaperedEval.Eg = 0;
    TaperedEval.Mg = 0;
    TaperedEval.SumResult = 0;
    TaperedEval.MaterialOwn = ((QueenCounttOwnLocal * 14) + ((RookCounttOwnLocal * 6) + ((RookMinorCounttOwnLocal - RookCounttOwnLocal) * 3)));
    TaperedEval.MaterialOpp = ((QueenCountOppLocal * 14) + ((RookCountOppLocal * 6) + ((RookMinorCountLocalOpp - RookCountOppLocal) * 3)));
    TaperedEval.Material = (TaperedEval.MaterialOpp + TaperedEval.MaterialOwn);
    If (TaperedEval.Material > 76)
    {
        TaperedEval.Material = 76;
    }
    If (TaperedEval.Material < 8)
    {
        TaperedEval.Material = 8;
    }
    TaperedEval.Phase = Operator.Round((((TaperedEval.Material - 8) * 128) / (76 - 8)));
    TaperedEval.MaterialOpp += PawnCountOppLocal;
    TaperedEval.MaterialOwn += PawnCounttOwnLocal;
    If ((1 == 1) And ((((BishopCounttOwnLocal == 1) And (BishopCountOppLocal == 1)) And (((QueenCountOppLocal + (RookCountOppLocal + RookMinorCountLocalOpp)) == 1) And ((QueenCounttOwnLocal + (RookCounttOwnLocal + RookMinorCounttOwnLocal)) == 1))) And (Not ((((IdxToFile[SingleBishopIdxtOwnLocal] + IdxToRank[SingleBishopIdxtOwnLocal]) % 2) == ((IdxToFile[SingleBishopIdxOppLocal] + IdxToRank[SingleBishopIdxOppLocal]) % 2))))))
    {
        If (TaperedEval.MaterialOpp > TaperedEval.MaterialOwn)
        {
            TaperedEval.ScaleFactor = (42 + (6 * ((RookMinorCountLocalOpp - RookCountOppLocal) + PawnCountOppLocal)));
        }
        Else
        {
            TaperedEval.ScaleFactor = (42 + (6 * ((RookMinorCounttOwnLocal - RookCounttOwnLocal) + PawnCounttOwnLocal)));
        }
    }
    Else
    {
        If ((QueenCountOppLocal + QueenCounttOwnLocal) == 1)
        {
            If (QueenCountOppLocal == 1)
            {
                TaperedEval.ScaleFactor = (74 + (6 * (RookMinorCountLocalOpp - RookCountOppLocal)));
            }
            Else
            {
                TaperedEval.ScaleFactor = (74 + (6 * (RookMinorCounttOwnLocal + RookCounttOwnLocal)));
            }
        }
        Else
        {
            If ((1 == 1) And ((((QueenCountOppLocal == 0) And (QueenCounttOwnLocal == 0)) And ((RookMinorCountLocalOpp < 2) And (RookMinorCounttOwnLocal < 2))) And (((TaperedEval.MaterialOpp > TaperedEval.MaterialOwn) And ((PawnCountOppLocal - PawnCounttOwnLocal) > 2)) Or ((TaperedEval.MaterialOwn > TaperedEval.MaterialOpp) And ((PawnCounttOwnLocal - PawnCountOppLocal) > 2)))))
            {
                If (TaperedEval.MaterialOpp > TaperedEval.MaterialOwn)
                {
                    TaperedEval.ScaleFactor = (136 + (3 * PawnCountOppLocal));
                }
                Else
                {
                    TaperedEval.ScaleFactor = (136 + (3 * PawnCounttOwnLocal));
                }
            }
            Else
            {
                If (TaperedEval.MaterialOpp > TaperedEval.MaterialOwn)
                {
                    TaperedEval.ScaleFactor = (72 + (14 * PawnCountOppLocal));
                }
                Else
                {
                    TaperedEval.ScaleFactor = (72 + (14 * PawnCounttOwnLocal));
                }
                If (TaperedEval.ScaleFactor > 128)
                {
                    TaperedEval.ScaleFactor = 128;
                }
            }
        }
    }
    If (TaperedEval.MaterialOpp > TaperedEval.MaterialOwn)
    {
        CurrentValue = ((PawnCountOpp[1] + PawnCountOpp[2]) + (PawnCountOpp[3] + PawnCountOpp[4]));
        CurrentValue2 = ((PawnCountOwn[1] + PawnCountOwn[2]) + (PawnCountOwn[3] + PawnCountOwn[4]));
    }
    Else
    {
        CurrentValue = ((PawnCountOpp[5] + PawnCountOpp[6]) + (PawnCountOpp[7] + PawnCountOpp[8]));
        CurrentValue2 = ((PawnCountOwn[5] + PawnCountOwn[6]) + (PawnCountOwn[7] + PawnCountOwn[8]));
    }
    If (Not (((CurrentValue > 0) And (CurrentValue2 > 0))))
    {
        TaperedEval.ScaleFactor += -8;
    }
}

Define TTProbeBoard(string BoardHash)(string Depth) (warp=true)
{
    Call GetTTNodeHash(BoardHash)(Depth);
    Call TTProbeBoardImpl(TTNodeHashResult);
}

Define TTProbeBoardImpl(string BoardHash) (warp=true)
{
    If (TTProbeBoardPrevMiss == BoardHash)
    {
        Stop(this script);
    }
    HashBucket = ((BoardHash % (List.Length(TTBoardHash) - 5)) + 1);
    If (Not ((TTBoardHash[(HashBucket + 0)] == BoardHash)))
    {
        HashBucket += 1;
        If (Not ((TTBoardHash[(HashBucket + 0)] == BoardHash)))
        {
            HashBucket += 1;
            If (Not ((TTBoardHash[(HashBucket + 0)] == BoardHash)))
            {
                HashBucket += 1;
                If (Not ((TTBoardHash[(HashBucket + 0)] == BoardHash)))
                {
                    HashBucket += 1;
                    If (Not ((TTBoardHash[(HashBucket + 0)] == BoardHash)))
                    {
                        TTProbeBoardPrevMiss = BoardHash;
                        TTProbeRes = 0;
                        Stop(this script);
                    }
                }
            }
        }
    }
    TTProbeRes = 1;
    TTProbeBoardScore1Res = TTBoardScore1[(HashBucket + 0)];
    TTProbeBoardScore2Res = TTBoardScore2[(HashBucket + 0)];
    TTProbeBoardScore3Res = TTBoardScore3[(HashBucket + 0)];
    TTProbeBoardScoreSumRes = TTBoardScoreSum[(HashBucket + 0)];
    TTProbeBoardAgeRes = TTBoardAge[(HashBucket + 0)];
}

Define TTProbeNode(string BoardHash)(string Depth) (warp=true)
{
    Call GetTTNodeHash(BoardHash)(Depth);
    Call TTProbeNodeImpl(TTNodeHashResult);
}

Define TTProbeNodeImpl(string NodeHash) (warp=true)
{
    If (TTProbeNodePrevMiss == NodeHash)
    {
        Stop(this script);
    }
    HashBucket = ((NodeHash % (List.Length(TTNodeHash) - 5)) + 1);
    If (Not ((TTNodeHash[(HashBucket + 0)] == (NodeHash + 0))))
    {
        HashBucket += 1;
        If (Not ((TTNodeHash[(HashBucket + 0)] == (NodeHash + 0))))
        {
            HashBucket += 1;
            If (Not ((TTNodeHash[(HashBucket + 0)] == (NodeHash + 0))))
            {
                HashBucket += 1;
                If (Not ((TTNodeHash[(HashBucket + 0)] == (NodeHash + 0))))
                {
                    HashBucket += 1;
                    If (Not ((TTNodeHash[(HashBucket + 0)] == (NodeHash + 0))))
                    {
                        TTProbeNodePrevMiss = NodeHash;
                        TTProbeRes = 0;
                        Stop(this script);
                    }
                }
            }
        }
    }
    TTProbeRes = 1;
    TTProbeBestMoveRes = TTNodeBestMove[(HashBucket + 0)];
    TTProbeNodeScoreRes = TTNodeScore[(HashBucket + 0)];
    TTProbeNodeTypeRes = TTNodeType[(HashBucket + 0)];
    TTProbeCheckedRes = TTNodeChecked[(HashBucket + 0)];
    TTProbeCheckedAttackLinesRes = TTNodeCheckedAttackLines[(HashBucket + 0)];
    TTProbeHorizonRes = TTNodeHorizon[(HashBucket + 0)];
    TTProbeBoardAttackedByOpp = TTNodeBoardAttackedByOpp[(HashBucket + 0)];
    TTProbeBoardAttackedByOppPiece = TTNodeBoardAttackedByOppPiece[(HashBucket + 0)];
    TTProbeNodeAgeRes = TTNodeAge[(HashBucket + 0)];
    TTProbeNodeScoreIsDynamicRes = TTNodeIsDynamic[(HashBucket + 0)];
}

Define TTStoreBoard(string BoardHash)(string Depth)(string BoardScore1)(string BoardScore2)(string BoardScore3)(string BoardScoreSum) (warp=true)
{
    If (IsMinMaxTimeout == 1)
    {
        Stop(this script);
    }
    Call GetTTNodeHash(BoardHash)(Depth);
    Call TTStoreBoardImpl(TTNodeHashResult)(BoardScore1)(BoardScore2)(BoardScore3)(BoardScoreSum);
}

Define TTStoreBoardImpl(string BoardHash)(string BoardScore1)(string BoardScore2)(string BoardScore3)(string BoardScoreSum) (warp=true)
{
    HashBucket = ((BoardHash % (List.Length(TTBoardHash) - 5)) + 1);
    Hash = TTBoardHash[(HashBucket + 0)];
    Idx = 1;
    Repeat Until (((Hash == BoardHash) Or (Hash == 0)) Or (Idx > 4))
    {
        Idx += 1;
        HashBucket += 1;
        Hash = TTBoardHash[(HashBucket + 0)];
    }
    If ((Not ((Hash == BoardHash))) And (Not ((Hash == 0))))
    {
        HashBucket = ((BoardHash % (List.Length(TTBoardHash) - 5)) + 1);
        Idx = 1;
        Repeat Until (TTBoardAge[(HashBucket + 0)] < (TTCurrentAge - 1))
        {
            If (Idx > 4)
            {
                Stop(this script);
            }
            Idx += 1;
            HashBucket += 1;
        }
    }
    If (TTBoardHash[(HashBucket + 0)] == BoardHash)
    {
        If (Not ((BoardScore1 == "")))
        {
            List.ReplaceItem(TTBoardScore1, (HashBucket + 0), BoardScore1);
        }
        If (Not ((BoardScore2 == "")))
        {
            List.ReplaceItem(TTBoardScore2, (HashBucket + 0), BoardScore2);
        }
        If (Not ((BoardScore3 == "")))
        {
            List.ReplaceItem(TTBoardScore3, (HashBucket + 0), BoardScore3);
        }
        If (Not ((BoardScoreSum == "")))
        {
            List.ReplaceItem(TTBoardScoreSum, (HashBucket + 0), BoardScoreSum);
        }
        List.ReplaceItem(TTBoardAge, (HashBucket + 0), TTCurrentAge);
    }
    Else
    {
        List.ReplaceItem(TTBoardHash, (HashBucket + 0), BoardHash);
        List.ReplaceItem(TTBoardScore1, (HashBucket + 0), BoardScore1);
        List.ReplaceItem(TTBoardScore2, (HashBucket + 0), BoardScore2);
        List.ReplaceItem(TTBoardScore3, (HashBucket + 0), BoardScore3);
        List.ReplaceItem(TTBoardScoreSum, (HashBucket + 0), BoardScoreSum);
        List.ReplaceItem(TTBoardAge, (HashBucket + 0), TTCurrentAge);
    }
    TTProbeBoardPrevMiss = -1;
}

Define TTStoreNode(string BoardHash)(string Depth)(string Score)(string BestMove)(string Type)(string Checked)(string Horizon)(string BlackMob)(string WhiteMob)(string BoardAttackedByOpp)(string BoardAttackedByOppPiece)(string CheckedAttackLines)(string IsDynamic) (warp=true)
{
    If (IsMinMaxTimeout == 1)
    {
        Stop(this script);
    }
    If (Score == DrawByRepetitionEval)
    {
        Stop(this script);
    }
    If (Score == 0)
    {
        Stop(this script);
    }
    If (Score > AbsMinCheckmateEval)
    {
        Stop(this script);
    }
    If (ChebyshevDistance[((KingIdxtOwn * 100) + KingIdxOpp)] == 1)
    {
        Stop(this script);
    }
    Call GetTTNodeHash(BoardHash)(Depth);
    Call TTStoreNodeImpl(TTNodeHashResult)(Depth)(Score)(BestMove)(Type)(Checked)(Horizon)(BlackMob)(WhiteMob)(BoardAttackedByOpp)(BoardAttackedByOppPiece)(CheckedAttackLines)(IsDynamic);
}

Define TTStoreNodeImpl(string NodeHash)(string Depth)(string Score)(string BestMove)(string Type)(string Checked)(string Horizon)(string BlackMob)(string WhiteMob)(string BoardAttackedByOpp)(string BoardAttackedByOppPiece)(string CheckedAttackLines)(string IsDynamic) (warp=true)
{
    HashBucket = ((NodeHash % (List.Length(TTNodeHash) - 5)) + 1);
    Hash = TTNodeHash[(HashBucket + 0)];
    Idx = 1;
    Repeat Until (((Hash == NodeHash) Or (Hash == 0)) Or (Idx > 4))
    {
        Idx += 1;
        HashBucket += 1;
        Hash = TTNodeHash[(HashBucket + 0)];
    }
    If ((Not ((Hash == NodeHash))) And (Not ((Hash == 0))))
    {
        HashBucket = ((NodeHash % (List.Length(TTNodeHash) - 5)) + 1);
        Idx = 1;
        Repeat Until (TTNodeAge[(HashBucket + 0)] < (TTCurrentAge - 1))
        {
            If (Idx > 4)
            {
                Stop(this script);
            }
            Idx += 1;
            HashBucket += 1;
        }
    }
    If (TTNodeHash[(HashBucket + 0)] == NodeHash)
    {
        If (Not ((BoardAttackedByOpp == "")))
        {
            List.ReplaceItem(TTNodeBoardAttackedByOpp, (HashBucket + 0), BoardAttackedByOpp);
            List.ReplaceItem(TTNodeBoardAttackedByOppPiece, (HashBucket + 0), BoardAttackedByOppPiece);
            List.ReplaceItem(TTNodeCheckedAttackLines, (HashBucket + 0), CheckedAttackLines);
        }
        If (Not ((Checked == "")))
        {
            List.ReplaceItem(TTNodeChecked, (HashBucket + 0), Checked);
        }
        HorizonLoc = TTNodeHorizon[(HashBucket + 0)];
        If (((Not ((Score == ""))) And (Not ((Horizon == "")))) And (((Not ((Horizon < HorizonLoc))) Or (HorizonLoc == "")) Or (TTNodeScore[(HashBucket + 0)] == "")))
        {
            List.ReplaceItem(TTNodeType, (HashBucket + 0), Type);
            List.ReplaceItem(TTNodeScore, (HashBucket + 0), Score);
            List.ReplaceItem(TTNodeHorizon, (HashBucket + 0), Horizon);
            List.ReplaceItem(TTNodeAge, (HashBucket + 0), TTCurrentAge);
            List.ReplaceItem(TTNodeIsDynamic, (HashBucket + 0), IsDynamic);
            List.ReplaceItem(TTNodeBestMove, (HashBucket + 0), BestMove);
        }
    }
    Else
    {
        List.ReplaceItem(TTNodeHash, (HashBucket + 0), NodeHash);
        List.ReplaceItem(TTNodeDepth, (HashBucket + 0), Depth);
        List.ReplaceItem(TTNodeHorizon, (HashBucket + 0), Horizon);
        List.ReplaceItem(TTNodeType, (HashBucket + 0), Type);
        List.ReplaceItem(TTNodeScore, (HashBucket + 0), Score);
        List.ReplaceItem(TTNodeBestMove, (HashBucket + 0), BestMove);
        List.ReplaceItem(TTNodeBoardAttackedByOpp, (HashBucket + 0), BoardAttackedByOpp);
        List.ReplaceItem(TTNodeBoardAttackedByOppPiece, (HashBucket + 0), BoardAttackedByOppPiece);
        List.ReplaceItem(TTNodeChecked, (HashBucket + 0), Checked);
        List.ReplaceItem(TTNodeCheckedAttackLines, (HashBucket + 0), CheckedAttackLines);
        List.ReplaceItem(TTNodeIsDynamic, (HashBucket + 0), IsDynamic);
        List.ReplaceItem(TTNodeAge, (HashBucket + 0), TTCurrentAge);
    }
    TTProbeNodePrevMiss = -1;
}

Define UndoMove (warp=false)
{
    Call EnterExecution;
    If ((IsInUndo == 0) And (List.Length(GameMovesAN) > 1))
    {
        IsInUndo = 1;
        Stg_FromSquareIdx = -1;
        Stg_ToSquareIdx = -1;
        Event.BroadcastAndWait("fromsquareselected");
        Event.BroadcastAndWait("tosquareselected");
        Call UndoPrevMove;
        If (BoardHistoryWasEngineMove[List.Length(BoardHistoryWasEngineMove)] == 0)
        {
            Call UndoPrevMove;
        }
        Call DrawBoardAndWait;
        GoK_IsGameSuspended = 0;
        IsInUndo = 0;
    }
    Call ExitExecution;
}

Define UndoPrevMove (warp=false)
{
    If (List.Length(GameMovesAN) > 0)
    {
        List.DeleteItem(BoardHistory, List.Length(BoardHistory));
        List.DeleteItem(BoardHistoryHash, List.Length(BoardHistoryHash));
        List.DeleteItem(BoardHistoryFiftyMoves, List.Length(BoardHistoryFiftyMoves));
        List.DeleteItem(BoardHistoryMetaState, List.Length(BoardHistoryMetaState));
        List.DeleteItem(BoardHistoryWasEngineMove, List.Length(BoardHistoryWasEngineMove));
        List.DeleteItem(GameMovesAN, List.Length(GameMovesAN));
        Call ImportBoardImpl(BoardHistory[List.Length(BoardHistory)]);
        Call GetSubstringLeft(GameMoves)((Variable.Length(GameMoves) - 4));
        GameMoves = SubstringRes;
        HasOwnCastled = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 1);
        HasOwnKingMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 2);
        HasOwnRookKSMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 3);
        HasOwnRookQSMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 4);
        HasOppCastled = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 5);
        HasOppKingMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 6);
        HasOppRookKSMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 7);
        HasOppRookQSMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 8);
        Call CalcBoardStats;
    }
}

Define UpdateMoveHash(string Piece)(string SourceIdx)(string TargetIdx)(string Depth) (warp=true)
{
    Call GetPiecePosHash(Piece)(SourceIdx);
    CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
    If ((abs(Piece) == GoK_OwnPawn) Or (abs(Piece) == GoK_OwnKing))
    {
        CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
    }
    Call GetPiecePosHash(Piece)(TargetIdx);
    CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
    If ((abs(Piece) == GoK_OwnPawn) Or (abs(Piece) == GoK_OwnKing))
    {
        CurrentBoardHash2 = (CurrentBoardHash2 + PiecePosHash);
    }
}

Define UpdateMoveHashPosScore(string Piece)(string SourceIdx)(string TargetIdx)(bool PosScoreUpdate)(string Depth) (warp=true)
{
    Call GetPiecePosHash(Piece)(SourceIdx);
    CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
    If ((abs(Piece) == GoK_OwnPawn) Or (abs(Piece) == GoK_OwnKing))
    {
        CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
    }
    Call GetPiecePosHash(Piece)(TargetIdx);
    CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
    If ((abs(Piece) == GoK_OwnPawn) Or (abs(Piece) == GoK_OwnKing))
    {
        CurrentBoardHash2 = (CurrentBoardHash2 + PiecePosHash);
    }
    Call TaperedEval.GetPiecePosResult(Piece)(SourceIdx);
    If PosScoreUpdate
    {
        List.ReplaceItem(PosScoreDelta, Depth, (PosScoreDelta[Depth] - TaperedEval.PiecePosResult));
    }
    Else
    {
        List.ReplaceItem(PosScoreDelta, Depth, (0 - TaperedEval.PiecePosResult));
    }
    Call TaperedEval.GetPiecePosResult(Piece)(TargetIdx);
    List.ReplaceItem(PosScoreDelta, Depth, (PosScoreDelta[Depth] + TaperedEval.PiecePosResult));
}

Define UpdateMoveNotationPV (warp=true)
{
    PV = "";
    Idx = 2;
    Repeat (PV[1])
    {
        PV = Operator.Join(Operator.Join(PV, PV[Idx]), " ");
        Idx += 1;
    }
}

Define UpdatePV(string Depth)(string BestMove) (warp=true)
{
    If ((Betas[Depth] - Alphas[Depth]) == 1)
    {
        Stop(this script);
    }
    If (IsInNullMove == 1)
    {
        Stop(this script);
    }
    Idx = (((Depth - 1) * MaxSearchDepthStackFrames) + 1);
    IdxSub = ((Depth * MaxSearchDepthStackFrames) + 1);
    Len = PV[IdxSub];
    List.ReplaceItem(PV, Idx, (Len + 1));
    List.ReplaceItem(PVRaw, Idx, (Len + 1));
    Call GetMoveNotation(BestMove);
    List.ReplaceItem(PV, (Idx + 1), MoveNotationRes);
    List.ReplaceItem(PVRaw, (Idx + 1), BestMove);
    Idx += 2;
    IdxSub += 1;
    Repeat (Len)
    {
        List.ReplaceItem(PV, Idx, PV[IdxSub]);
        List.ReplaceItem(PVRaw, Idx, PVRaw[IdxSub]);
        Idx += 1;
        IdxSub += 1;
    }
    If (Depth == 1)
    {
        If (PV[1] > 0)
        {
            Call UpdateMoveNotationPV;
            List.DeleteAll(PVStable);
            Idx = 2;
            Repeat (PVRaw[1])
            {
                List.Add(PVStable, PVRaw[Idx]);
                Idx += 1;
            }
        }
    }
}

Define _ClearLists (warp=true)
{
    List.DeleteItem(MoveToZeroPadStr, all);
    List.DeleteItem(OpeningMoves, all);
    List.DeleteItem(OpeningMovesMapHash, all);
    List.DeleteItem(OpeningMovesMapMove, all);
    List.DeleteItem(OpeningMovesMapStack, all);
    List.DeleteItem(PosPieceHashLookup, all);
    List.DeleteItem(KillerMoves, all);
    List.DeleteItem(HistoryMoveScores, all);
    List.DeleteItem(MaxHistoryMoveScore, all);
    List.DeleteItem(HistoryCounterMoves, all);
    List.DeleteItem(BoardHistory, all);
    List.DeleteItem(BoardHistoryHash, all);
    List.DeleteItem(BoardHistoryFiftyMoves, all);
    List.DeleteItem(BoardHistoryMetaState, all);
    List.DeleteItem(BoardHistoryWasEngineMove, all);
    List.DeleteItem(GameMovesAN, all);
    List.DeleteItem(BoardAttackedByOpp, all);
    List.DeleteItem(BoardAttackedByOwn, all);
    List.DeleteItem(PieceMobility, all);
    List.DeleteItem(BoardAttackedByOppPiece, all);
    List.DeleteItem(BoardAttackedByOwnPiece, all);
    List.DeleteItem(Alphas, all);
    List.DeleteItem(Betas, all);
    List.DeleteItem(AlphasOld, all);
    List.DeleteItem(BetasOld, all);
    List.DeleteItem(MinMaxResults, all);
    List.DeleteItem(MinMaxResultsIsDynamic, all);
    List.DeleteItem(MovesCount, all);
    List.DeleteItem(MovesIdx, all);
    List.DeleteItem(MovesIdxBestMove, all);
    List.DeleteItem(TargetPieces, all);
    List.DeleteItem(PreviousBoardHash, all);
    List.DeleteItem(PreviousBoardHash2, all);
    List.DeleteItem(ScoreTypes, all);
    List.DeleteItem(PickMoveRes, all);
    List.DeleteItem(PickPhase, all);
    List.DeleteItem(PickedMoves, all);
    List.DeleteItem(PickedMoveCount, all);
    List.DeleteItem(BestMoves, all);
    List.DeleteItem(CheckedState, all);
    List.DeleteItem(CheckedStateAttackLines, all);
    List.DeleteItem(PromotionPieces, all);
    List.DeleteItem(TargetPiecesIdx, all);
    List.DeleteItem(PosScoreDelta, all);
    List.DeleteItem(BoardAttackedCalculated, all);
    List.DeleteItem(PutsInCheck, all);
    List.DeleteItem(EvalExtended1, all);
    List.DeleteItem(PlyExtension, all);
    List.DeleteItem(SourcePieces, all);
    List.DeleteItem(EvalExtended2, all);
    List.DeleteItem(EvalExtended3, all);
    List.DeleteItem(MobBonusOwn, all);
    List.DeleteItem(MobBonusOpp, all);
    List.DeleteItem(AppliedMove, all);
    List.DeleteItem(CapturesDeltaSum, all);
    List.DeleteItem(PosScoreDeltaSum, all);
    List.DeleteItem(PlyExtensionTagged, all);
    List.DeleteItem(BoardAttackedByOwnPieceSnapshot, all);
    List.DeleteItem(BoardAttackedByOwnSnapshot, all);
    List.DeleteItem(BoardAttackedByOppPieceSnapshot, all);
    List.DeleteItem(BoardAttackedByOppSnapshot, all);
    List.DeleteItem(Quiescence, all);
    List.DeleteItem(EnPassantTarget, all);
    List.DeleteItem(PassedOppPawnOnEndgame, all);
    List.DeleteItem(CastlingState, all);
    List.DeleteItem(PawnShelterCapture, all);
    List.DeleteItem(BoardEval, all);
    List.DeleteItem(HashMoveMetaData, all);
    List.DeleteAll(ChebyshevDistance);
    List.DeleteAll(MoveHashLookupOwn);
    List.DeleteAll(MoveHashLookupOpp);
    List.DeleteAll(MovePosLookupMgOwn);
    List.DeleteAll(MovePosLookupOppMg);
    List.DeleteAll(MovePathDelta);
    List.DeleteAll(MovePathStepInc);
    List.DeleteAll(Moves);
    List.DeleteAll(HistoryMoveScores);
    List.DeleteAll(HistoryCounterMoves);
    List.DeleteAll(PieceIdxLookup);
    List.DeleteItem(MoveLookupStraight, all);
    List.DeleteItem(MoveLookupCross, all);
    List.DeleteItem(MoveLookupOffsetsStraight, all);
    List.DeleteItem(MoveLookupOffsetsCross, all);
    List.DeleteItem(MoveLookupKnight, all);
    List.DeleteItem(MoveLookupKing, all);
    List.DeleteItem(MoveLookupIndexOffset, all);
    List.DeleteItem(MoveLookupLineIndexOffset, all);
    List.DeleteItem(TTNodeHash, all);
    List.DeleteItem(TTNodeBestMove, all);
    List.DeleteItem(TTNodeScore, all);
    List.DeleteItem(TTNodeDepth, all);
    List.DeleteItem(TTNodeAge, all);
    List.DeleteItem(TTNodeIsDynamic, all);
    List.DeleteItem(TTNodeType, all);
    List.DeleteItem(TTNodeChecked, all);
    List.DeleteItem(TTNodeHorizon, all);
    List.DeleteItem(TTBoardAge, all);
    List.DeleteItem(TTBoardHash, all);
    List.DeleteItem(TTBoardScore1, all);
    List.DeleteItem(TTBoardScore2, all);
    List.DeleteItem(TTBoardScore3, all);
    List.DeleteItem(TTBoardScoreSum, all);
    List.DeleteItem(TTNodeBoardAttackedByOpp, all);
    List.DeleteItem(TTNodeBoardAttackedByOppPiece, all);
    List.DeleteItem(TTNodeCheckedAttackLines, all);
    List.DeleteItem(PieceMobilityPrep, all);
    List.DeleteItem(PieceMobility, all);
    List.DeleteItem(MovePosLookupOwnLegal, all);
    List.DeleteItem(MovePosLookupOppLegal, all);
    List.DeleteItem(MovePosLookupOwnEg, all);
    List.DeleteItem(MovePosLookupOppEg, all);
    List.DeleteItem(MovePosLookupMgOwn, all);
    List.DeleteItem(MovePosLookupOppMg, all);
    List.DeleteItem(MinMaxPly1Scores, all);
    List.DeleteItem(PersistedBoardAttackedByOppSnapshot, all);
    List.DeleteItem(PersistedBoardAttackedByOppPieceSnapshot, all);
    List.DeleteItem(Logfile, all);
    List.DeleteItem(PV, all);
    List.DeleteItem(HistoryContinuationOwn, all);
    List.DeleteItem(HistoryContinuationOpp, all);
    List.DeleteItem(HistoryContinuation2Own, all);
    List.DeleteItem(HistoryContinuation2Opp, all);
}
