//----- Green flag events ---------------------------------------------------------------------------------------------

WhenGreenFlagClicked()
{
    If is compiled?
    {
        IsScratch3 = 0;
    }
    Else
    {
        IsScratch3 = 1;
    }
    Call OnRestart;
}


//----- Key pressed events --------------------------------------------------------------------------------------------

WhenKeyPressed(l)
{
    If (DebugMode == -1)
    {
        Stop(this script);
    }
    List.Show(Logfile);
}

WhenKeyPressed(p)
{
    If (ProfilerMode == -1)
    {
        Stop(this script);
    }
    If ((ProfilerMode % 10) == 0)
    {
        ProfilerMode += 1;
        IsBlockProfilerEnabled = 0;
        Call SayAsync("Statistical profiling enabled. Press 'l' to view data.")(2);
    }
    Else
    {
        If ((ProfilerMode % 10) == 1)
        {
            ProfilerMode += 1;
            IsBlockProfilerEnabled = 1;
            Call SayAsync("Full profiling enabled. Press 'l' / 'r' to view data.")(2);
        }
        Else
        {
            If ((ProfilerMode % 10) == 2)
            {
                ProfilerMode += -2;
                IsBlockProfilerEnabled = 0;
                Call SayAsync("Profiling disabled.")(2);
            }
        }
    }
}

WhenKeyPressed(d)
{
    If (DebugMode == -1)
    {
        Stop(this script);
    }
    If (DebugMode == 0)
    {
        DebugMode = 1;
        Variable.Show(IdxDeepening);
        Variable.Show(BestMinMaxRes);
        Variable.Show(BestMove);
        Variable.Show(NPS);
        Variable.Show(MPS);
    }
    Else
    {
        DebugMode = 0;
        Variable.Hide(IdxDeepening);
        Variable.Hide(BestMinMaxRes);
        Variable.Hide(BestMove);
        Variable.Hide(NPS);
        Variable.Hide(MPS);
    }
}

WhenKeyPressed(c)
{
    PlayingMode = ((PlayingMode + 1) % 3);
    If (PlayingMode == 0)
    {
        Call SayAsync("Standard mode (full null move pruning). Think time on Difficult set to 25/15 seconds, re-initializing cache.")(5);
        If (IsScratch3 == 0)
        {
            Control.Wait(0.1);
            Call ClearTT;
        }
    }
    Else
    {
        If (PlayingMode == 1)
        {
            Call SayAsync("Competition mode (full null move pruning). Think time on Difficult set to 60 seconds, re-initializing cache.")(5);
            If (IsScratch3 == 0)
            {
                Control.Wait(0.1);
                Call ClearTT;
            }
        }
        Else
        {
            Call SayAsync("Puzzle mode (limited null move pruning). Think time on Difficult set to 60 seconds.")(5);
        }
    }
}

WhenKeyPressed(v)
{
    Call SayAsync("Game of Kings Chess NNUE Version 7.023 (15.06.2024) by ArnoHu")(5);
}

WhenKeyPressed(t)
{
    If (IsExecutionRunning == 0)
    {
        Sensing.Ask("Please enter transposition table cache size (default is 200000 on Scratch 3, 1000000 on TurboWarp)");
        If (Sensing.Answer() > 0)
        {
            Call ClearTTImpl(Sensing.Answer());
        }
    }
}

WhenKeyPressed(r)
{
    If (ProfilerMode == -1)
    {
        Stop(this script);
    }
    If (ProfilerMode < 10)
    {
        ProfilerMode += 10;
        List.Show(Profile_Data);
    }
    Else
    {
        ProfilerMode += -10;
        List.Hide(Profile_Data);
    }
}


//----- Broadcast received events -------------------------------------------------------------------------------------

WhenBroadcastReceived(advisor)
{
    If (IsExecutionRunning == 0)
    {
        If (IsAdvisorEnabled == 1)
        {
            IsAdvisorEnabled = 0;
            Call DrawBoardAndWait;
        }
        Else
        {
            IsAdvisorEnabled = 1;
            If (Not ((FromSquareIdx == -1)))
            {
                Event.BroadcastAndWait("fromsquareselected");
            }
        }
    }
}

WhenBroadcastReceived(evaluationvaluechangedinternal)
{
    Event.BroadcastAndWait("evaluationvaluechanged");
}

WhenBroadcastReceived(export)
{
    If (IsExecutionRunning == 0)
    {
        Call ExportBoardFEN((IsPlayerBlack == 1))((1 == 1));
        List.DeleteItem(ExportData, all);
        List.Add(ExportData, "DATA EXPORT");
        List.Add(ExportData, "Select data row by triple-clicking. You can then copy to");
        List.Add(ExportData, "clipboard by right-click / Copy or by pressing Ctrl-C.");
        List.Add(ExportData, "");
        List.Add(ExportData, "PGN (Game Protocol):");
        Call ExportMovesPGN;
        List.Add(ExportData, ExportMovesPGN);
        List.Add(ExportData, "");
        List.Add(ExportData, "FEN (Current Board):");
        List.Add(ExportData, ExportDataFEN);
        List.Add(ExportData, "");
        List.Add(ExportData, "Board Analysis Link (lichess.org)");
        List.Add(ExportData, ExportDataFENLichess);
        List.Show(ExportData);
        If (1 == 0)
        {
            Call SayAsync("You can copy FEN data, lichess.org URL or PGN data to your clipboard via Ctrl-C. Select data by triple-click.")(5);
        }
    }
}

WhenBroadcastReceived(fromsquareselected)
{
    If ((IsAdvisorEnabled == 1) And (Not ((FromSquareIdx == -1))))
    {
        BestMoveFromIdx = FromSquareIdx;
        List.DeleteAll(UserMoveTargets);
        Call GenerateMovesPublic(2);
        List.ReplaceItem(MovesIdx, 2, 1);
        Repeat (MovesCount[2])
        {
            Call GetCurrentMove(2);
            CurrentMoveOuter = CurrentMove;
            If (floor((CurrentMoveOuter / 100)) == FromSquareIdx)
            {
                Call ApplyMove(2);
                Call CalcBoardAttackedByMove(3);
                Call RevertMove(2);
                If (IsWhiteChecked == 0)
                {
                    List.Add(UserMoveTargets, floor((CurrentMoveOuter % 100)));
                }
            }
            Else
            {
                If (Board[FromSquareIdx] == WhiteKing)
                {
                    If (CurrentMoveOuter == WhiteKingsideCastling)
                    {
                        List.Add(UserMoveTargets, VirtualBoard[63]);
                    }
                    Else
                    {
                        If (CurrentMoveOuter == WhiteQueensideCastling)
                        {
                            List.Add(UserMoveTargets, VirtualBoard[59]);
                        }
                    }
                }
            }
            List.ReplaceItem(MovesIdx, 2, (MovesIdx[2] + 1));
        }
        Call DrawBoardAndWait;
        Event.BroadcastAndWait("StampUserMoveTargets");
    }
}

WhenBroadcastReceived(import)
{
    If (IsExecutionRunning == 0)
    {
        Sensing.Ask("Board data import. Please paste FEN data from your clipboard into the text field by pressing Ctrl-V.");
        If (Variable.Length(Sensing.Answer()) > 0)
        {
            Call ImportBoard(Sensing.Answer());
        }
    }
}

WhenBroadcastReceived(levelchanged)
{
    Call DrawBoardAndWait;
}

WhenBroadcastReceived(progressvaluechangedinternal)
{
    Event.BroadcastAndWait("progressvaluechanged");
}

WhenBroadcastReceived(sayasyncmsg)
{
    Looks.Say(SayAsyncText, SayAsyncDuration);
}

WhenBroadcastReceived(showmoves)
{
    Call ExportMovesPGN;
    List.DeleteItem(ExportMoves, all);
    List.Add(ExportMoves, ExportMovesPGN);
    List.Show(ExportMoves);
    Call SayAsync("You can copy PGN data to your clipboard via Ctrl-C")(5);
}

WhenBroadcastReceived(squareclicked)
{
    If ((IsExecutionRunning == 0) And (IsGameSuspended == 0))
    {
        Call EnterExecution;
        If (Board[SquareClickedIdx] < 0)
        {
            MoveFromIdx = SquareClickedIdx;
            FromSquareIdx = SquareClickedIdx;
            Event.BroadcastAndWait("fromsquareselected");
        }
        Else
        {
            If ((Not ((MoveFromIdx == -1))) And (Not ((FromSquareIdx == -1))))
            {
                MoveToIdx = SquareClickedIdx;
                ToSquareIdx = SquareClickedIdx;
                Event.BroadcastAndWait("tosquareselected");
                If ((Board[MoveFromIdx] < 0) And (Not ((MoveFromIdx == MoveToIdx))))
                {
                    UserMove = "";
                    If ((Board[MoveFromIdx] == WhiteKing) And (MoveFromIdx == VirtualBoard[61]))
                    {
                        If ((MoveToIdx == VirtualBoard[59]) And (Board[VirtualBoard[57]] == WhiteRook))
                        {
                            Call GenerateMovesPublic(2);
                            If List.ContainsItem(Moves2, WhiteQueensideCastling)
                            {
                                UserMove = WhiteQueensideCastling;
                            }
                            Else
                            {
                                UserMove = Operator.Join(VirtualBoard[61], VirtualBoard[59]);
                            }
                        }
                        If ((MoveToIdx == VirtualBoard[63]) And (Board[VirtualBoard[64]] == WhiteRook))
                        {
                            Call GenerateMovesPublic(2);
                            If List.ContainsItem(Moves2, WhiteKingsideCastling)
                            {
                                UserMove = WhiteKingsideCastling;
                            }
                            Else
                            {
                                UserMove = Operator.Join(VirtualBoard[61], VirtualBoard[63]);
                            }
                        }
                    }
                    If (UserMove == "")
                    {
                        UserMove = ((MoveFromIdx * 100) + MoveToIdx);
                        If (Variable.Length(UserMove) == 3)
                        {
                            UserMove = Operator.Join(0, UserMove);
                        }
                        If ((Board[MoveFromIdx] == WhitePawn) And (MoveToIdx < 9))
                        {
                            UserMove = Operator.Join(UserMove, .1);
                        }
                    }
                }
                Call ExecuteUserMove(UserMove);
            }
        }
        Call ExitExecution;
    }
}

WhenBroadcastReceived(stageclicked)
{
    List.Hide(ExportData);
    List.Hide(ExportMoves);
    List.Hide(Logfile);
    If (Not ((ProfilerMode < 10)))
    {
        ProfilerMode += -10;
        List.Hide(Profile_Data);
    }
    If (IsExecutionRunning == 0)
    {
        Looks.Say("");
    }
}

WhenBroadcastReceived(startgame)
{
    Motion.GoToXY(240, 80);
    ExecutionDepth = 0;
    IsExecutionRunning = 0;
    Call EnterExecution;
    Call InitBoard;
    Call DrawBoardAndWait;
    Looks.Say("Initializing engine, please wait...");
    Control.Wait(0.1);
    Call InitBoardPhase2;
    Call ExitExecution;
    Call ExecuteInit;
    Looks.Say("");
}

WhenBroadcastReceived(triggerrestart)
{
    Call OnRestart;
}

WhenBroadcastReceived(undo)
{
    If (IsExecutionRunning == 0)
    {
        Call UndoMove;
        Call OnEvaluationChanged(0);
        Looks.Say("");
    }
}


//----- Custom blocks -------------------------------------------------------------------------------------------------

Define //(string Comment) (warp=true)
{
}

Define AddBoardToHistory(string WasEngineMove) (warp=true)
{
    Call GetBoardString;
    List.Add(BoardHistory, GetBoardStringRes);
    Call CreateCurrentBoardHash;
    List.Add(BoardHistoryHash, CurrentBoardHash);
    List.Add(BoardHistoryMetaState, Operator.Join(Operator.Join(Operator.Join(HasBlackCastled, HasBlackKingMoved), Operator.Join(HasBlackRookKSMoved, HasBlackRookQSMoved)), Operator.Join(Operator.Join(HasWhiteCastled, HasWhiteKingMoved), Operator.Join(HasWhiteRookKSMoved, HasWhiteRookQSMoved))));
    List.Add(BoardHistoryWasEngineMove, WasEngineMove);
}

Define AddLookupMove(string SourceIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool LookupMoveTypeKing) (warp=true)
{
    SourcePieceOuter = Board[SourceIdx];
    IdxOuter = MoveLookupIndexOffset[SourceIdx];
    Count = 1;
    Repeat (8)
    {
        If LookupMoveTypeKing
        {
            TargetIdxOuter = MoveLookupKing[(IdxOuter + Count)];
        }
        Else
        {
            TargetIdxOuter = MoveLookupKnight[(IdxOuter + Count)];
        }
        If (TargetIdxOuter == -1)
        {
            Stop(this script);
        }
        If CalcAttackState
        {
            Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
        }
        Else
        {
            If (Board[TargetIdxOuter] == 0)
            {
                If CapturesOnly
                {
                    If LookupMoveTypeKing
                    {
                        If (CheckedState[Depth] == 1)
                        {
                            Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                        }
                        Else
                        {
                            If (IsPotentialNonCapQuiescMove == 1)
                            {
                                Call AddPotentialQuiescenceMove(SourceIdx)(TargetIdxOuter)(SourcePieceOuter)(Depth);
                            }
                        }
                    }
                    Else
                    {
                        If (IsPotentialNonCapQuiescMove == 1)
                        {
                            Call AddPotentialQuiescenceMove(SourceIdx)(TargetIdxOuter)(SourcePieceOuter)(Depth);
                        }
                    }
                }
                Else
                {
                    Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                }
            }
            Else
            {
                If (SourcePieceOuter > 0)
                {
                    If (Board[TargetIdxOuter] < 0)
                    {
                        Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                    }
                }
                Else
                {
                    If (Board[TargetIdxOuter] > 0)
                    {
                        Call AddMoveImplLookup(SourceIdx)(TargetIdxOuter)(Depth)(CalcAttackState)(CapturesOnly)(LookupMoveTypeKing);
                    }
                }
            }
        }
        Count += 1;
    }
}

Define AddMoveImpl(string SourceIdx)(string TargetIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    If CalcAttackState
    {
        If (Board[SourceIdx] > 0)
        {
            If (BoardAttackedByBlack[TargetIdx] < 9)
            {
                List.ReplaceItem(BoardAttackedByBlack, TargetIdx, (BoardAttackedByBlack[TargetIdx] + 1));
            }
            If ((BoardAttackedByBlackPiece[TargetIdx] == 0) Or (Board[BoardAttackedByBlackPiece[TargetIdx]] > Board[SourceIdx]))
            {
                List.ReplaceItem(BoardAttackedByBlackPiece, TargetIdx, SourceIdx);
            }
            If (Board[TargetIdx] == WhiteKing)
            {
                IsWhiteChecked = 1;
                List.Add(KingAttackLines, SourceIdx);
            }
        }
        Else
        {
            If (BoardAttackedByWhite[TargetIdx] < 9)
            {
                List.ReplaceItem(BoardAttackedByWhite, TargetIdx, (BoardAttackedByWhite[TargetIdx] + 1));
            }
            If ((BoardAttackedByWhitePiece[TargetIdx] == 0) Or (Board[BoardAttackedByWhitePiece[TargetIdx]] < Board[SourceIdx]))
            {
                List.ReplaceItem(BoardAttackedByWhitePiece, TargetIdx, SourceIdx);
            }
            If (Board[TargetIdx] == BlackKing)
            {
                IsBlackChecked = 1;
                List.Add(KingAttackLines, SourceIdx);
            }
        }
        Stop(this script);
    }
    If (CheckedState[Depth] == 1)
    {
        If (Not ((Operator.LetterOf(CheckedStateAttackLines[Depth], TargetIdx) == 1)))
        {
            If (Not ((abs(Board[SourceIdx]) == BlackKing)))
            {
                If (Not ((abs(Board[TargetIdx]) == BlackKing)))
                {
                    If (BoardAttackedCalculated[Depth] == 1)
                    {
                        If ((Depth > 2) And (EnPassantTarget[Depth] == ""))
                        {
                            Stop(this script);
                        }
                    }
                }
            }
        }
    }
    CurrentMove = MoveNotationLookup[((SourceIdx * 100) + TargetIdx)];
    If (abs(Board[SourceIdx]) == BlackPawn)
    {
        If ((IdxToRank[TargetIdx] == 1) Or (IdxToRank[TargetIdx] == 8))
        {
            Call AddSpecialMove(Operator.Join(CurrentMove, .1))(Depth);
            Call AddSpecialMove(Operator.Join(CurrentMove, .2))(Depth);
            Call AddSpecialMove(Operator.Join(CurrentMove, .3))(Depth);
            Call AddSpecialMove(Operator.Join(CurrentMove, .4))(Depth);
            Stop(this script);
        }
    }
    Else
    {
        If (Not (CapturesOnly))
        {
            If ((Depth % 2) == 1)
            {
                If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], TargetIdx) == 0)
                {
                    List.ReplaceItem(PieceMobility, SourceIdx, (PieceMobility[SourceIdx] + 1));
                }
            }
            Else
            {
                If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], TargetIdx) == 0)
                {
                    List.ReplaceItem(PieceMobility, SourceIdx, (PieceMobility[SourceIdx] + 1));
                }
            }
        }
    }
    List.Add(CalcMovesMoveList, CurrentMove);
    If Operator.Contains(PickedMoves[Depth], CurrentMove)
    {
        If ((Depth % 2) == 1)
        {
            List.Add(CalcMovesScoreList, MaxMoveOrderScore);
        }
        Else
        {
            List.Add(CalcMovesScoreList, (0 - MaxMoveOrderScore));
        }
        Stop(this script);
    }
    Call GetMoveScore(Board[SourceIdx])(Board[TargetIdx])(SourceIdx)(TargetIdx)(CurrentMove)(Depth);
    List.Add(CalcMovesScoreList, MoveScoreRes);
}

Define AddMoveImplLookup(string SourceIdx)(string TargetIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool IsKing) (warp=true)
{
    If IsKing
    {
        If (Not (CalcAttackState))
        {
            If (BoardAttackedCalculated[Depth] == 0)
            {
                If (Not (CapturesOnly))
                {
                    GenerateMovesRequiresAttackRecalc = 1;
                    Stop(this script);
                }
            }
            Else
            {
                If ((Depth % 2) == 1)
                {
                    If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], TargetIdx) > 0)
                    {
                        Stop(this script);
                    }
                }
                Else
                {
                    If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], TargetIdx) > 0)
                    {
                        Stop(this script);
                    }
                }
            }
        }
    }
    Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)(CalcAttackState)(CapturesOnly);
}

Define AddMoveToList(string Move)(string Depth) (warp=true)
{
    Count = (MovesCount[Depth] + 1);
    List.ReplaceItem(Moves, (((Depth - 1) * MaxMovesPerGeneration) + Count), Move);
    List.ReplaceItem(MovesCount, Depth, Count);
    If (Depth < 3)
    {
        If (Depth == 1)
        {
            List.Add(Moves1, Move);
        }
        Else
        {
            If (Depth == 2)
            {
                List.Add(Moves2, Move);
            }
        }
    }
}

Define AddPotentialQuiescenceMove(string SourceIdx)(string TargetIdx)(string Piece)(string Depth) (warp=true)
{
    Call //("Include move in quiescence search if it's a check or check evasion");
    If (Operator.LetterOf(CheckedStateAttackLines[Depth], TargetIdx) == 1)
    {
        Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
        Stop(this script);
    }
    If (Piece == BlackPawn)
    {
        If (IdxToRank[TargetIdx] == 8)
        {
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
    }
    If (Piece == WhitePawn)
    {
        If (IdxToRank[TargetIdx] == 1)
        {
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
    }
    If (IsQuiescentCheckInvariantRes == 0)
    {
        Stop(this script);
    }
    TargetPiece = Board[TargetIdx];
    List.ReplaceItem(Board, TargetIdx, Board[SourceIdx]);
    List.ReplaceItem(Board, SourceIdx, 0);
    Call IsCheckingPieceDiscovery(SourceIdx)(TargetIdx)(Depth);
    List.ReplaceItem(Board, SourceIdx, Board[TargetIdx]);
    List.ReplaceItem(Board, TargetIdx, TargetPiece);
    If (IsCheckingPieceRes == 1)
    {
        Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
        Stop(this script);
    }
    If (Piece > 0)
    {
        If (MovePosLookupBlack[((PieceIdxLookup[Piece] * 10000) + ((TargetIdx * 100) + WhiteKingIdx))] == "")
        {
            Stop(this script);
        }
        If (Piece == BlackPawn)
        {
            If (IdxToFile[TargetIdx] == IdxToFile[WhiteKingIdx])
            {
                Stop(this script);
            }
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
        If (Piece == BlackKnight)
        {
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
        CurrentMove = MoveNotationLookup[((TargetIdx * 100) + WhiteKingIdx)];
    }
    Else
    {
        If (MovePosLookupWhite[((PieceIdxLookup[(0 - Piece)] * 10000) + ((TargetIdx * 100) + BlackKingIdx))] == "")
        {
            Stop(this script);
        }
        If (Piece == WhitePawn)
        {
            If (IdxToFile[TargetIdx] == IdxToFile[BlackKingIdx])
            {
                Stop(this script);
            }
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
        If (Piece == WhiteKnight)
        {
            Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
            Stop(this script);
        }
        CurrentMove = MoveNotationLookup[((TargetIdx * 100) + BlackKingIdx)];
    }
    SourceIdx = TargetIdx;
    IdxInc = MovePathStepInc[CurrentMove];
    Repeat ((MovePathDelta[CurrentMove] - 1))
    {
        SourceIdx += IdxInc;
        If (Not ((Board[SourceIdx] == 0)))
        {
            Stop(this script);
        }
    }
    Call AddMoveImpl(SourceIdx)(TargetIdx)(Depth)((1 == 0))((1 == 1));
}

Define AddSlidingMove(string SourceIdx)(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool SlidingMoveTypeStraight) (warp=true)
{
    If CalcAttackState
    {
        Call ASMAttack(SourceIdx)(Depth)(SlidingMoveTypeStraight);
    }
    Else
    {
        Call ASM(SourceIdx)(Depth)(CapturesOnly)(SlidingMoveTypeStraight);
    }
}

Define AddSpecialMove(string Move)(string Depth) (warp=true)
{
    List.Add(CalcMovesMoveList, Move);
    If (Variable.Length(PickedMoves[Depth]) > 0)
    {
        If Operator.Contains(PickedMoves[Depth], Move)
        {
            If ((Depth % 2) == 1)
            {
                List.Add(CalcMovesScoreList, MaxMoveOrderScore);
            }
            Else
            {
                List.Add(CalcMovesScoreList, (0 - MaxMoveOrderScore));
            }
            Stop(this script);
        }
    }
    Call GetSpecialMoveScore(Move)(Depth);
    List.Add(CalcMovesScoreList, MoveScoreRes);
}

Define AlphaBetaMinMax(string Alpha)(string Beta)(string MinDepth)(string MaxDepth)(bool InitialDeepening)(string QuiescenceDepth)(bool ShowProgress) (warp=true)
{
    MinMaxEvalRes = "";
    MinMaxMoveRes = "";
    Call InitAlphaBeta((MaxDepth - 1))(InitialDeepening);
    Call OnScoreCalc(0)(MinDepth)((MaxDepth - 1))((1 == 0));
    List.ReplaceItem(Alphas, MinDepth, Alpha);
    List.ReplaceItem(Betas, MinDepth, Beta);
    MoveCount = 0;
    MoveCountQ = 0;
    NodeCount = 0;
    NodeCountQ = 0;
    ProfBestMoveCount = 0;
    ProfBestMoveIdxSum = 0;
    ProfBestMoveCountQ = 0;
    ProfBestMoveIdxSumQ = 0;
    MinMaxTimer = (Sensing.DaysSince2000() * 86400);
    Call AlphaBetaMinMaxImpl(MinDepth)(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)((1 == 0))((1 == 0))(ShowProgress);
    MinMaxTimer = ((Sensing.DaysSince2000() * 86400) - MinMaxTimer);
    If ((ProfilerMode % 10) > 0)
    {
        Call Log("========================================")("")("")("")("")("")("")("");
        Call Log("SEARCH STATS")("")("")("")("")("")("")("");
        Call Log("========================================")("")("")("")("")("")("")("");
        Call Log("Depth = ")((MaxDepth - 1))(", Time = ")((Operator.Round((MinMaxTimer * 100)) / 100))("")("")("")("");
        Call Log(MoveCount)(" moves (full), ")((Operator.Round(((MoveCount / MinMaxTimer) / 100)) / 10))("k MPS")("")("")("")("");
        Call Log(NodeCount)(" nodes (full), ")((Operator.Round(((NodeCount / MinMaxTimer) / 100)) / 10))("k NPS")("")("")("")("");
        Call Log(MoveCountQ)(" moves (q), ")((Operator.Round(((MoveCountQ / MinMaxTimer) / 100)) / 10))("k MPS")("")("")("")("");
        Call Log(NodeCountQ)(" nodes (q), ")((Operator.Round(((NodeCountQ / MinMaxTimer) / 100)) / 10))("k NPS")("")("")("")("");
        Call Log((MoveCount + MoveCountQ))(" moves (all), ")((Operator.Round((((MoveCount + MoveCountQ) / MinMaxTimer) / 100)) / 10))("k MPS")("")("")("")("");
        Call Log((NodeCount + NodeCountQ))(" nodes (all), ")((Operator.Round((((NodeCount + NodeCountQ) / MinMaxTimer) / 100)) / 10))("k NPS")("")("")("")("");
        Call Log("Avg. best move idx (full) = ")((Operator.Round(((ProfBestMoveIdxSum / ProfBestMoveCount) * 100)) / 100))("")("")("")("")("")("");
        Call Log("Avg. best move idx (q) = ")((Operator.Round(((ProfBestMoveIdxSumQ / ProfBestMoveCountQ) * 100)) / 100))("")("")("")("")("")("");
        Call Log("========================================")("")("")("")("")("")("")("");
    }
    MPS = Operator.Round(((MoveCount + MoveCountQ) / MinMaxTimer));
    NPS = Operator.Round(((NodeCount + NodeCountQ) / MinMaxTimer));
}

Define AlphaBetaMinMaxImpl(string Depth)(string MinDepth)(string MaxDepth)(bool InitialDeepening)(string QuiescenceDepth)(bool Quiescence)(bool PrevQuiescence)(bool ShowProgress) (warp=true)
{
    Call //("Search function (minimax / alpha-beta pruning)");
    List.ReplaceItem(MinMaxResults, Depth, "");
    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
    List.ReplaceItem(ScoreTypes, Depth, "E");
    List.ReplaceItem(BestMoves, Depth, "");
    List.ReplaceItem(AppliedMove, Depth, "");
    List.ReplaceItem(AppliedMove_NNUE_State, Depth, 0);
    If (IsMinMaxTimeout == 1)
    {
        Stop(this script);
    }
    If (Depth > 1)
    {
        List.ReplaceItem(CheckedState, Depth, PutsInCheck[(Depth - 1)]);
    }
    Else
    {
        List.ReplaceItem(CheckedState, Depth, "");
    }
    If Quiescence
    {
        List.ReplaceItem(Quiescence, Depth, 1);
    }
    Else
    {
        List.ReplaceItem(Quiescence, Depth, 0);
    }
    If ((Depth > 1) And (IsInNullMove == 0))
    {
        Call //("Draw-by-repetition detection. This happens on every ply and could be costly, so we check previous plies for pawn moves and captures, and the history tables for board hash. Only then we count hash occurrences for same side.");
        CurrentValue = 0;
        Idx = (Depth - 1);
        Repeat Until (((Idx < 1) Or (Idx < (Depth - 7))) Or (CurrentValue == 1))
        {
            If ((abs(SourcePieces[Idx]) == BlackPawn) Or (Not ((TargetPieces[Idx] == 0))))
            {
                CurrentValue = 1;
            }
            Idx += -1;
        }
        If (CurrentValue == 0)
        {
            If (List.ContainsItem(BoardHistoryHash, CurrentBoardHash) Or List.ContainsItem(PreviousBoardHash, CurrentBoardHash))
            {
                Count = 1;
                Idx = (Depth - 2);
                Repeat Until (Idx < 1)
                {
                    If (CurrentBoardHash == PreviousBoardHash[Idx])
                    {
                        Count += 1;
                    }
                    Idx += -2;
                }
                Idx = ((List.Length(BoardHistoryHash) - 1) + (Depth % 2));
                Repeat Until (Idx < 1)
                {
                    If (CurrentBoardHash == BoardHistoryHash[Idx])
                    {
                        Count += 1;
                    }
                    Idx += -2;
                }
                If (Count > 2)
                {
                    List.ReplaceItem(MinMaxResults, Depth, DrawByRepetitionEval);
                    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 1);
                    Stop(this script);
                }
            }
        }
    }
    If ((Depth > 1) And (Not (InitialDeepening)))
    {
        Call //("Probe transposition table for cached node evaluations");
        Call TTProbeNode(CurrentBoardHash)(Depth);
        If ((TTProbeRes == 1) And (Not ((TTProbeNodeScoreRes == ""))))
        {
            If ((((Not (Quiescence)) And (Not ((TTProbeNodeAgeRes == -1)))) And (Not ((TTProbeHorizonRes < (MaxDepth - Depth))))) Or (Quiescence And (TTProbeHorizonRes == -1)))
            {
                If ((TTProbeNodeTypeRes == "E") Or (((TTProbeNodeTypeRes == "A") And (Not ((TTProbeNodeScoreRes > Alphas[Depth])))) Or ((TTProbeNodeTypeRes == "B") And (Not ((TTProbeNodeScoreRes < Betas[Depth]))))))
                {
                    If ((Depth > 2) Or (Not ((abs(TTProbeNodeScoreRes) > AbsMinCheckmateEval))))
                    {
                        If (((Depth > 1) And ((abs(SourcePieces[(Depth - 1)]) == BlackPawn) Or (Not ((TargetPieces[(Depth - 1)] == 0))))) Or ((Depth > 2) And ((abs(SourcePieces[(Depth - 2)]) == BlackPawn) Or (Not ((TargetPieces[(Depth - 2)] == 0))))))
                        {
                            List.ReplaceItem(MinMaxResults, Depth, TTProbeNodeScoreRes);
                            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, TTProbeNodeScoreIsDynamicRes);
                            Stop(this script);
                        }
                        Else
                        {
                            If ((Not (List.ContainsItem(BoardHistoryHash, CurrentBoardHash))) And (Not (List.ContainsItem(PreviousBoardHash, CurrentBoardHash))))
                            {
                                List.ReplaceItem(MinMaxResults, Depth, TTProbeNodeScoreRes);
                                List.ReplaceItem(MinMaxResultsIsDynamic, Depth, TTProbeNodeScoreIsDynamicRes);
                                Stop(this script);
                            }
                        }
                    }
                }
            }
        }
    }
    If (Depth > 1)
    {
        Call //("Virtual king captures on previous ply => depth-corrected checkmate evaluation");
        If (TargetPieces[(Depth - 1)] == WhiteKing)
        {
            List.ReplaceItem(MinMaxResults, Depth, (100000 - ((Depth - 1) * 1000)));
            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
            Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
            Stop(this script);
        }
        If (TargetPieces[(Depth - 1)] == BlackKing)
        {
            List.ReplaceItem(MinMaxResults, Depth, (-100000 + ((Depth - 1) * 1000)));
            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
            Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
            Stop(this script);
        }
    }
    If ((Depth == 2) Or (CheckedState[(Depth - 1)] == 1))
    {
        Call //("Early checkmate evaluation on previous checks when not evaded. As we now have special check evasion search, this is mainly for safety");
        Call CalcBoardAttackedByMoveChecked(Depth);
        If ((Depth % 2) == 1)
        {
            If ((IsWhiteChecked == 1) Or ((abs((IdxToRank[BlackKingIdx] - IdxToRank[WhiteKingIdx])) < 2) And (abs((IdxToFile[BlackKingIdx] - IdxToFile[WhiteKingIdx])) < 2)))
            {
                List.ReplaceItem(MinMaxResults, Depth, (100000 - (Depth * 1000)));
                List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
                Stop(this script);
            }
        }
        Else
        {
            If ((IsBlackChecked == 1) Or ((abs((IdxToRank[BlackKingIdx] - IdxToRank[WhiteKingIdx])) < 2) And (abs((IdxToFile[BlackKingIdx] - IdxToFile[WhiteKingIdx])) < 2)))
            {
                List.ReplaceItem(MinMaxResults, Depth, (-100000 + (Depth * 1000)));
                List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
                Stop(this script);
            }
        }
    }
    If ((Depth > 1) And (IsInNullMove == 0))
    {
        Call //("Draw-by-stalemate detection. This is expensive, and is only applied at low search depth or during late endgame stage (no minor pieces left)");
        If ((Depth < 3) Or ((Depth < 4) And (IsEndgame2 == 1)))
        {
            Call IsDrawByStalemate((Depth + 2));
            If (IsDrawRes == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, 0);
                List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
                Stop(this script);
            }
        }
        Call //("Fast draw-by-material verification");
        If (IsEndgame == 1)
        {
            If (((BlackQueenCountLocal == 0) And (WhiteQueenCountLocal == 0)) And ((BlackPawnCountLocal == 0) And (WhitePawnCountLocal == 0)))
            {
                If (((BlackRookCountLocal == 0) And (BlackMinorCountLocal < 2)) And ((WhiteRookCountLocal == 0) And (WhiteMinorCountLocal < 2)))
                {
                    List.ReplaceItem(MinMaxResults, Depth, 0);
                    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                    Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
                    Stop(this script);
                }
            }
        }
        If (1 == 0)
        {
            Call //("Special K-KP endgame draw detection, according to pawn and king position. Finds draws otherwise not visible within search horizon");
            If (IsEndgame == 1)
            {
                If ((Depth > 1) And (Not (PrevQuiescence)))
                {
                    If (((WhiteQueenCountLocal + WhiteMinorCountLocal) == 0) And ((BlackQueenCountLocal + BlackMinorCountLocal) == 0))
                    {
                        If ((BlackPawnCountLocal + WhitePawnCountLocal) == 1)
                        {
                            Idx = 1;
                            Repeat (64)
                            {
                                If ((Board[Idx] == WhitePawn) And ((Depth % 2) == 0))
                                {
                                    If ((IdxToFile[Idx] == 1) Or (IdxToFile[Idx] == 8))
                                    {
                                        If ((IdxToFile[Idx] == IdxToFile[BlackKingIdx]) And (IdxToRank[BlackKingIdx] < IdxToRank[Idx]))
                                        {
                                            List.ReplaceItem(MinMaxResults, Depth, 0);
                                            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                                            Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
                                            Stop(this script);
                                        }
                                    }
                                    Else
                                    {
                                        If (((Idx - 8) == BlackKingIdx) Or ((Idx - 16) == BlackKingIdx))
                                        {
                                            If (Not ((((Idx - 1) == WhiteKingIdx) Or ((Idx + 1) == WhiteKingIdx))))
                                            {
                                                List.ReplaceItem(MinMaxResults, Depth, 0);
                                                List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                                                Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
                                                Stop(this script);
                                            }
                                        }
                                        If ((Idx - 24) == BlackKingIdx)
                                        {
                                            If ((IdxToRank[Idx] > 4) And ((Idx - 8) == WhiteKingIdx))
                                            {
                                                List.ReplaceItem(MinMaxResults, Depth, 0);
                                                List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                                                Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
                                                Stop(this script);
                                            }
                                        }
                                    }
                                }
                                Else
                                {
                                    If ((Board[Idx] == BlackPawn) And ((Depth % 2) == 1))
                                    {
                                        If ((IdxToFile[Idx] == 1) Or (IdxToFile[Idx] == 8))
                                        {
                                            If ((IdxToFile[Idx] == IdxToFile[WhiteKingIdx]) And (IdxToRank[WhiteKingIdx] > IdxToRank[Idx]))
                                            {
                                                List.ReplaceItem(MinMaxResults, Depth, 0);
                                                List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                                                Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
                                                Stop(this script);
                                            }
                                        }
                                        Else
                                        {
                                            If (((Idx + 8) == WhiteKingIdx) Or ((Idx + 16) == WhiteKingIdx))
                                            {
                                                If (Not ((((Idx - 1) == BlackKingIdx) Or ((Idx + 1) == BlackKingIdx))))
                                                {
                                                    List.ReplaceItem(MinMaxResults, Depth, 0);
                                                    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                                                    Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
                                                    Stop(this script);
                                                }
                                            }
                                            If ((Idx + 24) == WhiteKingIdx)
                                            {
                                                If ((IdxToRank[Idx] < 5) And ((Idx + 8) == BlackKingIdx))
                                                {
                                                    List.ReplaceItem(MinMaxResults, Depth, 0);
                                                    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
                                                    Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(99)("")("")("")("")("")(0);
                                                    Stop(this script);
                                                }
                                            }
                                        }
                                    }
                                }
                                Idx += 1;
                            }
                        }
                    }
                }
            }
        }
    }
    Call //("Initialize local variables or forward state from previous ply");
    If (Depth == 1)
    {
        If InitialDeepening
        {
            List.DeleteItem(DeepeningScore, all);
            List.DeleteItem(DeepeningScoreOrderMap, all);
        }
        Call CalcBoardAttackedByMove(1);
        Call StoreAttackInfo(1)(1);
        Call CalcBoardAttackedByMove(2);
        Call StoreAttackInfo(2)(1);
        List.ReplaceItem(BoardAttackedCalculated, 1, 1);
        Call GenerateMovesImplWrapper(1)((1 == 0))((1 == 0));
        Call GenerateMovesImplWrapper(2)((1 == 0))((1 == 0));
        List.ReplaceItem(WhiteMobBonus, 1, WhiteMobBonus[2]);
        List.ReplaceItem(CastlingState, 1, Operator.Join(Operator.Join(Operator.Join(HasBlackCastled, HasBlackKingMoved), Operator.Join(HasBlackRookKSMoved, HasBlackRookQSMoved)), Operator.Join(Operator.Join(HasWhiteCastled, HasWhiteKingMoved), Operator.Join(HasWhiteRookKSMoved, HasWhiteRookQSMoved))));
    }
    Else
    {
        List.ReplaceItem(BoardAttackedByBlackSnapshot, Depth, BoardAttackedByBlackSnapshot[(Depth - 1)]);
        List.ReplaceItem(BoardAttackedByBlackPieceSnapshot, Depth, BoardAttackedByBlackPieceSnapshot[(Depth - 1)]);
        List.ReplaceItem(BoardAttackedByWhiteSnapshot, Depth, BoardAttackedByWhiteSnapshot[(Depth - 1)]);
        List.ReplaceItem(BoardAttackedByWhitePieceSnapshot, Depth, BoardAttackedByWhitePieceSnapshot[(Depth - 1)]);
        List.ReplaceItem(BoardAttackedCalculated, Depth, 0);
        List.ReplaceItem(CheckedState, Depth, PutsInCheck[(Depth - 1)]);
        List.ReplaceItem(CheckedStateAttackLines, Depth, "");
        List.ReplaceItem(BlackMobBonus, Depth, BlackMobBonus[(Depth - 1)]);
        List.ReplaceItem(WhiteMobBonus, Depth, WhiteMobBonus[(Depth - 1)]);
        List.ReplaceItem(CastlingState, Depth, CastlingState[(Depth - 1)]);
    }
    List.ReplaceItem(AlphasOld, Depth, Alphas[Depth]);
    List.ReplaceItem(BetasOld, Depth, Betas[Depth]);
    List.ReplaceItem(PutsInCheck, Depth, 0);
    Call //("Search tree leaf reached => evaluate board and return result");
    If (Depth == MaxDepth)
    {
        Call OnScoreCalc((Depth - 1))(MinDepth)((MaxDepth - 1))(PrevQuiescence);
        Call OnScoreCalcPostProcess((Depth - 1));
        List.ReplaceItem(MinMaxResults, Depth, ScoreCalcRes);
        List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreCalcResIsDynamic);
        Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("E")("")(0)("")("")("")("")("")(MinMaxResultsIsDynamic[Depth]);
        Stop(this script);
    }
    If Quiescence
    {
        Call //("Quiescence search standing pat handling (unless in check and must evade)");
        Call OnScoreCalc((Depth - 1))(MinDepth)((Depth - 1))(PrevQuiescence);
        Call OnScoreCalcPostProcess((Depth - 1));
        If (CheckedState[Depth] == 0)
        {
            List.ReplaceItem(MinMaxResults, Depth, ScoreCalcRes);
            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreCalcResIsDynamic);
            If ((Depth % 2) == 1)
            {
                If (Not ((ScoreCalcRes < Betas[Depth])))
                {
                    List.ReplaceItem(MinMaxResults, Depth, Betas[Depth]);
                    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreCalcResIsDynamic);
                    If (1 == 0)
                    {
                        Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("B")("")(-1)("")("")("")("")("")(MinMaxResultsIsDynamic[Depth]);
                    }
                    Stop(this script);
                }
                If (ScoreCalcRes > Alphas[Depth])
                {
                    List.ReplaceItem(Alphas, Depth, ScoreCalcRes);
                }
            }
            Else
            {
                If (Not ((ScoreCalcRes > Alphas[Depth])))
                {
                    List.ReplaceItem(MinMaxResults, Depth, Alphas[Depth]);
                    List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreCalcResIsDynamic);
                    If (1 == 0)
                    {
                        Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")("A")("")(-1)("")("")("")("")("")(MinMaxResultsIsDynamic[Depth]);
                    }
                    Stop(this script);
                }
                If (ScoreCalcRes < Betas[Depth])
                {
                    List.ReplaceItem(Betas, Depth, ScoreCalcRes);
                }
            }
        }
        Else
        {
            If ((Depth % 2) == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, (-100000 + (Depth * 1000)));
            }
            Else
            {
                List.ReplaceItem(MinMaxResults, Depth, (100000 - (Depth * 1000)));
            }
        }
    }
    Else
    {
        Call //("Full search => invoke board evaluation to calculate intermediate results if required");
        Call OnScoreCalc((Depth - 1))(MinDepth)((MaxDepth - 1))(PrevQuiescence);
    }
    Call //("Null move pruning");
    If (Not (Quiescence))
    {
        If (((IsInNullMove == 0) And (Not ((PlayingMode == 2)))) And (((Depth > 2) And ((MaxDepth - Depth) > 2)) And (((Betas[Depth] - Alphas[Depth]) == 1) And ((Not ((CheckedState[(Depth - 1)] == 1))) And (Not ((CheckedState[Depth] == 1)))))))
        {
            If (((BlackMinorCountLocal + BlackQueenCountLocal) > 0) And ((WhiteMinorCountLocal + WhiteQueenCountLocal) > 0))
            {
                IsInNullMove += 1;
                If ((Depth % 2) == 1)
                {
                    Call OnScoreCalc((Depth - 1))(MinDepth)((Depth - 1))(Quiescence);
                    If (Not ((ScoreCalcRes < Betas[Depth])))
                    {
                        Call ClearMoveList((Depth + 0));
                        Call AddMoveToList(0000)((Depth + 0));
                        List.ReplaceItem(MovesIdx, (Depth + 0), 1);
                        Call ApplyMove((Depth + 0));
                        Call OnScoreCalc((Depth + 0))(MinDepth)((MaxDepth - 1))(Quiescence);
                        List.ReplaceItem(Alphas, (Depth + 1), (Betas[Depth] - 1));
                        List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                        IsPlyExtensionRes = 0;
                        If ((MaxDepth - Depth) == 1)
                        {
                            Call IsPlyExtension(Depth);
                        }
                        CurrentValue = (((MaxDepth - Depth) - 2) - IsPlyExtensionRes);
                        If (CurrentValue > 2)
                        {
                            CurrentValue = 2;
                        }
                        CurrentValue += floor((((MaxDepth - Depth) - 2) / 4));
                        If (CurrentValue < 0)
                        {
                            CurrentValue = 0;
                        }
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth - CurrentValue))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                        Score = MinMaxResults[(Depth + 1)];
                        ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                        Call RevertMove((Depth + 0));
                        If ((Not ((Score < Betas[Depth]))) And (Not ((abs(Score) > AbsMinCheckmateEval))))
                        {
                            List.ReplaceItem(MinMaxResults, Depth, Betas[Depth]);
                            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreIsDynamic);
                            IsInNullMove += -1;
                            Stop(this script);
                        }
                    }
                }
                Else
                {
                    Call OnScoreCalc((Depth - 1))(MinDepth)((Depth - 1))(Quiescence);
                    If (Not ((ScoreCalcRes > Alphas[Depth])))
                    {
                        Call ClearMoveList((Depth + 0));
                        Call AddMoveToList(0000)((Depth + 0));
                        List.ReplaceItem(MovesIdx, (Depth + 0), 1);
                        Call ApplyMove((Depth + 0));
                        Call OnScoreCalc((Depth + 0))(MinDepth)((MaxDepth - 1))(Quiescence);
                        List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                        List.ReplaceItem(Betas, (Depth + 1), (Alphas[Depth] + 1));
                        IsPlyExtensionRes = 0;
                        If ((MaxDepth - Depth) == 1)
                        {
                            Call IsPlyExtension(Depth);
                        }
                        CurrentValue = (((MaxDepth - Depth) - 2) - IsPlyExtensionRes);
                        If (CurrentValue > 2)
                        {
                            CurrentValue = 2;
                        }
                        CurrentValue += floor((((MaxDepth - Depth) - 2) / 4));
                        If (CurrentValue < 0)
                        {
                            CurrentValue = 0;
                        }
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth - CurrentValue))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                        Score = MinMaxResults[(Depth + 1)];
                        ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                        Call RevertMove((Depth + 0));
                        If ((Not ((Score > Alphas[Depth]))) And (Not ((abs(Score) > AbsMinCheckmateEval))))
                        {
                            List.ReplaceItem(MinMaxResults, Depth, Alphas[Depth]);
                            List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreIsDynamic);
                            IsInNullMove += -1;
                            Stop(this script);
                        }
                    }
                }
                IsInNullMove += -1;
            }
        }
    }
    List.ReplaceItem(PickPhase, Depth, 1);
    List.ReplaceItem(PickMoveRes, Depth, 1);
    Call //("Move generation and application loop, recursive search invocation");
    Repeat Until (PickMoveRes[Depth] == 0)
    {
        If ((Depth < 6) Or ((Depth < 9) And (Not (Quiescence))))
        {
            If ((IsMinMaxTimeout == 0) And (Not (InitialDeepening)))
            {
                If (((Sensing.DaysSince2000() * 86400) - ThinkTimeStart) > ThinkTimeLimitMinMax)
                {
                    IsMinMaxTimeout = 1;
                }
            }
        }
        If (IsMinMaxTimeout == 1)
        {
            If (Quiescence[Depth] == 0)
            {
                MoveCount += MovesCount[Depth];
            }
            Else
            {
                MoveCountQ += MovesCount[Depth];
            }
            Stop(this script);
        }
        If (IsBlockProfilerEnabled == 1)
        {
            Call Profile_MethodEnter(((5 * MaxSearchDepthStackFrames) + Depth));
        }
        Call //("Invoke move generator and apply next move from list");
        Call PickMove(Depth)(Quiescence);
        If (IsBlockProfilerEnabled == 1)
        {
            Call Profile_MethodExit(((5 * MaxSearchDepthStackFrames) + Depth));
        }
        If (PickMoveRes[Depth] == 1)
        {
            Call //("Show progress and collect statistics");
            If (ShowProgress And (Depth < 6))
            {
                CurrentValue = (Sensing.DaysSince2000() * 86400);
                If (CurrentValue > (PrevProgressUpdate + 1))
                {
                    Call OnProgressChanged((((CurrentValue - ThinkTimeStart) / ThinkTimeLimitMinMax) * 100));
                }
            }
            List.ReplaceItem(PutsInCheck, Depth, 0);
            List.ReplaceItem(PlyExtensionTagged, Depth, 0);
            List.ReplaceItem(PlyExtension, Depth, 0);
            SourceIdxOuter2 = floor((AppliedMove[Depth] / 100));
            TargetIdxOuter2 = floor((AppliedMove[Depth] % 100));
            Call //("Fast check detection for current move");
            Call IsCheckingPiece(TargetIdxOuter2);
            If (IsCheckingPieceRes == 1)
            {
                List.ReplaceItem(PutsInCheck, Depth, 1);
                Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(1)(0)("")("")("")("")("")("");
            }
            Call //("Fast discovered check detection for current move");
            Call IsCheckingPieceDiscovery(SourceIdxOuter2)(TargetIdxOuter2)(Depth);
            If (IsCheckingPieceRes == 1)
            {
                List.ReplaceItem(PutsInCheck, Depth, 1);
                Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(1)(0)("")("")("")("")("")("");
            }
            Call //("Fork detection for Scratch 3 runtime. Forks at low search depth will trigger search extension");
            If ((Not (Quiescence)) And ((Level > 4) Or (IsScratch3 == 0)))
            {
                SourceIdxOuter2 = floor((AppliedMove[Depth] % 100));
                SourcePieceOuter2 = Board[SourceIdxOuter2];
                If ((((Depth < 5) And (IsScratch3 == 1)) And (IsEndgame == 0)) And (abs(SourcePieceOuter2) < BlackRook))
                {
                    CountOuter1 = 0;
                    If ((Depth % 2) == 1)
                    {
                        TargetIdxOuter2 = 1;
                        Repeat (64)
                        {
                            If (Board[TargetIdxOuter2] < 0)
                            {
                                If (SourcePieceOuter2 < abs(Board[TargetIdxOuter2]))
                                {
                                    If (Not ((MovePosLookupBlack[((PieceIdxLookup[SourcePieceOuter2] * 10000) + ((SourceIdxOuter2 * 100) + TargetIdxOuter2))] == "")))
                                    {
                                        CountOuter1 += 1;
                                    }
                                }
                            }
                            TargetIdxOuter2 += 1;
                        }
                    }
                    Else
                    {
                        TargetIdxOuter2 = 1;
                        Repeat (64)
                        {
                            If (Board[TargetIdxOuter2] > 0)
                            {
                                If (abs(SourcePieceOuter2) < Board[TargetIdxOuter2])
                                {
                                    If (Not ((MovePosLookupWhite[((PieceIdxLookup[abs(SourcePieceOuter2)] * 10000) + ((SourceIdxOuter2 * 100) + TargetIdxOuter2))] == "")))
                                    {
                                        CountOuter1 += 1;
                                    }
                                }
                            }
                            TargetIdxOuter2 += 1;
                        }
                    }
                    If (CountOuter1 > 1)
                    {
                        CountOuter2 = 0;
                        Call ClearMoveList((Depth + 2));
                        Call GenerateMovesForSourceEx((Depth + 2))(floor((AppliedMove[Depth] % 100)))((1 == 0))((1 == 1));
                        List.ReplaceItem(MovesIdx, (Depth + 2), 1);
                        Repeat Until ((MovesIdx[(Depth + 2)] > MovesCount[(Depth + 2)]) Or (CountOuter2 > 1))
                        {
                            Call GetCurrentMove((Depth + 2));
                            SourceIdxOuter2 = floor((CurrentMove / 100));
                            TargetIdxOuter2 = floor((CurrentMove % 100));
                            If (abs(Board[SourceIdxOuter2]) < abs(Board[TargetIdxOuter2]))
                            {
                                CountOuter2 += 1;
                            }
                            List.ReplaceItem(MovesIdx, (Depth + 2), (MovesIdx[(Depth + 2)] + 1));
                        }
                        If (CountOuter2 > 1)
                        {
                            List.ReplaceItem(PlyExtensionTagged, Depth, 1);
                        }
                    }
                }
                Call //("Search extensions for Scratch 3 runtime when in check and attacking piece is not counter-attacked");
                If ((IsScratch3 == 1) And (Depth < 6))
                {
                    If ((Depth > 1) And (CheckedState[Depth] == 1))
                    {
                        TargetIdxOuter2 = floor((AppliedMove[(Depth - 1)] % 100));
                        If ((Depth % 2) == 0)
                        {
                            If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[(Depth - 1)], TargetIdxOuter2) == 0)
                            {
                                List.ReplaceItem(PlyExtensionTagged, Depth, 1);
                            }
                        }
                        Else
                        {
                            If (Operator.LetterOf(BoardAttackedByBlackSnapshot[(Depth - 1)], TargetIdxOuter2) == 0)
                            {
                                List.ReplaceItem(PlyExtensionTagged, Depth, 1);
                            }
                        }
                    }
                }
                If ((Depth > 1) And ((MaxDepth - Depth) == 1))
                {
                    Call IsPlyExtension(Depth);
                    If (IsPlyExtensionRes == 1)
                    {
                        List.ReplaceItem(PlyExtension, Depth, 1);
                    }
                }
            }
            Call //("Futility pruning");
            IsFutile = 0;
            If ((Not ((CheckedState[Depth] == 1))) And (Not ((PutsInCheck[Depth] == 1))))
            {
                FutilityMargin = "";
                If Quiescence
                {
                    FutilityMargin = 125;
                }
                Else
                {
                    If ((Depth > 2) And ((MaxDepth - Depth) < 3))
                    {
                        If (((TargetPieces[Depth] == 0) And (PromotionPieces[Depth] == 0)) And ((PickedMoveCount[Depth] > 1) And ((Betas[Depth] - Alphas[Depth]) == 1)))
                        {
                            FutilityMargin = ((MaxDepth - Depth) * 75);
                        }
                    }
                }
                If ((Not ((FutilityMargin == ""))) And (1 == 1))
                {
                    Call OnScoreCalc(Depth)(MinDepth)(Depth)(Quiescence);
                    If ((Depth % 2) == 1)
                    {
                        If (Not (((ScoreCalcRes + FutilityMargin) > Alphas[Depth])))
                        {
                            IsFutile = 1;
                        }
                    }
                    Else
                    {
                        If (Not (((ScoreCalcRes - FutilityMargin) < Betas[Depth])))
                        {
                            IsFutile = 1;
                        }
                    }
                }
            }
            If (IsFutile == 1)
            {
                Call RevertMove(Depth);
            }
            Else
            {
                Call //("Late move reduction preparation");
                IsReductionAndDone = 0;
                If ((Not (Quiescence)) And (IsMinMaxTimeout == 0))
                {
                    If (((((BlackQueenCount + BlackMinorCount) > 0) And ((WhiteQueenCount + WhiteMinorCount) > 0)) And (MaxDepth > 2)) And (((MaxDepth + PlyExtension[Depth]) - Depth) > 1))
                    {
                        CurrentValue = "";
                        If (PickedMoveCount[Depth] > 1)
                        {
                            If ((TargetPieces[Depth] == 0) And (PromotionPieces[Depth] == 0))
                            {
                                If (((MaxDepth + PlyExtension[Depth]) - Depth) > 2)
                                {
                                    CurrentValue = ceiling(((log(Depth) * log(PickedMoveCount[Depth])) / 2));
                                    If ((Betas[Depth] - Alphas[Depth]) == 1)
                                    {
                                        CurrentValue += 1;
                                    }
                                    Else
                                    {
                                        CurrentValue += -1;
                                    }
                                    If (CheckedState[Depth] == 1)
                                    {
                                        CurrentValue += -1;
                                    }
                                    If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (PickedMoveCount[Depth] < 5))
                                    {
                                        SourceIdx = floor((AppliedMove[Depth] / 100));
                                        TargetIdx = floor((AppliedMove[Depth] % 100));
                                        Call GetMoveScore(Board[SourceIdx])(Board[TargetIdx])(SourceIdx)(TargetIdx)(AppliedMove[Depth])(Depth);
                                        If (abs(MoveScoreRes) > 60)
                                        {
                                            CurrentValue += -1;
                                        }
                                    }
                                    If (CurrentValue > 2)
                                    {
                                        CurrentValue = 2;
                                    }
                                    If (CurrentValue > (((MaxDepth + PlyExtension[Depth]) - Depth) - 1))
                                    {
                                        CurrentValue = (((MaxDepth + PlyExtension[Depth]) - Depth) - 1);
                                    }
                                    If (CurrentValue < 0)
                                    {
                                        CurrentValue = 0;
                                    }
                                }
                            }
                        }
                        If ((Depth % 2) == 1)
                        {
                            Call //("Late move reduction");
                            If ((Not ((CurrentValue == ""))) And (CurrentValue > 0))
                            {
                                List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                                List.ReplaceItem(Betas, (Depth + 1), (Alphas[Depth] + 1));
                                Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)(((MaxDepth + PlyExtension[Depth]) - CurrentValue))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                                Score = MinMaxResults[(Depth + 1)];
                                ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                                IsReductionAndDone = 1;
                            }
                            Call //("Non-PV search");
                            If ((((IsReductionAndDone == 1) And (Score > Alphas[Depth])) Or ((IsReductionAndDone == 0) And (((Betas[Depth] - Alphas[Depth]) == 1) Or (PickedMoveCount[Depth] > 2)))) And (IsMinMaxTimeout == 0))
                            {
                                List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                                List.ReplaceItem(Betas, (Depth + 1), (Alphas[Depth] + 1));
                                Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth + PlyExtension[Depth]))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                                Score = MinMaxResults[(Depth + 1)];
                                ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                                IsReductionAndDone = 1;
                                If ((Score > Alphas[Depth]) And (Score < Betas[Depth]))
                                {
                                    IsReductionAndDone = 0;
                                }
                            }
                        }
                        Else
                        {
                            Call //("Late move reduction");
                            If ((Not ((CurrentValue == ""))) And (CurrentValue > 0))
                            {
                                List.ReplaceItem(Alphas, (Depth + 1), (Betas[Depth] - 1));
                                List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                                Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)(((MaxDepth + PlyExtension[Depth]) - CurrentValue))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                                Score = MinMaxResults[(Depth + 1)];
                                ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                                IsReductionAndDone = 1;
                            }
                            Call //("Non-PV search");
                            If ((((IsReductionAndDone == 1) And (Score < Betas[Depth])) Or ((IsReductionAndDone == 0) And (((Betas[Depth] - Alphas[Depth]) == 1) Or (PickedMoveCount[Depth] > 2)))) And (IsMinMaxTimeout == 0))
                            {
                                List.ReplaceItem(Alphas, (Depth + 1), (Betas[Depth] - 1));
                                List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                                Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth + PlyExtension[Depth]))(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                                Score = MinMaxResults[(Depth + 1)];
                                ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                                IsReductionAndDone = 1;
                                If ((Score > Alphas[Depth]) And (Score < Betas[Depth]))
                                {
                                    IsReductionAndDone = 0;
                                }
                            }
                        }
                    }
                }
                Call //("Move was not pruned upfront, enter standard search");
                If ((IsReductionAndDone == 0) And (IsMinMaxTimeout == 0))
                {
                    List.ReplaceItem(Alphas, (Depth + 1), Alphas[Depth]);
                    List.ReplaceItem(Betas, (Depth + 1), Betas[Depth]);
                    If ((QuiescenceDepth > 0) And (Depth == (MaxDepth - 1)))
                    {
                        Call //("If still on full search: max depth reached, extend or continue with quiescence. If on quiescence search, continue");
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)((MaxDepth + 1))(InitialDeepening)((QuiescenceDepth - 1))((Quiescence Or (PlyExtension[Depth] == 0)))(Quiescence)(ShowProgress);
                    }
                    Else
                    {
                        Call AlphaBetaMinMaxImpl((Depth + 1))(MinDepth)(MaxDepth)(InitialDeepening)(QuiescenceDepth)(Quiescence)(Quiescence)(ShowProgress);
                    }
                    Score = MinMaxResults[(Depth + 1)];
                    ScoreIsDynamic = MinMaxResultsIsDynamic[(Depth + 1)];
                    IsReductionAndDone = 0;
                }
                Call //("Revert applied move, restore board to previous state");
                Call RevertMove(Depth);
                If (IsMinMaxTimeout == 1)
                {
                    If (Quiescence[Depth] == 0)
                    {
                        MoveCount += MovesCount[Depth];
                    }
                    Else
                    {
                        MoveCountQ += MovesCount[Depth];
                    }
                    Stop(this script);
                }
                Call //("Compare node evaluation with search window, adapt node evaluation result and alpha/beta funnel accordingly");
                If ((Depth % 2) == 1)
                {
                    If (Depth == 1)
                    {
                        List.Add(MinMaxPly1EvalMoves, Moves1[MovesIdx[1]]);
                    }
                    If ((Score > MinMaxResults[Depth]) Or (MinMaxResults[Depth] == ""))
                    {
                        List.ReplaceItem(MinMaxResults, Depth, Score);
                        List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreIsDynamic);
                        If (Score > Alphas[Depth])
                        {
                            Call GetCurrentMove(Depth);
                            List.ReplaceItem(BestMoves, Depth, CurrentMove);
                            List.ReplaceItem(MovesIdxBestMove, Depth, MovesIdx[Depth]);
                            If Quiescence
                            {
                                If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (Score < Betas[Depth]))
                                {
                                    List.ReplaceItem(Alphas, Depth, Score);
                                }
                                Else
                                {
                                    Call //("Cutoff");
                                    List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                    List.ReplaceItem(PickPhase, Depth, "*");
                                }
                            }
                            Else
                            {
                                List.ReplaceItem(Alphas, Depth, Score);
                                If (Not ((Score < Betas[Depth])))
                                {
                                    If (Depth > 1)
                                    {
                                        If ((floor((BestMoves[Depth] / 100)) == 0) Or (Board[floor((BestMoves[Depth] % 100))] == 0))
                                        {
                                            Call StoreKillerMove(Depth)(BestMoves[Depth])(MaxDepth);
                                        }
                                        Call //("Cutoff");
                                        List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                        List.ReplaceItem(PickPhase, Depth, "*");
                                    }
                                }
                                Else
                                {
                                    If ((Depth == 1) And (IsMinMaxTimeout == 0))
                                    {
                                        Call OnEvaluationChanged(Score);
                                        If (Not ((Score < (0 - AbsMaxCheckmateEval))))
                                        {
                                            Call //("Best move found for depth = 1, special handling (re-use history for iterative deepening order, logging, move preview visualization)");
                                            MinMaxMoveRes = Moves1[MovesIdx[1]];
                                            MinMaxEvalRes = Score;
                                            If (1 == 1)
                                            {
                                                Call Log((MaxDepth - 1))(" : ")(MinMaxMoveRes)(" : ")(MinMaxEvalRes)("")("")("");
                                            }
                                            Idx = (MaxPly1DeepeningMoveOrderScore - 4);
                                            Repeat (5)
                                            {
                                                List.ReplaceItem(DeepeningScore, List.IndexOf(DeepeningScore, Idx), (Idx - 1));
                                                Idx += 1;
                                            }
                                            List.ReplaceItem(DeepeningScore, DeepeningScoreOrderMap[MovesIdx[1]], MaxPly1DeepeningMoveOrderScore);
                                            If (MinMaxMoveRes == BlackKingsideCastling)
                                            {
                                                BestMoveFromIdx = VirtualBoard[5];
                                                BestMoveToIdx = VirtualBoard[7];
                                            }
                                            Else
                                            {
                                                If (MinMaxMoveRes == BlackQueensideCastling)
                                                {
                                                    BestMoveFromIdx = VirtualBoard[5];
                                                    BestMoveToIdx = VirtualBoard[3];
                                                }
                                                Else
                                                {
                                                    BestMoveFromIdx = floor((MinMaxMoveRes / 100));
                                                    BestMoveToIdx = floor((MinMaxMoveRes % 100));
                                                }
                                            }
                                            Event.Broadcast("showbestmove");
                                            If (Score > (AbsMaxCheckmateEval - ((MaxDepth - 1) * 1000)))
                                            {
                                                IsMinMaxTimeout = 1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                Else
                {
                    If ((Score < MinMaxResults[Depth]) Or (MinMaxResults[Depth] == ""))
                    {
                        List.ReplaceItem(MinMaxResults, Depth, Score);
                        List.ReplaceItem(MinMaxResultsIsDynamic, Depth, ScoreIsDynamic);
                        If (Score < Betas[Depth])
                        {
                            Call GetCurrentMove(Depth);
                            List.ReplaceItem(BestMoves, Depth, CurrentMove);
                            List.ReplaceItem(MovesIdxBestMove, Depth, MovesIdx[Depth]);
                            If Quiescence
                            {
                                If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (Score > Alphas[Depth]))
                                {
                                    List.ReplaceItem(Betas, Depth, Score);
                                }
                                Else
                                {
                                    List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                    List.ReplaceItem(PickPhase, Depth, "*");
                                    Call //("Cutoff");
                                }
                            }
                            Else
                            {
                                List.ReplaceItem(Betas, Depth, Score);
                                If (Not ((Score > Alphas[Depth])))
                                {
                                    If ((floor((BestMoves[Depth] / 100)) == 0) Or (Board[floor((BestMoves[Depth] % 100))] == 0))
                                    {
                                        Call StoreKillerMove(Depth)(BestMoves[Depth])(MaxDepth);
                                    }
                                    List.ReplaceItem(MovesIdx, Depth, (MovesCount[Depth] + 1));
                                    List.ReplaceItem(PickPhase, Depth, "*");
                                    Call //("Cutoff");
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    If (Quiescence[Depth] == 0)
    {
        MoveCount += MovesCount[Depth];
    }
    Else
    {
        MoveCountQ += MovesCount[Depth];
    }
    Call //("Evaluation alpha-bound, beta-bound or exact?");
    If ((Depth % 2) == 1)
    {
        If (Not ((MinMaxResults[Depth] < Betas[Depth])))
        {
            List.ReplaceItem(ScoreTypes, Depth, "B");
        }
        Else
        {
            If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (((Not (Quiescence)) And (Not ((BestMoves[Depth] == "")))) Or (Quiescence And (MinMaxResults[Depth] > AlphasOld[Depth]))))
            {
                List.ReplaceItem(ScoreTypes, Depth, "E");
            }
            Else
            {
                List.ReplaceItem(ScoreTypes, Depth, "A");
            }
        }
    }
    Else
    {
        If (Not ((MinMaxResults[Depth] > Alphas[Depth])))
        {
            List.ReplaceItem(ScoreTypes, Depth, "A");
        }
        Else
        {
            If ((Not (((Betas[Depth] - Alphas[Depth]) == 1))) And (((Not (Quiescence)) And (Not ((BestMoves[Depth] == "")))) Or (Quiescence And (MinMaxResults[Depth] < BetasOld[Depth]))))
            {
                List.ReplaceItem(ScoreTypes, Depth, "E");
            }
            Else
            {
                List.ReplaceItem(ScoreTypes, Depth, "B");
            }
        }
    }
    Call //("Fast quiescence search checkmate detection (no check evasion found)");
    If (Quiescence And ((MovesCount[Depth] == 0) And (CheckedState[Depth] == 1)))
    {
        List.ReplaceItem(ScoreTypes, Depth, "E");
        If ((Depth % 2) == 1)
        {
            List.ReplaceItem(MinMaxResults, Depth, (-100000 + ((Depth + 1) * 1000)));
        }
        Else
        {
            List.ReplaceItem(MinMaxResults, Depth, (100000 - ((Depth + 1) * 1000)));
        }
        List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
    }
    Call //("Fast full search checkmate and stalemate detection");
    If ((Not (Quiescence)) And (MovesCount[Depth] == 0))
    {
        List.ReplaceItem(ScoreTypes, Depth, "E");
        If ((Depth % 2) == 1)
        {
            If (CheckedState[Depth] == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, (-100000 + ((Depth + 1) * 1000)));
            }
            Else
            {
                Call CalcBoardAttackedByMoveChecked((Depth + 1));
                If (IsBlackChecked == 1)
                {
                    List.ReplaceItem(MinMaxResults, Depth, (-100000 + ((Depth + 1) * 1000)));
                }
                Else
                {
                    List.ReplaceItem(MinMaxResults, Depth, 0);
                }
            }
        }
        Else
        {
            If (CheckedState[Depth] == 1)
            {
                List.ReplaceItem(MinMaxResults, Depth, (100000 - ((Depth + 1) * 1000)));
            }
            Else
            {
                Call CalcBoardAttackedByMoveChecked((Depth + 1));
                If (IsWhiteChecked == 1)
                {
                    List.ReplaceItem(MinMaxResults, Depth, (100000 - ((Depth + 1) * 1000)));
                }
                Else
                {
                    List.ReplaceItem(MinMaxResults, Depth, 0);
                }
            }
        }
        List.ReplaceItem(MinMaxResultsIsDynamic, Depth, 0);
        Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])("")(ScoreTypes[Depth])("")(99)("")("")("")("")("")(0);
    }
    If (BestMoves[Depth] == "")
    {
        If (MovesCount[Depth] > 0)
        {
            List.ReplaceItem(MovesIdx, Depth, 1);
            Call GetCurrentMove(Depth);
            List.ReplaceItem(BestMoves, Depth, CurrentMove);
        }
    }
    If ((IsMinMaxTimeout == 0) And (Depth > 1))
    {
        Call //("Store evaluations, hash moves, attack tables, check state, mobility, ... to transposition table");
        If Quiescence
        {
            If (InitialDeepening And (abs(MinMaxResults[Depth]) < AbsMinCheckmateEval))
            {
                Call TTStoreNode(CurrentBoardHash)(Depth)("")(BestMoves[Depth])("")("")(-1)("")("")("")("")("")("");
            }
            Else
            {
                Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])(BestMoves[Depth])(ScoreTypes[Depth])("")(-1)("")("")("")("")("")(MinMaxResultsIsDynamic[Depth]);
            }
        }
        Else
        {
            Call TTStoreNode(CurrentBoardHash)(Depth)(MinMaxResults[Depth])(BestMoves[Depth])(ScoreTypes[Depth])("")((MaxDepth - Depth))("")("")("")("")("")(MinMaxResultsIsDynamic[Depth]);
        }
    }
    Call //("Collect statistics");
    If (MovesIdxBestMove[Depth] > 0)
    {
        If Quiescence
        {
            ProfBestMoveCountQ += 1;
            ProfBestMoveIdxSumQ += MovesIdxBestMove[Depth];
        }
        Else
        {
            ProfBestMoveCount += 1;
            ProfBestMoveIdxSum += MovesIdxBestMove[Depth];
        }
        If (1 == 0)
        {
            If (IsBlockProfilerEnabled == 1)
            {
                If (MovesIdxBestMove[Depth] > (3 - (Quiescence[Depth] * 2)))
                {
                    Call ExportBoardFEN((IsPlayerBlack == 1))(((Depth % 2) == 0));
                    Call Log("Move ordering indication")(Operator.Join(Operator.Join(":", Depth), Operator.Join(":", MovesIdxBestMove[Depth])))(Operator.Join(Operator.Join(":", Board[floor((BestMoves[Depth] / 100))]), Operator.Join(":", BestMoves[Depth])))(Operator.Join(Operator.Join(":", Board[floor((BestMoves[Depth] % 100))]), Operator.Join(":", Quiescence[Depth])))(":")(ExportDataFEN)("")("");
                }
            }
        }
    }
}

Define ApplyMove(num Depth) (warp=true)
{
    List.ReplaceItem(PosScoreDelta, Depth, 0);
    List.ReplaceItem(SourcePieces, Depth, 0);
    List.ReplaceItem(TargetPiecesIdx, Depth, "");
    List.ReplaceItem(TargetPieces, Depth, 0);
    List.ReplaceItem(PromotionPieces, Depth, 0);
    If (Depth < 3)
    {
        List.ReplaceItem(PawnShelterCapture, Depth, 0);
    }
    Else
    {
        List.ReplaceItem(PawnShelterCapture, Depth, PawnShelterCapture[(Depth - 2)]);
    }
    If (Depth > 1)
    {
        List.ReplaceItem(CastlingState, Depth, CastlingState[(Depth - 1)]);
    }
    List.ReplaceItem(EnPassantTarget, (Depth + 1), "");
    List.ReplaceItem(PreviousBoardHash, Depth, CurrentBoardHash);
    List.ReplaceItem(PreviousBoardHash2, Depth, CurrentBoardHash2);
    Call GetCurrentMove(Depth);
    List.ReplaceItem(AppliedMove, Depth, CurrentMove);
    List.ReplaceItem(AppliedMove_NNUE_State, Depth, 0);
    SourceIdx = floor((CurrentMove / 100));
    If (SourceIdx > 0)
    {
        TargetIdx = floor((CurrentMove % 100));
        SourcePiece = Board[SourceIdx];
        TargetPiece = Board[TargetIdx];
        List.ReplaceItem(SourcePieces, Depth, SourcePiece);
        List.ReplaceItem(TargetPiecesIdx, Depth, TargetIdx);
        List.ReplaceItem(TargetPieces, Depth, TargetPiece);
        List.ReplaceItem(PromotionPieces, Depth, 0);
        List.ReplaceItem(Board, TargetIdx, SourcePiece);
        List.ReplaceItem(Board, SourceIdx, 0);
        If (SourcePiece > 0)
        {
            IdxSub = ((PieceIdxLookup[SourcePiece] * 10000) + ((SourceIdx * 100) + TargetIdx));
            List.ReplaceItem(PosScoreDelta, Depth, MovePosLookupBlack[IdxSub]);
            CurrentBoardHash += MoveHashLookupBlack[IdxSub];
            If (SourcePiece == BlackPawn)
            {
                CurrentBoardHash2 += MoveHashLookupBlack[IdxSub];
                If (Not ((IdxToFile[SourceIdx] == IdxToFile[TargetIdx])))
                {
                    If (TargetPieces[Depth] == 0)
                    {
                        List.ReplaceItem(TargetPiecesIdx, Depth, (TargetIdx - 8));
                        List.ReplaceItem(TargetPieces, Depth, Board[(TargetIdx - 8)]);
                        TargetPiece = Board[(TargetIdx - 8)];
                        List.ReplaceItem(Board, (TargetIdx - 8), 0);
                        Call GetPiecePosHash(Board[(TargetIdx - 8)])((TargetIdx - 8));
                        CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                        CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
                    }
                }
                If ((TargetIdx - SourceIdx) == 16)
                {
                    List.ReplaceItem(EnPassantTarget, (Depth + 1), TargetIdx);
                }
                If (TargetIdx > 56)
                {
                    PromotionVal = Operator.LetterOf(CurrentMove, 6);
                    If (PromotionVal == 1)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, BlackQueen);
                        BlackQueenCountLocal += 1;
                    }
                    If (PromotionVal == 2)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, BlackRook);
                        BlackRookCountLocal += 1;
                        BlackMinorCountLocal += 1;
                    }
                    If (PromotionVal == 3)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, BlackBishop);
                        BlackBishopCountLocal += 1;
                        BlackMinorCountLocal += 1;
                    }
                    If (PromotionVal == 4)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, BlackKnight);
                        BlackMinorCountLocal += 1;
                    }
                    List.ReplaceItem(Board, TargetIdx, PromotionPieces[Depth]);
                    BlackPawnCountLocal += -1;
                    Call GetPiecePosHash(BlackPawn)(SourceIdx);
                    CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                    CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
                    Call GetPiecePosHash(PromotionPieces[Depth])(TargetIdx);
                    CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
                }
            }
            Else
            {
                If (SourcePiece == BlackKing)
                {
                    BlackKingIdx = TargetIdx;
                    CurrentBoardHash2 += MoveHashLookupBlack[IdxSub];
                    Call SetCastlingStateFlag(Depth)(2)(1);
                }
                If (SourcePiece == BlackRook)
                {
                    If (Operator.LetterOf(CastlingState[Depth], 3) == 0)
                    {
                        If (SourceIdx == VirtualBoard[8])
                        {
                            Call SetCastlingStateFlag(Depth)(3)(1);
                        }
                    }
                    If (Operator.LetterOf(CastlingState[Depth], 4) == 0)
                    {
                        If (SourceIdx == VirtualBoard[1])
                        {
                            Call SetCastlingStateFlag(Depth)(4)(1);
                        }
                    }
                }
            }
        }
        Else
        {
            IdxSub = ((PieceIdxLookup[(0 - SourcePiece)] * 10000) + ((SourceIdx * 100) + TargetIdx));
            List.ReplaceItem(PosScoreDelta, Depth, MovePosLookupWhite[IdxSub]);
            CurrentBoardHash += MoveHashLookupWhite[IdxSub];
            If (SourcePiece == WhitePawn)
            {
                CurrentBoardHash2 += MoveHashLookupWhite[IdxSub];
                If (Not ((IdxToFile[SourceIdx] == IdxToFile[TargetIdx])))
                {
                    If (TargetPieces[Depth] == 0)
                    {
                        List.ReplaceItem(TargetPiecesIdx, Depth, (TargetIdx + 8));
                        List.ReplaceItem(TargetPieces, Depth, Board[(TargetIdx + 8)]);
                        TargetPiece = Board[(TargetIdx + 8)];
                        List.ReplaceItem(Board, (TargetIdx + 8), 0);
                        Call GetPiecePosHash(Board[(TargetIdx + 8)])((TargetIdx + 8));
                        CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                        CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
                    }
                }
                If ((TargetIdx - SourceIdx) == -16)
                {
                    List.ReplaceItem(EnPassantTarget, (Depth + 1), TargetIdx);
                }
                If (TargetIdx < 9)
                {
                    PromotionVal = Operator.LetterOf(CurrentMove, 6);
                    If (PromotionVal == 1)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, WhiteQueen);
                        WhiteQueenCountLocal += 1;
                    }
                    If (PromotionVal == 2)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, WhiteRook);
                        WhiteRookCountLocal += 1;
                        WhiteMinorCountLocal += 1;
                    }
                    If (PromotionVal == 3)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, WhiteBishop);
                        WhiteBishopCountLocal += 1;
                        WhiteMinorCountLocal += 1;
                    }
                    If (PromotionVal == 4)
                    {
                        List.ReplaceItem(PromotionPieces, Depth, WhiteKnight);
                        WhiteMinorCountLocal += 1;
                    }
                    List.ReplaceItem(Board, TargetIdx, PromotionPieces[Depth]);
                    WhitePawnCountLocal += -1;
                    Call GetPiecePosHash(WhitePawn)(SourceIdx);
                    CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
                    CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
                    Call GetPiecePosHash(PromotionPieces[Depth])(TargetIdx);
                    CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
                }
            }
            Else
            {
                If (SourcePiece == WhiteKing)
                {
                    WhiteKingIdx = TargetIdx;
                    CurrentBoardHash2 += MoveHashLookupWhite[IdxSub];
                    Call SetCastlingStateFlag(Depth)(6)(1);
                }
                If (SourcePiece == WhiteRook)
                {
                    If (Operator.LetterOf(CastlingState[Depth], 7) == 0)
                    {
                        If (SourceIdx == VirtualBoard[64])
                        {
                            Call SetCastlingStateFlag(Depth)(7)(1);
                        }
                    }
                    If (Operator.LetterOf(CastlingState[Depth], 8) == 0)
                    {
                        If (SourceIdx == VirtualBoard[57])
                        {
                            Call SetCastlingStateFlag(Depth)(8)(1);
                        }
                    }
                }
            }
        }
        If (TargetPiece > 0)
        {
            IdxSub = ((PieceIdxLookup[TargetPiece] * 10000) + (TargetIdx * 100));
            List.ReplaceItem(PosScoreDelta, Depth, (PosScoreDelta[Depth] + MovePosLookupBlack[IdxSub]));
            CurrentBoardHash += MoveHashLookupBlack[IdxSub];
            If (TargetPiece > 0)
            {
                If (TargetPiece == BlackPawn)
                {
                    CurrentBoardHash2 += MoveHashLookupBlack[IdxSub];
                    BlackPawnCountLocal += -1;
                    If ((IdxToRank[BlackKingIdx] < IdxToRank[TargetIdx]) And ((abs((IdxToRank[BlackKingIdx] - IdxToRank[TargetIdx])) < 4) And (abs((IdxToFile[BlackKingIdx] - IdxToFile[TargetIdx])) < 2)))
                    {
                        List.ReplaceItem(PawnShelterCapture, Depth, (PawnShelterCapture[Depth] + 1));
                    }
                }
                Else
                {
                    If (TargetPiece < BlackQueen)
                    {
                        BlackMinorCountLocal += -1;
                        If (TargetPiece == BlackRook)
                        {
                            BlackRookCountLocal += -1;
                        }
                        If (TargetPiece == BlackBishop)
                        {
                            BlackBishopCountLocal += -1;
                        }
                    }
                    Else
                    {
                        If (TargetPiece == BlackQueen)
                        {
                            BlackQueenCountLocal += -1;
                        }
                    }
                }
            }
        }
        Else
        {
            If (TargetPiece < 0)
            {
                IdxSub = ((PieceIdxLookup[(0 - TargetPiece)] * 10000) + (TargetIdx * 100));
                List.ReplaceItem(PosScoreDelta, Depth, (PosScoreDelta[Depth] + MovePosLookupWhite[IdxSub]));
                CurrentBoardHash += MoveHashLookupWhite[IdxSub];
                If (TargetPiece < 0)
                {
                    If (TargetPiece == WhitePawn)
                    {
                        CurrentBoardHash2 += MoveHashLookupWhite[IdxSub];
                        WhitePawnCountLocal += -1;
                        If ((IdxToRank[TargetIdx] < IdxToRank[WhiteKingIdx]) And ((abs((IdxToRank[WhiteKingIdx] - IdxToRank[TargetIdx])) < 4) And (abs((IdxToFile[WhiteKingIdx] - IdxToFile[TargetIdx])) < 2)))
                        {
                            List.ReplaceItem(PawnShelterCapture, Depth, (PawnShelterCapture[Depth] + 1));
                        }
                    }
                    Else
                    {
                        If (TargetPiece > WhiteQueen)
                        {
                            WhiteMinorCountLocal += -1;
                            If (TargetPiece == WhiteRook)
                            {
                                WhiteRookCountLocal += -1;
                            }
                            If (TargetPiece == WhiteBishop)
                            {
                                WhiteBishopCountLocal += -1;
                            }
                        }
                        Else
                        {
                            If (TargetPiece == WhiteQueen)
                            {
                                WhiteQueenCountLocal += -1;
                            }
                        }
                    }
                }
            }
        }
    }
    Else
    {
        If (CurrentMove == WhiteKingsideCastling)
        {
            List.ReplaceItem(SourcePieces, Depth, WhiteKing);
            List.ReplaceItem(Board, VirtualBoard[61], 0);
            List.ReplaceItem(Board, VirtualBoard[62], WhiteRook);
            List.ReplaceItem(Board, VirtualBoard[63], WhiteKing);
            List.ReplaceItem(Board, VirtualBoard[64], 0);
            WhiteKingIdx = VirtualBoard[63];
            Call UpdateMoveHashPosScore(WhiteKing)(VirtualBoard[61])(VirtualBoard[63])((1 == 0));
            Call UpdateMoveHashPosScore(WhiteRook)(VirtualBoard[64])(VirtualBoard[62])((1 == 1));
            Call SetCastlingStateFlag(Depth)(5)(1);
        }
        Else
        {
            If (CurrentMove == WhiteQueensideCastling)
            {
                List.ReplaceItem(SourcePieces, Depth, WhiteKing);
                List.ReplaceItem(Board, VirtualBoard[57], 0);
                List.ReplaceItem(Board, VirtualBoard[59], WhiteKing);
                List.ReplaceItem(Board, VirtualBoard[60], WhiteRook);
                List.ReplaceItem(Board, VirtualBoard[61], 0);
                WhiteKingIdx = VirtualBoard[59];
                Call UpdateMoveHashPosScore(WhiteKing)(VirtualBoard[61])(VirtualBoard[59])((1 == 0));
                Call UpdateMoveHashPosScore(WhiteRook)(VirtualBoard[57])(VirtualBoard[59])((1 == 1));
                Call SetCastlingStateFlag(Depth)(5)(1);
            }
            Else
            {
                If (CurrentMove == BlackKingsideCastling)
                {
                    List.ReplaceItem(SourcePieces, Depth, BlackKing);
                    List.ReplaceItem(Board, VirtualBoard[5], 0);
                    List.ReplaceItem(Board, VirtualBoard[6], BlackRook);
                    List.ReplaceItem(Board, VirtualBoard[7], BlackKing);
                    List.ReplaceItem(Board, VirtualBoard[8], 0);
                    BlackKingIdx = VirtualBoard[3];
                    Call UpdateMoveHashPosScore(BlackKing)(VirtualBoard[5])(VirtualBoard[7])((1 == 0));
                    Call UpdateMoveHashPosScore(BlackRook)(VirtualBoard[8])(VirtualBoard[6])((1 == 1));
                    Call SetCastlingStateFlag(Depth)(1)(1);
                }
                Else
                {
                    If (CurrentMove == BlackQueensideCastling)
                    {
                        List.ReplaceItem(SourcePieces, Depth, BlackKing);
                        List.ReplaceItem(Board, VirtualBoard[1], 0);
                        List.ReplaceItem(Board, VirtualBoard[3], BlackKing);
                        List.ReplaceItem(Board, VirtualBoard[4], BlackRook);
                        List.ReplaceItem(Board, VirtualBoard[5], 0);
                        BlackKingIdx = VirtualBoard[5];
                        Call UpdateMoveHashPosScore(BlackKing)(VirtualBoard[5])(VirtualBoard[3])((1 == 0));
                        Call UpdateMoveHashPosScore(BlackRook)(VirtualBoard[1])(VirtualBoard[4])((1 == 1));
                        Call SetCastlingStateFlag(Depth)(1)(1);
                    }
                }
            }
        }
    }
    If (Not ((AppliedMove[Depth] == 0000)))
    {
        If (Quiescence[Depth] == 0)
        {
            NodeCount += 1;
        }
        Else
        {
            NodeCountQ += 1;
        }
    }
}

Define ApplyMoveLight(string Depth) (warp=true)
{
    List.ReplaceItem(PreviousBoardHash, Depth, CurrentBoardHash);
    Call GetCurrentMove(Depth);
    List.ReplaceItem(AppliedMove, Depth, CurrentMove);
    SourceIdx = floor((CurrentMove / 100));
    If (SourceIdx > 0)
    {
        TargetIdx = floor((CurrentMove % 100));
        SourcePiece = Board[SourceIdx];
        TargetPiece = Board[TargetIdx];
        List.ReplaceItem(SourcePieces, Depth, SourcePiece);
        List.ReplaceItem(TargetPiecesIdx, Depth, TargetIdx);
        List.ReplaceItem(TargetPieces, Depth, TargetPiece);
        List.ReplaceItem(PromotionPieces, Depth, 0);
        List.ReplaceItem(Board, TargetIdx, SourcePiece);
        List.ReplaceItem(Board, SourceIdx, 0);
        If (SourcePiece > 0)
        {
            CurrentBoardHash += MoveHashLookupBlack[((PieceIdxLookup[SourcePiece] * 10000) + ((SourceIdx * 100) + TargetIdx))];
        }
        Else
        {
            CurrentBoardHash += MoveHashLookupWhite[((PieceIdxLookup[(0 - SourcePiece)] * 10000) + ((SourceIdx * 100) + TargetIdx))];
        }
        If (TargetPiece > 0)
        {
            CurrentBoardHash += MoveHashLookupBlack[((PieceIdxLookup[TargetPiece] * 10000) + (TargetIdx * 100))];
        }
        Else
        {
            If (TargetPiece < 0)
            {
                CurrentBoardHash += MoveHashLookupWhite[((PieceIdxLookup[(0 - TargetPiece)] * 10000) + (TargetIdx * 100))];
            }
        }
    }
    Else
    {
        List.ReplaceItem(PosScoreDelta, Depth, 0);
        List.ReplaceItem(SourcePieces, Depth, 0);
        List.ReplaceItem(TargetPiecesIdx, Depth, "");
        List.ReplaceItem(TargetPieces, Depth, 0);
        List.ReplaceItem(PromotionPieces, Depth, 0);
        If (CurrentMove == WhiteKingsideCastling)
        {
            List.ReplaceItem(SourcePieces, Depth, WhiteKing);
            List.ReplaceItem(Board, VirtualBoard[61], 0);
            List.ReplaceItem(Board, VirtualBoard[62], WhiteRook);
            List.ReplaceItem(Board, VirtualBoard[63], WhiteKing);
            List.ReplaceItem(Board, VirtualBoard[64], 0);
            WhiteKingIdx = VirtualBoard[63];
            Call UpdateMoveHashPosScore(WhiteKing)(VirtualBoard[61])(VirtualBoard[63])((1 == 0));
            Call UpdateMoveHashPosScore(WhiteRook)(VirtualBoard[64])(VirtualBoard[62])((1 == 1));
        }
        Else
        {
            If (CurrentMove == WhiteQueensideCastling)
            {
                List.ReplaceItem(SourcePieces, Depth, WhiteKing);
                List.ReplaceItem(Board, VirtualBoard[57], 0);
                List.ReplaceItem(Board, VirtualBoard[59], WhiteKing);
                List.ReplaceItem(Board, VirtualBoard[60], WhiteRook);
                List.ReplaceItem(Board, VirtualBoard[61], 0);
                WhiteKingIdx = VirtualBoard[59];
                Call UpdateMoveHashPosScore(WhiteKing)(VirtualBoard[61])(VirtualBoard[59])((1 == 0));
                Call UpdateMoveHashPosScore(WhiteRook)(VirtualBoard[57])(VirtualBoard[59])((1 == 1));
            }
            Else
            {
                If (CurrentMove == BlackKingsideCastling)
                {
                    List.ReplaceItem(SourcePieces, Depth, BlackKing);
                    List.ReplaceItem(Board, VirtualBoard[5], 0);
                    List.ReplaceItem(Board, VirtualBoard[6], BlackRook);
                    List.ReplaceItem(Board, VirtualBoard[7], BlackKing);
                    List.ReplaceItem(Board, VirtualBoard[8], 0);
                    BlackKingIdx = VirtualBoard[3];
                    Call UpdateMoveHashPosScore(BlackKing)(VirtualBoard[5])(VirtualBoard[7])((1 == 0));
                    Call UpdateMoveHashPosScore(BlackRook)(VirtualBoard[8])(VirtualBoard[6])((1 == 1));
                }
                Else
                {
                    If (CurrentMove == BlackQueensideCastling)
                    {
                        List.ReplaceItem(SourcePieces, Depth, BlackKing);
                        List.ReplaceItem(Board, VirtualBoard[1], 0);
                        List.ReplaceItem(Board, VirtualBoard[3], BlackKing);
                        List.ReplaceItem(Board, VirtualBoard[4], BlackRook);
                        List.ReplaceItem(Board, VirtualBoard[5], 0);
                        BlackKingIdx = VirtualBoard[5];
                        Call UpdateMoveHashPosScore(BlackKing)(VirtualBoard[5])(VirtualBoard[3])((1 == 0));
                        Call UpdateMoveHashPosScore(BlackRook)(VirtualBoard[1])(VirtualBoard[4])((1 == 1));
                    }
                }
            }
        }
    }
}

Define ASM(string SourceIdx)(string Depth)(bool CapturesOnly)(bool SlidingMoveTypeStraight) (warp=true)
{
    SourcePieceOuter = Board[SourceIdx];
    IdxOuter = MoveLookupLineIndexOffset[SourceIdx];
    Count = 1;
    InvIdxOuter = 8;
    Repeat Until (Count > 32)
    {
        If SlidingMoveTypeStraight
        {
            TargetIdxOuter = MoveLookupStraight[(IdxOuter + Count)];
        }
        Else
        {
            TargetIdxOuter = MoveLookupCross[(IdxOuter + Count)];
        }
        If (TargetIdxOuter == -1)
        {
            Count += InvIdxOuter;
            InvIdxOuter = 8;
        }
        Else
        {
            If (Board[TargetIdxOuter] == 0)
            {
                If CapturesOnly
                {
                    If (IsPotentialNonCapQuiescMove == 1)
                    {
                        Call AddPotentialQuiescenceMove(SourceIdx)(TargetIdxOuter)(SourcePieceOuter)(Depth);
                    }
                }
                Else
                {
                    Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)((1 == 0))(CapturesOnly);
                }
                Count += 1;
                InvIdxOuter += -1;
            }
            Else
            {
                If (SourcePieceOuter > 0)
                {
                    If (Board[TargetIdxOuter] < 0)
                    {
                        Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)((1 == 0))(CapturesOnly);
                    }
                }
                Else
                {
                    If (Board[TargetIdxOuter] > 0)
                    {
                        Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)((1 == 0))(CapturesOnly);
                    }
                }
                Count += InvIdxOuter;
                InvIdxOuter = 8;
            }
        }
    }
}

Define ASMAttack(string SourceIdx)(string Depth)(bool SlidingMoveTypeStraight) (warp=true)
{
    SourcePieceOuter = Board[SourceIdx];
    IdxOuter = MoveLookupLineIndexOffset[SourceIdx];
    Count = 1;
    InvIdxOuter = 8;
    List.DeleteAll(KingAttackLinesTemp);
    Repeat Until (Count > 32)
    {
        If SlidingMoveTypeStraight
        {
            TargetIdxOuter = MoveLookupStraight[(IdxOuter + Count)];
        }
        Else
        {
            TargetIdxOuter = MoveLookupCross[(IdxOuter + Count)];
        }
        If (TargetIdxOuter == -1)
        {
            Count += InvIdxOuter;
            InvIdxOuter = 8;
            List.DeleteAll(KingAttackLinesTemp);
        }
        Else
        {
            If (Board[TargetIdxOuter] == 0)
            {
                Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)((1 == 1))((1 == 0));
                List.Add(KingAttackLinesTemp, TargetIdxOuter);
                Count += 1;
                InvIdxOuter += -1;
            }
            Else
            {
                Call AddMoveImpl(SourceIdx)(TargetIdxOuter)(Depth)((1 == 1))((1 == 0));
                IsXRay = 0;
                TargetPieceOuter = Board[TargetIdxOuter];
                If (SourcePieceOuter > 0)
                {
                    If (TargetPieceOuter == WhiteKing)
                    {
                        Idx = 1;
                        Repeat (List.Length(KingAttackLinesTemp))
                        {
                            List.Add(KingAttackLines, KingAttackLinesTemp[Idx]);
                            Idx += 1;
                        }
                    }
                    If (TargetPieceOuter > BlackKnight)
                    {
                        If SlidingMoveTypeStraight
                        {
                            If ((TargetPieceOuter == BlackQueen) Or (TargetPieceOuter == BlackRook))
                            {
                                IsXRay = 1;
                            }
                        }
                        Else
                        {
                            If ((TargetPieceOuter == BlackQueen) Or (TargetPieceOuter == BlackBishop))
                            {
                                IsXRay = 1;
                            }
                        }
                    }
                }
                Else
                {
                    If (TargetPieceOuter == BlackKing)
                    {
                        Idx = 1;
                        Repeat (List.Length(KingAttackLinesTemp))
                        {
                            List.Add(KingAttackLines, KingAttackLinesTemp[Idx]);
                            Idx += 1;
                        }
                    }
                    If (TargetPieceOuter < WhiteKnight)
                    {
                        If SlidingMoveTypeStraight
                        {
                            If ((TargetPieceOuter == WhiteQueen) Or (TargetPieceOuter == WhiteRook))
                            {
                                IsXRay = 1;
                            }
                        }
                        Else
                        {
                            If ((TargetPieceOuter == WhiteQueen) Or (TargetPieceOuter == WhiteBishop))
                            {
                                IsXRay = 1;
                            }
                        }
                    }
                }
                If (IsXRay == 1)
                {
                    Count += 1;
                    InvIdxOuter += -1;
                }
                Else
                {
                    Count += InvIdxOuter;
                    InvIdxOuter = 8;
                }
                List.DeleteAll(KingAttackLinesTemp);
            }
        }
    }
}

Define CalcBoardAttackedByMove(string Depth) (warp=true)
{
    Call ClearBoardAttackedByMove(Depth);
    Call GenerateMovesImplWrapper(Depth)((1 == 1))((1 == 0));
}

Define CalcBoardAttackedByMoveChecked(string Depth) (warp=true)
{
    Call TTProbeNode(CurrentBoardHash)((Depth + 1));
    If ((TTProbeRes == 1) And (Not ((TTProbeCheckedRes == ""))))
    {
        If ((Depth % 2) == 1)
        {
            IsWhiteChecked = TTProbeCheckedRes;
        }
        Else
        {
            IsBlackChecked = TTProbeCheckedRes;
        }
        Stop(this script);
    }
    If ((Depth % 2) == 1)
    {
        IsWhiteChecked = 0;
        IdxOuter2 = 1;
        Repeat (64)
        {
            If (Board[IdxOuter2] > 0)
            {
                Call IsCheckingPiece(IdxOuter2);
                If (IsCheckingPieceRes == 1)
                {
                    IsWhiteChecked = 1;
                }
            }
            IdxOuter2 += 1;
        }
        Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(IsWhiteChecked)(-1)("")("")("")("")("")("");
    }
    Else
    {
        IsBlackChecked = 0;
        IdxOuter2 = 1;
        Repeat (64)
        {
            If (Board[IdxOuter2] < 0)
            {
                Call IsCheckingPiece(IdxOuter2);
                If (IsCheckingPieceRes == 1)
                {
                    IsBlackChecked = 1;
                }
            }
            IdxOuter2 += 1;
        }
        Call TTStoreNode(CurrentBoardHash)((Depth + 1))("")("")("")(IsBlackChecked)(-1)("")("")("")("")("")("");
    }
}

Define CalcBoardAttackedIfRequiredForDepth(string Depth)(bool Quiescence)(bool ForceOnCheck)(string MinDepth) (warp=true)
{
    If (BoardAttackedCalculated[Depth] == 0)
    {
        If ((ForceOnCheck And (CheckedState[Depth] == 1)) Or ((Not (Quiescence)) And (Depth < (MinDepth + 1))))
        {
            Call CalcBoardAttackedByMove((Depth + 1));
            Call StoreAttackInfo((Depth + 1))(Depth);
            List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
        }
    }
}

Define CalcBoardStats (warp=true)
{
    BlackKingIdx = "";
    WhiteKingIdx = "";
    CurrentBoardHash = 0;
    CurrentBoardHash2 = 0;
    Idx = 1;
    Repeat (8)
    {
        List.ReplaceItem(BlackPawnCount, Idx, 0);
        List.ReplaceItem(WhitePawnCount, Idx, 0);
        Idx += 1;
    }
    Idx = 1;
    Repeat (64)
    {
        If (Board[Idx] == WhitePawn)
        {
            List.ReplaceItem(WhitePawnCount, IdxToFile[Idx], (WhitePawnCount[IdxToFile[Idx]] + 1));
        }
        Else
        {
            If (Board[Idx] == BlackPawn)
            {
                List.ReplaceItem(BlackPawnCount, IdxToFile[Idx], (BlackPawnCount[IdxToFile[Idx]] + 1));
            }
            Else
            {
                If (Board[Idx] == WhiteKing)
                {
                    WhiteKingIdx = Idx;
                }
                Else
                {
                    If (Board[Idx] == BlackKing)
                    {
                        BlackKingIdx = Idx;
                    }
                }
            }
        }
        Call GetPiecePosHash(Board[Idx])(Idx);
        CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
        If ((abs(Board[Idx]) == BlackPawn) Or (abs(Board[Idx]) == BlackKing))
        {
            CurrentBoardHash2 = (CurrentBoardHash2 + PiecePosHash);
        }
        Idx += 1;
    }
    BlackMinorCount = 0;
    BlackQueenCount = 0;
    BlackPawnCount = 0;
    BlackRookCount = 0;
    BlackBishopCount = 0;
    WhiteQueenCount = 0;
    WhiteMinorCount = 0;
    WhitePawnCount = 0;
    WhiteRookCount = 0;
    WhiteBishopCount = 0;
    Idx = 1;
    Repeat (64)
    {
        If (Board[Idx] == WhiteQueen)
        {
            WhiteQueenCount += 1;
        }
        If (Board[Idx] == BlackQueen)
        {
            BlackQueenCount += 1;
        }
        If ((Board[Idx] == WhiteKnight) Or ((Board[Idx] == WhiteBishop) Or (Board[Idx] == WhiteRook)))
        {
            WhiteMinorCount += 1;
            If (Board[Idx] == WhiteRook)
            {
                WhiteRookCount += 1;
            }
            If (Board[Idx] == WhiteBishop)
            {
                WhiteBishopCount += 1;
            }
        }
        If ((Board[Idx] == BlackKnight) Or ((Board[Idx] == BlackBishop) Or (Board[Idx] == BlackRook)))
        {
            BlackMinorCount += 1;
            If (Board[Idx] == BlackRook)
            {
                BlackRookCount += 1;
            }
            If (Board[Idx] == BlackBishop)
            {
                BlackBishopCount += 1;
            }
        }
        If (Board[Idx] == WhitePawn)
        {
            WhitePawnCount += 1;
        }
        If (Board[Idx] == BlackPawn)
        {
            BlackPawnCount += 1;
        }
        Idx += 1;
    }
    If ((((WhiteQueenCount + WhiteMinorCount) + (BlackQueenCount + BlackMinorCount)) < 3) And ((WhiteQueenCount == 0) Or (BlackQueenCount == 0)))
    {
        IsEndgame2 = 1;
        IsEndgame = 1;
    }
    Else
    {
        If ((((WhiteQueenCount * 9) + (WhiteMinorCount * 4)) < 10) Or (((BlackQueenCount * 9) + (BlackMinorCount * 4)) < 10))
        {
            IsEndgame2 = 0;
            IsEndgame = 1;
        }
        Else
        {
            IsEndgame2 = 0;
            IsEndgame = 0;
        }
    }
    If ((HasBlackCastled == 0) And ((HasBlackKingMoved == 0) And ((HasBlackRookKSMoved == 0) Or (HasBlackRookQSMoved == 0))))
    {
        IsBlackCastlingPossible = 1;
    }
    Else
    {
        IsBlackCastlingPossible = 0;
    }
    If ((HasWhiteCastled == 0) And ((HasWhiteKingMoved == 0) And ((HasWhiteRookKSMoved == 0) Or (HasWhiteRookQSMoved == 0))))
    {
        IsWhiteCastlingPossible = 1;
    }
    Else
    {
        IsWhiteCastlingPossible = 0;
    }
    WhiteQueenCountLocal = WhiteQueenCount;
    WhiteMinorCountLocal = WhiteMinorCount;
    BlackQueenCountLocal = BlackQueenCount;
    BlackMinorCountLocal = BlackMinorCount;
    WhiteRookCountLocal = WhiteRookCount;
    BlackRookCountLocal = BlackRookCount;
    WhitePawnCountLocal = WhitePawnCount;
    BlackPawnCountLocal = BlackPawnCount;
    WhiteBishopCountLocal = WhiteBishopCount;
    BlackBishopCountLocal = BlackBishopCount;
    List.ReplaceItem(CastlingState, 1, Operator.Join(Operator.Join(Operator.Join(HasBlackCastled, HasBlackKingMoved), Operator.Join(HasBlackRookKSMoved, HasBlackRookQSMoved)), Operator.Join(Operator.Join(HasWhiteCastled, HasWhiteKingMoved), Operator.Join(HasWhiteRookKSMoved, HasWhiteRookQSMoved))));
    List.ReplaceItem(CastlingState, 2, CastlingState[1]);
}

Define ClearBoardAttackedByMove(num Depth) (warp=true)
{
    If ((Depth % 2) == 1)
    {
        List.DeleteAll(BoardAttackedByBlack);
        List.DeleteAll(BoardAttackedByBlackPiece);
        Repeat (64)
        {
            List.Add(BoardAttackedByBlack, 0);
            List.Add(BoardAttackedByBlackPiece, 0);
        }
        IsWhiteChecked = 0;
    }
    Else
    {
        List.DeleteAll(BoardAttackedByWhite);
        List.DeleteAll(BoardAttackedByWhitePiece);
        Repeat (64)
        {
            List.Add(BoardAttackedByWhite, 0);
            List.Add(BoardAttackedByWhitePiece, 0);
        }
        IsBlackChecked = 0;
    }
    List.DeleteAll(KingAttackLines);
}

Define ClearMoveList(num Depth) (warp=true)
{
    List.ReplaceItem(MovesCount, Depth, 0);
    If (Depth == 1)
    {
        List.DeleteAll(Moves1);
    }
    Else
    {
        If (Depth == 2)
        {
            List.DeleteAll(Moves2);
        }
    }
}

Define ClearTT (warp=true)
{
    If (IsScratch3 == 1)
    {
        Call ClearTTImpl(200000);
    }
    Else
    {
        If (PlayingMode == 0)
        {
            Call ClearTTImpl(1000000);
        }
        Else
        {
            Call ClearTTImpl(2000000);
        }
    }
}

Define ClearTTImpl(string Size) (warp=true)
{
    List.DeleteItem(TTNodeHash, all);
    List.DeleteItem(TTNodeBestMove, all);
    List.DeleteItem(TTNodeScore, all);
    List.DeleteItem(TTNodeDepth, all);
    List.DeleteItem(TTNodeAge, all);
    List.DeleteItem(TTNodeType, all);
    List.DeleteItem(TTNodeChecked, all);
    List.DeleteItem(TTNodeHorizon, all);
    List.DeleteItem(TTNodeBlackMobility, all);
    List.DeleteItem(TTNodeWhiteMobility, all);
    List.DeleteItem(TTBoardAge, all);
    List.DeleteItem(TTBoardHash, all);
    List.DeleteItem(TTBoardScore1, all);
    List.DeleteItem(TTBoardScore2, all);
    List.DeleteItem(TTBoardScore3, all);
    List.DeleteItem(TTBoardScoreSum, all);
    List.DeleteItem(TTNodeBoardAttackedByOpp, all);
    List.DeleteItem(TTNodeBoardAttackedByOppPiece, all);
    List.DeleteItem(TTNodeCheckedAttackLines, all);
    List.DeleteItem(TTNodeScoreIsDynamic, all);
    List.DeleteItem(TTBoardScoreIsDynamic, all);
    Repeat (Size)
    {
        List.Add(TTNodeHash, "");
        List.Add(TTNodeBestMove, "");
        List.Add(TTNodeScore, "");
        List.Add(TTNodeDepth, "");
        List.Add(TTNodeAge, 0);
        List.Add(TTNodeType, "");
        List.Add(TTNodeChecked, "");
        List.Add(TTNodeHorizon, "");
        List.Add(TTNodeBlackMobility, "");
        List.Add(TTNodeWhiteMobility, "");
        List.Add(TTBoardAge, 0);
        List.Add(TTBoardHash, "");
        List.Add(TTBoardScore1, "");
        List.Add(TTBoardScore2, "");
        List.Add(TTBoardScore3, "");
        List.Add(TTBoardScoreSum, "");
        List.Add(TTNodeBoardAttackedByOpp, "");
        List.Add(TTNodeBoardAttackedByOppPiece, "");
        List.Add(TTNodeCheckedAttackLines, "");
        List.Add(TTNodeScoreIsDynamic, "");
        List.Add(TTBoardScoreIsDynamic, "");
    }
}

Define CreateCurrentBoardHash (warp=true)
{
    CurrentBoardHash = 0;
    CurrentBoardHash2 = 0;
    Idx = 1;
    Repeat (64)
    {
        Call GetPiecePosHash(Board[Idx])(Idx);
        CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
        If ((abs(Board[Idx]) == BlackPawn) Or (abs(Board[Idx]) == BlackKing))
        {
            CurrentBoardHash2 = (CurrentBoardHash2 + PiecePosHash);
        }
        Idx += 1;
    }
}

Define DrawBoardAndWait (warp=false)
{
    ProgressValue = 0;
    Event.BroadcastAndWait("drawboard");
    Event.BroadcastAndWait("progressvaluechanged");
    Event.BroadcastAndWait("evaluationvaluechanged");
}

Define EnterExecution (warp=false)
{
    ExecutionDepth += 1;
    If (ExecutionDepth == 1)
    {
        IsExecutionRunning = 1;
        Event.BroadcastAndWait("calcmode");
    }
}

Define EvaluateBoard (warp=true)
{
    EvalResult = 0;
    Idx = 1;
    Repeat (64)
    {
        CurrentPiece = Board[Idx];
        If (Not ((CurrentPiece == 0)))
        {
            EvalResult += CurrentPiece;
            Call GetPiecePosScore(CurrentPiece)(Idx);
            EvalResult += PosScoreRes;
        }
        Idx += 1;
    }
}

Define ExecuteEngineMove (warp=false)
{
    Call EnterExecution;
    Call ExecuteEngineMoveImpl;
    Call ExitExecution;
}

Define ExecuteEngineMoveImpl (warp=false)
{
    If (IsGameSuspended == 1)
    {
        Stop(this script);
    }
    Event.Broadcast("OpeningBookHide");
    BestMove = "";
    If (Level > 2)
    {
        Call GetOpeningMoves;
        If (List.Length(OpeningMovesRes) > 0)
        {
            Event.Broadcast("OpeningBookShow");
            BestMove = OpeningMovesRes[Operator.Random(1 , List.Length(OpeningMovesRes))];
        }
    }
    Call IsEngineValidMove(BestMove);
    If (ValidMoveRes == 0)
    {
        Looks.Think("Thinking...");
        Control.Wait(0);
        If (Level > 2)
        {
            If (Level > 4)
            {
                Call GetBestMoveMedDiff;
            }
            Else
            {
                Call GetBestMoveBlitz;
            }
        }
        Else
        {
            Call GetBestMoveEasy;
        }
    }
    Event.BroadcastAndWait("hidebestmove");
    Call OnProgressChanged(100);
    Control.Wait(0);
    Call IsEngineValidMove(BestMove);
    If (ValidMoveRes == 0)
    {
        Looks.Say(Operator.Join("Internal Error: No valid move found. Sorry, this should not happen. Maybe you cleared lookup lists in the editor? If you are running a normal game, please export board data and report bug via project comment", Operator.Join(" Move: ", BestMove)), 10);
        IsGameSuspended = 1;
        Stop(this script);
    }
    Looks.Think("");
    MovePieceFromIdx = floor((BestMove / 100));
    MovePieceToIdx = floor((BestMove % 100));
    If (((BestMove == BlackQueensideCastling) Or (BestMove == BlackKingsideCastling)) Or ((BestMove == WhiteQueensideCastling) Or (BestMove == WhiteKingsideCastling)))
    {
        MovePieceSpecial = BestMove;
    }
    Else
    {
        MovePieceSpecial = "";
    }
    Event.BroadcastAndWait("movepiece");
    Event.Broadcast("SoundMove");
    If (Variable.Length(BestMove) == 4)
    {
        GameMoves = Operator.Join(GameMoves, BestMove);
    }
    Else
    {
        If (Variable.Length(BestMove) == 3)
        {
            GameMoves = Operator.Join(GameMoves, Operator.Join(0, BestMove));
        }
        Else
        {
            If (Variable.Length(BestMove) == 6)
            {
                GameMoves = Operator.Join(GameMoves, floor(BestMove));
            }
        }
    }
    Call GetMoveNotation(BestMove);
    List.Add(GameMovesAN, MoveNotationRes);
    Call ClearMoveList(1);
    Call AddMoveToList(BestMove)(1);
    List.ReplaceItem(MovesIdx, 1, 1);
    Call ApplyMove(1);
    Call DrawBoardAndWait;
    If (Board[(BestMove % 100)] == BlackKing)
    {
        HasBlackKingMoved = 1;
    }
    If (Board[(BestMove % 100)] == BlackRook)
    {
        If (floor((BestMove / 100)) == VirtualBoard[1])
        {
            HasBlackRookQSMoved = 1;
        }
        If (floor((BestMove / 100)) == VirtualBoard[8])
        {
            HasBlackRookKSMoved = 1;
        }
    }
    If ((BestMove == BlackQueensideCastling) Or (BestMove == BlackKingsideCastling))
    {
        HasBlackKingMoved = 1;
        HasBlackCastled = 1;
    }
    Call AddBoardToHistory(1);
    Call GetRepetitionCount;
    If (RepetitionCountRes > 2)
    {
        Looks.Say("Draw!");
        Event.Broadcast("SoundDraw");
        IsGameSuspended = 1;
    }
    Else
    {
        Call IsDrawByMaterial;
        If (IsDrawRes == 1)
        {
            Looks.Say("Draw!");
            Event.Broadcast("SoundDraw");
            IsGameSuspended = 1;
        }
        Else
        {
            Call IsWhiteKingCheckMate;
            If (IsWhiteKingCheckMateRes == 1)
            {
                Looks.Say("Checkmate!");
                Event.Broadcast("SoundCheckmate");
                IsGameSuspended = 1;
            }
            Else
            {
                Call IsDrawByStalemate(2);
                If (IsDrawRes == 1)
                {
                    Looks.Say("Draw!");
                    Event.Broadcast("SoundDraw");
                    IsGameSuspended = 1;
                }
                Else
                {
                    Call CalcBoardAttackedByMove(1);
                    If (IsWhiteChecked == 1)
                    {
                        Call SayAsync("Check!")(2);
                        Event.Broadcast("SoundCheck");
                    }
                }
            }
        }
    }
}

Define ExecuteInit (warp=false)
{
    ExecutionDepth = 0;
    IsExecutionRunning = 0;
    If (IsPlayerBlack == 1)
    {
        Call ExecuteEngineMove;
    }
}

Define ExecuteUserMove(string UserMove) (warp=false)
{
    Call EnterExecution;
    Call ExecuteUserMoveImpl(UserMove);
    Call ExitExecution;
}

Define ExecuteUserMoveImpl(string UserMoveParam) (warp=false)
{
    If (IsGameSuspended == 1)
    {
        Stop(this script);
    }
    MovePieceFromIdx = floor((UserMoveParam / 100));
    MovePieceToIdx = floor((UserMoveParam % 100));
    If (((UserMoveParam == BlackQueensideCastling) Or (UserMoveParam == BlackKingsideCastling)) Or ((UserMoveParam == WhiteQueensideCastling) Or (UserMoveParam == WhiteKingsideCastling)))
    {
        MovePieceSpecial = UserMoveParam;
    }
    Else
    {
        MovePieceSpecial = "";
    }
    Event.BroadcastAndWait("movepiece");
    Event.Broadcast("SoundMove");
    FromSquareIdx = -1;
    ToSquareIdx = -1;
    Event.BroadcastAndWait("fromsquareselected");
    Event.BroadcastAndWait("tosquareselected");
    Call GenerateMovesPublic(2);
    If (Not (List.ContainsItem(Moves2, UserMoveParam)))
    {
        If (Variable.Length(UserMoveParam) == 6)
        {
            Call SayAsync("Invalid move!")(2);
            Event.Broadcast("SoundInvalidMove");
        }
        Else
        {
            Call ClearMoveList(2);
            Call AddMoveToList(UserMoveParam)(2);
            List.ReplaceItem(MovesIdx, 2, 1);
            Call ApplyMove(2);
            Call CalcBoardAttackedByMove(3);
            If (IsWhiteChecked == 1)
            {
                Call SayAsync("Invalid move - Check!")(2);
                Event.Broadcast("SoundInvalidMoveCheck");
            }
            Else
            {
                Call SayAsync("Invalid move!")(2);
                Event.Broadcast("SoundInvalidMove");
            }
            Call RevertMove(2);
        }
        Call DrawBoardAndWait;
        Stop(this script);
    }
    UserMove = UserMoveParam;
    If (Variable.Length(UserMove) == 3)
    {
        UserMove = Operator.Join(0, UserMove);
    }
    If (Variable.Length(UserMove) == 6)
    {
        Looks.Say("Please select promotion piece");
        Event.BroadcastAndWait("selectpromotionpiecewhite");
        Looks.Say("");
        If (SelectedPromotionPiece == WhiteQueen)
        {
            UserMove = Operator.Join(floor(UserMove), .1);
        }
        Else
        {
            If (SelectedPromotionPiece == WhiteRook)
            {
                UserMove = Operator.Join(floor(UserMove), .2);
            }
            Else
            {
                If (SelectedPromotionPiece == WhiteBishop)
                {
                    UserMove = Operator.Join(floor(UserMove), .3);
                }
                Else
                {
                    If (SelectedPromotionPiece == WhiteKnight)
                    {
                        UserMove = Operator.Join(floor(UserMove), .4);
                    }
                }
            }
        }
        If (Variable.Length(UserMove) == 5)
        {
            UserMove = Operator.Join(0, UserMove);
        }
    }
    Call GetMoveNotation(UserMove);
    Call ClearMoveList(2);
    Call AddMoveToList(UserMove)(2);
    List.ReplaceItem(MovesIdx, 2, 1);
    Call ApplyMove(2);
    Call DrawBoardAndWait;
    Call CalcBoardAttackedByMove(1);
    If (IsWhiteChecked == 1)
    {
        Call RevertMove(2);
        Call DrawBoardAndWait;
        Control.Wait(0);
        Call SayAsync("Invalid move - Check!")(2);
        Event.Broadcast("SoundInvalidMoveCheck");
        Stop(this script);
    }
    List.Add(GameMovesAN, MoveNotationRes);
    If (Variable.Length(UserMove) == 4)
    {
        GameMoves = Operator.Join(GameMoves, UserMove);
    }
    Else
    {
        If (Variable.Length(UserMove) == 3)
        {
            GameMoves = Operator.Join(GameMoves, Operator.Join(0, UserMove));
        }
        Else
        {
            If (Variable.Length(UserMove) == 6)
            {
                GameMoves = Operator.Join(GameMoves, floor(UserMove));
            }
        }
    }
    Looks.Think("Thinking...");
    Call DrawBoardAndWait;
    Control.Wait(0);
    SourceIdx = floor((UserMove / 100));
    TargetIdx = floor((UserMove % 100));
    If (Board[TargetIdx] == WhiteKing)
    {
        HasWhiteKingMoved = 1;
    }
    If (Board[TargetIdx] == WhiteRook)
    {
        If (SourceIdx == VirtualBoard[57])
        {
            HasWhiteRookQSMoved = 1;
        }
        If (SourceIdx == VirtualBoard[64])
        {
            HasWhiteRookKSMoved = 1;
        }
    }
    If ((UserMove == WhiteQueensideCastling) Or (UserMove == WhiteKingsideCastling))
    {
        HasWhiteCastled = 1;
        HasWhiteKingMoved = 1;
    }
    Call AddBoardToHistory(0);
    Call IsBlackKingCheckMate;
    If (IsBlackKingCheckMateRes == 1)
    {
        Looks.Say("Checkmate!");
        Event.Broadcast("SoundCheckmate");
        IsGameSuspended = 1;
    }
    Else
    {
        Call IsDrawByStalemate(1);
        If (IsDrawRes == 1)
        {
            Looks.Say("Draw!");
            Event.Broadcast("SoundDraw");
            IsGameSuspended = 1;
        }
        Else
        {
            Call GetRepetitionCount;
            If (RepetitionCountRes > 2)
            {
                Looks.Say("Draw!");
                Event.Broadcast("SoundDraw");
                IsGameSuspended = 1;
            }
            Else
            {
                Call IsDrawByMaterial;
                If (IsDrawRes == 1)
                {
                    Looks.Say("Draw!");
                    Event.Broadcast("SoundDraw");
                    IsGameSuspended = 1;
                }
                Else
                {
                    Call ExecuteEngineMove;
                }
            }
        }
    }
}

Define ExitExecution (warp=false)
{
    ExecutionDepth += -1;
    If (ExecutionDepth == 0)
    {
        IsExecutionRunning = 0;
        Event.BroadcastAndWait("inputmode");
    }
}

Define ExportBoardFEN(bool IsPlayerBlack)(bool IsPlayerTurn) (warp=true)
{
    ExportDataFEN = "";
    ExportDataFENLichess = "https://lichess.org/analysis/";
    Idx = 1;
    Repeat Until (Idx > 64)
    {
        If IsPlayerBlack
        {
            CurrentPiece = (0 - Board[(65 - Idx)]);
        }
        Else
        {
            CurrentPiece = Board[Idx];
        }
        If (CurrentPiece == BlackPawn)
        {
            CurrentValue = "p";
        }
        If (CurrentPiece == BlackKnight)
        {
            CurrentValue = "n";
        }
        If (CurrentPiece == BlackBishop)
        {
            CurrentValue = "b";
        }
        If (CurrentPiece == BlackRook)
        {
            CurrentValue = "r";
        }
        If (CurrentPiece == BlackQueen)
        {
            CurrentValue = "q";
        }
        If (CurrentPiece == BlackKing)
        {
            CurrentValue = "k";
        }
        If (CurrentPiece == WhitePawn)
        {
            CurrentValue = "P";
        }
        If (CurrentPiece == WhiteKnight)
        {
            CurrentValue = "N";
        }
        If (CurrentPiece == WhiteBishop)
        {
            CurrentValue = "B";
        }
        If (CurrentPiece == WhiteRook)
        {
            CurrentValue = "R";
        }
        If (CurrentPiece == WhiteQueen)
        {
            CurrentValue = "Q";
        }
        If (CurrentPiece == WhiteKing)
        {
            CurrentValue = "K";
        }
        If (CurrentPiece == 0)
        {
            IdxSub = Idx;
            Repeat Until (((IdxSub % 8) == 0) Or (((Not (IsPlayerBlack)) And (Not ((Board[(IdxSub + 1)] == 0)))) Or (IsPlayerBlack And (Not ((Board[(65 - (IdxSub + 1))] == 0))))))
            {
                IdxSub += 1;
            }
            CurrentValue = ((IdxSub - Idx) + 1);
            Idx += (IdxSub - Idx);
        }
        ExportDataFEN = Operator.Join(ExportDataFEN, CurrentValue);
        ExportDataFENLichess = Operator.Join(ExportDataFENLichess, CurrentValue);
        If (((Idx % 8) == 0) And (Idx < 64))
        {
            ExportDataFEN = Operator.Join(ExportDataFEN, "/");
            ExportDataFENLichess = Operator.Join(ExportDataFENLichess, "/");
        }
        Idx += 1;
    }
    If ((IsPlayerBlack And IsPlayerTurn) Or ((Not (IsPlayerBlack)) And (Not (IsPlayerTurn))))
    {
        ExportDataFEN = Operator.Join(ExportDataFEN, " b");
        ExportDataFENLichess = Operator.Join(ExportDataFENLichess, "_b");
    }
    Else
    {
        ExportDataFEN = Operator.Join(ExportDataFEN, " w");
        ExportDataFENLichess = Operator.Join(ExportDataFENLichess, "_w");
    }
}

Define ExportMovesPGN (warp=true)
{
    ExportMovesPGN = "";
    Idx = 1;
    Repeat (List.Length(GameMovesAN))
    {
        If ((Idx % 2) == 1)
        {
            ExportMovesPGN = Operator.Join(ExportMovesPGN, Operator.Join((((Idx - 1) / 2) + 1), ". "));
        }
        ExportMovesPGN = Operator.Join(ExportMovesPGN, Operator.Join(GameMovesAN[Idx], " "));
        Idx += 1;
    }
}

Define FillBoard (warp=true)
{
    List.DeleteItem(VirtualBoard, all);
    Idx = 1;
    Repeat (64)
    {
        If (IsPlayerBlack == 0)
        {
            List.Add(VirtualBoard, Idx);
        }
        Else
        {
            List.Add(VirtualBoard, (((IdxToRank[Idx] - 1) * 8) + (9 - IdxToFile[Idx])));
        }
        Idx += 1;
    }
    List.DeleteItem(Board, all);
    Repeat (64)
    {
        List.Add(Board, 0);
    }
    List.ReplaceItem(Board, VirtualBoard[1], BlackRook);
    List.ReplaceItem(Board, VirtualBoard[2], BlackKnight);
    List.ReplaceItem(Board, VirtualBoard[3], BlackBishop);
    List.ReplaceItem(Board, VirtualBoard[4], BlackQueen);
    List.ReplaceItem(Board, VirtualBoard[5], BlackKing);
    List.ReplaceItem(Board, VirtualBoard[6], BlackBishop);
    List.ReplaceItem(Board, VirtualBoard[7], BlackKnight);
    List.ReplaceItem(Board, VirtualBoard[8], BlackRook);
    Idx = 9;
    Repeat (8)
    {
        List.ReplaceItem(Board, VirtualBoard[Idx], BlackPawn);
        Idx += 1;
    }
    Idx = 49;
    Repeat (8)
    {
        List.ReplaceItem(Board, VirtualBoard[Idx], WhitePawn);
        Idx += 1;
    }
    List.ReplaceItem(Board, VirtualBoard[57], WhiteRook);
    List.ReplaceItem(Board, VirtualBoard[58], WhiteKnight);
    List.ReplaceItem(Board, VirtualBoard[59], WhiteBishop);
    List.ReplaceItem(Board, VirtualBoard[60], WhiteQueen);
    List.ReplaceItem(Board, VirtualBoard[61], WhiteKing);
    List.ReplaceItem(Board, VirtualBoard[62], WhiteBishop);
    List.ReplaceItem(Board, VirtualBoard[63], WhiteKnight);
    List.ReplaceItem(Board, VirtualBoard[64], WhiteRook);
}

Define GenerateMovesForSource(string Depth)(string SourceIdx)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    If ((IsQuiescentCheckInvariantRes == 1) Or (CheckedState[Depth] == 1))
    {
        IsPotentialNonCapQuiescMove = 1;
    }
    Else
    {
        IsPotentialNonCapQuiescMove = 0;
    }
    SourcePieceOuter2 = Board[SourceIdx];
    Call //("Pawn moves (generated via code logic)");
    If (SourcePieceOuter2 == BlackPawn)
    {
        If (CalcAttackState Or (Board[(SourceIdx + 7)] < 0))
        {
            If (IdxToFile[SourceIdx] > 1)
            {
                Call AddMoveImpl(SourceIdx)((SourceIdx + 7))(Depth)(CalcAttackState)(CapturesOnly);
            }
        }
        If (CalcAttackState Or (Board[(SourceIdx + 9)] < 0))
        {
            If (IdxToFile[SourceIdx] < 8)
            {
                Call AddMoveImpl(SourceIdx)((SourceIdx + 9))(Depth)(CalcAttackState)(CapturesOnly);
            }
        }
        If (Not (CalcAttackState))
        {
            If (Board[(SourceIdx + 8)] == 0)
            {
                If CapturesOnly
                {
                    If ((IsPotentialNonCapQuiescMove == 1) Or (IdxToRank[SourceIdx] == 7))
                    {
                        Call AddPotentialQuiescenceMove(SourceIdx)((SourceIdx + 8))(BlackPawn)(Depth);
                    }
                }
                Else
                {
                    Call AddMoveImpl(SourceIdx)((SourceIdx + 8))(Depth)(CalcAttackState)(CapturesOnly);
                }
                If ((IdxToRank[SourceIdx] == 2) And (Board[(SourceIdx + 16)] == 0))
                {
                    If CapturesOnly
                    {
                        If (IsPotentialNonCapQuiescMove == 1)
                        {
                            Call AddPotentialQuiescenceMove(SourceIdx)((SourceIdx + 16))(BlackPawn)(Depth);
                        }
                    }
                    Else
                    {
                        Call AddMoveImpl(SourceIdx)((SourceIdx + 16))(Depth)(CalcAttackState)(CapturesOnly);
                    }
                }
            }
        }
        If (Not ((EnPassantTarget[Depth] == "")))
        {
            TargetIdx = EnPassantTarget[Depth];
            If ((Not (CalcAttackState)) And (IdxToRank[SourceIdx] == IdxToRank[TargetIdx]))
            {
                If (abs((IdxToFile[SourceIdx] - IdxToFile[TargetIdx])) == 1)
                {
                    Call AddMoveImpl(SourceIdx)((TargetIdx + 8))(Depth)(CalcAttackState)(CapturesOnly);
                }
            }
        }
        Stop(this script);
    }
    If (SourcePieceOuter2 == WhitePawn)
    {
        If (CalcAttackState Or (Board[(SourceIdx - 9)] > 0))
        {
            If (IdxToFile[SourceIdx] > 1)
            {
                Call AddMoveImpl(SourceIdx)((SourceIdx - 9))(Depth)(CalcAttackState)(CapturesOnly);
            }
        }
        If (CalcAttackState Or (Board[(SourceIdx - 7)] > 0))
        {
            If (IdxToFile[SourceIdx] < 8)
            {
                Call AddMoveImpl(SourceIdx)((SourceIdx - 7))(Depth)(CalcAttackState)(CapturesOnly);
            }
        }
        If (Not (CalcAttackState))
        {
            If (Board[(SourceIdx - 8)] == 0)
            {
                If CapturesOnly
                {
                    If ((IsPotentialNonCapQuiescMove == 1) Or (IdxToRank[SourceIdx] == 2))
                    {
                        Call AddPotentialQuiescenceMove(SourceIdx)((SourceIdx - 8))(WhitePawn)(Depth);
                    }
                }
                Else
                {
                    Call AddMoveImpl(SourceIdx)((SourceIdx - 8))(Depth)(CalcAttackState)(CapturesOnly);
                }
                If ((IdxToRank[SourceIdx] == 7) And (Board[(SourceIdx - 16)] == 0))
                {
                    If CapturesOnly
                    {
                        If (IsPotentialNonCapQuiescMove == 1)
                        {
                            Call AddPotentialQuiescenceMove(SourceIdx)((SourceIdx - 16))(WhitePawn)(Depth);
                        }
                    }
                    Else
                    {
                        Call AddMoveImpl(SourceIdx)((SourceIdx - 16))(Depth)(CalcAttackState)(CapturesOnly);
                    }
                }
            }
        }
        If (Not ((EnPassantTarget[Depth] == "")))
        {
            TargetIdx = EnPassantTarget[Depth];
            If ((Not (CalcAttackState)) And (IdxToRank[SourceIdx] == IdxToRank[TargetIdx]))
            {
                If (abs((IdxToFile[SourceIdx] - IdxToFile[TargetIdx])) == 1)
                {
                    Call AddMoveImpl(SourceIdx)((TargetIdx - 8))(Depth)(CalcAttackState)(CapturesOnly);
                }
            }
        }
        Stop(this script);
    }
    Call //("Non-pawn moves (generated via lookup tables)");
    SourcePieceOuter2 = abs(SourcePieceOuter2);
    If (SourcePieceOuter2 == BlackRook)
    {
        Call AddSlidingMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 1));
        Stop(this script);
    }
    If (SourcePieceOuter2 == BlackBishop)
    {
        Call AddSlidingMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 0));
        Stop(this script);
    }
    If (SourcePieceOuter2 == BlackKnight)
    {
        Call AddLookupMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 0));
        Stop(this script);
    }
    If (SourcePieceOuter2 == BlackKing)
    {
        Call AddLookupMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 1));
        Stop(this script);
    }
    If (SourcePieceOuter2 == BlackQueen)
    {
        Call AddSlidingMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 1));
        Call AddSlidingMove(SourceIdx)(Depth)(CalcAttackState)(CapturesOnly)((1 == 0));
        Stop(this script);
    }
}

Define GenerateMovesForSourceEx(string Depth)(string SourceIdx)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    List.DeleteAll(CalcMovesMoveList);
    List.DeleteAll(CalcMovesScoreList);
    Call GenerateMovesForSource(Depth)(SourceIdx)(CalcAttackState)(CapturesOnly);
    Call SortMoveList(Depth);
}

Define GenerateMovesImpl(string Depth)(bool CalcAttackState)(bool CapturesOnly)(bool IsBlackMove) (warp=true)
{
    If ((Not (CalcAttackState)) And (Not (CapturesOnly)))
    {
        If (BoardAttackedCalculated[Depth] == 0)
        {
            If IsBlackMove
            {
                Call GenerateMovesForSource(Depth)(BlackKingIdx)(CalcAttackState)(CapturesOnly);
                If (GenerateMovesRequiresAttackRecalc == 1)
                {
                    Stop(this script);
                }
            }
            Else
            {
                Call GenerateMovesForSource(Depth)(WhiteKingIdx)(CalcAttackState)(CapturesOnly);
                If (GenerateMovesRequiresAttackRecalc == 1)
                {
                    Stop(this script);
                }
            }
        }
        If IsBlackMove
        {
            List.ReplaceItem(BlackMobBonus, Depth, 0);
        }
        Else
        {
            List.ReplaceItem(WhiteMobBonus, Depth, 0);
        }
        List.DeleteAll(PieceMobility);
        Repeat (64)
        {
            List.Add(PieceMobility, 0);
        }
    }
    List.DeleteAll(CalcMovesScoreList);
    List.DeleteAll(CalcMovesMoveList);
    Call PrepareCurrentKillerMoves(Depth);
    Call ClearMoveList(Depth);
    If IsBlackMove
    {
        SourceIdxOuter2 = 1;
        Repeat (64)
        {
            If (Board[SourceIdxOuter2] > 0)
            {
                CurrentPiece = Board[SourceIdxOuter2];
                Call GenerateMovesForSource(Depth)(SourceIdxOuter2)(CalcAttackState)(CapturesOnly);
                If (((Not (CalcAttackState)) And (Not (CapturesOnly))) And (Not ((CurrentPiece == BlackPawn))))
                {
                    If (IsEndgame == 0)
                    {
                        If (CurrentPiece == BlackRook)
                        {
                            List.ReplaceItem(BlackMobBonus, Depth, (BlackMobBonus[Depth] + RookMobilityBonus[(PieceMobility[SourceIdxOuter2] + 1)]));
                        }
                        Else
                        {
                            If (CurrentPiece == BlackBishop)
                            {
                                List.ReplaceItem(BlackMobBonus, Depth, (BlackMobBonus[Depth] + BishopMobilityBonus[(PieceMobility[SourceIdxOuter2] + 1)]));
                            }
                            Else
                            {
                                If (CurrentPiece == BlackKnight)
                                {
                                    List.ReplaceItem(BlackMobBonus, Depth, (BlackMobBonus[Depth] + KnightMobilityBonus[(PieceMobility[SourceIdxOuter2] + 1)]));
                                }
                                Else
                                {
                                    If (CurrentPiece == BlackQueen)
                                    {
                                        List.ReplaceItem(BlackMobBonus, Depth, (BlackMobBonus[Depth] + QueenMobilityBonus[(PieceMobility[SourceIdxOuter2] + 1)]));
                                    }
                                }
                            }
                        }
                    }
                    Else
                    {
                        If (CurrentPiece == BlackKing)
                        {
                            If ((IsEndgame2 == 1) And ((BlackQueenCountLocal + BlackMinorCountLocal) < (WhiteQueenCountLocal + WhiteMinorCountLocal)))
                            {
                                List.ReplaceItem(BlackMobBonus, Depth, (BlackMobBonus[Depth] + (PieceMobility[SourceIdxOuter2] * 10)));
                            }
                        }
                    }
                }
            }
            SourceIdxOuter2 += 1;
        }
    }
    Else
    {
        SourceIdxOuter2 = 64;
        Repeat (64)
        {
            If (Board[SourceIdxOuter2] < 0)
            {
                CurrentPiece = Board[SourceIdxOuter2];
                Call GenerateMovesForSource(Depth)(SourceIdxOuter2)(CalcAttackState)(CapturesOnly);
                If (((Not (CalcAttackState)) And (Not (CapturesOnly))) And (Not ((CurrentPiece == WhitePawn))))
                {
                    If (IsEndgame == 0)
                    {
                        If (CurrentPiece == WhiteRook)
                        {
                            List.ReplaceItem(WhiteMobBonus, Depth, (WhiteMobBonus[Depth] + RookMobilityBonus[(PieceMobility[SourceIdxOuter2] + 1)]));
                        }
                        Else
                        {
                            If (CurrentPiece == WhiteBishop)
                            {
                                List.ReplaceItem(WhiteMobBonus, Depth, (WhiteMobBonus[Depth] + BishopMobilityBonus[(PieceMobility[SourceIdxOuter2] + 1)]));
                            }
                            Else
                            {
                                If (CurrentPiece == WhiteKnight)
                                {
                                    List.ReplaceItem(WhiteMobBonus, Depth, (WhiteMobBonus[Depth] + KnightMobilityBonus[(PieceMobility[SourceIdxOuter2] + 1)]));
                                }
                                Else
                                {
                                    If (CurrentPiece == WhiteQueen)
                                    {
                                        List.ReplaceItem(WhiteMobBonus, Depth, (WhiteMobBonus[Depth] + QueenMobilityBonus[(PieceMobility[SourceIdxOuter2] + 1)]));
                                    }
                                }
                            }
                        }
                    }
                    Else
                    {
                        If (CurrentPiece == WhiteKing)
                        {
                            If ((IsEndgame2 == 1) And ((WhiteQueenCountLocal + WhiteMinorCountLocal) < (BlackQueenCountLocal + BlackMinorCountLocal)))
                            {
                                List.ReplaceItem(WhiteMobBonus, Depth, (WhiteMobBonus[Depth] + (PieceMobility[SourceIdxOuter2] * 10)));
                            }
                        }
                    }
                }
            }
            SourceIdxOuter2 += -1;
        }
    }
    Call //("Castling moves");
    If ((Not (CalcAttackState)) And (Not (CapturesOnly)))
    {
        If IsBlackMove
        {
            If ((Operator.LetterOf(CastlingState[Depth], 1) == 0) And (Operator.LetterOf(CastlingState[Depth], 2) == 0))
            {
                If (Operator.LetterOf(CastlingState[Depth], 4) == 0)
                {
                    If ((((Board[VirtualBoard[1]] == BlackRook) And (Board[VirtualBoard[2]] == 0)) And ((Board[VirtualBoard[3]] == 0) And (Board[VirtualBoard[4]] == 0))) And (Board[VirtualBoard[5]] == BlackKing))
                    {
                        If ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[3]) == 0) And ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[4]) == 0) And (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[5]) == 0)))
                        {
                            If (HasBlackRookQSMoved == 0)
                            {
                                Call AddSpecialMove(BlackQueensideCastling)(Depth);
                            }
                        }
                    }
                }
                If (Operator.LetterOf(CastlingState[Depth], 3) == 0)
                {
                    If (((Board[VirtualBoard[5]] == BlackKing) And (Board[VirtualBoard[6]] == 0)) And ((Board[VirtualBoard[7]] == 0) And (Board[VirtualBoard[8]] == BlackRook)))
                    {
                        If ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[5]) == 0) And ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[6]) == 0) And (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], VirtualBoard[7]) == 0)))
                        {
                            If (HasBlackRookKSMoved == 0)
                            {
                                Call AddSpecialMove(BlackKingsideCastling)(Depth);
                            }
                        }
                    }
                }
            }
        }
        Else
        {
            If ((Operator.LetterOf(CastlingState[Depth], 5) == 0) And (Operator.LetterOf(CastlingState[Depth], 6) == 0))
            {
                If (Operator.LetterOf(CastlingState[Depth], 8) == 0)
                {
                    If (((Board[VirtualBoard[57]] == WhiteRook) And (Board[VirtualBoard[58]] == 0)) And ((Board[VirtualBoard[59]] == 0) And ((Board[VirtualBoard[60]] == 0) And (Board[VirtualBoard[61]] == WhiteKing))))
                    {
                        If ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[59]) == 0) And ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[60]) == 0) And (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[61]) == 0)))
                        {
                            If (HasWhiteRookQSMoved == 0)
                            {
                                Call AddSpecialMove(WhiteQueensideCastling)(Depth);
                            }
                        }
                    }
                }
                If (Operator.LetterOf(CastlingState[Depth], 7) == 0)
                {
                    If (((Board[VirtualBoard[62]] == 0) And (Board[VirtualBoard[61]] == WhiteKing)) And ((Board[VirtualBoard[63]] == 0) And (Board[VirtualBoard[64]] == WhiteRook)))
                    {
                        If ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[61]) == 0) And ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[62]) == 0) And (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], VirtualBoard[63]) == 0)))
                        {
                            If (HasWhiteRookKSMoved == 0)
                            {
                                Call AddSpecialMove(WhiteKingsideCastling)(Depth);
                            }
                        }
                    }
                }
            }
        }
    }
    Call //("Move ordering");
    If (Not (CalcAttackState))
    {
        If (Depth == 1)
        {
            If (List.Length(DeepeningScore) == 0)
            {
                Call TTProbeNode(CurrentBoardHash)(Depth);
                Idx = 1;
                Repeat (List.Length(CalcMovesScoreList))
                {
                    List.Add(DeepeningScoreOrderMap, "");
                    List.Add(DeepeningScore, "");
                    If ((TTProbeRes == 1) And (CalcMovesMoveList[Idx] == TTProbeBestMoveRes))
                    {
                        List.ReplaceItem(CalcMovesScoreList, Idx, MaxPly1DeepeningMoveOrderScore);
                    }
                    Idx += 1;
                }
            }
            Else
            {
                Idx = 1;
                Repeat (List.Length(CalcMovesScoreList))
                {
                    If (Not ((DeepeningScore[Idx] == "")))
                    {
                        List.ReplaceItem(CalcMovesScoreList, Idx, DeepeningScore[Idx]);
                    }
                    Idx += 1;
                }
            }
        }
        Call SortMoveList(Depth);
    }
}

Define GenerateMovesImplWrapper(string Depth)(bool CalcAttackState)(bool CapturesOnly) (warp=true)
{
    If (IsBlockProfilerEnabled == 1)
    {
        Call Profile_MethodEnter(((((3 * MaxSearchDepthStackFrames) - (MaxSearchDepthStackFrames * CapturesOnly)) - ((2 * MaxSearchDepthStackFrames) * CalcAttackState)) + Depth));
    }
    Call IsQuiescentCheckCond(Depth);
    IsQuiescentCheckInvariantRes = IsQuiescentCheckRes;
    GenerateMovesRequiresAttackRecalc = 0;
    Call GenerateMovesImpl(Depth)(CalcAttackState)(CapturesOnly)(((Depth % 2) == 1));
    If (IsBlockProfilerEnabled == 1)
    {
        Call Profile_MethodExit(((((3 * MaxSearchDepthStackFrames) - (MaxSearchDepthStackFrames * CapturesOnly)) - ((2 * MaxSearchDepthStackFrames) * CalcAttackState)) + Depth));
    }
}

Define GenerateMovesPublic(string Depth) (warp=true)
{
    Idx = 1;
    Repeat (64)
    {
        If (Board[Idx] == WhiteKing)
        {
            WhiteKingIdx = Idx;
        }
        Else
        {
            If (Board[Idx] == BlackKing)
            {
                BlackKingIdx = Idx;
            }
        }
        Idx += 1;
    }
    Call CalcBoardAttackedByMove((Depth + 1));
    Call StoreAttackInfo((Depth + 1))(Depth);
    List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
    Call SetInitialEnPassantTarget(Depth);
    Call GenerateMovesImplWrapper(Depth)((1 == 0))((1 == 0));
    List.ReplaceItem(EnPassantTarget, Depth, "");
    List.ReplaceItem(BoardAttackedCalculated, Depth, 0);
}

Define GetBestMoveBlitz (warp=false)
{
    MaxSearchDepth = 20;
    ThinkTimeLimit = ((Level - 2) * 4);
    ThinkTimeStart = (Sensing.DaysSince2000() * 86400);
    IsMinMaxTimeout = 0;
    IsDeepeningDone = 0;
    IdxDeepening = 1;
    BestMove = "";
    BestMinMaxRes = "";
    ThinkTimeLimitMinMax = ThinkTimeLimit;
    Repeat ((((Level - 2) * 2) * (2 - IsScratch3)))
    {
        If ((IsMinMaxTimeout == 0) And ((IdxDeepening == 1) Or (abs(BestMinMaxRes) < AbsMinCheckmateEval)))
        {
            Call AlphaBetaMinMax(-100000)(100000)(1)((IdxDeepening + 1))((IdxDeepening == 1))(12)((1 == 1));
            If (Not ((MinMaxMoveRes == "")))
            {
                If ((BestMove == "") Or List.ContainsItem(MinMaxPly1EvalMoves, BestMove))
                {
                    BestMove = MinMaxMoveRes;
                    BestMinMaxRes = MinMaxEvalRes;
                    Call OnEvaluationChanged(BestMinMaxRes);
                }
            }
        }
        IdxDeepening += 1;
    }
}

Define GetBestMoveEasy (warp=false)
{
    ThinkTimeStart = (Sensing.DaysSince2000() * 86400);
    ThinkTimeLimitMinMax = 10;
    BestMove = "";
    If (Level == 1)
    {
        JuniorDistQuota = 40;
        JuniorSearchQuota = 40;
    }
    Else
    {
        If (Level == 2)
        {
            JuniorDistQuota = 20;
            JuniorSearchQuota = 75;
        }
    }
    Call AlphaBetaMinMax(-100000)(100000)(1)(2)((1 == 0))(3)((1 == 1));
    BestMove = MinMaxMoveRes;
    CurrentValue = Operator.Random(1 , 100);
    If ((CurrentValue > ((JuniorSearchQuota + 100) / 2)) Or (((BoardAttackedByWhite[floor((BestMove / 100))] == 0) And (Board[floor((BestMove % 100))] == 0)) And (CurrentValue > JuniorSearchQuota)))
    {
        Call GenerateMovesPublic(1);
        List.ReplaceItem(MovesIdx, 1, Operator.Random(1 , ceiling((List.Length(Moves1) * (JuniorDistQuota / 100)))));
        Call ApplyMove(1);
        Call CalcBoardAttackedByMove(2);
        Call RevertMove(1);
        Repeat Until (IsBlackChecked == 0)
        {
            List.ReplaceItem(MovesIdx, 1, Operator.Random(1 , List.Length(Moves1)));
            Call ApplyMove(1);
            Call CalcBoardAttackedByMove(2);
            Call RevertMove(1);
        }
        BestMove = Moves1[MovesIdx[1]];
    }
}

Define GetBestMoveMedDiff (warp=false)
{
    MaxSearchDepth = (MaxSearchDepthStackFrames - 5);
    If (Level == 5)
    {
        If (IsEndgame2 == 0)
        {
            ThinkTimeLimit = 15;
        }
        Else
        {
            ThinkTimeLimit = 10;
        }
    }
    Else
    {
        If (PlayingMode == 0)
        {
            If (IsEndgame == 0)
            {
                ThinkTimeLimit = 25;
            }
            Else
            {
                If (IsEndgame2 == 0)
                {
                    ThinkTimeLimit = 25;
                }
                Else
                {
                    If ((BlackPawnCount > 0) And (WhitePawnCount > 0))
                    {
                        ThinkTimeLimit = 20;
                    }
                    Else
                    {
                        ThinkTimeLimit = 15;
                    }
                }
            }
        }
        Else
        {
            ThinkTimeLimit = 60;
        }
    }
    ThinkTimeStart = (Sensing.DaysSince2000() * 86400);
    IsMinMaxTimeout = 0;
    IsDeepeningDone = 0;
    IdxDeepening = 1;
    BestMove = "";
    BestMinMaxRes = "";
    Repeat Until (IsDeepeningDone == 1)
    {
        IsDone = 0;
        If (IdxDeepening == 1)
        {
            QuiescenceDepth = (MaxSearchDepth - IdxDeepening);
        }
        Else
        {
            QuiescenceDepth = (MaxSearchDepth - IdxDeepening);
        }
        If (IdxDeepening < ((Level - 1) + IsEndgame))
        {
            ThinkTimeLimitMinMax = (ThinkTimeLimit * 1.5);
        }
        Else
        {
            ThinkTimeLimitMinMax = ThinkTimeLimit;
        }
        Call AlphaBetaMinMax(-100000)(100000)(1)((IdxDeepening + 1))((IdxDeepening == 1))(QuiescenceDepth)((1 == 1));
        If (Not ((MinMaxMoveRes == "")))
        {
            If ((BestMove == "") Or List.ContainsItem(MinMaxPly1EvalMoves, BestMove))
            {
                If ((BestMinMaxRes == "") Or (Not (((BestMinMaxRes > AbsMinCheckmateEval) And (MinMaxEvalRes < AbsMinCheckmateEval)))))
                {
                    BestMove = MinMaxMoveRes;
                    BestMinMaxRes = MinMaxEvalRes;
                    Call OnEvaluationChanged(BestMinMaxRes);
                }
            }
        }
        If (((IsMinMaxTimeout == 1) Or (IdxDeepening == MaxSearchDepth)) Or (((IsEndgame == 0) And ((abs(BestMinMaxRes) > AbsMinCheckmateEval) And (IdxDeepening == 1))) Or (abs(BestMinMaxRes) > (AbsMaxCheckmateEval - (IdxDeepening * 1000)))))
        {
            IsDeepeningDone = 1;
        }
        Else
        {
            IdxDeepening += 1;
        }
    }
}

Define GetBoardString (warp=true)
{
    GetBoardStringRes = "";
    Idx = 1;
    Repeat (64)
    {
        GetBoardStringRes = Operator.Join(GetBoardStringRes, Operator.Join(Board[Idx], ","));
        Idx += 1;
    }
}

Define GetCurrentMove(num Depth) (warp=true)
{
    CurrentMove = Moves[(((Depth - 1) * MaxMovesPerGeneration) + MovesIdx[Depth])];
}

Define GetKingProtection(string KingIdx)(bool IsBlack) (warp=true)
{
    KingProtection = 0;
    KingRank = IdxToRank[KingIdx];
    KingFile = IdxToFile[KingIdx];
    If ((KingFile == 1) Or (KingFile == 3))
    {
        KingFile = 2;
    }
    If ((KingFile == 6) Or (KingFile == 8))
    {
        KingFile = 7;
    }
    If IsBlack
    {
        File = (KingFile - 1);
        Repeat (3)
        {
            WhitePawnForwardRank = PawnAdvancePerFile[(File + 8)];
            BlackPawnBackwardRank = PawnAdvancePerFile[(File + 16)];
            If ((BlackPawnBackwardRank > 0) And (KingRank < BlackPawnBackwardRank))
            {
                KingProtection += PawnShelter[(((File - 1) * 8) + BlackPawnBackwardRank)];
            }
            Else
            {
                If ((KingRank == BlackPawnBackwardRank) Or (Board[((KingIdx + 8) + (File - KingFile))] > 0))
                {
                    KingProtection += Operator.Round((PawnShelter[(((File - 1) * 8) + (BlackPawnBackwardRank + 1))] / 2));
                }
                Else
                {
                    KingProtection += PawnShelter[(((File - 1) * 8) + 1)];
                }
            }
            If (abs((IdxToFile[WhiteKingIdx] - File)) > 1)
            {
                If ((WhitePawnForwardRank > 0) And (KingRank < WhitePawnForwardRank))
                {
                    CurrentValue = (0 - PawnStorm[(((File - 1) * 8) + WhitePawnForwardRank)]);
                    If ((BlackPawnBackwardRank > 0) And (BlackPawnBackwardRank < WhitePawnForwardRank))
                    {
                        KingProtection += Operator.Round((CurrentValue * 0.5));
                    }
                    Else
                    {
                        KingProtection += CurrentValue;
                    }
                }
                Else
                {
                    KingProtection += (0 - PawnStorm[(((File - 1) * 8) + 1)]);
                }
            }
            File += 1;
        }
    }
    Else
    {
        File = (KingFile - 1);
        Repeat (3)
        {
            WhitePawnBackwardRank = PawnAdvancePerFile[File];
            BlackPawnForwardRank = PawnAdvancePerFile[(File + 24)];
            If ((WhitePawnBackwardRank > 0) And (KingRank > WhitePawnBackwardRank))
            {
                KingProtection += PawnShelter[(((File - 1) * 8) + (9 - WhitePawnBackwardRank))];
            }
            Else
            {
                If ((KingRank == WhitePawnBackwardRank) Or (Board[((KingIdx - 8) + (File - KingFile))] < 0))
                {
                    KingProtection += Operator.Round((PawnShelter[(((File - 1) * 8) + (9 - WhitePawnBackwardRank))] / 2));
                }
                Else
                {
                    KingProtection += PawnShelter[(((File - 1) * 8) + 1)];
                }
            }
            If (abs((IdxToFile[BlackKingIdx] - File)) > 1)
            {
                If ((BlackPawnForwardRank > 0) And (KingRank > BlackPawnForwardRank))
                {
                    CurrentValue = (0 - PawnStorm[(((File - 1) * 8) + (9 - BlackPawnForwardRank))]);
                    If ((WhitePawnBackwardRank > 0) And (WhitePawnBackwardRank > BlackPawnForwardRank))
                    {
                        KingProtection += Operator.Round((CurrentValue * 0.5));
                    }
                    Else
                    {
                        KingProtection += CurrentValue;
                    }
                }
                Else
                {
                    KingProtection += (0 - PawnStorm[(((File - 1) * 8) + 1)]);
                }
            }
            File += 1;
        }
    }
}

Define GetMoveNotation(num Move) (warp=true)
{
    Call GetVirtualMove(Move);
    MoveNotationRes = "";
    If ((VirtualMove == BlackKingsideCastling) Or (VirtualMove == WhiteKingsideCastling))
    {
        MoveNotationRes = "O-O";
        Stop(this script);
    }
    If ((VirtualMove == BlackQueensideCastling) Or (VirtualMove == WhiteQueensideCastling))
    {
        MoveNotationRes = "O-O-O";
        Stop(this script);
    }
    SourceIdx = floor((VirtualMove / 100));
    TargetIdx = floor((VirtualMove % 100));
    CurrentPiece = Board[floor((Move / 100))];
    If ((CurrentPiece == BlackBishop) Or (CurrentPiece == WhiteBishop))
    {
        MoveNotationRes = "B";
    }
    If ((CurrentPiece == BlackKing) Or (CurrentPiece == WhiteKing))
    {
        MoveNotationRes = "K";
    }
    If ((CurrentPiece == BlackRook) Or (CurrentPiece == WhiteRook))
    {
        MoveNotationRes = "R";
    }
    If ((CurrentPiece == BlackKnight) Or (CurrentPiece == WhiteKnight))
    {
        MoveNotationRes = "N";
    }
    If ((CurrentPiece == WhiteQueen) Or (CurrentPiece == BlackQueen))
    {
        MoveNotationRes = "Q";
    }
    X = IdxToFile[SourceIdx];
    Y = (9 - IdxToRank[SourceIdx]);
    MoveNotationRes = Operator.Join(MoveNotationRes, Operator.Join(Operator.LetterOf("abcdefgh", X), Y));
    If (Not ((Board[floor((Move % 100))] == 0)))
    {
        MoveNotationRes = Operator.Join(MoveNotationRes, "x");
    }
    X = IdxToFile[TargetIdx];
    Y = (9 - IdxToRank[TargetIdx]);
    MoveNotationRes = Operator.Join(MoveNotationRes, Operator.Join(Operator.LetterOf("abcdefgh", X), Y));
    If (Operator.LetterOf(VirtualMove, 5) == ".")
    {
        If (Operator.LetterOf(VirtualMove, 6) == 1)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "=Q");
        }
        If (Operator.LetterOf(VirtualMove, 6) == 2)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "=R");
        }
        If (Operator.LetterOf(VirtualMove, 6) == 3)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "=B");
        }
        If (Operator.LetterOf(VirtualMove, 6) == 4)
        {
            MoveNotationRes = Operator.Join(MoveNotationRes, "=N");
        }
    }
}

Define GetMoveScore(string SourcePieceParam)(string TargetPieceParam)(string FromIdx)(string ToIdx)(string Move)(string Depth) (warp=true)
{
    If (CheckedState[Depth] == 1)
    {
        If (abs(SourcePieceParam) == BlackKing)
        {
            MoveScoreRes = (SourcePieceParam - TargetPieceParam);
            Stop(this script);
        }
        If (Operator.LetterOf(CheckedStateAttackLines[Depth], ToIdx) == 1)
        {
            MoveScoreRes = ((BlackKing * (((SourcePieceParam > 0) * 2) - 1)) - TargetPieceParam);
            Stop(this script);
        }
    }
    If (TargetPieceParam == 0)
    {
        Idx = List.IndexOf(CurrentKillerMoves, Move);
        If (Idx > 2)
        {
            MoveScoreRes = ((60 + Idx) * (((SourcePieceParam > 0) * 2) - 1));
            Stop(this script);
        }
    }
    MoveScoreRes = 0;
    If (Not ((TargetPieceParam == 0)))
    {
        If (Not ((abs(TargetPieceParam) < abs(SourcePieceParam))))
        {
            MoveScoreRes += ((0 - SourcePieceParam) - (10 * TargetPieceParam));
            Stop(this script);
        }
        Else
        {
            If (1 == 1)
            {
                CurrentValue = (70 + PieceIdxLookup[abs(TargetPieceParam)]);
                If (SourcePieceParam > 0)
                {
                    MoveScoreRes += CurrentValue;
                }
                Else
                {
                    MoveScoreRes += (0 - CurrentValue);
                }
            }
        }
        If (floor((AppliedMove[(Depth - 1)] % 100)) == ToIdx)
        {
            If (SourcePieceParam > 0)
            {
                MoveScoreRes += 30;
            }
            Else
            {
                MoveScoreRes += -30;
            }
        }
    }
    Call IsCheckingPieceImpl(ToIdx)(SourcePieceParam);
    If (IsCheckingPieceRes == 1)
    {
        If (SourcePieceParam > 0)
        {
            MoveScoreRes += 30;
        }
        Else
        {
            MoveScoreRes += -30;
        }
    }
    If (BoardAttackedCalculated[Depth] == 1)
    {
        If (SourcePieceParam > 0)
        {
            If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], FromIdx) > Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], FromIdx))
            {
                If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], ToIdx) < Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], ToIdx))
                {
                    MoveScoreRes += (70 + PieceIdxLookup[abs(SourcePieceParam)]);
                    Stop(this script);
                }
            }
            Else
            {
                If (Not ((Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], ToIdx) < Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], ToIdx))))
                {
                    MoveScoreRes += (0 - (70 + PieceIdxLookup[abs(SourcePieceParam)]));
                    Stop(this script);
                }
            }
        }
        Else
        {
            If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], FromIdx) > Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], FromIdx))
            {
                If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], ToIdx) < Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], ToIdx))
                {
                    MoveScoreRes += (0 - (70 + PieceIdxLookup[abs(SourcePieceParam)]));
                    Stop(this script);
                }
            }
            Else
            {
                If (Not ((Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], ToIdx) < Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], ToIdx))))
                {
                    MoveScoreRes += (70 + PieceIdxLookup[abs(SourcePieceParam)]);
                    Stop(this script);
                }
            }
        }
    }
    If (TargetPieceParam == 0)
    {
        If (SourcePieceParam > 0)
        {
            MoveScoreRes += MovePosLookupBlack[((PieceIdxLookup[SourcePieceParam] * 10000) + Move)];
        }
        Else
        {
            MoveScoreRes += MovePosLookupWhite[((PieceIdxLookup[abs(SourcePieceParam)] * 10000) + Move)];
        }
        If ((Depth > 1) And (abs(MoveScoreRes) < 40))
        {
            CurrentValue = HistoryMoveScores[(((Depth % 2) * 1000) + ((PieceIdxLookup[abs(SourcePieceParam)] * 100) + ToIdx))];
            CurrentValue = (CurrentValue / MaxHistoryMoveScore[((Depth % 2) + 1)]);
            If (CurrentValue > 0.05)
            {
                MoveScoreRes = ((40 + (Operator.Round((CurrentValue * 1000)) / 100)) * (((SourcePieceParam > 0) * 2) - 1));
                Stop(this script);
            }
        }
    }
    If (IsEndgame2 == 1)
    {
        If (abs(SourcePieceParam) > BlackBishop)
        {
            If (SourcePieceParam > 0)
            {
                Idx = WhiteKingIdx;
            }
            Else
            {
                Idx = BlackKingIdx;
            }
            KingRank = IdxToRank[Idx];
            KingFile = IdxToFile[Idx];
            Delta = abs((IdxToFile[FromIdx] - KingFile));
            Delta2 = abs((IdxToRank[FromIdx] - KingRank));
            If (abs(SourcePieceParam) == BlackKing)
            {
                If (Delta2 < Delta)
                {
                    Delta2 = Delta;
                }
            }
            Else
            {
                If (Delta < Delta2)
                {
                    Delta2 = Delta;
                }
            }
            Delta = abs((IdxToFile[ToIdx] - KingFile));
            Delta3 = abs((IdxToRank[ToIdx] - KingRank));
            If (abs(SourcePieceParam) == BlackKing)
            {
                If (Delta3 < Delta)
                {
                    Delta3 = Delta;
                }
                Delta = (Delta2 - Delta3);
            }
            Else
            {
                If (Delta < Delta3)
                {
                    Delta3 = Delta;
                }
                Delta = 0;
                If ((Delta2 > 1) And (Delta3 == 1))
                {
                    Delta = 2;
                }
                If ((Delta2 > 1) And (Delta3 == 0))
                {
                    Delta = 1;
                }
                If ((Delta2 == 1) And (Delta3 > 1))
                {
                    Delta = -2;
                }
            }
            If ((WhiteQueenCount + WhiteMinorCount) == 0)
            {
                MoveScoreRes += (25 * Delta);
            }
            If ((BlackQueenCount + BlackMinorCount) == 0)
            {
                MoveScoreRes += (-25 * Delta);
            }
            Stop(this script);
        }
    }
}

Define GetOpeningMoves (warp=true)
{
    List.DeleteItem(OpeningMovesRes, all);
    Call GenerateMovesPublic(1);
    Call CreateCurrentBoardHash;
    IdxOuter = 1;
    Repeat (List.Length(OpeningMovesMapHash))
    {
        If (OpeningMovesMapHash[IdxOuter] == CurrentBoardHash)
        {
            If List.ContainsItem(Moves1, OpeningMovesMapMove[IdxOuter])
            {
                List.Add(OpeningMovesRes, OpeningMovesMapMove[IdxOuter]);
            }
        }
        IdxOuter += 1;
    }
}

Define GetPiecePosHash(string Piece)(string Pos) (warp=true)
{
    PiecePosHash = 0;
    If ((Not ((Pos > 0))) Or (Piece == 0))
    {
        Stop(this script);
    }
    If (Piece > BlackBishop)
    {
        If (Piece == BlackRook)
        {
            PiecePosHash = PosPieceHashLookup[(320 + Pos)];
            Stop(this script);
        }
        If (Piece == BlackQueen)
        {
            PiecePosHash = PosPieceHashLookup[(128 + Pos)];
            Stop(this script);
        }
        If (Piece == BlackKing)
        {
            PiecePosHash = PosPieceHashLookup[(192 + Pos)];
            Stop(this script);
        }
    }
    If (Piece > 0)
    {
        If (Piece == BlackPawn)
        {
            PiecePosHash = PosPieceHashLookup[(64 + Pos)];
            Stop(this script);
        }
        If (Piece == BlackKnight)
        {
            PiecePosHash = PosPieceHashLookup[(256 + Pos)];
            Stop(this script);
        }
        If (Piece == BlackBishop)
        {
            PiecePosHash = PosPieceHashLookup[Pos];
            Stop(this script);
        }
    }
    If (Piece < WhiteBishop)
    {
        If (Piece == WhiteRook)
        {
            PiecePosHash = PosPieceHashLookup[(704 + Pos)];
            Stop(this script);
        }
        If (Piece == WhiteQueen)
        {
            PiecePosHash = PosPieceHashLookup[(512 + Pos)];
            Stop(this script);
        }
        If (Piece == WhiteKing)
        {
            PiecePosHash = PosPieceHashLookup[(448 + Pos)];
            Stop(this script);
        }
    }
    If (Piece < 0)
    {
        If (Piece == WhitePawn)
        {
            PiecePosHash = PosPieceHashLookup[(576 + Pos)];
            Stop(this script);
        }
        If (Piece == WhiteBishop)
        {
            PiecePosHash = PosPieceHashLookup[(384 + Pos)];
            Stop(this script);
        }
        If (Piece == WhiteKnight)
        {
            PiecePosHash = PosPieceHashLookup[(640 + Pos)];
            Stop(this script);
        }
    }
}

Define GetPiecePosScore(string Piece)(string Idx) (warp=true)
{
    PosScoreRes = 0;
    If ((Idx == 0) Or (Piece == 0))
    {
        Stop(this script);
    }
    If (Piece == BlackPawn)
    {
        If (IsEndgame == 0)
        {
            If (IsBlackCastlingPossible == 1)
            {
                PosScoreRes = PawnPieceSquarePreCastling[(65 - Idx)];
            }
            Else
            {
                PosScoreRes = PawnPieceSquare[(65 - Idx)];
            }
        }
        Else
        {
            PosScoreRes = PawnPieceSquareEndgame[(65 - Idx)];
        }
        Stop(this script);
    }
    If (Piece == WhitePawn)
    {
        If (IsEndgame == 0)
        {
            If (IsWhiteCastlingPossible == 1)
            {
                PosScoreRes = (0 - PawnPieceSquarePreCastling[Idx]);
            }
            Else
            {
                PosScoreRes = (0 - PawnPieceSquare[Idx]);
            }
        }
        Else
        {
            PosScoreRes = (0 - PawnPieceSquareEndgame[Idx]);
        }
        Stop(this script);
    }
    If (IsEndgame == 1)
    {
        If (Piece > BlackBishop)
        {
            If (Piece == BlackKing)
            {
                If ((BlackPawnCount == 0) And ((BlackQueenCount + BlackMinorCount) == 0))
                {
                    PosScoreRes = Operator.Round((1.33 * KingPieceSquareEndgame[(65 - Idx)]));
                    Stop(this script);
                }
                If ((WhitePawnCount == 0) And ((WhiteQueenCount + WhiteMinorCount) == 0))
                {
                    PosScoreRes = Operator.Round((0.67 * KingPieceSquareEndgame[(65 - Idx)]));
                    Stop(this script);
                }
                PosScoreRes = KingPieceSquareEndgame[(65 - Idx)];
                Stop(this script);
            }
            If (IsEndgame2 == 1)
            {
                Stop(this script);
            }
            If (Piece == BlackRook)
            {
                PosScoreRes = RookPieceSquareEndgame[(65 - Idx)];
                Stop(this script);
            }
            If (Piece == BlackQueen)
            {
                PosScoreRes = QueenPieceSquareEndgame[(65 - Idx)];
                Stop(this script);
            }
        }
        If (Piece > 0)
        {
            If (IsEndgame2 == 1)
            {
                Stop(this script);
            }
            If (Piece == BlackKnight)
            {
                PosScoreRes = KnightPieceSquareEndgame[(65 - Idx)];
                Stop(this script);
            }
            If (Piece == BlackBishop)
            {
                PosScoreRes = BishopPieceSquareEndgame[(65 - Idx)];
                Stop(this script);
            }
        }
        If (Piece < WhiteBishop)
        {
            If (Piece == WhiteKing)
            {
                If ((WhitePawnCount == 0) And ((WhiteQueenCount + WhiteMinorCount) == 0))
                {
                    PosScoreRes = Operator.Round((1.33 * (0 - KingPieceSquareEndgame[Idx])));
                    Stop(this script);
                }
                If ((BlackPawnCount == 0) And ((BlackQueenCount + BlackMinorCount) == 0))
                {
                    PosScoreRes = Operator.Round((0.67 * (0 - KingPieceSquareEndgame[Idx])));
                    Stop(this script);
                }
                PosScoreRes = (0 - KingPieceSquareEndgame[Idx]);
                Stop(this script);
            }
            If (IsEndgame2 == 1)
            {
                Stop(this script);
            }
            If (Piece == WhiteRook)
            {
                PosScoreRes = (0 - RookPieceSquareEndgame[Idx]);
                Stop(this script);
            }
            If (Piece == WhiteQueen)
            {
                PosScoreRes = (0 - QueenPieceSquareEndgame[Idx]);
                Stop(this script);
            }
        }
        If (Piece < 0)
        {
            If (IsEndgame2 == 1)
            {
                Stop(this script);
            }
            If (Piece == WhiteBishop)
            {
                PosScoreRes = (0 - BishopPieceSquareEndgame[Idx]);
                Stop(this script);
            }
            If (Piece == WhiteKnight)
            {
                PosScoreRes = (0 - KnightPieceSquareEndgame[Idx]);
                Stop(this script);
            }
        }
        Stop(this script);
    }
    If (Piece > BlackBishop)
    {
        If (Piece == BlackRook)
        {
            PosScoreRes = RookPieceSquare[(65 - Idx)];
            Stop(this script);
        }
        If (Piece == BlackQueen)
        {
            PosScoreRes = QueenPieceSquare[(65 - Idx)];
            Stop(this script);
        }
        If (Piece == BlackKing)
        {
            PosScoreRes = KingPieceSquare[(65 - Idx)];
            Stop(this script);
        }
    }
    If (Piece > 0)
    {
        If (Piece == BlackKnight)
        {
            PosScoreRes = KnightPieceSquare[(65 - Idx)];
            Stop(this script);
        }
        If (Piece == BlackBishop)
        {
            PosScoreRes = BishopPieceSquare[(65 - Idx)];
            Stop(this script);
        }
    }
    If (Piece < WhiteBishop)
    {
        If (Piece == WhiteRook)
        {
            PosScoreRes = (0 - RookPieceSquare[Idx]);
            Stop(this script);
        }
        If (Piece == WhiteQueen)
        {
            PosScoreRes = (0 - QueenPieceSquare[Idx]);
            Stop(this script);
        }
        If (Piece == WhiteKing)
        {
            PosScoreRes = (0 - KingPieceSquare[Idx]);
            Stop(this script);
        }
    }
    If (Piece < 0)
    {
        If (Piece == WhiteBishop)
        {
            PosScoreRes = (0 - BishopPieceSquare[Idx]);
            Stop(this script);
        }
        If (Piece == WhiteKnight)
        {
            PosScoreRes = (0 - KnightPieceSquare[Idx]);
            Stop(this script);
        }
    }
}

Define GetRepetitionCount (warp=true)
{
    RepetitionCountRes = 1;
    Idx = (List.Length(BoardHistory) - 2);
    Repeat Until (Idx < 1)
    {
        If (BoardHistory[Idx] == BoardHistory[last])
        {
            RepetitionCountRes += 1;
        }
        Idx += -2;
    }
}

Define GetSpecialMoveScore(string Move)(string Depth) (warp=true)
{
    If (floor((Move / 100)) == 0)
    {
        If ((Depth % 2) == 1)
        {
            MoveScoreRes = 85;
        }
        Else
        {
            MoveScoreRes = -85;
        }
        Stop(this script);
    }
    If (Variable.Length(Move) == 6)
    {
        If ((Depth % 2) == 1)
        {
            MoveScoreRes = (1000 - (200 * Operator.LetterOf(Move, 6)));
        }
        Else
        {
            MoveScoreRes = (-1000 + (200 * Operator.LetterOf(Move, 6)));
        }
        Stop(this script);
    }
    MoveScoreRes = 0;
}

Define GetSubstring(string Text)(num FromIdx)(num ToIdx) (warp=true)
{
    SubstringRes = "";
    IdxString = FromIdx;
    Repeat (((ToIdx - FromIdx) + 1))
    {
        SubstringRes = Operator.Join(SubstringRes, Operator.LetterOf(Text, IdxString));
        IdxString += 1;
    }
}

Define GetSubstringLeft(string Text)(num Count) (warp=true)
{
    Call GetSubstring(Text)(1)(Count);
}

Define GetSubstringRight(string Text)(num Count) (warp=true)
{
    Call GetSubstring(Text)(((Variable.Length(Text) - Count) + 1))(Variable.Length(Text));
}

Define GetTargetIdx(num SourceIdx)(num DeltaX)(num DeltaY) (warp=true)
{
    GetTargetIdxRes = -1;
    X = (IdxToFile[SourceIdx] + DeltaX);
    If ((X > 0) And (X < 9))
    {
        Y = (IdxToRank[SourceIdx] + DeltaY);
        If ((Y > 0) And (Y < 9))
        {
            GetTargetIdxRes = (X + ((Y - 1) * 8));
        }
    }
}

Define GetVirtualMove(num Move) (warp=true)
{
    If (IsPlayerBlack == 0)
    {
        VirtualMove = Move;
    }
    Else
    {
        If ((Not ((Move < 0100))) And (Not ((Move > 6499))))
        {
            VirtualMove = (65 - floor((Move % 100)));
            Repeat Until (Variable.Length(VirtualMove) > 1)
            {
                VirtualMove = Operator.Join(0, VirtualMove);
            }
            VirtualMove = Operator.Join((65 - floor((Move / 100))), VirtualMove);
            Repeat Until (Variable.Length(VirtualMove) > 3)
            {
                VirtualMove = Operator.Join(0, VirtualMove);
            }
            If (Operator.LetterOf(Move, 5) == ".")
            {
                VirtualMove = Operator.Join(VirtualMove, Operator.Join(Operator.LetterOf(Move, 5), Operator.LetterOf(Move, 6)));
            }
        }
        Else
        {
            If (Move == BlackKingsideCastling)
            {
                VirtualMove = WhiteKingsideCastling;
            }
            Else
            {
                If (Move == BlackQueensideCastling)
                {
                    VirtualMove = WhiteQueensideCastling;
                }
                Else
                {
                    If (Move == WhiteKingsideCastling)
                    {
                        VirtualMove = BlackKingsideCastling;
                    }
                    Else
                    {
                        If (Move == WhiteQueensideCastling)
                        {
                            VirtualMove = BlackQueensideCastling;
                        }
                    }
                }
            }
        }
    }
}

Define ImportBoard(string ImpBoard) (warp=false)
{
    Call EnterExecution;
    Call ExportBoardFEN((IsPlayerBlack == 1))((1 == 1));
    Call ImportBoardFEN(ImpBoard);
    Call CalcBoardStats;
    If ((BlackKingIdx == "") Or (WhiteKingIdx == ""))
    {
        Call SayAsync("Invalid FEN data")(5);
        Call ImportBoardFEN(ExportDataFEN);
        Call CalcBoardStats;
    }
    Else
    {
        FromSquareIdx = -1;
        ToSquareIdx = -1;
        Event.BroadcastAndWait("fromsquareselected");
        Event.BroadcastAndWait("tosquareselected");
        IsImportedBoard = 1;
        HasWhiteKingMoved = 0;
        HasBlackKingMoved = 0;
        HasWhiteCastled = 0;
        HasBlackCastled = 0;
        HasWhiteRookKSMoved = 0;
        HasWhiteRookQSMoved = 0;
        HasBlackRookKSMoved = 0;
        HasBlackRookQSMoved = 0;
        GameMoves = "";
        List.DeleteItem(BoardHistory, all);
        List.DeleteItem(BoardHistoryHash, all);
        List.DeleteItem(BoardHistoryMetaState, all);
        List.DeleteItem(BoardHistoryWasEngineMove, all);
        List.DeleteItem(GameMovesAN, all);
        If (Not ((Board[VirtualBoard[1]] == BlackRook)))
        {
            HasBlackRookQSMoved = 1;
        }
        If (Not ((Board[VirtualBoard[5]] == BlackKing)))
        {
            HasBlackKingMoved = 1;
        }
        If (Not ((Board[VirtualBoard[8]] == BlackRook)))
        {
            HasBlackRookKSMoved = 1;
        }
        If (Not ((Board[VirtualBoard[57]] == WhiteRook)))
        {
            HasWhiteRookQSMoved = 1;
        }
        If (Not ((Board[VirtualBoard[61]] == WhiteKing)))
        {
            HasWhiteKingMoved = 1;
        }
        If (Not ((Board[VirtualBoard[64]] == WhiteRook)))
        {
            HasWhiteRookKSMoved = 1;
        }
        Call AddBoardToHistory("");
        Call DrawBoardAndWait;
        IsGameSuspended = 0;
        Call CalcBoardAttackedByMoveChecked(1);
        Call CalcBoardAttackedByMoveChecked(2);
        IdxString += 1;
        CurrentValue = Operator.LetterOf(ImpBoard, IdxString);
        If (((CurrentValue == "B") And (IsPlayerBlack == 0)) Or ((CurrentValue == "W") And (IsPlayerBlack == 1)))
        {
            If (IsWhiteChecked == 1)
            {
                Call SayAsync("Checkmate!")(5);
                IsGameSuspended = 1;
            }
            Else
            {
                Call IsDrawByStalemate(1);
                If (IsDrawRes == 1)
                {
                    Call SayAsync("Draw!")(5);
                    IsGameSuspended = 1;
                }
                Else
                {
                    Call ExecuteEngineMove;
                }
            }
        }
        Else
        {
            If (((CurrentValue == "W") And (IsPlayerBlack == 0)) Or ((CurrentValue == "B") And (IsPlayerBlack == 1)))
            {
                If (IsBlackChecked == 1)
                {
                    Call SayAsync("Checkmate!")(5);
                    IsGameSuspended = 1;
                }
                Else
                {
                    Call IsDrawByStalemate(2);
                    If (IsDrawRes == 1)
                    {
                        Call SayAsync("Draw!")(5);
                        IsGameSuspended = 1;
                    }
                }
            }
        }
    }
    Call ExitExecution;
}

Define ImportBoardFEN(string ImpBoard) (warp=false)
{
    Idx = 1;
    Repeat (64)
    {
        List.ReplaceItem(Board, Idx, 0);
        Idx += 1;
    }
    If (IsPlayerBlack == 0)
    {
        Idx = 1;
        IdxInc = 1;
    }
    Else
    {
        Idx = 64;
        IdxInc = -1;
    }
    IdxString = 1;
    Repeat Until (((Idx > 64) Or (Idx < 1)) Or (IdxString > Variable.Length(ImpBoard)))
    {
        CurrentValue = Operator.LetterOf(ImpBoard, IdxString);
        If ((Not ((CurrentValue < "A"))) And (Not ((CurrentValue > "Z"))))
        {
            CurrentPiece = 0;
            If (CurrentValue == "P")
            {
                CurrentPiece = BlackPawn;
            }
            If (CurrentValue == "N")
            {
                CurrentPiece = BlackKnight;
            }
            If (CurrentValue == "B")
            {
                CurrentPiece = BlackBishop;
            }
            If (CurrentValue == "R")
            {
                CurrentPiece = BlackRook;
            }
            If (CurrentValue == "Q")
            {
                CurrentPiece = BlackQueen;
            }
            If (CurrentValue == "K")
            {
                CurrentPiece = BlackKing;
            }
            Call IsLowerCase(CurrentValue);
            If (IsLowerCaseRes == 0)
            {
                CurrentPiece = (CurrentPiece * -1);
            }
            If (IsPlayerBlack == 1)
            {
                CurrentPiece = (CurrentPiece * -1);
            }
            List.ReplaceItem(Board, Idx, CurrentPiece);
            Idx += IdxInc;
        }
        Else
        {
            If ((Not ((CurrentValue < 0))) And (Not ((CurrentValue > 9))))
            {
                Repeat (CurrentValue)
                {
                    List.ReplaceItem(Board, Idx, 0);
                    Idx += IdxInc;
                }
            }
            Else
            {
                If (CurrentValue == "/")
                {
                    Repeat Until ((((Idx % 8) == 1) And (IsPlayerBlack == 0)) Or (((Idx % 8) == 0) And (IsPlayerBlack == 1)))
                    {
                        List.ReplaceItem(Board, Idx, 0);
                        Idx += IdxInc;
                    }
                }
            }
        }
        IdxString += 1;
    }
}

Define ImportBoardImpl(string ImpBoard) (warp=true)
{
    Idx = 1;
    IdxString = 1;
    CurrentPiece = "";
    Repeat Until (IdxString > Variable.Length(ImpBoard))
    {
        If (Operator.LetterOf(ImpBoard, IdxString) == ",")
        {
            List.ReplaceItem(Board, Idx, CurrentPiece);
            Idx += 1;
            CurrentPiece = "";
        }
        Else
        {
            CurrentPiece = Operator.Join(CurrentPiece, Operator.LetterOf(ImpBoard, IdxString));
        }
        IdxString += 1;
    }
}

Define InitAlphaBeta(string MaxDepth)(bool InitialDeepening) (warp=true)
{
    IsInNullMove = 0;
    IsMinMaxTimeout = 0;
    If InitialDeepening
    {
        Call Profile_Reset;
        PrevProgressUpdate = (Sensing.DaysSince2000() * 86400);
        TTCurrentAge = ((floor((TTCurrentAge / 100)) + 1) * 100);
        IdxOuter = 1;
        Repeat (List.Length(HistoryMoveScores))
        {
            List.ReplaceItem(HistoryMoveScores, IdxOuter, Operator.Round((HistoryMoveScores[IdxOuter] / 8)));
            IdxOuter += 1;
        }
        IdxOuter = 1;
        Repeat (List.Length(MaxHistoryMoveScore))
        {
            List.ReplaceItem(MaxHistoryMoveScore, IdxOuter, Operator.Round((MaxHistoryMoveScore[IdxOuter] / 8)));
            IdxOuter += 1;
        }
    }
    Call SetInitialEnPassantTarget(1);
    List.DeleteItem(MinMaxPly1EvalMoves, all);
    TTCurrentAge += 1;
    Call CalcBoardStats;
    Call InitMovePosLookup((1 == 0));
    Call NNUE_Public_Refresh;
    Call Log(MaxDepth)(" : ")("Search start, depth = ")(MaxDepth)("")("")("")("");
}

Define InitBoard (warp=true)
{
    FromSquareIdx = -1;
    ToSquareIdx = -1;
    ProfilerMode = 0;
    DebugMode = 0;
    PlayingMode = 0;
    MoveFromIdx = -1;
    MoveToIdx = -1;
    ProgressValue = 0;
    EvaluationValue = 0;
    IsAdvisorEnabled = 1;
    IsInUndo = 0;
    IsBlockProfilerEnabled = 0;
    IsEndgame = 0;
    IsEndgame2 = 0;
    IsImportedBoard = 0;
    BlackKingsideCastling = 0090;
    WhiteKingsideCastling = 0092;
    BlackQueensideCastling = 0091;
    WhiteQueensideCastling = 0093;
    HasBlackCastled = 0;
    HasWhiteKingMoved = 0;
    HasWhiteCastled = 0;
    HasBlackKingMoved = 0;
    HasWhiteRookKSMoved = 0;
    HasWhiteRookQSMoved = 0;
    HasBlackRookKSMoved = 0;
    HasBlackRookQSMoved = 0;
    GameMoves = "";
    IsGameSuspended = 0;
    PrevProgressUpdate = 0;
    Empty = 0;
    WhiteKing = -50000;
    WhiteQueen = -900;
    WhiteRook = -500;
    WhiteBishop = -330;
    WhiteKnight = -315;
    WhitePawn = -100;
    BlackKing = 50000;
    BlackQueen = 900;
    BlackRook = 500;
    BlackBishop = 330;
    BlackKnight = 315;
    BlackPawn = 100;
    AbsMinCheckmateEval = (BlackKing - 10000);
    AbsMaxCheckmateEval = 97000;
    DrawByRepetitionEval = -50.1;
    MaxPly1DeepeningMoveOrderScore = 900000;
    MaxMoveOrderScore = 999999;
    MaxSearchDepthStackFrames = 40;
    MaxMovesPerGeneration = 300;
    Call InitCoordLookup;
    Call FillBoard;
    List.DeleteAll(PieceIdxLookup);
    Idx = 1;
    Repeat (BlackKing)
    {
        List.Add(PieceIdxLookup, "");
        Idx += 1;
    }
    List.ReplaceItem(PieceIdxLookup, BlackPawn, 1);
    List.ReplaceItem(PieceIdxLookup, BlackKnight, 2);
    List.ReplaceItem(PieceIdxLookup, BlackBishop, 3);
    List.ReplaceItem(PieceIdxLookup, BlackRook, 4);
    List.ReplaceItem(PieceIdxLookup, BlackQueen, 5);
    List.ReplaceItem(PieceIdxLookup, BlackKing, 6);
    CharsUpperCase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    List.DeleteItem(CharsUpperCaseList, all);
    Idx = 1;
    Repeat (List.Length(CharsUpperCaseList))
    {
        List.Add(CharsUpperCaseList, Operator.LetterOf(CharsUpperCase, Idx));
        Idx += 1;
    }
    List.DeleteItem(KillerMoves, all);
    Repeat ((4 * MaxSearchDepthStackFrames))
    {
        List.Add(KillerMoves, "");
    }
    List.DeleteItem(HistoryMoveScores, all);
    Repeat (2000)
    {
        List.Add(HistoryMoveScores, 0);
    }
    List.DeleteItem(MaxHistoryMoveScore, all);
    Repeat (2)
    {
        List.Add(MaxHistoryMoveScore, 0);
    }
    List.DeleteItem(BoardHistory, all);
    List.DeleteItem(BoardHistoryHash, all);
    List.DeleteItem(BoardHistoryMetaState, all);
    List.DeleteItem(BoardHistoryWasEngineMove, all);
    List.DeleteItem(GameMovesAN, all);
    List.DeleteItem(BoardAttackedByWhite, all);
    List.DeleteItem(BoardAttackedByBlack, all);
    List.DeleteItem(PieceMobility, all);
    List.DeleteItem(BoardAttackedByWhitePiece, all);
    List.DeleteItem(BoardAttackedByBlackPiece, all);
    Repeat (64)
    {
        List.Add(BoardAttackedByWhite, 0);
        List.Add(BoardAttackedByBlack, 0);
        List.Add(PieceMobility, 0);
        List.Add(BoardAttackedByWhitePiece, 0);
        List.Add(BoardAttackedByBlackPiece, 0);
    }
    Call //("Due to the lack of local variables in Scratch, we emulate a method stack for recursive Minimax using lists");
    List.DeleteItem(Alphas, all);
    List.DeleteItem(Betas, all);
    List.DeleteItem(AlphasOld, all);
    List.DeleteItem(BetasOld, all);
    List.DeleteItem(MinMaxResults, all);
    List.DeleteItem(MinMaxResultsIsDynamic, all);
    List.DeleteItem(MovesCount, all);
    List.DeleteItem(MovesIdx, all);
    List.DeleteItem(MovesIdxBestMove, all);
    List.DeleteItem(TargetPieces, all);
    List.DeleteItem(PreviousBoardHash, all);
    List.DeleteItem(PreviousBoardHash2, all);
    List.DeleteItem(ScoreTypes, all);
    List.DeleteItem(PickMoveRes, all);
    List.DeleteItem(PickPhase, all);
    List.DeleteItem(PickedMoves, all);
    List.DeleteItem(PickedMoveCount, all);
    List.DeleteItem(BestMoves, all);
    List.DeleteItem(CheckedState, all);
    List.DeleteItem(CheckedStateAttackLines, all);
    List.DeleteItem(PromotionPieces, all);
    List.DeleteItem(TargetPiecesIdx, all);
    List.DeleteItem(PosScoreDelta, all);
    List.DeleteItem(BoardAttackedCalculated, all);
    List.DeleteItem(PutsInCheck, all);
    List.DeleteItem(EvalExtended1, all);
    List.DeleteItem(PlyExtension, all);
    List.DeleteItem(SourcePieces, all);
    List.DeleteItem(EvalExtended2, all);
    List.DeleteItem(EvalExtended3, all);
    List.DeleteItem(BlackMobBonus, all);
    List.DeleteItem(WhiteMobBonus, all);
    List.DeleteItem(AppliedMove, all);
    List.DeleteItem(CapturesDeltaSum, all);
    List.DeleteItem(PosScoreDeltaSum, all);
    List.DeleteItem(PlyExtensionTagged, all);
    List.DeleteItem(BoardAttackedByBlackPieceSnapshot, all);
    List.DeleteItem(BoardAttackedByBlackSnapshot, all);
    List.DeleteItem(BoardAttackedByWhitePieceSnapshot, all);
    List.DeleteItem(BoardAttackedByWhiteSnapshot, all);
    List.DeleteItem(Quiescence, all);
    List.DeleteItem(EnPassantTarget, all);
    List.DeleteItem(PassedWhitePawnOnEndgame, all);
    List.DeleteItem(CastlingState, all);
    List.DeleteItem(PawnShelterCapture, all);
    List.DeleteItem(AppliedMove_NNUE_State, all);
    Repeat (MaxSearchDepthStackFrames)
    {
        List.Add(Alphas, "");
        List.Add(Betas, "");
        List.Add(AlphasOld, "");
        List.Add(BetasOld, "");
        List.Add(MinMaxResults, "");
        List.Add(MinMaxResultsIsDynamic, "");
        List.Add(MovesCount, 0);
        List.Add(MovesIdx, "");
        List.Add(MovesIdxBestMove, "");
        List.Add(TargetPieces, "");
        List.Add(PreviousBoardHash, "");
        List.Add(PreviousBoardHash2, "");
        List.Add(ScoreTypes, "");
        List.Add(PickMoveRes, "");
        List.Add(PickPhase, "");
        List.Add(PickedMoves, "");
        List.Add(PickedMoveCount, 0);
        List.Add(BestMoves, "");
        List.Add(CheckedState, "");
        List.Add(CheckedStateAttackLines, "");
        List.Add(PromotionPieces, "");
        List.Add(TargetPiecesIdx, "");
        List.Add(PosScoreDelta, "");
        List.Add(BoardAttackedCalculated, "");
        List.Add(PutsInCheck, "");
        List.Add(EvalExtended1, "");
        List.Add(PlyExtension, "");
        List.Add(SourcePieces, 0);
        List.Add(EvalExtended2, "");
        List.Add(EvalExtended3, "");
        List.Add(BlackMobBonus, "");
        List.Add(WhiteMobBonus, "");
        List.Add(AppliedMove, "");
        List.Add(CapturesDeltaSum, "");
        List.Add(PosScoreDeltaSum, "");
        List.Add(PlyExtensionTagged, "");
        List.Add(BoardAttackedByBlackPieceSnapshot, "");
        List.Add(BoardAttackedByBlackSnapshot, "");
        List.Add(BoardAttackedByWhitePieceSnapshot, "");
        List.Add(BoardAttackedByWhiteSnapshot, "");
        List.Add(Quiescence, "");
        List.Add(EnPassantTarget, "");
        List.Add(PassedWhitePawnOnEndgame, 0);
        List.Add(CastlingState, 0);
        List.Add(PawnShelterCapture, 0);
        List.Add(AppliedMove_NNUE_State, 0);
    }
    List.DeleteItem(CastlingStateLookup, all);
    Idx = 0;
    Repeat (256)
    {
        List.Add(CastlingStateLookup, Operator.Join(Operator.Join(Operator.Join((floor((Idx / 128)) % 2), (floor((Idx / 64)) % 2)), Operator.Join((floor((Idx / 32)) % 2), (floor((Idx / 16)) % 2))), Operator.Join(Operator.Join((floor((Idx / 8)) % 2), (floor((Idx / 4)) % 2)), Operator.Join((floor((Idx / 2)) % 2), (Idx % 2)))));
        Idx += 1;
    }
    List.DeleteItem(CastlingStatePow2, all);
    Idx = 128;
    Repeat (8)
    {
        List.Add(CastlingStatePow2, Idx);
        Idx = (Idx / 2);
    }
    List.DeleteItem(BlackPawnCount, all);
    List.DeleteItem(WhitePawnCount, all);
    Repeat (8)
    {
        List.Add(BlackPawnCount, 0);
        List.Add(WhitePawnCount, 0);
    }
    Call //("Generated moves are stores in per-ply segments within Moves list");
    List.DeleteAll(Moves);
    Repeat ((MaxMovesPerGeneration * MaxSearchDepthStackFrames))
    {
        List.Add(Moves, "");
    }
}

Define InitBoardPhase2 (warp=true)
{
    Call InitHashLookup;
    Call InitMoveLookup;
    Call InitMobilityBonusLookup;
    Call InitKingSafety;
    Call InitPieceSquareTables;
    Call CalcBoardStats;
    Call InitMovePosLookup((1 == 1));
    Call InitOpeningBook;
    Call InitOpeningMovesMap;
    Call InitChebyshev;
    Call NNUE_Init;
    Call AddBoardToHistory("");
}

Define InitChebyshev (warp=true)
{
    List.DeleteAll(ChebyshevDistance);
    Repeat (6500)
    {
        List.Add(ChebyshevDistance, "");
    }
    Idx = 1;
    Repeat (64)
    {
        IdxSub = 1;
        Repeat (64)
        {
            Delta = abs((IdxToRank[Idx] - IdxToRank[IdxSub]));
            Delta2 = abs((IdxToFile[Idx] - IdxToFile[IdxSub]));
            If (Delta > Delta2)
            {
                List.ReplaceItem(ChebyshevDistance, ((Idx * 100) + IdxSub), Delta);
            }
            Else
            {
                List.ReplaceItem(ChebyshevDistance, ((Idx * 100) + IdxSub), Delta2);
            }
            IdxSub += 1;
        }
        Idx += 1;
    }
}

Define InitCoordLookup (warp=true)
{
    List.DeleteItem(IdxToFile, all);
    List.DeleteItem(IdxToRank, all);
    Idx = 1;
    Repeat (64)
    {
        List.Add(IdxToFile, (((Idx - 1) % 8) + 1));
        List.Add(IdxToRank, ceiling((Idx / 8)));
        Idx += 1;
    }
}

Define InitHashLookup (warp=true)
{
    TTCurrentAge = 0;
    List.DeleteItem(PosPieceHashLookup, all);
    Repeat (1024)
    {
        List.Add(PosPieceHashLookup, Operator.Random((1 - ((65536 * 65536) * (65536 * 1))) , ((65536 * 65536) * (65536 * 1))));
    }
    Call ClearTT;
}

Define InitKingSafety (warp=true)
{
    List.DeleteItem(PawnStorm, all);
    Call LoadList(" 0, 22, 27, 19,  1, -24, -33, 0,  0, 31, 31, 19,  1, -19, -28, 0,  0, 22, 19, 10,  1, -19, -28, 0,  0,  0,  1,  1,  1, -15, -19, 0,  0,  0,  1,  1,  1, -15, -19, 0,  0, 22, 19, 10,  1, -19, -28, 0,  0, 31, 31, 19,  1, -19, -28, 0,  0, 22, 27, 19,  1, -24, -33, 0,")("PawnStorm");
    List.DeleteItem(PawnShelter, all);
    Call LoadList("-3, 38, 44, 22, 18, 8, 12, 0,    -20, 29, 8, -23, -14, -5, -30, 0,     5, 35, 11, -1, 15, 1, -21, 0,    -18, -6, -14, -24, -23, -31, -48, 0,    -18, -6, -14, -24, -23, -31, -48, 0,     5, 35, 11, -1, 15, 1, -21, 0,    -20, 29, 8, -23, -14, -5, -30, 0,   - 3, 38, 44, 22, 18, 8, 12, 0,")("PawnShelter");
}

Define InitMobilityBonusLookup (warp=true)
{
    List.DeleteItem(QueenMobilityBonus, all);
    List.DeleteItem(BishopMobilityBonus, all);
    List.DeleteItem(RookMobilityBonus, all);
    List.DeleteItem(KnightMobilityBonus, all);
    Call LoadList("-15,-10,0,0,1,2,3,4,4,5,5,6,6,7,7,7,8,8,9,9,10,11,11,11,12,12,12,13")("QueenMobilityBonus");
    Call LoadList("-6,-2,2,3,4,5,5,6,7,7,8,8,9,10")("BishopMobilityBonus");
    Call LoadList("-8,-6,-1,-1,0,0,1,1,2,2,3,3,4,5,6")("RookMobilityBonus");
    Call LoadList("-8,-6,-1,0,1,2,2,3,4")("KnightMobilityBonus");
}

Define InitMoveLookup (warp=true)
{
    List.DeleteItem(KnightMoveOffsets, all);
    List.DeleteItem(KingMoveOffsets, all);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KnightMoveOffsets, -2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, -1);
    List.Add(KnightMoveOffsets, 2);
    List.Add(KnightMoveOffsets, 1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, -1);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 0);
    List.Add(KingMoveOffsets, 1);
    List.Add(KingMoveOffsets, 1);
    List.DeleteItem(MoveLookupStraight, all);
    List.DeleteItem(MoveLookupCross, all);
    List.DeleteItem(MoveLookupOffsetsStraight, all);
    List.DeleteItem(MoveLookupOffsetsCross, all);
    List.DeleteItem(MoveLookupKnight, all);
    List.DeleteItem(MoveLookupKing, all);
    List.DeleteItem(MoveLookupIndexOffset, all);
    List.DeleteItem(MoveLookupLineIndexOffset, all);
    List.Add(MoveLookupOffsetsStraight, 1);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, 1);
    List.Add(MoveLookupOffsetsStraight, -1);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, 0);
    List.Add(MoveLookupOffsetsStraight, -1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, -1);
    List.Add(MoveLookupOffsetsCross, -1);
    List.Add(MoveLookupOffsetsCross, 1);
    List.Add(MoveLookupOffsetsCross, -1);
    List.Add(MoveLookupOffsetsCross, -1);
    Idx = 1;
    Repeat (64)
    {
        IdxSub = 1;
        Repeat (4)
        {
            X = IdxToFile[Idx];
            Y = IdxToRank[Idx];
            Repeat (8)
            {
                X += MoveLookupOffsetsStraight[IdxSub];
                Y += MoveLookupOffsetsStraight[(IdxSub + 1)];
                List.Add(MoveLookupStraight, -1);
                If ((Y > 0) And (Y < 9))
                {
                    If ((X > 0) And (X < 9))
                    {
                        TargetIdx = (X + ((Y - 1) * 8));
                        List.ReplaceItem(MoveLookupStraight, last, TargetIdx);
                    }
                }
            }
            IdxSub += 2;
        }
        IdxSub = 1;
        Repeat (4)
        {
            X = IdxToFile[Idx];
            Y = IdxToRank[Idx];
            Repeat (8)
            {
                X += MoveLookupOffsetsCross[IdxSub];
                Y += MoveLookupOffsetsCross[(IdxSub + 1)];
                List.Add(MoveLookupCross, -1);
                If ((Y > 0) And (Y < 9))
                {
                    If ((X > 0) And (X < 9))
                    {
                        TargetIdx = (X + ((Y - 1) * 8));
                        List.ReplaceItem(MoveLookupCross, last, TargetIdx);
                    }
                }
            }
            IdxSub += 2;
        }
        Idx += 1;
    }
    Idx = 1;
    Repeat (64)
    {
        List.InsertItem(MoveLookupIndexOffset, Idx, ((Idx - 1) * 8));
        List.InsertItem(MoveLookupLineIndexOffset, Idx, ((Idx - 1) * 32));
        Idx += 1;
    }
    Idx = 1;
    Repeat (64)
    {
        IdxSub = 1;
        Repeat (8)
        {
            Call GetTargetIdx(Idx)(KingMoveOffsets[IdxSub])(KingMoveOffsets[(IdxSub + 1)]);
            If (Not ((GetTargetIdxRes == -1)))
            {
                List.Add(MoveLookupKing, GetTargetIdxRes);
            }
            IdxSub += 2;
        }
        Repeat Until (List.Length(MoveLookupKing) == (Idx * 8))
        {
            List.Add(MoveLookupKing, -1);
        }
        IdxSub = 1;
        Repeat (8)
        {
            Call GetTargetIdx(Idx)(KnightMoveOffsets[IdxSub])(KnightMoveOffsets[(IdxSub + 1)]);
            If (Not ((GetTargetIdxRes == -1)))
            {
                List.Add(MoveLookupKnight, GetTargetIdxRes);
            }
            IdxSub += 2;
        }
        Repeat Until (List.Length(MoveLookupKnight) == (Idx * 8))
        {
            List.Add(MoveLookupKnight, -1);
        }
        Idx += 1;
    }
    List.DeleteItem(MoveNotationLookup, all);
    List.DeleteItem(MovePathDelta, all);
    List.DeleteItem(MovePathStepInc, all);
    List.DeleteItem(BoardAttackedByPieceMap, all);
    Idx = 0;
    Repeat (10000)
    {
        If (Idx < 10)
        {
            List.Add(BoardAttackedByPieceMap, Operator.Join(000, Idx));
        }
        Else
        {
            If (Idx < 100)
            {
                List.Add(BoardAttackedByPieceMap, Operator.Join(00, Idx));
            }
            Else
            {
                If (Idx < 1000)
                {
                    List.Add(BoardAttackedByPieceMap, Operator.Join(0, Idx));
                }
                Else
                {
                    List.Add(BoardAttackedByPieceMap, Idx);
                }
            }
        }
        Idx += 1;
    }
    Idx = 1;
    Repeat (9999)
    {
        If (Idx < 10)
        {
            List.Add(MoveNotationLookup, Operator.Join(000, Idx));
        }
        Else
        {
            If (Idx < 100)
            {
                List.Add(MoveNotationLookup, Operator.Join(00, Idx));
            }
            Else
            {
                If (Idx < 1000)
                {
                    List.Add(MoveNotationLookup, Operator.Join(0, Idx));
                }
                Else
                {
                    List.Add(MoveNotationLookup, Idx);
                }
            }
        }
        Idx += 1;
    }
    Repeat (10000)
    {
        List.Add(MovePathDelta, "");
        List.Add(MovePathStepInc, "");
    }
    Idx = 1;
    Repeat (64)
    {
        IdxSub = 1;
        Repeat (64)
        {
            X = (IdxToFile[IdxSub] - IdxToFile[Idx]);
            Y = (IdxToRank[IdxSub] - IdxToRank[Idx]);
            If ((Not ((Idx == IdxSub))) And (((X == 0) Or (Y == 0)) Or (abs(X) == abs(Y))))
            {
                If (abs(X) > abs(Y))
                {
                    Delta = abs(X);
                }
                Else
                {
                    Delta = abs(Y);
                }
                List.ReplaceItem(MovePathDelta, ((Idx * 100) + IdxSub), Delta);
                List.ReplaceItem(MovePathStepInc, ((Idx * 100) + IdxSub), ((8 * (Y / Delta)) + (X / Delta)));
            }
            IdxSub += 1;
        }
        Idx += 1;
    }
}

Define InitMovePosLookup(bool Init) (warp=true)
{
    MetaState = Operator.Join(IsBlackCastlingPossible, Operator.Join(IsWhiteCastlingPossible, Operator.Join(IsEndgame, IsEndgame2)));
    If (BlackQueenCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (WhiteQueenCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (BlackMinorCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (WhiteMinorCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (BlackPawnCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (WhitePawnCount == 0)
    {
        MetaState = Operator.Join(MetaState, 0);
    }
    Else
    {
        MetaState = Operator.Join(MetaState, 1);
    }
    If (Init Or (Not ((MetaState == PrevMetaState))))
    {
        PrevMetaState = MetaState;
        If (Not (Init))
        {
            IdxOuter = 1;
            Repeat (List.Length(TTNodeScore))
            {
                List.ReplaceItem(TTNodeScore, IdxOuter, "");
                List.ReplaceItem(TTNodeScoreIsDynamic, IdxOuter, "");
                List.ReplaceItem(TTNodeType, IdxOuter, "");
                IdxOuter += 1;
            }
            IdxOuter = 1;
            Repeat (List.Length(TTBoardScoreSum))
            {
                List.ReplaceItem(TTBoardScore1, IdxOuter, "");
                List.ReplaceItem(TTBoardScore2, IdxOuter, "");
                List.ReplaceItem(TTBoardScore3, IdxOuter, "");
                List.ReplaceItem(TTBoardScoreSum, IdxOuter, "");
                List.ReplaceItem(TTBoardScoreIsDynamic, IdxOuter, "");
                IdxOuter += 1;
            }
        }
        If (((Not ((List.Length(MovePosLookupBlack) == 100000))) Or (Not ((List.Length(MovePosLookupWhite) == 100000)))) Or ((Not ((List.Length(MoveHashLookupBlack) == 100000))) Or (Not ((List.Length(MoveHashLookupWhite) == 100000)))))
        {
            List.DeleteAll(MovePosLookupBlack);
            List.DeleteAll(MovePosLookupWhite);
            List.DeleteAll(MoveHashLookupBlack);
            List.DeleteAll(MoveHashLookupWhite);
            Repeat (100000)
            {
                List.Add(MovePosLookupBlack, "");
                List.Add(MovePosLookupWhite, "");
                List.Add(MoveHashLookupBlack, "");
                List.Add(MoveHashLookupWhite, "");
            }
        }
        List.DeleteAll(Pieces);
        List.Add(Pieces, BlackKing);
        List.Add(Pieces, BlackQueen);
        List.Add(Pieces, BlackRook);
        List.Add(Pieces, BlackBishop);
        List.Add(Pieces, BlackKnight);
        List.Add(Pieces, BlackPawn);
        List.Add(Pieces, WhiteKing);
        List.Add(Pieces, WhiteQueen);
        List.Add(Pieces, WhiteRook);
        List.Add(Pieces, WhiteBishop);
        List.Add(Pieces, WhiteKnight);
        List.Add(Pieces, WhitePawn);
        IdxOuter = 1;
        Repeat (List.Length(Pieces))
        {
            SourcePiece = Pieces[IdxOuter];
            IsSlidingPiece = 0;
            If (abs(SourcePiece) == BlackBishop)
            {
                IsSlidingPiece = 1;
            }
            If (abs(SourcePiece) == BlackRook)
            {
                IsSlidingPiece = 2;
            }
            If (abs(SourcePiece) == BlackQueen)
            {
                IsSlidingPiece = 3;
            }
            SourceIdx = 0;
            Repeat (65)
            {
                File = IdxToFile[SourceIdx];
                Rank = IdxToRank[SourceIdx];
                Call GetPiecePosScore(SourcePiece)(SourceIdx);
                PosScoreRes2 = PosScoreRes;
                Call GetPiecePosHash(SourcePiece)(SourceIdx);
                PiecePosHash2 = PiecePosHash;
                TargetIdx = 0;
                Repeat (65)
                {
                    IsLegalMove = 0;
                    If (((Not ((SourceIdx == 0))) And (Not ((TargetIdx == 0)))) And (Not ((SourceIdx == TargetIdx))))
                    {
                        X = abs((IdxToFile[TargetIdx] - File));
                        Y = abs((IdxToRank[TargetIdx] - Rank));
                        If (IsSlidingPiece == 0)
                        {
                            If (((X < 2) And (Y < 3)) Or ((X < 3) And (Y < 2)))
                            {
                                If (SourcePiece == BlackPawn)
                                {
                                    If (((IdxToRank[TargetIdx] - Rank) == 1) And (X < 2))
                                    {
                                        IsLegalMove = 1;
                                    }
                                    Else
                                    {
                                        If ((Rank == 2) And ((TargetIdx - SourceIdx) == 16))
                                        {
                                            IsLegalMove = 1;
                                        }
                                    }
                                }
                                Else
                                {
                                    If (SourcePiece == WhitePawn)
                                    {
                                        If (((IdxToRank[TargetIdx] - Rank) == -1) And (X < 2))
                                        {
                                            IsLegalMove = 1;
                                        }
                                        Else
                                        {
                                            If ((Rank == 7) And ((TargetIdx - SourceIdx) == -16))
                                            {
                                                IsLegalMove = 1;
                                            }
                                        }
                                    }
                                    Else
                                    {
                                        If (abs(SourcePiece) == BlackKing)
                                        {
                                            If (((X == 1) And (Y < 2)) Or ((Y == 1) And (X < 2)))
                                            {
                                                IsLegalMove = 1;
                                            }
                                        }
                                        Else
                                        {
                                            If (abs(SourcePiece) == BlackKnight)
                                            {
                                                If (((X == 1) And (Y == 2)) Or ((X == 2) And (Y == 1)))
                                                {
                                                    IsLegalMove = 1;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        Else
                        {
                            If ((X == 0) Or (Y == 0))
                            {
                                If (IsSlidingPiece > 1)
                                {
                                    IsLegalMove = 1;
                                }
                            }
                            Else
                            {
                                If (X == Y)
                                {
                                    If (Not ((IsSlidingPiece == 2)))
                                    {
                                        IsLegalMove = 1;
                                    }
                                }
                            }
                        }
                    }
                    If ((IsLegalMove == 1) Or ((SourceIdx == 0) Or (TargetIdx == 0)))
                    {
                        Call GetPiecePosScore(SourcePiece)(TargetIdx);
                        Call GetPiecePosHash(SourcePiece)(TargetIdx);
                        If (SourcePiece > 0)
                        {
                            IdxOuter2 = ((PieceIdxLookup[SourcePiece] * 10000) + ((SourceIdx * 100) + TargetIdx));
                            List.ReplaceItem(MovePosLookupBlack, IdxOuter2, (PosScoreRes - PosScoreRes2));
                            List.ReplaceItem(MoveHashLookupBlack, IdxOuter2, (PiecePosHash - PiecePosHash2));
                        }
                        Else
                        {
                            IdxOuter2 = ((PieceIdxLookup[(0 - SourcePiece)] * 10000) + ((SourceIdx * 100) + TargetIdx));
                            List.ReplaceItem(MovePosLookupWhite, IdxOuter2, (PosScoreRes - PosScoreRes2));
                            List.ReplaceItem(MoveHashLookupWhite, IdxOuter2, (PiecePosHash - PiecePosHash2));
                        }
                    }
                    TargetIdx += 1;
                }
                SourceIdx += 1;
            }
            IdxOuter += 1;
        }
    }
}

Define InitOpeningBook (warp=true)
{
    List.DeleteItem(OpeningMoves, all);
    List.Add(OpeningMoves, 533711276346122052362736463607225843021962531321);
    List.Add(OpeningMoves, 533711276346122052362736514336435843072262351321);
    List.Add(OpeningMoves, 533711276346132152362736463602195843091754462129);
    List.Add(OpeningMoves, 5337112763461220622603124933021900921321);
    List.Add(OpeningMoves, 5337112763460219523627364636072258431220);
    List.Add(OpeningMoves, 5337112763460219622613210092071362610917266212285244152337282128);
    List.Add(OpeningMoves, 5337112751430722372922285236273643361220);
    List.Add(OpeningMoves, 5337112758430219554715236255061552441220);
    List.Add(OpeningMoves, 5337112758430219634612206226031200920722);
    List.Add(OpeningMoves, 5337112762351321634609170092102635530310);
    List.Add(OpeningMoves, 533711276235132158430917493306136346041100920219523627364636072236191019);
    List.Add(OpeningMoves, 533711275236273660360219364407225843132163460411);
    List.Add(OpeningMoves, 5337111952361228372903305843132155393023635319275640163253380219);
    List.Add(OpeningMoves, 533711195236122858432837433703303747302363460212);
    List.Add(OpeningMoves, 5337111952361228372919273627132159450212);
    List.Add(OpeningMoves, 533713296032021962351523324607226353061552440090);
    List.Add(OpeningMoves, 533713296046072262350219635312205648032135211421);
    List.Add(OpeningMoves, 533713296235072252440219634606275843122059311624);
    List.Add(OpeningMoves, 5337132962350219524407225931061363460090009216243140153140472232);
    List.Add(OpeningMoves, 533713295843072254381228382922376346061360533743);
    List.Add(OpeningMoves, 5337132958430722623522376032372035420219);
    List.Add(OpeningMoves, 533713296346021962260917263307220092061362610090);
    List.Add(OpeningMoves, 533713296346021962260917263307226053102633420613);
    List.Add(OpeningMoves, 533713296346021962260917263307225236293600920613);
    List.Add(OpeningMoves, 533713296346021962260917263307225843061300921026);
    List.Add(OpeningMoves, 5337132963460219622609172619121946290436);
    List.Add(OpeningMoves, 53371329634602196226091726191219009203395648393255393223);
    List.Add(OpeningMoves, 533713296346021962260917261912195843142252362936);
    List.Add(OpeningMoves, 533713296346021962260917261912195236293660360436);
    List.Add(OpeningMoves, 5337132963460219523629364636062759450422);
    List.Add(OpeningMoves, 53371329634602195236293662350627514336445034271849330917);
    List.Add(OpeningMoves, 533713296346021962350722463112283728102635260428);
    List.Add(OpeningMoves, 53371329634602196235072246311228372819253526111928191019);
    List.Add(OpeningMoves, 5337132963460219584307226226063400920090);
    If (1 == 0)
    {
        List.Add(OpeningMoves, 53371329634602195843072252362936463622374337041354461430);
        List.Add(OpeningMoves, 53371329634602195843072246291929523629193628192954382923372922072820112029200422);
    }
    List.Add(OpeningMoves, 533713295438293863461531623531394629044061620219);
    List.Add(OpeningMoves, 53371329543829386346153162353139009239466046062763640440523627365938142258431220);
    List.Add(OpeningMoves, 5337132954382938634615315640313946290722523612202944223759380615);
    List.Add(OpeningMoves, 5337132954382938623504406162062752362718634640325938122058430339);
    List.Add(OpeningMoves, 53371329543829386346061362350722584300900092021952360917);
    List.Add(OpeningMoves, 5337132954382938623507225843111937291228292228352215061560530321);
    List.Add(OpeningMoves, 5337132954382938523604406153122063460339593839465346072262440219);
    List.Add(OpeningMoves, 533713295438293862351228352807225843063463463443524311192842);
    List.Add(OpeningMoves, 5337132954380627634612206235072238292029462904363514050629443637);
    List.Add(OpeningMoves, 53371329543802196346122062350339009219363829364655463948);
    List.Add(OpeningMoves, 533702195236122837280428634603396253009151352832);
    List.Add(OpeningMoves, 53370219634613296226091726331026334207220092223762613727);
    List.Add(OpeningMoves, 5337072237292228523612206346033962531119);
    List.Add(OpeningMoves, 533715235236061562351220634607226053009000920339);
    List.Add(OpeningMoves, 5337152352360615634612206235072260530090009203393729202936292228);
    List.Add(OpeningMoves, 53371523523606155843072263460090372922055938122056480212);
    List.Add(OpeningMoves, 533713215236122837291127514302195438273643360418);
    List.Add(OpeningMoves, 53371321523612283729112751430219634604186253273643360713);
    List.Add(OpeningMoves, 533713215236122858430634604428374437072237400428);
    List.Add(OpeningMoves, 53371321523612285843063437291127494134435043071360390090);
    List.Add(OpeningMoves, 53371321523612285843063437282128595207224941342043262013);
    List.Add(OpeningMoves, 53371321634612283728212852360722584311196244062059310090);
    List.Add(OpeningMoves, 5337122052360722584302126346132955392239646339226235162459451119);
    List.Add(OpeningMoves, 5337122052360722584302126346132962351624009211194933041160530613);
    List.Add(OpeningMoves, 5337122052360722584302126346132962530613009200906261111949330925);
    List.Add(OpeningMoves, 5337122052360722584315235945061554460090605213293628111900931928);
    List.Add(OpeningMoves, 533712205236072258431523623506156346021956480090594522373514061443372028);
    List.Add(OpeningMoves, 5337122837280428584328255236111963460722);
    List.Add(OpeningMoves, 52361228634607225931223731401127362702195852372751431523);
    List.Add(OpeningMoves, 5236122863460722534511275135273645361523584306156253009000920219);
    List.Add(OpeningMoves, 5236122863460219584313215337072237292212593106135640121860521624);
    List.Add(OpeningMoves, 52361228634602195938033953451321513506345843071356483932);
    List.Add(OpeningMoves, 523612286346072251351119584313215931061353450090);
    List.Add(OpeningMoves, 52361228634613215843072253450219624409170092063449413420);
    List.Add(OpeningMoves, 52361228634613215843072259310613312213225337283743370090);
    List.Add(OpeningMoves, 523612285135132158430722534509176244283544350634);
    List.Add(OpeningMoves, 5236122851351321584307225931021253450634);
    List.Add(OpeningMoves, 52361228534507226244132163461127514302195852061300920090);
    List.Add(OpeningMoves, 52361228513511195843072263461321593106135345009062440212);
    List.Add(OpeningMoves, 52361228513511196346072258431321593106135345009062440212);
    List.Add(OpeningMoves, 52361228593807225345132163460620462902125852009051431127);
    List.Add(OpeningMoves, 52360722513515235843061563460090533712206253132936280925);
    List.Add(OpeningMoves, 523607225135152363460615554700905843122835282228);
    List.Add(OpeningMoves, 52360722513515236346061558430090533712206253132900920219);
    List.Add(OpeningMoves, 52360722513513215843063453450090624412286346112700920219);
    List.Add(OpeningMoves, 5236072251351220634603395345021256483932584313295539322362551119);
    List.Add(OpeningMoves, 523607225135152358430615533712206346009062531329);
    List.Add(OpeningMoves, 52360722634613215135101858430310534506346253009060510219);
    List.Add(OpeningMoves, 523607226346122851351321584311195345021260510620);
    List.Add(OpeningMoves, 523607225135132163461228584306346033021953450090);
    List.Add(OpeningMoves, 52360722513513216346101855470310625506130092009058432237);
    List.Add(OpeningMoves, 523614305135072258431321534506346253009063462237);
    List.Add(OpeningMoves, 52361430554707226255152363460615009200905135122058430405);
    List.Add(OpeningMoves, 5236143063460722554713215135122862551119009206205042041359500090);
    List.Add(OpeningMoves, 52361321513507226346101855470310625506130092009058432237);
    List.Add(OpeningMoves, 52361321513507225843063460510090634610185931031000933443);
    List.Add(OpeningMoves, 52361321513512285843072263461119534502126051062062440090);
    If (1 == 0)
    {
        List.Add(OpeningMoves, 5236132936290219634604135938133438523450584306345758504158424125);
        List.Add(OpeningMoves, 523613293629021963460413593813343852345058431934463606275758504158424125);
    }
    List.Add(OpeningMoves, 4941132953451228513507225034032135271119);
    List.Add(OpeningMoves, 4933132953370722524412283728222855470620);
    List.Add(OpeningMoves, 493313293325122856401127403202195733072233400425);
    List.Add(OpeningMoves, 504213295950021951350722534512283528222849410620);
    List.Add(OpeningMoves, 503413295950122051350722584306135345009063460339);
    List.Add(OpeningMoves, 584312285337283643531329);
    List.Add(OpeningMoves, 514313295337072252440219604612205648032162530412);
    List.Add(OpeningMoves, 513513295843072255471228352822286255284350431119);
    List.Add(OpeningMoves, 51351329634602195843072255470627625500900092122052440330);
    List.Add(OpeningMoves, 5135132955471228352807226255222852441119);
    List.Add(OpeningMoves, 5135132953370722584306275244122062530219);
    List.Add(OpeningMoves, 513511275843021955471523625506156346072200920090523627364636193660361220);
    List.Add(OpeningMoves, 524412285547132962550722);
    List.Add(OpeningMoves, 53451329523629364536122863460722);
    List.Add(OpeningMoves, 54461329533706275843122043280219);
    List.Add(OpeningMoves, 54461329533707225244062755391624);
    If (1 == 0)
    {
        List.Add(OpeningMoves, 54381321634612285345112750420219);
        List.Add(OpeningMoves, 543812286346152355470615625507220092009052441127);
    }
    List.Add(OpeningMoves, 55391329625512285135283560331119);
    List.Add(OpeningMoves, 554712286255132951352836524411275438062038292029);
    List.Add(OpeningMoves, 56481329533707225244122859312837312204224437062763462218);
    List.Add(OpeningMoves, 56481329494112285345072250341127342609174133031259500620);
    List.Add(OpeningMoves, 564013295337072252440627625312205143021249330925);
    List.Add(OpeningMoves, 5640072251351127584302195345132152360917);
    List.Add(OpeningMoves, 56400722634602194032122852361321);
    List.Add(OpeningMoves, 6346072251351523554706156255009000921220);
    List.Add(OpeningMoves, 6346072251351321523612285843061359380090);
    List.Add(OpeningMoves, 634612285236072251351321584306135931009053451624);
    List.Add(OpeningMoves, 634612285843132152360722593106135345009062441624);
    List.Add(OpeningMoves, 6346122846631329634629374663072258432836435802195244374451440620);
    If (IsPlayerBlack == 1)
    {
        Idx = 1;
        Repeat (List.Length(OpeningMoves))
        {
            CurrentValue = OpeningMoves[Idx];
            CurrentValue2 = "";
            IdxSub = 1;
            Repeat ((Variable.Length(CurrentValue) / 4))
            {
                CurrentMoveOuter = Operator.Join(Operator.Join(Operator.LetterOf(CurrentValue, IdxSub), Operator.LetterOf(CurrentValue, (IdxSub + 1))), Operator.Join(Operator.LetterOf(CurrentValue, (IdxSub + 2)), Operator.LetterOf(CurrentValue, (IdxSub + 3))));
                Call GetVirtualMove(CurrentMoveOuter);
                CurrentValue2 = Operator.Join(CurrentValue2, VirtualMove);
                IdxSub += 4;
            }
            If ((Operator.Join(Operator.LetterOf(CurrentValue2, 1), Operator.LetterOf(CurrentValue2, 2)) == 9) Or (Operator.Join(Operator.LetterOf(CurrentValue2, 1), Operator.LetterOf(CurrentValue2, 2)) == 16))
            {
                List.ReplaceItem(OpeningMoves, Idx, "");
            }
            Else
            {
                List.ReplaceItem(OpeningMoves, Idx, CurrentValue2);
            }
            Idx += 1;
        }
    }
}

Define InitOpeningMovesMap (warp=true)
{
    List.DeleteAll(OpeningMovesMapHash);
    List.DeleteAll(OpeningMovesMapMove);
    List.DeleteAll(OpeningMovesMapStack);
    Repeat (List.Length(OpeningMoves))
    {
        List.Add(OpeningMovesMapStack, 1);
    }
    Call CreateCurrentBoardHash;
    Call InitOpeningMovesMapImpl((1 + IsPlayerBlack))(0)("")((1 == 1));
}

Define InitOpeningMovesMapImpl(string Depth)(string GameMovesLen)(string Move)(bool Init) (warp=true)
{
    List.DeleteAll(OpeningMovesRes);
    Idx = 1;
    Repeat (List.Length(OpeningMovesMapStack))
    {
        IsEqual = 0;
        CurrentValue = OpeningMoves[Idx];
        If ((OpeningMovesMapStack[Idx] % 2) == 1)
        {
            IsEqual = 1;
            IdxString = 1;
            If (Not (Init))
            {
                Repeat Until ((IsEqual == 0) Or (IdxString > 4))
                {
                    If (Not ((Operator.LetterOf(Move, IdxString) == Operator.LetterOf(CurrentValue, (GameMovesLen + IdxString)))))
                    {
                        IsEqual = 0;
                    }
                    IdxString += 1;
                }
            }
        }
        If (IsEqual == 1)
        {
            CurrentMoveOuter = Operator.Join(Operator.Join(Operator.LetterOf(CurrentValue, (GameMovesLen + IdxString)), Operator.LetterOf(CurrentValue, ((GameMovesLen + IdxString) + 1))), Operator.Join(Operator.LetterOf(CurrentValue, ((GameMovesLen + IdxString) + 2)), Operator.LetterOf(CurrentValue, ((GameMovesLen + IdxString) + 3))));
            If (Not ((CurrentMoveOuter == "")))
            {
                List.Add(OpeningMovesRes, CurrentMoveOuter);
            }
            List.ReplaceItem(OpeningMovesMapStack, Idx, ((OpeningMovesMapStack[Idx] * 2) + 1));
        }
        Else
        {
            List.ReplaceItem(OpeningMovesMapStack, Idx, ((OpeningMovesMapStack[Idx] * 2) + 0));
        }
        Idx += 1;
    }
    If (List.Length(OpeningMovesRes) > 0)
    {
        List.DeleteAll(TmpList1);
        Call ClearMoveList(Depth);
        IdxOuter = 1;
        Repeat (List.Length(OpeningMovesRes))
        {
            CurrentMoveOuter = OpeningMovesRes[IdxOuter];
            List.Add(OpeningMovesMapHash, CurrentBoardHash);
            List.Add(OpeningMovesMapMove, CurrentMoveOuter);
            If (Not (List.ContainsItem(TmpList1, CurrentMoveOuter)))
            {
                Call AddMoveToList(CurrentMoveOuter)(Depth);
                List.Add(TmpList1, CurrentMoveOuter);
            }
            IdxOuter += 1;
        }
        List.ReplaceItem(MovesIdx, Depth, 1);
        Repeat (MovesCount[Depth])
        {
            Call ApplyMoveLight(Depth);
            Call GetCurrentMove(Depth);
            If Init
            {
                Call InitOpeningMovesMapImpl((Depth + 1))(0)(AppliedMove[Depth])((1 == 0));
            }
            Else
            {
                Call InitOpeningMovesMapImpl((Depth + 1))((GameMovesLen + 4))(AppliedMove[Depth])((1 == 0));
            }
            Call RevertMoveLight(Depth);
            List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
        }
    }
    Idx = 1;
    Repeat (List.Length(OpeningMovesMapStack))
    {
        List.ReplaceItem(OpeningMovesMapStack, Idx, floor((OpeningMovesMapStack[Idx] / 2)));
        Idx += 1;
    }
}

Define InitPieceSquareTables (warp=true)
{
    List.DeleteItem(PawnPieceSquarePreCastling, all);
    Call LoadList("0, 0, 0, 0, 0, 0, 0, 0,  7, 11, 23, 39, 39, 23, 11, 7, -7, 1, 14, 29, 29, 14, 1, -7, -21, -8, 6, 26, 26, 6, -8, -21, -21, -16, -1, 22, 22, -1, -16, -21, -21, -16, -6, 12, 12, -6, -16, -21, -14, -8, 6, -1, -1, 6, -8, -14, 0, 0, 0, 0, 0, 0, 0, 0")("PawnPieceSquarePreCastling");
    List.DeleteItem(PawnPieceSquare, all);
    Call LoadList("0, 0, 0, 0, 0, 0, 0, 0,     7, 11, 23, 39, 39, 23, 11, 7,     -5, 1, 14, 29, 29, 14, 1, -5,     -10, -12, -4, 26, 26, -4, -12, -16,     -16, -12, -4, 22, 22, -4, -12, -16,     -12, -8, 0, 12, 12, 0, -8, -12,     -8, -4, 4, -1, -1, 4, -4, -8,     0, 0, 0, 0, 0, 0, 0, 0")("PawnPieceSquare");
    List.DeleteItem(PawnPieceSquareEndgame, all);
    Call LoadList("0, 0, 0, 0, 0, 0, 0, 0,  45, 30, 16, 5, 5, 16, 30, 45,  30, 14, 1, -10, -10, 1, 14, 30,  18, 2, -8, -15, -15, -8, 2, 18,  10, -5, -15, -20, -20, -15, -5, 10,  5, -10, -20, -25, -25, -20, -10, 5,  5, -10, -20, -25, -25, -20, -10, 5,  0, 0, 0, 0, 0, 0, 0, 0")("PawnPieceSquareEndgame");
    List.DeleteItem(KnightPieceSquare, all);
    Call LoadList("-59, -39, -29, -29, -29, -29, -39, -59, -39, 21, 41, 41, 41, 41, 21, -39, -39, 46, 61, 71, 71, 61, 46, -39,  -39, 41, 51, 51, 51, 51, 41, -39,  -39, 11, 41, 36, 36, 41, 11, -39,  -39, 1, 31, 21, 21, 31, 1, -39,  -54, -39, -9, 11, 11, -9, -39, -54,  -69, -19, -24, -14, -14, -24, -19, -69")("KnightPieceSquare");
    List.DeleteItem(KnightPieceSquareEndgame, all);
    Call LoadList("-63, -53, -43, -43, -43, -43, -53, -63,  -53, -43, 38, 48, 48, 38, -43, -53,  -43, 28, 78, 73, 73, 78, 28, -43,  -43, 38, 73, 78, 78, 73, 38, -43,  -43, 38, 58, 68, 68, 58, 38, -43,  -43, 18, 48, 38, 38, 48, 18, -43,  -53, -43, 18, 28, 28, 18, -43, -53,  -63, -53, -43, -43, -43, -43, -53, -63")("KnightPieceSquareEndgame");
    List.DeleteItem(BishopPieceSquare, all);
    Call LoadList("-20, -18, -16, -14, -14, -16, -18, -20,  -10, 11, 1, 1, 1, 1, 11, -10,   1, 11, 21, 26, 26, 21, 11, 1,   1, 21, 21, 26, 26, 21, 21, 1,   1, 1, 16, 21, 21, 16, 1, 1,   -25, 6, 16, 11, 11, 16, 6, -25,   -28, 11, 6, 1, 1, 6, 11, -28,   -30, -25, -20, -20, -20, -20, -25, -30")("BishopPieceSquare");
    List.DeleteItem(BishopPieceSquareEndgame, all);
    Call LoadList("-38, -18, -8, 2, 2, -8, -18, -38,  -18, -8, 0, 12, 12, 0, -8, -18,  -8, 2, 20, 22, 22, 20, 2, -8,  2, 12, 17, 22, 22, 17, 12, 2,  2, 12, 16, 20, 20, 16, 12, 2,  -8, 2, 10, 12, 12, 10, 2, -8,  -18, -8, 2, 7, 7, 2, -8, -18,  -38, -18, -8, 2, 2, -8, -18, -38")("BishopPieceSquareEndgame");
    List.DeleteItem(RookPieceSquare, all);
    Call LoadList("-8, -6, 2, 7, 7, 2, -6, -8,  2, 2, 7, 12, 12, 7, 2, 2,  -8, -6, 6, 10, 10, 6, -6, -8,  -8, -6, 6, 8, 8, 6, -6, -8,  -8, -6, 6, 7, 7, 6, -6, -8,  -8, -6, 6, 7, 7, 6, -6, -8,  -8, -6, 2, 7, 7, 2, -6, -8,  -8, -6, 2, 7, 7, 2, -6, -8")("RookPieceSquare");
    List.DeleteItem(RookPieceSquareEndgame, all);
    Call LoadList("0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0")("RookPieceSquareEndgame");
    List.DeleteItem(QueenPieceSquare, all);
    Call LoadList("4, 4, 4, 4, 4, 4, 4, 4,  4, 4, 4, 4, 4, 4, 4, 4,  4, 4, 4, 4, 4, 4, 4, 4,  4, 4, 4, 4, 4, 4, 4, 4,  4, 4, 4, 4, 4, 4, 4, 4,  -6, -6, -1, 4, 4, -1, -6, -6,  -16, -11, -1, 4, 4, -1, -11, -16,  -26, -16, -6, 4, 4, -6, -16, -26")("QueenPieceSquare");
    List.DeleteItem(QueenPieceSquareEndgame, all);
    Call LoadList("-26, -6, -1, 4, 4, -1, -6, -26,  -16, 4, 19, 29, 29, 19, 4, -16,  -6, 9, 24, 34, 34, 24, 9, -6,  -6, 9, 24, 34, 34, 24, 9, -6,  -6, 9, 24, 34, 34, 24, 9, -6,  -16, -1, 14, 24, 24, 14, -1, -16,  -31, -26, -16, -6, -6, -16, -26, -31,  -46, -41, -31, -26, -26, -31, -41, -46")("QueenPieceSquareEndgame");
    List.DeleteItem(KingPieceSquare, all);
    Call LoadList("-55, -55, -60, -70, -70, -60, -55, -55,  -55, -55, -60, -70, -70, -60, -55, -55,  -55, -55, -60, -70, -70, -60, -55, -55,  -55, -55, -60, -70, -70, -60, -55, -55,  -50, -50, -55, -60, -60, -55, -50, -50,  -40, -40, -45, -50, -50, -45, -40, -40,  -30, -30, -30, -35, -35, -30, -30, -30,  -20, 0, 0, -10, -10, 0, 0, -20")("KingPieceSquare");
    List.DeleteItem(KingPieceSquareEndgame, all);
    Call LoadList("-10, 10, 15, 20, 20, 15, 10, -10,  0, 20, 35, 45, 45, 35, 20, 0,  10, 25, 40, 50, 50, 40, 25, 10,  10, 25, 40, 50, 50, 40, 25, 10,  10, 25, 40, 50, 50, 40, 25, 10,  0, 15, 30, 40, 40, 30, 15, 0,  -15, -10, 0, 10, 10, 0, -10, -15,  -30, -25, -15, -10, -10, -15, -25, -30")("KingPieceSquareEndgame");
}

Define IsBlackKingCheckMate (warp=true)
{
    IsBlackKingCheckMateRes = 0;
    Call CalcBoardAttackedByMove(2);
    If (IsBlackChecked == 1)
    {
        IsBlackKingCheckMateRes = 1;
        Call GenerateMovesPublic(1);
        List.ReplaceItem(MovesIdx, 1, 1);
        Repeat (MovesCount[1])
        {
            If (IsBlackKingCheckMateRes == 1)
            {
                Call ApplyMove(1);
                Call CalcBoardAttackedByMove(2);
                If (IsBlackChecked == 0)
                {
                    IsBlackKingCheckMateRes = 0;
                }
                Call RevertMove(1);
            }
            List.ReplaceItem(MovesIdx, 1, (MovesIdx[1] + 1));
        }
    }
}

Define IsCheckingPiece(string Idx) (warp=true)
{
    Call IsCheckingPieceImpl(Idx)(Board[Idx]);
}

Define IsCheckingPieceDiscovery(string SourceIdx)(string TargetIdx)(string Depth) (warp=true)
{
    IsCheckingPieceRes = 0;
    If ((Depth % 2) == 1)
    {
        If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], SourceIdx) > 0)
        {
            SourceIdx = Operator.Join(Operator.LetterOf(BoardAttackedByBlackPieceSnapshot[Depth], ((SourceIdx * 2) - 1)), Operator.LetterOf(BoardAttackedByBlackPieceSnapshot[Depth], (SourceIdx * 2)));
            If (Board[SourceIdx] > BlackKnight)
            {
                Call IsCheckingPiece(SourceIdx);
            }
        }
    }
    Else
    {
        If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], SourceIdx) > 0)
        {
            SourceIdx = Operator.Join(Operator.LetterOf(BoardAttackedByWhitePieceSnapshot[Depth], ((SourceIdx * 2) - 1)), Operator.LetterOf(BoardAttackedByWhitePieceSnapshot[Depth], (SourceIdx * 2)));
            If (Board[SourceIdx] < WhiteKnight)
            {
                Call IsCheckingPiece(SourceIdx);
            }
        }
    }
}

Define IsCheckingPieceImpl(string Idx)(string Piece) (warp=true)
{
    IsCheckingPieceRes = 0;
    CurrentPiece = Piece;
    If (abs(CurrentPiece) == BlackKing)
    {
        Stop(this script);
    }
    If (CurrentPiece > 0)
    {
        If (MovePosLookupBlack[((PieceIdxLookup[CurrentPiece] * 10000) + ((Idx * 100) + WhiteKingIdx))] == "")
        {
            Stop(this script);
        }
        If (CurrentPiece == BlackPawn)
        {
            If (IdxToFile[Idx] == IdxToFile[WhiteKingIdx])
            {
                Stop(this script);
            }
            IsCheckingPieceRes = 1;
            Stop(this script);
        }
        If (CurrentPiece == BlackKnight)
        {
            IsCheckingPieceRes = 1;
            Stop(this script);
        }
        CurrentMove = MoveNotationLookup[((Idx * 100) + WhiteKingIdx)];
    }
    Else
    {
        If (CurrentPiece < 0)
        {
            If (MovePosLookupWhite[((PieceIdxLookup[(0 - CurrentPiece)] * 10000) + ((Idx * 100) + BlackKingIdx))] == "")
            {
                Stop(this script);
            }
            If (CurrentPiece == WhitePawn)
            {
                If (IdxToFile[Idx] == IdxToFile[BlackKingIdx])
                {
                    Stop(this script);
                }
                IsCheckingPieceRes = 1;
                Stop(this script);
            }
            If (CurrentPiece == WhiteKnight)
            {
                IsCheckingPieceRes = 1;
                Stop(this script);
            }
            CurrentMove = MoveNotationLookup[((Idx * 100) + BlackKingIdx)];
        }
    }
    SourceIdx = Idx;
    IdxInc = MovePathStepInc[CurrentMove];
    Repeat ((MovePathDelta[CurrentMove] - 1))
    {
        SourceIdx += IdxInc;
        If (Not ((Board[SourceIdx] == 0)))
        {
            Stop(this script);
        }
    }
    IsCheckingPieceRes = 1;
}

Define IsDrawByMaterial (warp=true)
{
    IsDrawRes = 0;
    CurrentValue = 0;
    CurrentValue2 = 0;
    Idx = 1;
    Repeat (64)
    {
        CurrentPiece = Board[Idx];
        If (Not ((CurrentPiece == 0)))
        {
            If ((CurrentPiece == BlackBishop) Or (CurrentPiece == BlackKnight))
            {
                CurrentValue += 1;
            }
            Else
            {
                If ((CurrentPiece == WhiteBishop) Or (CurrentPiece == WhiteKnight))
                {
                    CurrentValue2 += 1;
                }
                Else
                {
                    If (Not ((abs(CurrentPiece) == BlackKing)))
                    {
                        Stop(this script);
                    }
                }
            }
        }
        Idx += 1;
    }
    If ((CurrentValue + CurrentValue2) < 2)
    {
        IsDrawRes = 1;
    }
}

Define IsDrawByStalemate(string Depth) (warp=true)
{
    Call CalcBoardAttackedByMoveChecked((Depth + 1));
    If ((((Depth % 2) == 1) And (IsBlackChecked == 1)) Or (((Depth % 2) == 0) And (IsWhiteChecked == 1)))
    {
        IsDrawRes = 0;
        Stop(this script);
    }
    IsDrawRes = 1;
    List.ReplaceItem(Quiescence, Depth, 0);
    Call CalcBoardAttackedByMove((Depth + 1));
    Call StoreAttackInfo((Depth + 1))(Depth);
    List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
    Call GenerateMovesImplWrapper(Depth)((1 == 0))((1 == 0));
    List.ReplaceItem(BoardAttackedCalculated, Depth, 0);
    If (Quiescence[Depth] == 0)
    {
        MoveCount += MovesCount[Depth];
    }
    Else
    {
        MoveCountQ += MovesCount[Depth];
    }
    List.ReplaceItem(MovesIdx, Depth, 1);
    Repeat (MovesCount[Depth])
    {
        If (IsDrawRes == 1)
        {
            Call ApplyMoveLight(Depth);
            Call CalcBoardAttackedByMoveChecked((Depth + 1));
            If ((((Depth % 2) == 1) And (IsBlackChecked == 0)) Or (((Depth % 2) == 0) And (IsWhiteChecked == 0)))
            {
                IsDrawRes = 0;
                Call RevertMoveLight(Depth);
                Stop(this script);
            }
            Call RevertMoveLight(Depth);
        }
        List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
    }
}

Define IsEngineValidMove(string Move) (warp=true)
{
    Call GenerateMovesPublic(1);
    If List.ContainsItem(Moves1, Move)
    {
        ValidMoveRes = 1;
    }
    Else
    {
        ValidMoveRes = 0;
    }
}

Define IsLowerCase(string Char) (warp=true)
{
    Chars = "";
    CharsIdx = 1;
    Repeat (Variable.Length(CharsUpperCase))
    {
        If (Operator.LetterOf(CharsUpperCase, CharsIdx) == Char)
        {
            Chars = Operator.Join(Chars, Char);
        }
        Else
        {
            Chars = Operator.Join(Chars, Operator.LetterOf(CharsUpperCase, CharsIdx));
        }
        CharsIdx += 1;
    }
    Looks.SwitchCostumeTo(_ABCDEFGHIJKLMNOPQRSTUVWXYZ);
    Looks.SwitchCostumeTo(Chars);
    If (Costume.GetNumberName(number) == 1)
    {
        IsLowerCaseRes = 0;
    }
    Else
    {
        IsLowerCaseRes = 1;
    }
}

Define IsPlyExtension(string Depth) (warp=true)
{
    IsPlyExtensionRes = 0;
    If ((Depth > 3) And (PlyExtension[(Depth - 1)] == 1))
    {
        Stop(this script);
    }
    If ((IsScratch3 == 1) And (IsEndgame == 0))
    {
        If (Depth < 5)
        {
            Idx = 1;
            Repeat (Depth)
            {
                If (PlyExtensionTagged[Idx] == 1)
                {
                    IsPlyExtensionRes = 1;
                    Stop(this script);
                }
                Idx += 1;
            }
        }
    }
    If (IsScratch3 == 0)
    {
        If (PutsInCheck[Depth] == 1)
        {
            TargetIdx = floor((AppliedMove[Depth] % 100));
            If ((Depth % 2) == 1)
            {
                If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], TargetIdx) > Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], TargetIdx))
                {
                    IsPlyExtensionRes = 1;
                }
            }
            Else
            {
                If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], TargetIdx) > Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], TargetIdx))
                {
                    IsPlyExtensionRes = 1;
                }
            }
        }
        If (IsEndgame == 1)
        {
            If ((PickPhase[Depth] == 6) And ((MovesCount[Depth] == 1) And (MovesIdx[Depth] == 1)))
            {
                IsPlyExtensionRes = 1;
            }
            If (abs(SourcePieces[Depth]) == BlackPawn)
            {
                Rank = IdxToRank[floor((AppliedMove[Depth] % 100))];
                If ((Rank == 2) Or (Rank == 7))
                {
                    IsPlyExtensionRes = 1;
                }
            }
            If (Depth > 1)
            {
                If ((Not ((TargetPieces[Depth] == 0))) And (Not ((TargetPieces[(Depth - 1)] == 0))))
                {
                    If (floor((AppliedMove[Depth] % 100)) == floor((AppliedMove[(Depth - 1)] % 100)))
                    {
                        IsPlyExtensionRes = 1;
                    }
                }
            }
        }
    }
}

Define IsQuiescentCheckCond(string Depth) (warp=true)
{
    Call //("Quiescence search extension for checking moves, esp. check sequences. Return value defined whether check sequences should pursued at this point");
    If (IsScratch3 == 1)
    {
        IsQuiescentCheckRes = 0;
        Stop(this script);
    }
    IsQuiescentCheckRes = 1;
    If ((Depth < 6) And ((Quiescence[2] == 1) And (CheckedState[(Depth - 1)] == 1)))
    {
        Stop(this script);
    }
    If (Quiescence[(Depth - 1)] == 0)
    {
        If (IsScratch3 == 0)
        {
            Stop(this script);
        }
    }
    Else
    {
        If (Quiescence[(Depth - 2)] == 0)
        {
            If (((IsScratch3 == 0) And (IsEndgame2 == 1)) And (CheckedState[(Depth - 1)] == 1))
            {
                Stop(this script);
            }
        }
        Else
        {
            If (Quiescence[(Depth - 3)] == 0)
            {
                If (((IsScratch3 == 0) And (IsEndgame2 == 1)) And (CheckedState[(Depth - 1)] == 1))
                {
                    Stop(this script);
                }
            }
            Else
            {
                If (1 == 0)
                {
                    If (Quiescence[(Depth - 4)] == 0)
                    {
                        If (((IsScratch3 == 0) And (IsEndgame2 == 1)) And (CheckedState[(Depth - 1)] == 1))
                        {
                            Stop(this script);
                        }
                    }
                    Else
                    {
                        If (Quiescence[(Depth - 5)] == 0)
                        {
                            If (((IsScratch3 == 0) And (IsEndgame2 == 1)) And (CheckedState[(Depth - 1)] == 1))
                            {
                                Stop(this script);
                            }
                        }
                    }
                }
            }
        }
    }
    IsQuiescentCheckRes = 0;
}

Define IsReachable(string SourceIdx)(string TargetIdx) (warp=true)
{
    IsReachableRes = 0;
    SourcePiece = Board[SourceIdx];
    If (SourcePiece == 0)
    {
        Stop(this script);
    }
    If (SourcePiece > 0)
    {
        If (MovePosLookupBlack[((PieceIdxLookup[SourcePiece] * 10000) + ((SourceIdx * 100) + TargetIdx))] == "")
        {
            Stop(this script);
        }
    }
    Else
    {
        If (MovePosLookupWhite[((PieceIdxLookup[(0 - SourcePiece)] * 10000) + ((SourceIdx * 100) + TargetIdx))] == "")
        {
            Stop(this script);
        }
    }
    If (abs(SourcePiece) == BlackPawn)
    {
        If (IdxToFile[SourceIdx] == IdxToFile[TargetIdx])
        {
            If (Board[TargetIdx] == 0)
            {
                IsReachableRes = 1;
            }
        }
        Else
        {
            If (Board[TargetIdx] < 0)
            {
                IsReachableRes = 1;
            }
        }
    }
    If ((abs(SourcePiece) == BlackKnight) Or (abs(SourcePiece) == BlackKing))
    {
        IsReachableRes = 1;
        Stop(this script);
    }
    CurrentMove = MoveNotationLookup[((SourceIdx * 100) + TargetIdx)];
    SourceIdx = SourceIdx;
    IdxInc = MovePathStepInc[CurrentMove];
    Repeat (MovePathDelta[CurrentMove])
    {
        SourceIdx += IdxInc;
        If (SourcePiece > 0)
        {
            If (Board[SourceIdx] > 0)
            {
                Stop(this script);
            }
            If (Board[SourceIdx] < 0)
            {
                If (Not ((SourceIdx == TargetIdx)))
                {
                    Stop(this script);
                }
            }
        }
        Else
        {
            If (Board[SourceIdx] < 0)
            {
                Stop(this script);
            }
            If (Board[SourceIdx] > 0)
            {
                If (Not ((SourceIdx == TargetIdx)))
                {
                    Stop(this script);
                }
            }
        }
    }
    IsReachableRes = 1;
}

Define IsWhiteKingCheckMate (warp=true)
{
    IsWhiteKingCheckMateRes = 0;
    Call CalcBoardAttackedByMove(1);
    If (IsWhiteChecked == 1)
    {
        IsWhiteKingCheckMateRes = 1;
        Call GenerateMovesPublic(2);
        List.ReplaceItem(MovesIdx, 2, 1);
        Repeat (MovesCount[2])
        {
            If (IsWhiteKingCheckMateRes == 1)
            {
                Call ApplyMove(2);
                Call CalcBoardAttackedByMove(1);
                If (IsWhiteChecked == 0)
                {
                    IsWhiteKingCheckMateRes = 0;
                }
                Call RevertMove(2);
            }
            List.ReplaceItem(MovesIdx, 2, (MovesIdx[2] + 1));
        }
    }
}

Define LoadList(string Data)(string ListName) (warp=true)
{
    IdxString = 1;
    CurrentValue = "";
    Repeat Until (IdxString > Variable.Length(Data))
    {
        If ((Not ((Operator.LetterOf(Data, IdxString) == " "))) And (Not ((Operator.LetterOf(Data, IdxString) == ","))))
        {
            CurrentValue = Operator.Join(CurrentValue, Operator.LetterOf(Data, IdxString));
        }
        If ((Operator.LetterOf(Data, IdxString) == ",") Or (IdxString == Variable.Length(Data)))
        {
            If (ListName == "PawnPieceSquare")
            {
                List.Add(PawnPieceSquare, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "PawnPieceSquareEndgame")
            {
                List.Add(PawnPieceSquareEndgame, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "PawnPieceSquarePreCastling")
            {
                List.Add(PawnPieceSquarePreCastling, Operator.Round((CurrentValue * 1)));
            }
            If (ListName == "KingPieceSquare")
            {
                List.Add(KingPieceSquare, CurrentValue);
            }
            If (ListName == "KingPieceSquareEndgame")
            {
                List.Add(KingPieceSquareEndgame, CurrentValue);
            }
            If (ListName == "QueenPieceSquare")
            {
                List.Add(QueenPieceSquare, CurrentValue);
            }
            If (ListName == "QueenPieceSquareEndgame")
            {
                List.Add(QueenPieceSquareEndgame, CurrentValue);
            }
            If (ListName == "RookPieceSquare")
            {
                List.Add(RookPieceSquare, CurrentValue);
            }
            If (ListName == "RookPieceSquareEndgame")
            {
                List.Add(RookPieceSquareEndgame, CurrentValue);
            }
            If (ListName == "BishopPieceSquare")
            {
                List.Add(BishopPieceSquare, CurrentValue);
            }
            If (ListName == "BishopPieceSquareEndgame")
            {
                List.Add(BishopPieceSquareEndgame, CurrentValue);
            }
            If (ListName == "KnightPieceSquare")
            {
                List.Add(KnightPieceSquare, Operator.Round((CurrentValue * 0.4)));
            }
            If (ListName == "KnightPieceSquareEndgame")
            {
                List.Add(KnightPieceSquareEndgame, Operator.Round((CurrentValue * 0.4)));
            }
            If (ListName == "KnightMobilityBonus")
            {
                List.Add(KnightMobilityBonus, (CurrentValue * 1));
            }
            If (ListName == "BishopMobilityBonus")
            {
                List.Add(BishopMobilityBonus, (CurrentValue * 1));
            }
            If (ListName == "RookMobilityBonus")
            {
                List.Add(RookMobilityBonus, (CurrentValue * 1));
            }
            If (ListName == "QueenMobilityBonus")
            {
                List.Add(QueenMobilityBonus, (CurrentValue * 1));
            }
            If (ListName == "PawnStorm")
            {
                List.Add(PawnStorm, Operator.Round((CurrentValue * 0.8)));
            }
            If (ListName == "PawnShelter")
            {
                List.Add(PawnShelter, Operator.Round((CurrentValue * 0.8)));
            }
            CurrentValue = "";
        }
        IdxString += 1;
    }
}

Define Log(string Txt1)(string Txt2)(string Txt3)(string Txt4)(string Txt5)(string Txt6)(string Txt7)(string Txt8) (warp=true)
{
    Tmp = (floor((((Sensing.DaysSince2000() * 86400) - ThinkTimeStart) * 1000)) / 1000);
    If Operator.Contains(Tmp, ".")
    {
        If ((Operator.LetterOf(Tmp, (Variable.Length(Tmp) - 1)) == ".") Or (Operator.LetterOf(Tmp, (Variable.Length(Tmp) - 2)) == "."))
        {
            Tmp = Operator.Join(Tmp, 0);
        }
    }
    Else
    {
        Tmp = Operator.Join(Tmp, .000);
    }
    List.Add(Logfile, Operator.Join(Operator.Join(Tmp, ": "), Operator.Join(Txt1, Operator.Join(Txt2, Operator.Join(Txt3, Operator.Join(Txt4, Operator.Join(Txt5, Operator.Join(Txt6, Operator.Join(Txt7, Txt8)))))))));
}

Define NNUE_ActDeactImpl(string Square)(string Piece)(bool Activate) (warp=true)
{
    NNUE_Side = 0;
    Repeat (2)
    {
        NNUE_Chunk = 0;
        Repeat ((NNUE_HiddenSize / 256))
        {
            NNUE_Offset = (NNUE_Chunk * 256);
            IdxSub = ((NNUE_Side * NNUE_HiddenSize) + NNUE_Offset);
            IdxSub2 = ((NNUE_InputIdxMap[(((1000 * NNUE_Side) + ((64 * Piece) + Square)) + 1)] * NNUE_HiddenSize) + NNUE_Offset);
            IdxSub += 1;
            IdxSub2 += 1;
            If Activate
            {
                If (IdxSub2 > (200000 - 256))
                {
                    If (Not ((IdxSub2 > 200000)))
                    {
                        IdxSub2 = 1;
                    }
                    Else
                    {
                        IdxSub2 += -200000;
                    }
                    Repeat (16)
                    {
                        Call NNUE_AddAccWght2_16(IdxSub)(IdxSub2);
                        IdxSub += 16;
                        IdxSub2 += 16;
                    }
                }
                Else
                {
                    Repeat (16)
                    {
                        Call NNUE_AddAccWght1_16(IdxSub)(IdxSub2);
                        IdxSub += 16;
                        IdxSub2 += 16;
                    }
                }
            }
            Else
            {
                If (IdxSub2 > (200000 - 256))
                {
                    If (Not ((IdxSub2 > 200000)))
                    {
                        IdxSub2 = 1;
                    }
                    Else
                    {
                        IdxSub2 += -200000;
                    }
                    Repeat (16)
                    {
                        Call NNUE_SubAccWght2_16(IdxSub)(IdxSub2);
                        IdxSub += 16;
                        IdxSub2 += 16;
                    }
                }
                Else
                {
                    Repeat (16)
                    {
                        Call NNUE_SubAccWght1_16(IdxSub)(IdxSub2);
                        IdxSub += 16;
                        IdxSub2 += 16;
                    }
                }
            }
            NNUE_Chunk += 1;
        }
        NNUE_Side += 1;
    }
}

Define NNUE_Activate(string GoKIdx)(string GoKPiece) (warp=true)
{
    Call NNUE_ActDeactImpl(NNUE_GoKIdxToSquare[VirtualBoard[GoKIdx]])((((6 * (GoKPiece > 0)) + PieceIdxLookup[abs(GoKPiece)]) - 1))((1 == 1));
}

Define NNUE_AddAccWght1_16(string IdxAcc)(string IdxWght) (warp=true)
{
    List.ReplaceItem(NNUE_Accumulator, IdxAcc, (NNUE_Accumulator[IdxAcc] + NNUE_InputWeights_1[IdxWght]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 1), (NNUE_Accumulator[(IdxAcc + 1)] + NNUE_InputWeights_1[(IdxWght + 1)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 2), (NNUE_Accumulator[(IdxAcc + 2)] + NNUE_InputWeights_1[(IdxWght + 2)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 3), (NNUE_Accumulator[(IdxAcc + 3)] + NNUE_InputWeights_1[(IdxWght + 3)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 4), (NNUE_Accumulator[(IdxAcc + 4)] + NNUE_InputWeights_1[(IdxWght + 4)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 5), (NNUE_Accumulator[(IdxAcc + 5)] + NNUE_InputWeights_1[(IdxWght + 5)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 6), (NNUE_Accumulator[(IdxAcc + 6)] + NNUE_InputWeights_1[(IdxWght + 6)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 7), (NNUE_Accumulator[(IdxAcc + 7)] + NNUE_InputWeights_1[(IdxWght + 7)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 8), (NNUE_Accumulator[(IdxAcc + 8)] + NNUE_InputWeights_1[(IdxWght + 8)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 9), (NNUE_Accumulator[(IdxAcc + 9)] + NNUE_InputWeights_1[(IdxWght + 9)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 10), (NNUE_Accumulator[(IdxAcc + 10)] + NNUE_InputWeights_1[(IdxWght + 10)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 11), (NNUE_Accumulator[(IdxAcc + 11)] + NNUE_InputWeights_1[(IdxWght + 11)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 12), (NNUE_Accumulator[(IdxAcc + 12)] + NNUE_InputWeights_1[(IdxWght + 12)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 13), (NNUE_Accumulator[(IdxAcc + 13)] + NNUE_InputWeights_1[(IdxWght + 13)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 14), (NNUE_Accumulator[(IdxAcc + 14)] + NNUE_InputWeights_1[(IdxWght + 14)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 15), (NNUE_Accumulator[(IdxAcc + 15)] + NNUE_InputWeights_1[(IdxWght + 15)]));
}

Define NNUE_AddAccWght2_16(string IdxAcc)(string IdxWght) (warp=true)
{
    List.ReplaceItem(NNUE_Accumulator, IdxAcc, (NNUE_Accumulator[IdxAcc] + NNUE_InputWeights_2[IdxWght]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 1), (NNUE_Accumulator[(IdxAcc + 1)] + NNUE_InputWeights_2[(IdxWght + 1)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 2), (NNUE_Accumulator[(IdxAcc + 2)] + NNUE_InputWeights_2[(IdxWght + 2)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 3), (NNUE_Accumulator[(IdxAcc + 3)] + NNUE_InputWeights_2[(IdxWght + 3)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 4), (NNUE_Accumulator[(IdxAcc + 4)] + NNUE_InputWeights_2[(IdxWght + 4)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 5), (NNUE_Accumulator[(IdxAcc + 5)] + NNUE_InputWeights_2[(IdxWght + 5)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 6), (NNUE_Accumulator[(IdxAcc + 6)] + NNUE_InputWeights_2[(IdxWght + 6)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 7), (NNUE_Accumulator[(IdxAcc + 7)] + NNUE_InputWeights_2[(IdxWght + 7)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 8), (NNUE_Accumulator[(IdxAcc + 8)] + NNUE_InputWeights_2[(IdxWght + 8)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 9), (NNUE_Accumulator[(IdxAcc + 9)] + NNUE_InputWeights_2[(IdxWght + 9)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 10), (NNUE_Accumulator[(IdxAcc + 10)] + NNUE_InputWeights_2[(IdxWght + 10)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 11), (NNUE_Accumulator[(IdxAcc + 11)] + NNUE_InputWeights_2[(IdxWght + 11)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 12), (NNUE_Accumulator[(IdxAcc + 12)] + NNUE_InputWeights_2[(IdxWght + 12)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 13), (NNUE_Accumulator[(IdxAcc + 13)] + NNUE_InputWeights_2[(IdxWght + 13)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 14), (NNUE_Accumulator[(IdxAcc + 14)] + NNUE_InputWeights_2[(IdxWght + 14)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 15), (NNUE_Accumulator[(IdxAcc + 15)] + NNUE_InputWeights_2[(IdxWght + 15)]));
}

Define NNUE_Deactivate(string GoKIdx)(string GoKPiece) (warp=true)
{
    Call NNUE_ActDeactImpl(NNUE_GoKIdxToSquare[VirtualBoard[GoKIdx]])((((6 * (GoKPiece > 0)) + PieceIdxLookup[abs(GoKPiece)]) - 1))((1 == 0));
}

Define NNUE_DecodeNetwork (warp=true)
{
    Call NNUE_HexToDec(NNUE_InputWeights_HEX);
    List.DeleteAll(NNUE_InputWeights_1);
    List.DeleteAll(NNUE_InputWeights_2);
    IdxString = 1;
    Repeat (List.Length(NNUE_ListRes_1))
    {
        List.Add(NNUE_InputWeights_1, NNUE_ListRes_1[IdxString]);
        IdxString += 1;
    }
    IdxString = 1;
    Repeat (List.Length(NNUE_ListRes_2))
    {
        List.Add(NNUE_InputWeights_2, NNUE_ListRes_2[IdxString]);
        IdxString += 1;
    }
    Call NNUE_LoadList(NNUE_HiddenBias_CSV);
    List.DeleteAll(NNUE_HiddenBias);
    IdxString = 1;
    Repeat (List.Length(NNUE_ListRes_1))
    {
        List.Add(NNUE_HiddenBias, NNUE_ListRes_1[IdxString]);
        IdxString += 1;
    }
    Call NNUE_LoadList(NNUE_HIddenWeights_CSV);
    List.DeleteAll(NNUE_HiddenWeights);
    IdxString = 1;
    Repeat (List.Length(NNUE_ListRes_1))
    {
        List.Add(NNUE_HiddenWeights, NNUE_ListRes_1[IdxString]);
        IdxString += 1;
    }
    Call NNUE_LoadList(NNUE_OutputBias_CSV);
    List.DeleteAll(NNUE_OutputBias);
    IdxString = 1;
    Repeat (List.Length(NNUE_ListRes_1))
    {
        List.Add(NNUE_OutputBias, NNUE_ListRes_1[IdxString]);
        IdxString += 1;
    }
}

Define NNUE_DecToHex(string CSV) (warp=true)
{
    List.DeleteAll(TmpList1);
    List.Add(TmpList1, 0);
    List.Add(TmpList1, 1);
    List.Add(TmpList1, 2);
    List.Add(TmpList1, 3);
    List.Add(TmpList1, 4);
    List.Add(TmpList1, 5);
    List.Add(TmpList1, 6);
    List.Add(TmpList1, 7);
    List.Add(TmpList1, 8);
    List.Add(TmpList1, 9);
    List.Add(TmpList1, "a");
    List.Add(TmpList1, "b");
    List.Add(TmpList1, "c");
    List.Add(TmpList1, "d");
    List.Add(TmpList1, "e");
    List.Add(TmpList1, "f");
    Call NNUE_LoadList(CSV);
    Res = "";
    Idx = 1;
    Repeat (List.Length(NNUE_ListRes_1))
    {
        CurrentValue = NNUE_ListRes_1[Idx];
        If (CurrentValue < 0)
        {
            CurrentValue = (2048 - CurrentValue);
        }
        Res = Operator.Join(Res, TmpList1[((floor((CurrentValue / 256)) % 16) + 1)]);
        Res = Operator.Join(Res, TmpList1[((floor((CurrentValue / 16)) % 16) + 1)]);
        Res = Operator.Join(Res, TmpList1[((CurrentValue % 16) + 1)]);
        Idx += 1;
    }
    Idx = 1;
    Repeat (List.Length(NNUE_ListRes_2))
    {
        CurrentValue = NNUE_ListRes_2[Idx];
        If (CurrentValue < 0)
        {
            CurrentValue = (2048 - CurrentValue);
        }
        Res = Operator.Join(Res, TmpList1[((floor((CurrentValue / 256)) % 16) + 1)]);
        Res = Operator.Join(Res, TmpList1[((floor((CurrentValue / 16)) % 16) + 1)]);
        Res = Operator.Join(Res, TmpList1[((CurrentValue % 16) + 1)]);
        Idx += 1;
    }
}

Define NNUE_Evaluate(string Side) (warp=true)
{
    NNUE_EvalRes = NNUE_OutputBias[1];
    NNUE_Chunk = 0;
    Repeat ((NNUE_HiddenSize / 256))
    {
        NNUE_Offset = (NNUE_Chunk * 256);
        Idx = (NNUE_Offset + 1);
        IdxSub = (Side * NNUE_HiddenSize);
        IdxSub2 = ((1 - Side) * NNUE_HiddenSize);
        Repeat (256)
        {
            CurrentValue = NNUE_Accumulator[(IdxSub + Idx)];
            If (CurrentValue > 0)
            {
                NNUE_EvalRes += (CurrentValue * NNUE_HiddenWeights[Idx]);
            }
            CurrentValue = NNUE_Accumulator[(IdxSub2 + Idx)];
            If (CurrentValue > 0)
            {
                NNUE_EvalRes += (CurrentValue * NNUE_HiddenWeights[(NNUE_HiddenSize + Idx)]);
            }
            Idx += 1;
        }
        NNUE_Chunk += 1;
    }
    NNUE_EvalRes = (NNUE_EvalRes / (16 * 512));
}

Define NNUE_HexToDec(string Hex) (warp=true)
{
    List.DeleteAll(TmpList1);
    List.Add(TmpList1, 0);
    List.Add(TmpList1, 1);
    List.Add(TmpList1, 2);
    List.Add(TmpList1, 3);
    List.Add(TmpList1, 4);
    List.Add(TmpList1, 5);
    List.Add(TmpList1, 6);
    List.Add(TmpList1, 7);
    List.Add(TmpList1, 8);
    List.Add(TmpList1, 9);
    List.Add(TmpList1, "a");
    List.Add(TmpList1, "b");
    List.Add(TmpList1, "c");
    List.Add(TmpList1, "d");
    List.Add(TmpList1, "e");
    List.Add(TmpList1, "f");
    List.DeleteAll(NNUE_ListRes_1);
    List.DeleteAll(NNUE_ListRes_2);
    Idx = 1;
    Repeat ((Variable.Length(Hex) / 3))
    {
        CurrentValue = ((((List.IndexOf(TmpList1, Operator.LetterOf(Hex, Idx)) - 1) * 256) + ((List.IndexOf(TmpList1, Operator.LetterOf(Hex, (Idx + 1))) - 1) * 16)) + (List.IndexOf(TmpList1, Operator.LetterOf(Hex, (Idx + 2))) - 1));
        If (CurrentValue > 2048)
        {
            CurrentValue = (2048 - CurrentValue);
        }
        If (List.Length(NNUE_ListRes_1) < 200000)
        {
            List.Add(NNUE_ListRes_1, CurrentValue);
        }
        Else
        {
            List.Add(NNUE_ListRes_2, CurrentValue);
        }
        Idx += 3;
    }
}

Define NNUE_ImportNetwork(string InputWeights)(string HiddenBias)(string HiddenWeights)(string OutputBias) (warp=true)
{
    List.DeleteAll(NNUE_InputWeights_1);
    List.DeleteAll(NNUE_InputWeights_2);
    List.DeleteAll(NNUE_HiddenBias);
    List.DeleteAll(NNUE_HiddenWeights);
    List.DeleteAll(NNUE_OutputBias);
    Call NNUE_DecToHex(InputWeights);
    NNUE_InputWeights_HEX = Res;
    NNUE_HiddenBias_CSV = HiddenBias;
    NNUE_HIddenWeights_CSV = HiddenWeights;
    NNUE_OutputBias_CSV = OutputBias;
    List.DeleteAll(NNUE_ListRes_1);
    List.DeleteAll(NNUE_ListRes_2);
    Res = "";
}

Define NNUE_Init (warp=true)
{
    Call NNUE_DecodeNetwork;
    NNUE_FeatureSize = 768;
    NNUE_HiddenSize = 512;
    List.DeleteAll(NNUE_Accumulator);
    Repeat ((NNUE_HiddenSize * 2))
    {
        List.Add(NNUE_Accumulator, "");
    }
    Idx = 1;
    Repeat (NNUE_HiddenSize)
    {
        List.ReplaceItem(NNUE_Accumulator, Idx, NNUE_HiddenBias[Idx]);
        List.ReplaceItem(NNUE_Accumulator, (NNUE_HiddenSize + Idx), NNUE_HiddenBias[Idx]);
        Idx += 1;
    }
    List.DeleteAll(NNUE_GoKIdxToSquare);
    Idx = 1;
    Repeat (64)
    {
        List.Add(NNUE_GoKIdxToSquare, ((((8 - IdxToRank[Idx]) * 8) + IdxToFile[Idx]) - 1));
        Idx += 1;
    }
    List.DeleteAll(NNUE_PrevRefreshBoard);
    Repeat (64)
    {
        List.Add(NNUE_PrevRefreshBoard, 0);
    }
    List.DeleteAll(NNUE_InputIdxMap);
    Repeat (2000)
    {
        List.Add(NNUE_InputIdxMap, "");
    }
    Idx = 0;
    Repeat (12)
    {
        IdxSub = 0;
        Repeat (64)
        {
            List.ReplaceItem(NNUE_InputIdxMap, (((Idx * 64) + IdxSub) + 1), ((Idx * 64) + IdxSub));
            CurrentValue = 0;
            Exp = 1;
            Repeat (8)
            {
                If (Not ((((IdxSub % (Exp * 2)) > (Exp - 1)) == ((56 % (Exp * 2)) > (Exp - 1)))))
                {
                    CurrentValue += Exp;
                }
                Exp = (Exp * 2);
            }
            If (Idx > 6)
            {
                CurrentValue += ((Idx - 6) * 64);
            }
            Else
            {
                CurrentValue += ((Idx + 6) * 64);
            }
            List.ReplaceItem(NNUE_InputIdxMap, ((1000 + ((Idx * 64) + IdxSub)) + 1), CurrentValue);
            IdxSub += 1;
        }
        Idx += 1;
    }
}

Define NNUE_LoadList(string Data) (warp=true)
{
    List.DeleteAll(NNUE_ListRes_1);
    List.DeleteAll(NNUE_ListRes_2);
    IdxString = 1;
    CurrentValue = "";
    Repeat Until (IdxString > Variable.Length(Data))
    {
        If ((Not ((Operator.LetterOf(Data, IdxString) == " "))) And (Not ((Operator.LetterOf(Data, IdxString) == ","))))
        {
            CurrentValue = Operator.Join(CurrentValue, Operator.LetterOf(Data, IdxString));
        }
        If ((Operator.LetterOf(Data, IdxString) == ",") Or (IdxString == Variable.Length(Data)))
        {
            If (List.Length(NNUE_ListRes_1) < (floor((200000 / 256)) * 256))
            {
                List.Add(NNUE_ListRes_1, CurrentValue);
            }
            Else
            {
                List.Add(NNUE_ListRes_2, CurrentValue);
            }
            CurrentValue = "";
        }
        IdxString += 1;
    }
}

Define NNUE_Public_Evaluate(string Depth) (warp=true)
{
    NNUE_Idx = 1;
    Repeat (64)
    {
        If (Not ((Board[NNUE_Idx] == NNUE_PrevRefreshBoard[NNUE_Idx])))
        {
            If (Not ((NNUE_PrevRefreshBoard[NNUE_Idx] == 0)))
            {
                Call NNUE_Deactivate(NNUE_Idx)(NNUE_PrevRefreshBoard[NNUE_Idx]);
            }
            If (Not ((Board[NNUE_Idx] == 0)))
            {
                Call NNUE_Activate(NNUE_Idx)(Board[NNUE_Idx]);
            }
            List.ReplaceItem(NNUE_PrevRefreshBoard, NNUE_Idx, Board[NNUE_Idx]);
        }
        NNUE_Idx += 1;
    }
    Call NNUE_Evaluate((Depth % 2));
    If (NNUE_EvalRes > AbsMinCheckmateEval)
    {
        NNUE_EvalRes = AbsMinCheckmateEval;
        Stop(this script);
    }
    Else
    {
        If (NNUE_EvalRes < (0 - AbsMinCheckmateEval))
        {
            NNUE_EvalRes = (0 - AbsMinCheckmateEval);
            Stop(this script);
        }
    }
    If ((Depth % 2) == 0)
    {
        NNUE_EvalRes = (0 - NNUE_EvalRes);
    }
    If (abs(NNUE_EvalRes) < AbsMinCheckmateEval)
    {
        NNUE_EvalRes = (Operator.Round((((NNUE_EvalRes + 220) / 1.5) * 100)) / 100);
    }
}

Define NNUE_Public_Refresh (warp=true)
{
    Idx = 1;
    Repeat (NNUE_HiddenSize)
    {
        List.ReplaceItem(NNUE_Accumulator, Idx, NNUE_HiddenBias[Idx]);
        List.ReplaceItem(NNUE_Accumulator, (NNUE_HiddenSize + Idx), NNUE_HiddenBias[Idx]);
        Idx += 1;
    }
    NNUE_Idx = 1;
    Repeat (64)
    {
        If (Not ((Board[NNUE_Idx] == 0)))
        {
            Call NNUE_Activate(NNUE_Idx)(Board[NNUE_Idx]);
        }
        List.ReplaceItem(NNUE_PrevRefreshBoard, NNUE_Idx, Board[NNUE_Idx]);
        NNUE_Idx += 1;
    }
}

Define NNUE_SubAccWght1_16(string IdxAcc)(string IdxWght) (warp=true)
{
    List.ReplaceItem(NNUE_Accumulator, IdxAcc, (NNUE_Accumulator[IdxAcc] - NNUE_InputWeights_1[IdxWght]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 1), (NNUE_Accumulator[(IdxAcc + 1)] - NNUE_InputWeights_1[(IdxWght + 1)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 2), (NNUE_Accumulator[(IdxAcc + 2)] - NNUE_InputWeights_1[(IdxWght + 2)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 3), (NNUE_Accumulator[(IdxAcc + 3)] - NNUE_InputWeights_1[(IdxWght + 3)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 4), (NNUE_Accumulator[(IdxAcc + 4)] - NNUE_InputWeights_1[(IdxWght + 4)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 5), (NNUE_Accumulator[(IdxAcc + 5)] - NNUE_InputWeights_1[(IdxWght + 5)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 6), (NNUE_Accumulator[(IdxAcc + 6)] - NNUE_InputWeights_1[(IdxWght + 6)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 7), (NNUE_Accumulator[(IdxAcc + 7)] - NNUE_InputWeights_1[(IdxWght + 7)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 8), (NNUE_Accumulator[(IdxAcc + 8)] - NNUE_InputWeights_1[(IdxWght + 8)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 9), (NNUE_Accumulator[(IdxAcc + 9)] - NNUE_InputWeights_1[(IdxWght + 9)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 10), (NNUE_Accumulator[(IdxAcc + 10)] - NNUE_InputWeights_1[(IdxWght + 10)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 11), (NNUE_Accumulator[(IdxAcc + 11)] - NNUE_InputWeights_1[(IdxWght + 11)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 12), (NNUE_Accumulator[(IdxAcc + 12)] - NNUE_InputWeights_1[(IdxWght + 12)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 13), (NNUE_Accumulator[(IdxAcc + 13)] - NNUE_InputWeights_1[(IdxWght + 13)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 14), (NNUE_Accumulator[(IdxAcc + 14)] - NNUE_InputWeights_1[(IdxWght + 14)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 15), (NNUE_Accumulator[(IdxAcc + 15)] - NNUE_InputWeights_1[(IdxWght + 15)]));
}

Define NNUE_SubAccWght2_16(string IdxAcc)(string IdxWght) (warp=true)
{
    List.ReplaceItem(NNUE_Accumulator, IdxAcc, (NNUE_Accumulator[IdxAcc] - NNUE_InputWeights_2[IdxWght]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 1), (NNUE_Accumulator[(IdxAcc + 1)] - NNUE_InputWeights_2[(IdxWght + 1)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 2), (NNUE_Accumulator[(IdxAcc + 2)] - NNUE_InputWeights_2[(IdxWght + 2)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 3), (NNUE_Accumulator[(IdxAcc + 3)] - NNUE_InputWeights_2[(IdxWght + 3)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 4), (NNUE_Accumulator[(IdxAcc + 4)] - NNUE_InputWeights_2[(IdxWght + 4)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 5), (NNUE_Accumulator[(IdxAcc + 5)] - NNUE_InputWeights_2[(IdxWght + 5)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 6), (NNUE_Accumulator[(IdxAcc + 6)] - NNUE_InputWeights_2[(IdxWght + 6)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 7), (NNUE_Accumulator[(IdxAcc + 7)] - NNUE_InputWeights_2[(IdxWght + 7)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 8), (NNUE_Accumulator[(IdxAcc + 8)] - NNUE_InputWeights_2[(IdxWght + 8)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 9), (NNUE_Accumulator[(IdxAcc + 9)] - NNUE_InputWeights_2[(IdxWght + 9)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 10), (NNUE_Accumulator[(IdxAcc + 10)] - NNUE_InputWeights_2[(IdxWght + 10)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 11), (NNUE_Accumulator[(IdxAcc + 11)] - NNUE_InputWeights_2[(IdxWght + 11)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 12), (NNUE_Accumulator[(IdxAcc + 12)] - NNUE_InputWeights_2[(IdxWght + 12)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 13), (NNUE_Accumulator[(IdxAcc + 13)] - NNUE_InputWeights_2[(IdxWght + 13)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 14), (NNUE_Accumulator[(IdxAcc + 14)] - NNUE_InputWeights_2[(IdxWght + 14)]));
    List.ReplaceItem(NNUE_Accumulator, (IdxAcc + 15), (NNUE_Accumulator[(IdxAcc + 15)] - NNUE_InputWeights_2[(IdxWght + 15)]));
}

Define OnEvaluationChanged(string Eval) (warp=true)
{
    If (Level > 2)
    {
        If (Eval > 1000)
        {
            EvaluationValue = 100;
        }
        Else
        {
            If (Eval < -1000)
            {
                EvaluationValue = -100;
            }
            Else
            {
                EvaluationValue = (Eval / 10);
            }
        }
    }
    Else
    {
        EvaluationValue = 0;
    }
    Event.Broadcast("evaluationvaluechanged");
    Control.Wait(0);
}

Define OnProgressChanged(string Progress) (warp=false)
{
    If (Progress < 100)
    {
        ProgressValue = Progress;
    }
    Else
    {
        ProgressValue = 100;
    }
    Event.Broadcast("progressvaluechangedinternal");
}

Define OnRestart (warp=true)
{
    Looks.Say("");
    List.DeleteAll(Logfile);
    List.Hide(BoardHistory);
    List.Hide(GameMovesAN);
    List.Hide(ExportData);
    List.Hide(ExportMoves);
    List.Hide(Logfile);
    List.Hide(Profile_Data);
    Variable.Hide(IdxDeepening);
    Variable.Hide(BestMinMaxRes);
    Variable.Hide(BestMove);
    Variable.Hide(NPS);
    Variable.Hide(MPS);
    ProfilerMode = -1;
    DebugMode = -1;
}

Define OnScoreCalc(string Depth)(string MinDepth)(string MaxDepth)(bool Quiescence) (warp=true)
{
    If (IsBlockProfilerEnabled == 1)
    {
        Call Profile_MethodEnter(Depth);
    }
    ScoreCalcRes = "";
    ScoreCalcResIsDynamic = 0;
    If ((IsScratch3 == 1) And (IsEndgame2 == 1))
    {
        If (Depth == 0)
        {
            Call EvaluateBoard;
            EvalResultBase = EvalResult;
            Call CalcBoardAttackedByMove(1);
            Call StoreAttackInfo(1)(1);
            Call CalcBoardAttackedByMove(2);
            Call StoreAttackInfo(2)(1);
            EvalMaterialBase = Operator.Round((((((BlackQueenCount * 9) + (BlackRookCount * 5)) + (((BlackBishopCount * 3.3) + (((BlackMinorCount - BlackRookCount) - BlackBishopCount) * 3.1)) + BlackPawnCount)) - (((WhiteQueenCount * 9) + (WhiteRookCount * 5)) + (((WhiteBishopCount * 3.3) + (((WhiteMinorCount - WhiteRookCount) - WhiteBishopCount) * 3.1)) + WhitePawnCount))) * 10));
            If (IsBlockProfilerEnabled == 1)
            {
                Call Profile_MethodExit(Depth);
            }
            Stop(this script);
        }
        Call //("Incremental Evaluation");
        If (Depth == 1)
        {
            List.ReplaceItem(PosScoreDeltaSum, Depth, PosScoreDelta[Depth]);
            List.ReplaceItem(CapturesDeltaSum, Depth, TargetPieces[Depth]);
            If (Not ((PromotionPieces[Depth] == 0)))
            {
                List.ReplaceItem(CapturesDeltaSum, Depth, ((CapturesDeltaSum[Depth] - PromotionPieces[Depth]) + SourcePieces[Depth]));
            }
        }
        Else
        {
            List.ReplaceItem(PosScoreDeltaSum, Depth, (PosScoreDeltaSum[(Depth - 1)] + PosScoreDelta[Depth]));
            List.ReplaceItem(CapturesDeltaSum, Depth, (CapturesDeltaSum[(Depth - 1)] + TargetPieces[Depth]));
            If (Not ((PromotionPieces[Depth] == 0)))
            {
                List.ReplaceItem(CapturesDeltaSum, Depth, ((CapturesDeltaSum[Depth] - PromotionPieces[Depth]) + SourcePieces[Depth]));
            }
        }
    }
    If (Depth == MaxDepth)
    {
        If (1 == 1)
        {
            Call TTProbeBoard(CurrentBoardHash)((Depth + 1));
            If ((TTProbeRes == 1) And (Not ((TTProbeBoardScoreSumRes == ""))))
            {
                ScoreCalcRes = TTProbeBoardScoreSumRes;
                ScoreCalcResIsDynamic = TTProbeBoardScoreIsDynamic;
                If (IsBlockProfilerEnabled == 1)
                {
                    Call Profile_MethodExit(Depth);
                }
                Stop(this script);
            }
        }
        If ((IsScratch3 == 1) And (IsEndgame2 == 1))
        {
            ScoreCalcRes = (EvalResultBase + ((PosScoreDeltaSum[Depth] - CapturesDeltaSum[Depth]) + (BlackMobBonus[Depth] - WhiteMobBonus[Depth])));
            Delta = abs((IdxToRank[WhiteKingIdx] - IdxToRank[BlackKingIdx]));
            Delta2 = abs((IdxToFile[WhiteKingIdx] - IdxToFile[BlackKingIdx]));
            If (Not ((PromotionPieces[1] == 0)))
            {
                ScoreCalcRes += 50;
                ScoreCalcResIsDynamic = 1;
            }
            If ((Depth > 1) And (Not ((PromotionPieces[2] == 0))))
            {
                ScoreCalcRes += -50;
                ScoreCalcResIsDynamic = 1;
            }
            If (Delta < Delta2)
            {
                Delta = Delta2;
            }
            If ((BlackQueenCountLocal + BlackMinorCountLocal) == 0)
            {
                ScoreCalcRes += (-20 * (Delta - 1));
            }
            If ((BlackQueenCountLocal + BlackMinorCountLocal) == 0)
            {
                ScoreCalcRes += (20 * (Delta - 1));
            }
            Call TTStoreBoard(CurrentBoardHash)((Depth + 1))(ScoreCalcRes);
            If (IsBlockProfilerEnabled == 1)
            {
                Call Profile_MethodExit(Depth);
            }
            Stop(this script);
        }
        Call NNUE_Public_Evaluate((Depth + 1));
        ScoreCalcRes = NNUE_EvalRes;
        ScoreCalcResIsDynamic = 0;
        Call TTStoreBoard(CurrentBoardHash)((Depth + 1))(ScoreCalcRes);
    }
    If (IsBlockProfilerEnabled == 1)
    {
        Call Profile_MethodExit(Depth);
    }
}

Define OnScoreCalcPostProcess(string Depth) (warp=true)
{
    Call //("Early promotion detection via Rule-of-Squares / Chebyshev distance");
    If ((IsScratch3 == 1) And (IsEndgame2 == 1))
    {
        If (((WhiteQueenCountLocal + WhiteMinorCountLocal) == 0) Or ((BlackQueenCountLocal + BlackMinorCountLocal) == 0))
        {
            List.DeleteItem(BlackPawnCount, all);
            List.DeleteItem(WhitePawnCount, all);
            Repeat (8)
            {
                List.Add(BlackPawnCount, 0);
                List.Add(WhitePawnCount, 0);
            }
            List.DeleteItem(PawnAdvancePerFile, all);
            Repeat (32)
            {
                List.Add(PawnAdvancePerFile, 0);
            }
            Idx = 1;
            Repeat (64)
            {
                SourcePiece = Board[Idx];
                If (SourcePiece == BlackPawn)
                {
                    File = IdxToFile[Idx];
                    Rank = IdxToRank[Idx];
                    List.ReplaceItem(BlackPawnCount, File, (BlackPawnCount[File] + 1));
                    If ((PawnAdvancePerFile[(File + 16)] == 0) Or (Rank < PawnAdvancePerFile[(File + 16)]))
                    {
                        List.ReplaceItem(PawnAdvancePerFile, (File + 16), Rank);
                    }
                    If (Rank > PawnAdvancePerFile[(File + 24)])
                    {
                        List.ReplaceItem(PawnAdvancePerFile, (File + 24), Rank);
                    }
                }
                If (SourcePiece == WhitePawn)
                {
                    File = IdxToFile[Idx];
                    Rank = IdxToRank[Idx];
                    List.ReplaceItem(WhitePawnCount, File, (WhitePawnCount[File] + 1));
                    If (Rank > PawnAdvancePerFile[File])
                    {
                        List.ReplaceItem(PawnAdvancePerFile, File, Rank);
                    }
                    If ((PawnAdvancePerFile[(File + 8)] == 0) Or (Rank < PawnAdvancePerFile[(File + 8)]))
                    {
                        List.ReplaceItem(PawnAdvancePerFile, (File + 8), Rank);
                    }
                }
                Idx += 1;
            }
            Idx = 1;
            Repeat (8)
            {
                WhitePawnForwardRank = PawnAdvancePerFile[(Idx + 8)];
                BlackPawnForwardRank = PawnAdvancePerFile[(Idx + 24)];
                If ((BlackQueenCountLocal + BlackMinorCountLocal) == 0)
                {
                    If ((WhitePawnForwardRank < 7) And (WhitePawnForwardRank > 0))
                    {
                        BlackPawnBackwardRank = PawnAdvancePerFile[(Idx + 16)];
                        If ((WhitePawnForwardRank < BlackPawnBackwardRank) Or (BlackPawnBackwardRank == 0))
                        {
                            LeftOppPawnRank = PawnAdvancePerFile[((Idx + 16) - 1)];
                            If (((Idx == 1) Or (LeftOppPawnRank == 0)) Or (WhitePawnForwardRank < LeftOppPawnRank))
                            {
                                RightOppPawnRank = PawnAdvancePerFile[((Idx + 16) + 1)];
                                If (((Idx == 8) Or (RightOppPawnRank == 0)) Or (WhitePawnForwardRank < RightOppPawnRank))
                                {
                                    TargetIdx = Idx;
                                    Delta = (WhitePawnForwardRank - 1);
                                    If (Delta > 5)
                                    {
                                        Delta = 5;
                                    }
                                    If ((ChebyshevDistance[((BlackKingIdx * 100) + TargetIdx)] - ((Depth + 1) % 2)) > Delta)
                                    {
                                        ScoreCalcRes += (WhiteQueen - WhitePawn);
                                    }
                                }
                            }
                        }
                    }
                }
                If ((WhiteQueenCountLocal + WhiteMinorCountLocal) == 0)
                {
                    If (BlackPawnForwardRank > 2)
                    {
                        WhitePawnBackwardRank = PawnAdvancePerFile[Idx];
                        If (BlackPawnForwardRank > WhitePawnBackwardRank)
                        {
                            LeftOppPawnRank = PawnAdvancePerFile[(Idx - 1)];
                            If (((Idx == 1) Or (LeftOppPawnRank == 0)) Or (BlackPawnForwardRank > LeftOppPawnRank))
                            {
                                RightOppPawnRank = PawnAdvancePerFile[(Idx + 1)];
                                If (((Idx == 8) Or (RightOppPawnRank == 0)) Or (BlackPawnForwardRank > RightOppPawnRank))
                                {
                                    TargetIdx = (56 + Idx);
                                    Delta = (8 - BlackPawnForwardRank);
                                    If (Delta > 5)
                                    {
                                        Delta = 5;
                                    }
                                    If ((ChebyshevDistance[((WhiteKingIdx * 100) + TargetIdx)] - (Depth % 2)) > Delta)
                                    {
                                        ScoreCalcRes += (BlackQueen - BlackPawn);
                                    }
                                }
                            }
                        }
                    }
                }
                Idx += 1;
            }
        }
    }
}

Define PickMove(string Depth)(bool Quiescence) (warp=true)
{
    Call //("Staged move-generator implementation");
    Call //("Phase 1: Look up hash-move from transposition table");
    If (PickPhase[Depth] == 1)
    {
        List.ReplaceItem(PickedMoves, Depth, "");
        List.ReplaceItem(PickedMoveCount, Depth, 0);
        List.ReplaceItem(MovesCount, Depth, 0);
        List.ReplaceItem(MovesIdx, Depth, 0);
        List.ReplaceItem(MovesIdxBestMove, Depth, 0);
        List.DeleteAll(CalcMovesMoveList);
        List.DeleteAll(CalcMovesScoreList);
        List.DeleteAll(TmpList1);
        List.DeleteAll(TmpList2);
        Call ClearMoveList(Depth);
        If (Depth > 1)
        {
            Call TTProbeNode(CurrentBoardHash)(Depth);
            If (TTProbeRes == 1)
            {
                If (Not ((TTProbeCheckedRes == "")))
                {
                    List.ReplaceItem(CheckedState, Depth, TTProbeCheckedRes);
                    If ((Not ((TTProbeBoardAttackedByOpp == ""))) And (Not ((TTProbeBoardAttackedByOppPiece == ""))))
                    {
                        List.ReplaceItem(CheckedStateAttackLines, Depth, TTProbeCheckedAttackLinesRes);
                        If ((Depth % 2) == 1)
                        {
                            List.ReplaceItem(BoardAttackedByWhiteSnapshot, Depth, TTProbeBoardAttackedByOpp);
                            List.ReplaceItem(BoardAttackedByWhitePieceSnapshot, Depth, TTProbeBoardAttackedByOppPiece);
                        }
                        Else
                        {
                            List.ReplaceItem(BoardAttackedByBlackSnapshot, Depth, TTProbeBoardAttackedByOpp);
                            List.ReplaceItem(BoardAttackedByBlackPieceSnapshot, Depth, TTProbeBoardAttackedByOppPiece);
                        }
                        List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
                    }
                }
                If ((Depth % 2) == 1)
                {
                    If (Not ((TTProbeBlackMobRes == "")))
                    {
                        List.ReplaceItem(BlackMobBonus, Depth, TTProbeBlackMobRes);
                    }
                }
                Else
                {
                    If (Not ((TTProbeWhiteMobRes == "")))
                    {
                        List.ReplaceItem(WhiteMobBonus, Depth, TTProbeWhiteMobRes);
                    }
                }
                If (Not ((TTProbeBestMoveRes == "")))
                {
                    SourceIdx = floor((TTProbeBestMoveRes / 100));
                    TargetIdx = floor((TTProbeBestMoveRes % 100));
                    If ((Not (Quiescence)) Or (Quiescence And ((TTProbeHorizonRes == -1) Or ((Not ((SourceIdx == 0))) And (Not ((Board[TargetIdx] == 0)))))))
                    {
                        If (Not (((abs(Board[SourceIdx]) == BlackPawn) And ((Not ((IdxToFile[SourceIdx] == IdxToFile[TargetIdx]))) And (Board[TargetIdx] == 0)))))
                        {
                            Call CalcBoardAttackedIfRequiredForDepth(Depth)(Quiescence)((1 == 1))(99);
                            Call AddMoveToList(TTProbeBestMoveRes)(Depth);
                            List.ReplaceItem(MovesIdx, Depth, 1);
                            Call ApplyMove(Depth);
                            List.ReplaceItem(PickedMoves, Depth, Operator.Join(AppliedMove[Depth], ":"));
                            List.ReplaceItem(PickedMoveCount, Depth, (PickedMoveCount[Depth] + 1));
                            List.ReplaceItem(PickPhase, Depth, 2);
                            List.ReplaceItem(PickMoveRes, Depth, 1);
                            Stop(this script);
                        }
                    }
                }
            }
        }
        List.ReplaceItem(PickPhase, Depth, 2);
    }
    Call //("Phase 2: Search for MVV-LVA captures via attack tables (and from recently moved pieces when attack tables not up-to-date)");
    If (PickPhase[Depth] == 2)
    {
        If ((IsEndgame2 == 1) Or (Depth < 4))
        {
            List.ReplaceItem(PickPhase, Depth, 6);
        }
        Else
        {
            Call CalcBoardAttackedIfRequiredForDepth(Depth)(Quiescence)((1 == 1))(99);
            List.DeleteAll(TmpList1);
            List.DeleteAll(TmpList2);
            List.DeleteAll(TmpList3);
            List.DeleteAll(TmpList4);
            Idx = (Depth - 2);
            Repeat Until ((Idx < 1) Or (BoardAttackedCalculated[(Idx + 1)] == 1))
            {
                SourceIdxOuter2 = floor((AppliedMove[Idx] % 100));
                If ((SourceIdxOuter2 > 0) And (SourceIdxOuter2 < 65))
                {
                    If ((Depth % 2) == 1)
                    {
                        If (Board[SourceIdxOuter2] > 0)
                        {
                            If (Not (List.ContainsItem(TmpList3, SourceIdxOuter2)))
                            {
                                List.Add(TmpList3, SourceIdxOuter2);
                                List.Add(TmpList4, ((PieceIdxLookup[Board[SourceIdxOuter2]] * 10000) + (SourceIdxOuter2 * 100)));
                            }
                        }
                    }
                    Else
                    {
                        If (Board[SourceIdxOuter2] < 0)
                        {
                            If (Not (List.ContainsItem(TmpList3, SourceIdxOuter2)))
                            {
                                List.Add(TmpList3, SourceIdxOuter2);
                                List.Add(TmpList4, ((PieceIdxLookup[abs(Board[SourceIdxOuter2])] * 10000) + (SourceIdxOuter2 * 100)));
                            }
                        }
                    }
                }
                Idx += -2;
            }
            TargetIdxOuter = floor((AppliedMove[(Depth - 1)] % 100));
            If ((Depth % 2) == 1)
            {
                TargetIdxOuter2 = 1;
                Repeat (64)
                {
                    If (Board[TargetIdxOuter2] < 0)
                    {
                        If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], TargetIdxOuter2) > 0)
                        {
                            SourceIdxOuter2 = Operator.Join(Operator.LetterOf(BoardAttackedByBlackPieceSnapshot[Depth], ((TargetIdxOuter2 * 2) - 1)), Operator.LetterOf(BoardAttackedByBlackPieceSnapshot[Depth], (TargetIdxOuter2 * 2)));
                            SourcePieceOuter2 = Board[SourceIdxOuter2];
                            If ((SourcePieceOuter2 > 0) And (Not ((MovePosLookupBlack[((PieceIdxLookup[SourcePieceOuter2] * 10000) + ((SourceIdxOuter2 * 100) + TargetIdxOuter2))] == ""))))
                            {
                                Call StagedMoveGenMVVLVA(Depth)(SourceIdxOuter2)(TargetIdxOuter2)(SourcePieceOuter2)(abs(Board[TargetIdxOuter2]))(TargetIdxOuter);
                            }
                        }
                        IdxOuter3 = 1;
                        Repeat (List.Length(TmpList3))
                        {
                            If (Not ((MovePosLookupBlack[(TmpList4[IdxOuter3] + TargetIdxOuter2)] == "")))
                            {
                                SourceIdxOuter2 = TmpList3[IdxOuter3];
                                Call StagedMoveGenMVVLVA(Depth)(SourceIdxOuter2)(TargetIdxOuter2)(Board[SourceIdxOuter2])(abs(Board[TargetIdxOuter2]))(TargetIdxOuter);
                            }
                            IdxOuter3 += 1;
                        }
                    }
                    TargetIdxOuter2 += 1;
                }
            }
            Else
            {
                TargetIdxOuter2 = 1;
                Repeat (64)
                {
                    If (Board[TargetIdxOuter2] > 0)
                    {
                        If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], TargetIdxOuter2) > 0)
                        {
                            SourceIdxOuter2 = Operator.Join(Operator.LetterOf(BoardAttackedByWhitePieceSnapshot[Depth], ((TargetIdxOuter2 * 2) - 1)), Operator.LetterOf(BoardAttackedByWhitePieceSnapshot[Depth], (TargetIdxOuter2 * 2)));
                            SourcePieceOuter2 = Board[SourceIdxOuter2];
                            If ((SourcePieceOuter2 < 0) And (Not ((MovePosLookupWhite[((PieceIdxLookup[abs(SourcePieceOuter2)] * 10000) + ((SourceIdxOuter2 * 100) + TargetIdxOuter2))] == ""))))
                            {
                                Call StagedMoveGenMVVLVA(Depth)(SourceIdxOuter2)(TargetIdxOuter2)(abs(SourcePieceOuter2))(Board[TargetIdxOuter2])(TargetIdxOuter);
                            }
                        }
                        IdxOuter3 = 1;
                        Repeat (List.Length(TmpList3))
                        {
                            If (Not ((MovePosLookupWhite[(TmpList4[IdxOuter3] + TargetIdxOuter2)] == "")))
                            {
                                SourceIdxOuter2 = TmpList3[IdxOuter3];
                                Call StagedMoveGenMVVLVA(Depth)(SourceIdxOuter2)(TargetIdxOuter2)(abs(Board[SourceIdxOuter2]))(Board[TargetIdxOuter2])(TargetIdxOuter);
                            }
                            IdxOuter3 += 1;
                        }
                    }
                    TargetIdxOuter2 += 1;
                }
            }
            If (List.Length(TmpList1) > 0)
            {
                If (List.Length(TmpList1) == 1)
                {
                    Call AddMoveToList(TmpList1[1])(Depth);
                }
                Else
                {
                    List.DeleteAll(CalcMovesMoveList);
                    List.DeleteAll(CalcMovesScoreList);
                    Idx = 1;
                    Repeat (List.Length(TmpList1))
                    {
                        List.Add(CalcMovesMoveList, TmpList1[Idx]);
                        List.Add(CalcMovesScoreList, TmpList2[Idx]);
                        Idx += 1;
                    }
                    Call SortMoveList((Depth + 2));
                    List.ReplaceItem(MovesIdx, (Depth + 2), 1);
                    Repeat (MovesCount[(Depth + 2)])
                    {
                        Call GetCurrentMove((Depth + 2));
                        Call AddMoveToList(CurrentMove)(Depth);
                        List.ReplaceItem(MovesIdx, (Depth + 2), (MovesIdx[(Depth + 2)] + 1));
                    }
                }
            }
            List.ReplaceItem(PickPhase, Depth, 3);
        }
    }
    Call //("Pick next move detected in phase 2");
    If (PickPhase[Depth] == 3)
    {
        If (MovesIdx[Depth] < MovesCount[Depth])
        {
            List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
            Call ApplyMove(Depth);
            List.ReplaceItem(PickedMoves, Depth, Operator.Join(PickedMoves[Depth], Operator.Join(AppliedMove[Depth], ":")));
            List.ReplaceItem(PickedMoveCount, Depth, (PickedMoveCount[Depth] + 1));
            List.ReplaceItem(PickMoveRes, Depth, 1);
            Stop(this script);
        }
        List.ReplaceItem(PickPhase, Depth, 4);
    }
    Call //("Phase 4: Search for killer moves that can be applied on current board");
    If (PickPhase[Depth] == 4)
    {
        If ((Quiescence Or (CheckedState[Depth] == 1)) Or (Depth == 1))
        {
            List.ReplaceItem(PickPhase, Depth, 6);
        }
        Else
        {
            Call CalcBoardAttackedIfRequiredForDepth(Depth)(Quiescence)((1 == 1))(99);
            List.DeleteAll(TmpList1);
            List.DeleteAll(TmpList2);
            Call PrepareCurrentKillerMoves(Depth);
            IdxOuter3 = List.Length(CurrentKillerMoves);
            Repeat Until ((IdxOuter3 == 2) Or (List.Length(TmpList1) == 2))
            {
                CurrentMoveOuter = CurrentKillerMoves[IdxOuter3];
                SourceIdxOuter2 = floor((CurrentMoveOuter / 100));
                TargetIdxOuter2 = floor((CurrentMoveOuter % 100));
                If ((SourceIdxOuter2 > 0) And (Board[TargetIdxOuter2] == 0))
                {
                    If ((Depth % 2) == 1)
                    {
                        If ((Board[SourceIdxOuter2] > 0) And (Not ((MovePosLookupBlack[((PieceIdxLookup[Board[SourceIdxOuter2]] * 10000) + ((SourceIdxOuter2 * 100) + TargetIdxOuter2))] == ""))))
                        {
                            Call StagedMoveGenKillerMoves(Depth)(CurrentMoveOuter)(SourceIdxOuter2)(TargetIdxOuter2)(Board[SourceIdxOuter2])(IdxOuter3);
                        }
                    }
                    Else
                    {
                        If ((Board[SourceIdxOuter2] < 0) And (Not ((MovePosLookupWhite[((PieceIdxLookup[abs(Board[SourceIdxOuter2])] * 10000) + ((SourceIdxOuter2 * 100) + TargetIdxOuter2))] == ""))))
                        {
                            Call StagedMoveGenKillerMoves(Depth)(CurrentMoveOuter)(SourceIdxOuter2)(TargetIdxOuter2)(abs(Board[SourceIdxOuter2]))(IdxOuter3);
                        }
                    }
                }
                IdxOuter3 += -1;
            }
            If (List.Length(TmpList1) > 0)
            {
                If (List.Length(TmpList1) == 1)
                {
                    Call AddMoveToList(TmpList1[1])(Depth);
                }
                Else
                {
                    List.DeleteAll(CalcMovesMoveList);
                    List.DeleteAll(CalcMovesScoreList);
                    Idx = 1;
                    Repeat (List.Length(TmpList1))
                    {
                        List.Add(CalcMovesMoveList, TmpList1[Idx]);
                        List.Add(CalcMovesScoreList, TmpList2[Idx]);
                        Idx += 1;
                    }
                    Call SortMoveList((Depth + 2));
                    List.ReplaceItem(MovesIdx, (Depth + 2), 1);
                    Repeat (MovesCount[(Depth + 2)])
                    {
                        Call GetCurrentMove((Depth + 2));
                        Call AddMoveToList(CurrentMove)(Depth);
                        List.ReplaceItem(MovesIdx, (Depth + 2), (MovesIdx[(Depth + 2)] + 1));
                    }
                }
            }
            List.ReplaceItem(PickPhase, Depth, 5);
        }
    }
    Call //("Pick next move detected in phase 4");
    If (PickPhase[Depth] == 5)
    {
        If (MovesIdx[Depth] < MovesCount[Depth])
        {
            List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
            Call ApplyMove(Depth);
            List.ReplaceItem(PickedMoves, Depth, Operator.Join(PickedMoves[Depth], Operator.Join(AppliedMove[Depth], ":")));
            List.ReplaceItem(PickedMoveCount, Depth, (PickedMoveCount[Depth] + 1));
            List.ReplaceItem(PickMoveRes, Depth, 1);
            Stop(this script);
        }
        List.ReplaceItem(PickPhase, Depth, 6);
    }
    Call //("Phase 6: Full move generator for all moves not found yet");
    If (PickPhase[Depth] == 6)
    {
        If (Depth == 1)
        {
            Call CalcBoardAttackedByMove((Depth + 2));
            Call StoreAttackInfo((Depth + 2))(Depth);
        }
        Call CalcBoardAttackedIfRequiredForDepth(Depth)(Quiescence)((1 == 1))(99);
        If (Not (Quiescence))
        {
            If (BoardAttackedCalculated[Depth] == 0)
            {
                Call CalcBoardAttackedByMove((Depth + 1));
                Call StoreAttackInfo((Depth + 1))(Depth);
                List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
            }
        }
        Call GenerateMovesImplWrapper(Depth)((1 == 0))((Quiescence Or ((Depth > 2) And (CheckedState[Depth] == 1))));
        If (GenerateMovesRequiresAttackRecalc == 1)
        {
            Call CalcBoardAttackedByMove((Depth + 1));
            Call StoreAttackInfo((Depth + 1))(Depth);
            List.ReplaceItem(BoardAttackedCalculated, Depth, 1);
            Call GenerateMovesImplWrapper(Depth)((1 == 0))((Quiescence Or ((Depth > 2) And (CheckedState[Depth] == 1))));
        }
        If (Not (Quiescence))
        {
            If ((Depth % 2) == 1)
            {
                Call TTStoreNode(CurrentBoardHash)(Depth)("")("")("")("")("")(BlackMobBonus[Depth])("")("")("")("")("");
            }
            Else
            {
                Call TTStoreNode(CurrentBoardHash)(Depth)("")("")("")("")("")("")(WhiteMobBonus[Depth])("")("")("")("");
            }
        }
        List.ReplaceItem(MovesIdx, Depth, 0);
        List.ReplaceItem(PickPhase, Depth, 7);
    }
    Call //("Pick next move detected in phase 6, skip those applied in earlier stages");
    If (PickPhase[Depth] == 7)
    {
        If (MovesIdx[Depth] < MovesCount[Depth])
        {
            List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
            If (Variable.Length(PickedMoves[Depth]) > 0)
            {
                Call GetCurrentMove(Depth);
                Repeat Until (Not (Operator.Contains(PickedMoves[Depth], CurrentMove)))
                {
                    List.ReplaceItem(MovesIdx, Depth, (MovesIdx[Depth] + 1));
                    If (MovesIdx[Depth] > MovesCount[Depth])
                    {
                        List.ReplaceItem(PickPhase, Depth, "*");
                        List.ReplaceItem(PickMoveRes, Depth, 0);
                        Stop(this script);
                    }
                    Call GetCurrentMove(Depth);
                }
            }
            Call ApplyMove(Depth);
            List.ReplaceItem(PickMoveRes, Depth, 1);
            List.ReplaceItem(PickedMoveCount, Depth, (PickedMoveCount[Depth] + 1));
            Stop(this script);
        }
        List.ReplaceItem(PickPhase, Depth, "*");
        List.ReplaceItem(PickMoveRes, Depth, 0);
    }
    List.ReplaceItem(PickMoveRes, Depth, 0);
}

Define PrepareCurrentKillerMoves(string Depth) (warp=true)
{
    List.DeleteAll(CurrentKillerMoves);
    Idx = (((Depth - 1) * 4) + 1);
    List.Add(CurrentKillerMoves, KillerMoves[Idx]);
    List.Add(CurrentKillerMoves, KillerMoves[(Idx + 1)]);
    List.Add(CurrentKillerMoves, KillerMoves[(Idx + 2)]);
    List.Add(CurrentKillerMoves, KillerMoves[(Idx + 3)]);
}

Define Profile_MethodEnter(num Id) (warp=true)
{
    Repeat Until (Not ((List.Length(Profile_Data) < Id)))
    {
        List.Add(Profile_Data, 0);
    }
    List.ReplaceItem(Profile_Data, Id, (Profile_Data[Id] - ((Sensing.DaysSince2000() * 24) * 3600)));
}

Define Profile_MethodExit(num Id) (warp=false)
{
    List.ReplaceItem(Profile_Data, Id, (Profile_Data[Id] + ((Sensing.DaysSince2000() * 24) * 3600)));
}

Define Profile_Reset (warp=true)
{
    List.DeleteItem(Profile_Data, all);
}

Define QuickSort (warp=true)
{
    List.DeleteAll(QSPartStack);
    Call QuickSortImpl(1)(List.Length(CalcMovesScoreList));
}

Define QuickSortImpl(string Lo)(string Hi) (warp=true)
{
    QSPivot = CalcMovesScoreList[floor(((Lo + Hi) / 2))];
    QSLower = Lo;
    QSUpper = Hi;
    Repeat Until (QSLower > QSUpper)
    {
        Repeat Until (Not ((CalcMovesScoreList[QSLower] < QSPivot)))
        {
            QSLower += 1;
        }
        Repeat Until (Not ((CalcMovesScoreList[QSUpper] > QSPivot)))
        {
            QSUpper += -1;
        }
        If (Not ((QSLower > QSUpper)))
        {
            QSSwap = CalcMovesScoreList[QSLower];
            List.ReplaceItem(CalcMovesScoreList, QSLower, CalcMovesScoreList[QSUpper]);
            List.ReplaceItem(CalcMovesScoreList, QSUpper, QSSwap);
            QSSwap = CalcMovesMoveList[QSLower];
            List.ReplaceItem(CalcMovesMoveList, QSLower, CalcMovesMoveList[QSUpper]);
            List.ReplaceItem(CalcMovesMoveList, QSUpper, QSSwap);
            QSLower += 1;
            QSUpper += -1;
        }
    }
    If (Lo < QSUpper)
    {
        List.Add(QSPartStack, QSLower);
        Call QuickSortImpl(Lo)(QSUpper);
        QSLower = QSPartStack[List.Length(QSPartStack)];
        List.DeleteItem(QSPartStack, List.Length(QSPartStack));
    }
    If (QSLower < Hi)
    {
        Call QuickSortImpl(QSLower)(Hi);
    }
}

Define RevertMove(num Depth) (warp=true)
{
    CurrentMove = AppliedMove[Depth];
    SourceIdx = floor((CurrentMove / 100));
    If (SourceIdx > 0)
    {
        TargetIdx = floor((CurrentMove % 100));
        SourcePiece = Board[TargetIdx];
        If (abs(Board[TargetIdx]) == BlackPawn)
        {
            List.ReplaceItem(EnPassantTarget, (Depth + 1), "");
        }
        List.ReplaceItem(Board, SourceIdx, Board[TargetIdx]);
        List.ReplaceItem(Board, TargetIdx, 0);
        List.ReplaceItem(Board, TargetPiecesIdx[Depth], TargetPieces[Depth]);
        If (PromotionPieces[Depth] > 0)
        {
            PromotionVal = Operator.LetterOf(CurrentMove, 6);
            If (PromotionVal == 1)
            {
                BlackQueenCountLocal += -1;
            }
            If (PromotionVal == 2)
            {
                BlackRookCountLocal += -1;
                BlackMinorCountLocal += -1;
            }
            If (PromotionVal == 3)
            {
                BlackBishopCountLocal += -1;
                BlackMinorCountLocal += -1;
            }
            If (PromotionVal == 4)
            {
                BlackMinorCountLocal += -1;
            }
            List.ReplaceItem(Board, SourceIdx, BlackPawn);
            BlackPawnCountLocal += 1;
            SourcePiece = BlackPawn;
        }
        Else
        {
            If (PromotionPieces[Depth] < 0)
            {
                PromotionVal = Operator.LetterOf(CurrentMove, 6);
                If (PromotionVal == 1)
                {
                    WhiteQueenCountLocal += -1;
                }
                If (PromotionVal == 2)
                {
                    WhiteRookCountLocal += -1;
                    WhiteMinorCountLocal += -1;
                }
                If (PromotionVal == 3)
                {
                    WhiteBishopCountLocal += -1;
                    WhiteMinorCountLocal += -1;
                }
                If (PromotionVal == 4)
                {
                    WhiteMinorCountLocal += -1;
                }
                List.ReplaceItem(Board, SourceIdx, WhitePawn);
                WhitePawnCountLocal += 1;
                SourcePiece = WhitePawn;
            }
        }
        If (Board[SourceIdx] == BlackKing)
        {
            BlackKingIdx = SourceIdx;
        }
        If (Board[SourceIdx] == WhiteKing)
        {
            WhiteKingIdx = SourceIdx;
        }
        TargetPiece = TargetPieces[Depth];
        If (TargetPiece > 0)
        {
            If (TargetPiece == BlackPawn)
            {
                BlackPawnCountLocal += 1;
            }
            Else
            {
                If (TargetPiece < BlackQueen)
                {
                    BlackMinorCountLocal += 1;
                    If (TargetPiece == BlackRook)
                    {
                        BlackRookCountLocal += 1;
                    }
                    If (TargetPiece == BlackBishop)
                    {
                        BlackBishopCountLocal += 1;
                    }
                }
                Else
                {
                    If (TargetPiece == BlackQueen)
                    {
                        BlackQueenCountLocal += 1;
                    }
                }
            }
        }
        If (TargetPiece < 0)
        {
            If (TargetPiece == WhitePawn)
            {
                WhitePawnCountLocal += 1;
            }
            Else
            {
                If (TargetPiece > WhiteQueen)
                {
                    WhiteMinorCountLocal += 1;
                    If (TargetPiece == WhiteRook)
                    {
                        WhiteRookCountLocal += 1;
                    }
                    If (TargetPiece == WhiteBishop)
                    {
                        WhiteBishopCountLocal += 1;
                    }
                }
                Else
                {
                    If (TargetPiece == WhiteQueen)
                    {
                        WhiteQueenCountLocal += 1;
                    }
                }
            }
        }
    }
    Else
    {
        If (CurrentMove == WhiteKingsideCastling)
        {
            List.ReplaceItem(Board, VirtualBoard[61], WhiteKing);
            List.ReplaceItem(Board, VirtualBoard[62], 0);
            List.ReplaceItem(Board, VirtualBoard[63], 0);
            List.ReplaceItem(Board, VirtualBoard[64], WhiteRook);
            WhiteKingIdx = VirtualBoard[61];
        }
        Else
        {
            If (CurrentMove == WhiteQueensideCastling)
            {
                List.ReplaceItem(Board, VirtualBoard[57], WhiteRook);
                List.ReplaceItem(Board, VirtualBoard[59], 0);
                List.ReplaceItem(Board, VirtualBoard[60], 0);
                List.ReplaceItem(Board, VirtualBoard[61], WhiteKing);
                WhiteKingIdx = VirtualBoard[61];
            }
            Else
            {
                If (CurrentMove == BlackKingsideCastling)
                {
                    List.ReplaceItem(Board, VirtualBoard[5], BlackKing);
                    List.ReplaceItem(Board, VirtualBoard[6], 0);
                    List.ReplaceItem(Board, VirtualBoard[7], 0);
                    List.ReplaceItem(Board, VirtualBoard[8], BlackRook);
                    BlackKingIdx = VirtualBoard[5];
                }
                Else
                {
                    If (CurrentMove == BlackQueensideCastling)
                    {
                        List.ReplaceItem(Board, VirtualBoard[1], BlackRook);
                        List.ReplaceItem(Board, VirtualBoard[4], 0);
                        List.ReplaceItem(Board, VirtualBoard[3], 0);
                        List.ReplaceItem(Board, VirtualBoard[5], BlackKing);
                        BlackKingIdx = VirtualBoard[5];
                    }
                }
            }
        }
    }
    CurrentBoardHash = PreviousBoardHash[Depth];
    CurrentBoardHash2 = PreviousBoardHash2[Depth];
    List.ReplaceItem(AppliedMove, Depth, "");
    List.ReplaceItem(PosScoreDelta, Depth, 0);
    List.ReplaceItem(SourcePieces, Depth, 0);
    List.ReplaceItem(TargetPiecesIdx, Depth, "");
    List.ReplaceItem(TargetPieces, Depth, 0);
    List.ReplaceItem(PromotionPieces, Depth, 0);
    If (Depth < 3)
    {
        List.ReplaceItem(PawnShelterCapture, Depth, 0);
    }
    Else
    {
        List.ReplaceItem(PawnShelterCapture, Depth, PawnShelterCapture[(Depth - 2)]);
    }
    If (Depth == 1)
    {
        List.ReplaceItem(CastlingState, Depth, Operator.Join(Operator.Join(Operator.Join(HasBlackCastled, HasBlackKingMoved), Operator.Join(HasBlackRookKSMoved, HasBlackRookQSMoved)), Operator.Join(Operator.Join(HasWhiteCastled, HasWhiteKingMoved), Operator.Join(HasWhiteRookKSMoved, HasWhiteRookQSMoved))));
    }
    Else
    {
        List.ReplaceItem(CastlingState, Depth, CastlingState[(Depth - 1)]);
    }
}

Define RevertMoveLight(string Depth) (warp=true)
{
    CurrentMove = AppliedMove[Depth];
    SourceIdx = floor((CurrentMove / 100));
    If (SourceIdx > 0)
    {
        TargetIdx = floor((CurrentMove % 100));
        List.ReplaceItem(Board, SourceIdx, Board[TargetIdx]);
        List.ReplaceItem(Board, TargetIdx, 0);
        List.ReplaceItem(Board, TargetPiecesIdx[Depth], TargetPieces[Depth]);
    }
    Else
    {
        If (CurrentMove == WhiteKingsideCastling)
        {
            List.ReplaceItem(Board, VirtualBoard[61], WhiteKing);
            List.ReplaceItem(Board, VirtualBoard[62], 0);
            List.ReplaceItem(Board, VirtualBoard[63], 0);
            List.ReplaceItem(Board, VirtualBoard[64], WhiteRook);
        }
        Else
        {
            If (CurrentMove == WhiteQueensideCastling)
            {
                List.ReplaceItem(Board, VirtualBoard[57], WhiteRook);
                List.ReplaceItem(Board, VirtualBoard[59], 0);
                List.ReplaceItem(Board, VirtualBoard[60], 0);
                List.ReplaceItem(Board, VirtualBoard[61], WhiteKing);
            }
            Else
            {
                If (CurrentMove == BlackKingsideCastling)
                {
                    List.ReplaceItem(Board, VirtualBoard[5], BlackKing);
                    List.ReplaceItem(Board, VirtualBoard[6], 0);
                    List.ReplaceItem(Board, VirtualBoard[7], 0);
                    List.ReplaceItem(Board, VirtualBoard[8], BlackRook);
                }
                Else
                {
                    If (CurrentMove == BlackQueensideCastling)
                    {
                        List.ReplaceItem(Board, VirtualBoard[1], BlackRook);
                        List.ReplaceItem(Board, VirtualBoard[4], 0);
                        List.ReplaceItem(Board, VirtualBoard[3], 0);
                        List.ReplaceItem(Board, VirtualBoard[5], BlackKing);
                    }
                }
            }
        }
    }
    CurrentBoardHash = PreviousBoardHash[Depth];
}

Define SayAsync(string Text)(num Duration) (warp=false)
{
    SayAsyncText = Text;
    SayAsyncDuration = Duration;
    Event.Broadcast("sayasyncmsg");
}

Define SetCastlingStateFlag(string Depth)(string Offset)(string Val) (warp=true)
{
    CurrentValue = CastlingState[Depth];
    If (Not ((Operator.LetterOf(CurrentValue, Offset) == Val)))
    {
        Idx = (((((Operator.LetterOf(CurrentValue, 1) * 128) + (Operator.LetterOf(CurrentValue, 2) * 64)) + ((Operator.LetterOf(CurrentValue, 3) * 32) + (Operator.LetterOf(CurrentValue, 4) * 16))) + (((Operator.LetterOf(CurrentValue, 5) * 8) + (Operator.LetterOf(CurrentValue, 6) * 4)) + ((Operator.LetterOf(CurrentValue, 7) * 2) + Operator.LetterOf(CurrentValue, 8)))) + 1);
        If (Val == 1)
        {
            List.ReplaceItem(CastlingState, Depth, CastlingStateLookup[(Idx + CastlingStatePow2[Offset])]);
        }
        Else
        {
            List.ReplaceItem(CastlingState, Depth, CastlingStateLookup[(Idx - CastlingStatePow2[Offset])]);
        }
    }
}

Define SetInitialEnPassantTarget(string Depth) (warp=true)
{
    List.ReplaceItem(EnPassantTarget, Depth, "");
    Call GetSubstringRight(GameMoves)(4);
    SourceIdx = floor((SubstringRes / 100));
    TargetIdx = floor((SubstringRes % 100));
    If ((abs(Board[TargetIdx]) == BlackPawn) And (abs((TargetIdx - SourceIdx)) == 16))
    {
        List.ReplaceItem(EnPassantTarget, Depth, TargetIdx);
    }
}

Define SortList (warp=true)
{
    If (List.Length(CalcMovesScoreList) > 1)
    {
        Call QuickSort;
    }
}

Define SortMoveList(string Depth) (warp=true)
{
    If (Depth == 1)
    {
        List.DeleteAll(Moves1);
        Idx = 1;
        Repeat (List.Length(CalcMovesMoveList))
        {
            List.Add(Moves1, CalcMovesMoveList[Idx]);
            Idx += 1;
        }
        Call SortList;
        Idx = 1;
        IdxSub = List.Length(CalcMovesMoveList);
        Repeat (List.Length(CalcMovesMoveList))
        {
            List.ReplaceItem(DeepeningScoreOrderMap, Idx, List.IndexOf(Moves1, CalcMovesMoveList[IdxSub]));
            Idx += 1;
            IdxSub += -1;
        }
        Idx = 1;
        IdxSub = List.Length(CalcMovesMoveList);
        Repeat (List.Length(CalcMovesMoveList))
        {
            List.ReplaceItem(Moves, Idx, CalcMovesMoveList[IdxSub]);
            List.ReplaceItem(Moves1, Idx, CalcMovesMoveList[IdxSub]);
            Idx += 1;
            IdxSub += -1;
        }
        List.ReplaceItem(MovesCount, Depth, List.Length(CalcMovesMoveList));
        Stop(this script);
    }
    If (Depth == 2)
    {
        Call SortList;
        IdxSub = ((Depth - 1) * 300);
        Idx = 1;
        Repeat (List.Length(CalcMovesMoveList))
        {
            List.ReplaceItem(Moves, (IdxSub + Idx), CalcMovesMoveList[Idx]);
            List.Add(Moves2, CalcMovesMoveList[Idx]);
            Idx += 1;
        }
        List.ReplaceItem(MovesCount, Depth, List.Length(CalcMovesMoveList));
        Stop(this script);
    }
    If ((Depth % 2) == 1)
    {
        Call SortList;
        IdxSub = ((Depth - 1) * MaxMovesPerGeneration);
        Idx = 1;
        Repeat (List.Length(CalcMovesMoveList))
        {
            List.ReplaceItem(Moves, (IdxSub + Idx), CalcMovesMoveList[((List.Length(CalcMovesMoveList) - Idx) + 1)]);
            Idx += 1;
        }
        List.ReplaceItem(MovesCount, Depth, List.Length(CalcMovesMoveList));
    }
    Else
    {
        Call SortList;
        IdxSub = ((Depth - 1) * MaxMovesPerGeneration);
        Idx = 1;
        Repeat (List.Length(CalcMovesMoveList))
        {
            List.ReplaceItem(Moves, (IdxSub + Idx), CalcMovesMoveList[Idx]);
            Idx += 1;
        }
        List.ReplaceItem(MovesCount, Depth, List.Length(CalcMovesMoveList));
    }
}

Define StagedMoveGenKillerMoves(string Depth)(string Move)(string SourceIdx)(string TargetIdx)(string SourcePieceAbs)(string KillerMoveIdx) (warp=true)
{
    If (SourcePieceAbs == BlackPawn)
    {
        If ((TargetIdx > 56) Or (TargetIdx < 9))
        {
            Stop(this script);
        }
        If (abs((TargetIdx - SourceIdx)) == 16)
        {
            If (Not ((Board[((TargetIdx + SourceIdx) / 2)] == 0)))
            {
                Stop(this script);
            }
        }
        If (Not ((IdxToFile[SourceIdx] == IdxToFile[TargetIdx])))
        {
            Stop(this script);
        }
    }
    If (SourcePieceAbs == BlackKing)
    {
        If (BoardAttackedCalculated[Depth] == 0)
        {
            Stop(this script);
        }
        If ((Depth % 2) == 1)
        {
            If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], TargetIdx) > 0)
            {
                Stop(this script);
            }
        }
        Else
        {
            If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], TargetIdx) > 0)
            {
                Stop(this script);
            }
        }
    }
    If (SourcePieceAbs > BlackKnight)
    {
        SourceIdx = SourceIdx;
        IdxInc = MovePathStepInc[Move];
        Repeat ((MovePathDelta[Move] - 1))
        {
            SourceIdx += IdxInc;
            If (Not ((Board[SourceIdx] == 0)))
            {
                Stop(this script);
            }
        }
    }
    If Operator.Contains(PickedMoves[Depth], Move)
    {
        Stop(this script);
    }
    If List.ContainsItem(TmpList1, Move)
    {
        Stop(this script);
    }
    Call GetMoveScore(Board[SourceIdx])(Board[TargetIdx])(SourceIdx)(TargetIdx)(Move)(Depth);
    List.Add(TmpList1, Move);
    List.Add(TmpList2, MoveScoreRes);
}

Define StagedMoveGenMVVLVA(string Depth)(string SourceIdx)(string TargetIdx)(string SourcePieceAbs)(string TargetPieceAbs)(string PrevTargetIdx) (warp=true)
{
    If (CheckedState[Depth] == 1)
    {
        If (Not ((TargetIdx == PrevTargetIdx)))
        {
            Stop(this script);
        }
    }
    Else
    {
        If (TargetPieceAbs < SourcePieceAbs)
        {
            Stop(this script);
        }
    }
    If (SourcePieceAbs == BlackPawn)
    {
        If (IdxToFile[SourceIdx] == IdxToFile[TargetIdx])
        {
            Stop(this script);
        }
        If ((TargetIdx > 56) Or (TargetIdx < 9))
        {
            Stop(this script);
        }
    }
    If (SourcePieceAbs == BlackKing)
    {
        If (BoardAttackedCalculated[Depth] == 0)
        {
            Stop(this script);
        }
        If ((Depth % 2) == 1)
        {
            If (Operator.LetterOf(BoardAttackedByWhiteSnapshot[Depth], TargetIdx) > 0)
            {
                Stop(this script);
            }
        }
        Else
        {
            If (Operator.LetterOf(BoardAttackedByBlackSnapshot[Depth], TargetIdx) > 0)
            {
                Stop(this script);
            }
        }
    }
    If (SourcePieceAbs > BlackKnight)
    {
        Idx = ((SourceIdx * 100) + TargetIdx);
        SourceIdx = SourceIdx;
        Repeat ((MovePathDelta[Idx] - 1))
        {
            SourceIdx += MovePathStepInc[Idx];
            If (Not ((Board[SourceIdx] == 0)))
            {
                Stop(this script);
            }
        }
    }
    CurrentMoveOuter = MoveNotationLookup[((SourceIdx * 100) + TargetIdx)];
    If Operator.Contains(PickedMoves[Depth], CurrentMoveOuter)
    {
        Stop(this script);
    }
    If List.ContainsItem(TmpList1, CurrentMoveOuter)
    {
        Stop(this script);
    }
    Call GetMoveScore(Board[SourceIdx])(Board[TargetIdx])(SourceIdx)(TargetIdx)(CurrentMoveOuter)(Depth);
    List.Add(TmpList1, CurrentMoveOuter);
    List.Add(TmpList2, MoveScoreRes);
}

Define StoreAttackInfo(string Depth)(string StoreDepth) (warp=true)
{
    If ((Depth % 2) == 1)
    {
        CurrentValue = "";
        CurrentValue2 = "";
        Idx = 1;
        Repeat (32)
        {
            CurrentValue = Operator.Join(CurrentValue, Operator.Join(BoardAttackedByBlack[Idx], BoardAttackedByBlack[(Idx + 1)]));
            CurrentValue2 = Operator.Join(CurrentValue2, BoardAttackedByPieceMap[(((BoardAttackedByBlackPiece[Idx] * 100) + BoardAttackedByBlackPiece[(Idx + 1)]) + 1)]);
            Idx += 2;
        }
        List.ReplaceItem(BoardAttackedByBlackSnapshot, StoreDepth, CurrentValue);
        List.ReplaceItem(BoardAttackedByBlackPieceSnapshot, StoreDepth, CurrentValue2);
        If ((StoreDepth % 2) == 0)
        {
            List.ReplaceItem(CheckedState, StoreDepth, IsWhiteChecked);
            If (IsWhiteChecked == 0)
            {
                List.ReplaceItem(CheckedStateAttackLines, StoreDepth, "");
            }
            Else
            {
                CurrentValue = "";
                Idx = 1;
                Repeat (64)
                {
                    If List.ContainsItem(KingAttackLines, Idx)
                    {
                        CurrentValue = Operator.Join(CurrentValue, 1);
                    }
                    Else
                    {
                        CurrentValue = Operator.Join(CurrentValue, 0);
                    }
                    Idx += 1;
                }
                List.ReplaceItem(CheckedStateAttackLines, StoreDepth, CurrentValue);
            }
            Call TTStoreNode(CurrentBoardHash)(StoreDepth)("")("")("")(CheckedState[StoreDepth])(0)("")("")(BoardAttackedByBlackSnapshot[StoreDepth])(BoardAttackedByBlackPieceSnapshot[StoreDepth])(CheckedStateAttackLines[StoreDepth])("");
        }
    }
    Else
    {
        CurrentValue = "";
        CurrentValue2 = "";
        Idx = 1;
        Repeat (32)
        {
            CurrentValue = Operator.Join(CurrentValue, Operator.Join(BoardAttackedByWhite[Idx], BoardAttackedByWhite[(Idx + 1)]));
            CurrentValue2 = Operator.Join(CurrentValue2, BoardAttackedByPieceMap[(((BoardAttackedByWhitePiece[Idx] * 100) + BoardAttackedByWhitePiece[(Idx + 1)]) + 1)]);
            Idx += 2;
        }
        List.ReplaceItem(BoardAttackedByWhiteSnapshot, StoreDepth, CurrentValue);
        List.ReplaceItem(BoardAttackedByWhitePieceSnapshot, StoreDepth, CurrentValue2);
        If ((StoreDepth % 2) == 1)
        {
            List.ReplaceItem(CheckedState, StoreDepth, IsBlackChecked);
            If (IsBlackChecked == 0)
            {
                List.ReplaceItem(CheckedStateAttackLines, StoreDepth, "");
            }
            Else
            {
                CurrentValue = "";
                Idx = 1;
                Repeat (64)
                {
                    If List.ContainsItem(KingAttackLines, Idx)
                    {
                        CurrentValue = Operator.Join(CurrentValue, 1);
                    }
                    Else
                    {
                        CurrentValue = Operator.Join(CurrentValue, 0);
                    }
                    Idx += 1;
                }
                List.ReplaceItem(CheckedStateAttackLines, StoreDepth, CurrentValue);
            }
            Call TTStoreNode(CurrentBoardHash)(StoreDepth)("")("")("")(CheckedState[StoreDepth])(0)("")("")(BoardAttackedByWhiteSnapshot[StoreDepth])(BoardAttackedByWhitePieceSnapshot[StoreDepth])(CheckedStateAttackLines[StoreDepth])("");
        }
    }
}

Define StoreKillerMove(string Depth)(string Move)(string MaxDepth) (warp=true)
{
    IdxSub = ((Depth - 1) * 4);
    Idx = 1;
    Repeat Until ((KillerMoves[(IdxSub + Idx)] == Move) Or (Idx > 4))
    {
        Idx += 1;
    }
    If (KillerMoves[(IdxSub + Idx)] == Move)
    {
        If (Idx < 4)
        {
            CurrentValue = KillerMoves[(IdxSub + (Idx + 1))];
            List.ReplaceItem(KillerMoves, (IdxSub + (Idx + 1)), Move);
            List.ReplaceItem(KillerMoves, (IdxSub + Idx), CurrentValue);
        }
    }
    Else
    {
        If (KillerMoves[(IdxSub + 4)] == "")
        {
            List.ReplaceItem(KillerMoves, (IdxSub + 4), Move);
        }
        Else
        {
            If (KillerMoves[(IdxSub + 3)] == "")
            {
                List.ReplaceItem(KillerMoves, (IdxSub + 3), Move);
            }
            Else
            {
                If (KillerMoves[(IdxSub + 2)] == "")
                {
                    List.ReplaceItem(KillerMoves, (IdxSub + 2), Move);
                }
                Else
                {
                    List.ReplaceItem(KillerMoves, (IdxSub + 1), Move);
                }
            }
        }
    }
    Idx = (((Depth % 2) * 1000) + ((PieceIdxLookup[Board[floor((Move / 100))]] * 100) + floor((Move % 100))));
    CurrentValue = (HistoryMoveScores[Idx] + ((IdxDeepening + 5) - Depth));
    List.ReplaceItem(HistoryMoveScores, Idx, CurrentValue);
    If (CurrentValue > MaxHistoryMoveScore[((Depth % 2) + 1)])
    {
        List.ReplaceItem(MaxHistoryMoveScore, ((Depth % 2) + 1), CurrentValue);
    }
}

Define TTProbeBoard(string BoardHash)(string Depth) (warp=true)
{
    Call TTProbeBoardImpl((BoardHash + ((Depth % 2) * floor((List.Length(TTBoardHash) / 2)))));
}

Define TTProbeBoardImpl(string BoardHash) (warp=true)
{
    HashBucket = ((BoardHash % (List.Length(TTBoardHash) - 3)) + 1);
    If (Not ((TTBoardHash[HashBucket] == BoardHash)))
    {
        HashBucket += 1;
        If (Not ((TTBoardHash[HashBucket] == BoardHash)))
        {
            HashBucket += 1;
            If (Not ((TTBoardHash[HashBucket] == BoardHash)))
            {
                TTProbeRes = 0;
                Stop(this script);
            }
        }
    }
    TTProbeRes = 1;
    TTProbeBoardAgeRes = TTBoardAge[HashBucket];
    TTProbeBoardScoreSumRes = TTBoardScoreSum[HashBucket];
    TTProbeBoardScoreIsDynamic = 0;
    TTProbeBoardScore1Res = "";
    TTProbeBoardScore2Res = "";
    TTProbeBoardScore3Res = "";
}

Define TTProbeBoard_Old(string BoardHash) (warp=true)
{
    HashBucket = ((BoardHash % (List.Length(TTBoardHash) - 3)) + 1);
    If (Not ((TTBoardHash[HashBucket] == BoardHash)))
    {
        HashBucket += 1;
        If (Not ((TTBoardHash[HashBucket] == BoardHash)))
        {
            HashBucket += 1;
            If (Not ((TTBoardHash[HashBucket] == BoardHash)))
            {
                TTProbeRes = 0;
                Stop(this script);
            }
        }
    }
    TTProbeRes = 1;
    TTProbeBoardScore1Res = TTBoardScore1[HashBucket];
    TTProbeBoardScore2Res = TTBoardScore2[HashBucket];
    TTProbeBoardScore3Res = TTBoardScore3[HashBucket];
    TTProbeBoardScoreSumRes = TTBoardScoreSum[HashBucket];
    TTProbeBoardAgeRes = TTBoardAge[HashBucket];
    TTProbeBoardScoreIsDynamic = TTBoardScoreIsDynamic[HashBucket];
}

Define TTProbeNode(string BoardHash)(string Depth) (warp=true)
{
    Call TTProbeNodeImpl((BoardHash + ((Depth % 2) * floor((List.Length(TTNodeHash) / 2)))));
}

Define TTProbeNodeImpl(string BoardHash) (warp=true)
{
    HashBucket = ((BoardHash % (List.Length(TTNodeHash) - 3)) + 1);
    If (Not ((TTNodeHash[HashBucket] == BoardHash)))
    {
        HashBucket += 1;
        If (Not ((TTNodeHash[HashBucket] == BoardHash)))
        {
            HashBucket += 1;
            If (Not ((TTNodeHash[HashBucket] == BoardHash)))
            {
                TTProbeRes = 0;
                Stop(this script);
            }
        }
    }
    TTProbeRes = 1;
    TTProbeBestMoveRes = TTNodeBestMove[HashBucket];
    TTProbeNodeScoreRes = TTNodeScore[HashBucket];
    TTProbeNodeScoreIsDynamicRes = TTNodeScoreIsDynamic[HashBucket];
    TTProbeNodeTypeRes = TTNodeType[HashBucket];
    TTProbeCheckedRes = TTNodeChecked[HashBucket];
    TTProbeCheckedAttackLinesRes = TTNodeCheckedAttackLines[HashBucket];
    TTProbeHorizonRes = TTNodeHorizon[HashBucket];
    TTProbeBlackMobRes = TTNodeBlackMobility[HashBucket];
    TTProbeWhiteMobRes = TTNodeWhiteMobility[HashBucket];
    TTProbeBoardAttackedByOpp = TTNodeBoardAttackedByOpp[HashBucket];
    TTProbeBoardAttackedByOppPiece = TTNodeBoardAttackedByOppPiece[HashBucket];
    TTProbeNodeAgeRes = TTNodeAge[HashBucket];
}

Define TTStoreBoard(string BoardHash)(string Depth)(string Eval) (warp=true)
{
    Call TTStoreBoardImpl((BoardHash + ((Depth % 2) * floor((List.Length(TTBoardHash) / 2)))))(Eval);
}

Define TTStoreBoardImpl(string BoardHash)(string BoardScoreSum) (warp=true)
{
    HashBucket = ((BoardHash % (List.Length(TTBoardHash) - 3)) + 1);
    Idx = 1;
    Repeat Until (((TTBoardHash[HashBucket] == BoardHash) Or (TTBoardHash[HashBucket] == 0)) Or (TTBoardAge[HashBucket] < (TTCurrentAge - 1)))
    {
        If (Idx > 2)
        {
            Stop(this script);
        }
        Idx += 1;
        HashBucket += 1;
    }
    If (Not ((TTBoardHash[HashBucket] == BoardHash)))
    {
        List.ReplaceItem(TTBoardAge, HashBucket, TTCurrentAge);
        List.ReplaceItem(TTBoardHash, HashBucket, BoardHash);
        List.ReplaceItem(TTBoardScoreSum, HashBucket, BoardScoreSum);
        List.ReplaceItem(TTBoardScoreIsDynamic, HashBucket, 0);
    }
    Else
    {
        If (Not ((BoardScoreSum == "")))
        {
            List.ReplaceItem(TTBoardScoreSum, HashBucket, BoardScoreSum);
            List.ReplaceItem(TTBoardScoreIsDynamic, HashBucket, 0);
        }
    }
}

Define TTStoreBoard_Old(string BoardHash)(string BoardScore1)(string BoardScore2)(string BoardScore3)(string BoardScoreSum)(string IsDynamic) (warp=true)
{
    HashBucket = ((BoardHash % (List.Length(TTBoardHash) - 3)) + 1);
    Idx = 1;
    Repeat Until (((TTBoardHash[HashBucket] == BoardHash) Or (TTBoardHash[HashBucket] == 0)) Or (TTBoardAge[HashBucket] < (TTCurrentAge - 1)))
    {
        If (Idx > 2)
        {
            Stop(this script);
        }
        Idx += 1;
        HashBucket += 1;
    }
    If (Not ((TTBoardHash[HashBucket] == BoardHash)))
    {
        List.ReplaceItem(TTBoardAge, HashBucket, TTCurrentAge);
        List.ReplaceItem(TTBoardHash, HashBucket, BoardHash);
        List.ReplaceItem(TTBoardScore1, HashBucket, BoardScore1);
        List.ReplaceItem(TTBoardScore2, HashBucket, BoardScore2);
        List.ReplaceItem(TTBoardScore3, HashBucket, BoardScore3);
        List.ReplaceItem(TTBoardScoreSum, HashBucket, BoardScoreSum);
        List.ReplaceItem(TTBoardScoreIsDynamic, HashBucket, IsDynamic);
    }
    Else
    {
        If (Not ((floor((TTCurrentAge / 100)) == floor((TTBoardAge[HashBucket] / 100)))))
        {
            List.ReplaceItem(TTBoardAge, HashBucket, TTCurrentAge);
            If (TTBoardScoreIsDynamic[HashBucket] == 1)
            {
                List.ReplaceItem(TTBoardScoreSum, HashBucket, "");
                List.ReplaceItem(TTBoardScoreIsDynamic, HashBucket, "");
            }
        }
        If (Not ((BoardScore1 == "")))
        {
            List.ReplaceItem(TTBoardScore1, HashBucket, BoardScore1);
        }
        If (Not ((BoardScore2 == "")))
        {
            List.ReplaceItem(TTBoardScore2, HashBucket, BoardScore2);
        }
        If (Not ((BoardScore3 == "")))
        {
            List.ReplaceItem(TTBoardScore3, HashBucket, BoardScore3);
        }
        If (Not ((BoardScoreSum == "")))
        {
            List.ReplaceItem(TTBoardScoreSum, HashBucket, BoardScoreSum);
            List.ReplaceItem(TTBoardScoreIsDynamic, HashBucket, IsDynamic);
        }
    }
}

Define TTStoreNode(string BoardHash)(string Depth)(string Score)(string BestMove)(string Type)(string Checked)(string Horizon)(string BlackMob)(string WhiteMob)(string BoardAttackedByOpp)(string BoardAttackedByOppPiece)(string CheckedAttackLines)(string IsDynamic) (warp=true)
{
    If (abs((IdxToRank[BlackKingIdx] - IdxToRank[WhiteKingIdx])) < 2)
    {
        If (abs((IdxToFile[BlackKingIdx] - IdxToFile[WhiteKingIdx])) < 2)
        {
            Stop(this script);
        }
    }
    If (Score == DrawByRepetitionEval)
    {
        Call TTStoreNodeImpl((BoardHash + ((Depth % 2) * floor((List.Length(TTNodeHash) / 2)))))(Depth)("")(BestMove)("")(Checked)(Horizon)(BlackMob)(WhiteMob)(BoardAttackedByOpp)(BoardAttackedByOppPiece)(CheckedAttackLines)("");
    }
    Else
    {
        Call TTStoreNodeImpl((BoardHash + ((Depth % 2) * floor((List.Length(TTNodeHash) / 2)))))(Depth)(Score)(BestMove)(Type)(Checked)(Horizon)(BlackMob)(WhiteMob)(BoardAttackedByOpp)(BoardAttackedByOppPiece)(CheckedAttackLines)(IsDynamic);
    }
}

Define TTStoreNodeImpl(string BoardHash)(string Depth)(string Score)(string BestMove)(string Type)(string Checked)(string Horizon)(string BlackMob)(string WhiteMob)(string BoardAttackedByOpp)(string BoardAttackedByOppPiece)(string CheckedAttackLines)(string IsDynamic) (warp=true)
{
    HashBucket = ((BoardHash % (List.Length(TTNodeHash) - 3)) + 1);
    Idx = 1;
    Repeat Until (((TTNodeHash[HashBucket] == BoardHash) Or (TTNodeHash[HashBucket] == 0)) Or (TTNodeAge[HashBucket] < TTCurrentAge))
    {
        If (Idx > 2)
        {
            Stop(this script);
        }
        Idx += 1;
        HashBucket += 1;
    }
    If (TTNodeHash[HashBucket] == BoardHash)
    {
        If ((Not ((BoardAttackedByOpp == ""))) And (TTNodeBoardAttackedByOpp[HashBucket] == ""))
        {
            List.ReplaceItem(TTNodeBoardAttackedByOpp, HashBucket, BoardAttackedByOpp);
            List.ReplaceItem(TTNodeBoardAttackedByOppPiece, HashBucket, BoardAttackedByOppPiece);
            List.ReplaceItem(TTNodeCheckedAttackLines, HashBucket, CheckedAttackLines);
        }
        If ((Not ((Checked == ""))) And (TTNodeChecked[HashBucket] == ""))
        {
            List.ReplaceItem(TTNodeChecked, HashBucket, Checked);
        }
        If (Horizon < TTNodeHorizon[HashBucket])
        {
            If (((Not ((BestMove == ""))) And (TTNodeBestMove[HashBucket] == "")) Or ((Not ((Score == ""))) And (TTNodeScore[HashBucket] == "")))
            {
                List.ReplaceItem(TTNodeBestMove, HashBucket, BestMove);
                List.ReplaceItem(TTNodeHorizon, HashBucket, Horizon);
                List.ReplaceItem(TTNodeType, HashBucket, Type);
                List.ReplaceItem(TTNodeScore, HashBucket, Score);
                List.ReplaceItem(TTNodeScoreIsDynamic, HashBucket, IsDynamic);
                List.ReplaceItem(TTNodeAge, HashBucket, TTCurrentAge);
            }
            Stop(this script);
        }
        If (Horizon == TTNodeHorizon[HashBucket])
        {
            If ((Not ((BestMove == ""))) And (TTNodeBestMove[HashBucket] == ""))
            {
                List.ReplaceItem(TTNodeBestMove, HashBucket, BestMove);
            }
            Call //("First iterative deepening iteration evals may override previous evals at same horizon (due to quiescence check/evasion extensions)");
            If ((Not ((Score == ""))) And ((TTNodeScore[HashBucket] == "") Or ((TTCurrentAge % 100) == 0)))
            {
                List.ReplaceItem(TTNodeType, HashBucket, Type);
                List.ReplaceItem(TTNodeScore, HashBucket, Score);
                List.ReplaceItem(TTNodeScoreIsDynamic, HashBucket, IsDynamic);
                List.ReplaceItem(TTNodeAge, HashBucket, TTCurrentAge);
            }
        }
        Else
        {
            List.ReplaceItem(TTNodeDepth, HashBucket, Depth);
            List.ReplaceItem(TTNodeBestMove, HashBucket, BestMove);
            List.ReplaceItem(TTNodeType, HashBucket, Type);
            List.ReplaceItem(TTNodeScore, HashBucket, Score);
            List.ReplaceItem(TTNodeScoreIsDynamic, HashBucket, IsDynamic);
            List.ReplaceItem(TTNodeHorizon, HashBucket, Horizon);
            List.ReplaceItem(TTNodeAge, HashBucket, TTCurrentAge);
        }
        If (Not ((BlackMob == "")))
        {
            List.ReplaceItem(TTNodeBlackMobility, HashBucket, BlackMob);
        }
        If (Not ((WhiteMob == "")))
        {
            List.ReplaceItem(TTNodeWhiteMobility, HashBucket, WhiteMob);
        }
    }
    Else
    {
        List.ReplaceItem(TTNodeBestMove, HashBucket, BestMove);
        List.ReplaceItem(TTNodeBoardAttackedByOpp, HashBucket, BoardAttackedByOpp);
        List.ReplaceItem(TTNodeBoardAttackedByOppPiece, HashBucket, BoardAttackedByOppPiece);
        List.ReplaceItem(TTNodeChecked, HashBucket, Checked);
        List.ReplaceItem(TTNodeCheckedAttackLines, HashBucket, CheckedAttackLines);
        List.ReplaceItem(TTNodeHash, HashBucket, BoardHash);
        List.ReplaceItem(TTNodeDepth, HashBucket, Depth);
        List.ReplaceItem(TTNodeType, HashBucket, Type);
        List.ReplaceItem(TTNodeBlackMobility, HashBucket, BlackMob);
        List.ReplaceItem(TTNodeWhiteMobility, HashBucket, WhiteMob);
        List.ReplaceItem(TTNodeScore, HashBucket, Score);
        List.ReplaceItem(TTNodeScoreIsDynamic, HashBucket, IsDynamic);
        List.ReplaceItem(TTNodeHorizon, HashBucket, Horizon);
        List.ReplaceItem(TTNodeAge, HashBucket, TTCurrentAge);
    }
}

Define UndoMove (warp=false)
{
    Call EnterExecution;
    If ((IsInUndo == 0) And (List.Length(GameMovesAN) > 1))
    {
        IsInUndo = 1;
        FromSquareIdx = -1;
        ToSquareIdx = -1;
        Event.BroadcastAndWait("fromsquareselected");
        Event.BroadcastAndWait("tosquareselected");
        Call UndoPrevMove;
        If (BoardHistoryWasEngineMove[List.Length(BoardHistoryWasEngineMove)] == 0)
        {
            Call UndoPrevMove;
        }
        Call DrawBoardAndWait;
        IsGameSuspended = 0;
        IsInUndo = 0;
    }
    Call ExitExecution;
}

Define UndoPrevMove (warp=false)
{
    If (List.Length(GameMovesAN) > 0)
    {
        List.DeleteItem(BoardHistory, List.Length(BoardHistory));
        List.DeleteItem(BoardHistoryHash, List.Length(BoardHistoryHash));
        List.DeleteItem(BoardHistoryMetaState, List.Length(BoardHistoryMetaState));
        List.DeleteItem(BoardHistoryWasEngineMove, List.Length(BoardHistoryWasEngineMove));
        List.DeleteItem(GameMovesAN, List.Length(GameMovesAN));
        Call ImportBoardImpl(BoardHistory[List.Length(BoardHistory)]);
        Call GetSubstringLeft(GameMoves)((Variable.Length(GameMoves) - 4));
        GameMoves = SubstringRes;
        HasBlackCastled = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 1);
        HasBlackKingMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 2);
        HasBlackRookKSMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 3);
        HasBlackRookQSMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 4);
        HasWhiteCastled = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 5);
        HasWhiteKingMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 6);
        HasWhiteRookKSMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 7);
        HasWhiteRookQSMoved = Operator.LetterOf(BoardHistoryMetaState[List.Length(BoardHistoryMetaState)], 8);
        Call CalcBoardStats;
    }
}

Define UpdateMoveHashPosScore(num Piece)(num SourceIdx)(num TargetIdx)(bool PosScoreUpdate) (warp=true)
{
    Call GetPiecePosHash(Piece)(SourceIdx);
    CurrentBoardHash = (CurrentBoardHash - PiecePosHash);
    If ((abs(Piece) == BlackPawn) Or (abs(Piece) == BlackKing))
    {
        CurrentBoardHash2 = (CurrentBoardHash2 - PiecePosHash);
    }
    Call GetPiecePosHash(Piece)(TargetIdx);
    CurrentBoardHash = (CurrentBoardHash + PiecePosHash);
    If ((abs(Piece) == BlackPawn) Or (abs(Piece) == BlackKing))
    {
        CurrentBoardHash2 = (CurrentBoardHash2 + PiecePosHash);
    }
    Call GetPiecePosScore(Piece)(SourceIdx);
    If PosScoreUpdate
    {
        List.ReplaceItem(PosScoreDelta, Depth, (PosScoreDelta[Depth] - PosScoreRes));
    }
    Else
    {
        List.ReplaceItem(PosScoreDelta, Depth, (0 - PosScoreRes));
    }
    Call GetPiecePosScore(Piece)(TargetIdx);
    List.ReplaceItem(PosScoreDelta, Depth, (PosScoreDelta[Depth] + PosScoreRes));
}

Define _ClearLists (warp=true)
{
    List.DeleteAll(TTNodeHorizon);
    List.DeleteAll(OpeningMoves);
    List.DeleteAll(PosPieceHashLookup);
    List.DeleteAll(MoveLookupStraight);
    List.DeleteAll(MoveLookupOffsetsCross);
    List.DeleteAll(MoveLookupKing);
    List.DeleteAll(MoveLookupKnight);
    List.DeleteAll(Logfile);
    List.DeleteAll(MovePosLookupBlack);
    List.DeleteAll(MovePosLookupWhite);
    List.DeleteAll(MoveHashLookupBlack);
    List.DeleteAll(MoveHashLookupWhite);
    List.DeleteAll(TmpList3);
    List.DeleteAll(MovePathDelta);
    List.DeleteAll(MovePathStepInc);
    List.DeleteAll(OpeningMoves);
    List.DeleteAll(OpeningMovesMapHash);
    List.DeleteAll(OpeningMovesMapStack);
    List.DeleteAll(OpeningMovesMapMove);
    List.DeleteAll(BoardAttackedByPieceMap);
    List.DeleteAll(PieceIdxLookup);
    List.DeleteAll(Moves);
    List.DeleteAll(HistoryMoveScores);
    List.DeleteAll(BoardHistoryHash);
    List.DeleteAll(ChebyshevDistance);
    List.DeleteAll(NNUE_ListRes_1);
    List.DeleteAll(NNUE_Accumulator);
    List.DeleteAll(MoveNotationLookup);
    List.DeleteAll(CastlingStateLookup);
    List.DeleteAll(MoveLookupCross);
    List.DeleteAll(MoveLookupIndexOffset);
    List.DeleteAll(MoveLookupKing);
    List.DeleteAll(MoveLookupKnight);
    List.DeleteAll(MoveLookupLineIndexOffset);
    List.DeleteAll(MoveLookupOffsetsCross);
    List.DeleteAll(MoveLookupOffsetsStraight);
    List.DeleteAll(MoveLookupStraight);
    List.DeleteAll(MoveNotationLookup);
    List.DeleteAll(MovePathDelta);
    List.DeleteAll(MovePathStepInc);
    List.DeleteAll(MovePosLookupBlack);
    List.DeleteAll(MovePosLookupWhite);
    List.DeleteAll(Moves);
}
